/* eslint-env jquery */
'use strict';

/**
 * 
 * @class APIGateway
 */

/**
 * mago3d 활성화/비활성화
 * @namespace
 * @param {ManagerFactory} managerFactoryInstance 
 * @param {Boolean} isShow true = show, false = hide
 */
function changeMagoStateAPI(managerFactoryInstance, isShow) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeMagoState");
	api.setMagoEnable(isShow);
	managerFactoryInstance.callAPI(api);
};

/**
 * Label show/hide
 * @param {ManagerFactory} managerFactoryInstance 
 * @param {Boolean} isShow true = show, false = hide
 */
function changeLabelAPI(managerFactoryInstance, isShow) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeLabel");
	api.setShowLabelInfo(isShow);
	managerFactoryInstance.callAPI(api);
}

/**
 * Origin show/hide
 * @param {ManagerFactory} managerFactoryInstance
 * @param {Boolean} isShow true = show, false = hide
 */
function changeOriginAPI(managerFactoryInstance, isShow)
{
	if (managerFactoryInstance === null) { return; }

	var api = new Mago3D.API("changeOrigin");
	api.setShowOrigin(isShow);
	managerFactoryInstance.callAPI(api);
}

/**
 * boundingBox show/hide
 * @param {ManagerFactory} managerFactoryInstance
 * @param {Boolean} isShow true = show, false = hide
 */
function changeBoundingBoxAPI(managerFactoryInstance, isShow) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeBoundingBox");
	api.setShowBoundingBox(isShow);
	managerFactoryInstance.callAPI(api);
}

/**
 * 속성값에 의한 가시화 유무설정
 * 삭제 예정
 * @param {ManagerFactory} managerFactoryInstance
 * @param {Boolean} isShow true = 표시, false = 비표시
 */
function changePropertyRenderingAPI(managerFactoryInstance, isShow, projectId, property) 
{
	if (managerFactoryInstance === null) { return; } 
		
	var api = new Mago3D.API("changePropertyRendering");
	api.setShowShadow(isShow);
	api.setProjectId(projectId);
	api.setProperty(property);
	managerFactoryInstance.callAPI(api);
}

/**
 * 그림자 표시/비표시
 * @param {ManagerFactory} managerFactoryInstance
 * @param {Boolean} isShow true = 활성화, false = 비활성화
 */
function changeShadowAPI(managerFactoryInstance, isShow) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeShadow");
	api.setShowShadow(isShow);
	managerFactoryInstance.callAPI(api);
}

/**
 * color 변경
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId 프로젝트 아이디
 * @param {string} dataKey data key
 * @param {Array<string>} objectIds object id. 복수개의 경우 , 로 입력
 * @param {string} property 속성값 예)isPhysical=true
 * @param {string} color R, G, B, Alpha 색깔을 ',' 로 연결한 string 값을 받음.
 */
function changeColorAPI(managerFactoryInstance, projectId, dataKey, objectIds, property, color) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeColor");
	api.setProjectId(projectId);
	api.setDataKey(dataKey);
	api.setObjectIds(objectIds);
	api.setProperty(property);
	api.setColor(color);
	managerFactoryInstance.callAPI(api);
}

/**
 * Object literal with change Location And Rotation animation option.
 * @typedef {Object} animationOption
 * @property {string} dutaion optional. 
 * @property {Boolean} autoChangeRotation optional. If this option is true, your heading, pitch will be ignore, Heading and pitch changes according to the direction.
 */

/**
 * location and rotation 변경
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId
 * @param {string} dataKey
 * @param {string} latitude 위도
 * @param {string} longitude 경도
 * @param {string} height 높이
 * @param {string} heading 좌, 우
 * @param {string} pitch 위, 아래
 * @param {string} roll 좌, 우 기울기
 * @param {animationOption} animationOption animation option
 */
function changeLocationAndRotationAPI(managerFactoryInstance, projectId, dataKey, latitude, longitude, height, heading, pitch, roll, animationOption) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeLocationAndRotation");
	api.setProjectId(projectId);
	api.setDataKey(dataKey);
	api.setLatitude(latitude);
	api.setLongitude(longitude);
	api.setElevation(height);
	api.setHeading(heading);
	api.setPitch(pitch);
	api.setRoll(roll);
	api.setAnimationOption(animationOption);
	managerFactoryInstance.callAPI(api);
}

/**
 * 마우스 클릭 객체 이동 대상 변경
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} objectMoveMode 0 = All, 1 = object, 2 = None
 */
function changeObjectMoveAPI(managerFactoryInstance, objectMoveMode) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeObjectMove");
	api.setObjectMoveMode(objectMoveMode);
	managerFactoryInstance.callAPI(api);
}

/**
 * 마우스로 이동한 객체 정보를 브라우저내 저장
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} objectMoveMode 0 = All, 1 = object, 2 = None
 */
function saveObjectMoveAPI(managerFactoryInstance, objectMoveMode) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("saveObjectMove");
	api.setObjectMoveMode(objectMoveMode);
	managerFactoryInstance.callAPI(api);
}

/**
 * 브라우저내 모든 마우스 이동 정보를 삭제
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} objectMoveMode 0 = All, 1 = object, 2 = None
 */
function deleteAllObjectMoveAPI(managerFactoryInstance, objectMoveMode) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("deleteAllObjectMove");
	api.setObjectMoveMode(objectMoveMode);
	managerFactoryInstance.callAPI(api);
}

/**
 * 브라우저내 모든 색깔 변경 이력을 삭제
 * @param {ManagerFactory} managerFactoryInstance
 */
function deleteAllChangeColorAPI(managerFactoryInstance) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("deleteAllChangeColor");
	managerFactoryInstance.callAPI(api);
}

/**
 * 이슈 등록 활성화 유무
 * @param {ManagerFactory} managerFactoryInstance
 * @param {Boolean} flag true = 활성화, false = 비활성화
 */
function changeInsertIssueModeAPI(managerFactoryInstance, flag) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeInsertIssueMode");
	api.setIssueInsertEnable(flag);
	managerFactoryInstance.callAPI(api);
}

/**
 * object 정보 표시 활성화 유무
 * @param {ManagerFactory} managerFactoryInstance
 * @param {Boolean} flag true = 활성화, false = 비활성화
 */
function changeObjectInfoViewModeAPI(managerFactoryInstance, flag) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeObjectInfoViewMode");
	api.setObjectInfoViewEnable(flag);
	managerFactoryInstance.callAPI(api);
}

/**
 * Object Occlusion culling
 * @param {ManagerFactory} managerFactoryInstance
 * @param {Boolean} flag true = 활성화, false = 비활성화
 * @param {string} dataKey
 */
function changeOcclusionCullingAPI(managerFactoryInstance, flag, dataKey) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeOcclusionCulling");
	api.setOcclusionCullingEnable(flag);
	api.setDataKey(dataKey);
	managerFactoryInstance.callAPI(api);
}

/**
 * 1인칭, 3인칭 모드 개발중...
 * @param {ManagerFactory} managerFactoryInstance
 * @param {Boolean} flag true = 활성화, false = 비활성화
 */
function changeFPVModeAPI(managerFactoryInstance, flag)
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeFPVMode");
	api.setFPVMode(flag);
	managerFactoryInstance.callAPI(api);
}

/**
 * 1인칭, 3인칭 모드 개발중...
 * @param {ManagerFactory} managerFactoryInstance
 * @param {Boolean} flag true = 활성화, false = 비활성화
 */
function changeMagoModeAPI(managerFactoryInstance, flag)
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeMagoMode");
	api.setMagoMode(flag);
	managerFactoryInstance.callAPI(api);
}

/**
 * 현재 위치 근처 issue list. false인 경우 clear
 * 삭제 예정
 * @param {ManagerFactory} managerFactoryInstance
 * @param {Boolean} flag true = 활성화, false = 비활성화
 */
function changeNearGeoIssueListViewModeAPI(managerFactoryInstance, flag) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeNearGeoIssueListViewMode");
	api.setNearGeoIssueListEnable(flag);
	managerFactoryInstance.callAPI(api);
}

/**
 * TODO 이건 위에 이슈 등록 활성화, 비활성화 api로 통합이 가능할거 같음
 * issue 등록 geo 정보 관련 상태 변경
 * 확인 필요
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} insertIssueState 이슈 등록 좌표 상태
 */
function changeInsertIssueStateAPI(managerFactoryInstance, insertIssueState) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeInsertIssueState");
	api.setInsertIssueState(insertIssueState);
	managerFactoryInstance.callAPI(api);
}

/**
 * LOD 설정을 변경
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} lod0DistInMeters
 * @param {string} lod1DistInMeters
 * @param {string} lod2DistInMeters
 * @param {string} lod3DistInMeters
 * @param {string} lod4DistInMeters
 * @param {string} lod5DistInMeters
 */
function changeLodAPI(managerFactoryInstance, lod0DistInMeters, lod1DistInMeters, lod2DistInMeters, lod3DistInMeters, lod4DistInMeters, lod5DistInMeters)
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeLod");
	api.setLod0DistInMeters(lod0DistInMeters);
	api.setLod1DistInMeters(lod1DistInMeters);
	api.setLod2DistInMeters(lod2DistInMeters);
	api.setLod3DistInMeters(lod3DistInMeters);
	api.setLod4DistInMeters(lod4DistInMeters);
	api.setLod5DistInMeters(lod5DistInMeters);
	managerFactoryInstance.callAPI(api);
}

/**
 * Lighting 설정
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} ambientReflectionCoef
 * @param {string} diffuseReflectionCoef
 * @param {string} specularReflectionCoef
 * @param {string} ambientColor
 * @param {string} specularColor
 */
function changeLightingAPI(managerFactoryInstance, ambientReflectionCoef, diffuseReflectionCoef, specularReflectionCoef, ambientColor, specularColor)
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeLighting");
	api.setAmbientReflectionCoef(ambientReflectionCoef);
	api.setDiffuseReflectionCoef(diffuseReflectionCoef);
	api.setSpecularReflectionCoef(specularReflectionCoef);
	api.setAmbientColor(ambientColor);
	api.setSpecularColor(specularColor);
	managerFactoryInstance.callAPI(api);
}

/**
 * SSAO Radius 설정
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} ssaoRadius
 */
function changeSsaoRadiusAPI(managerFactoryInstance, ssaoRadius)
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("changeSsaoRadius");
	api.setSsaoRadius(ssaoRadius);
	managerFactoryInstance.callAPI(api);
}

/**
 * 모든 f4d 데이터를 삭제, 비표시
 * @param {ManagerFactory} managerFactoryInstance
 */
function clearAllDataAPI(managerFactoryInstance)
{	
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("clearAllData");
	Mago3D.MagoConfig.clearAllData();
	managerFactoryInstance.callAPI(api);
}

/**
 * pin image를 그림
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} drawType 이미지를 그리는 유형 0 : DB, 1 : 이슈등록
 * @param {string} issue_id 이슈 고유키
 * @param {string} issue_type 이슈 고유키
 * @param {string} data_key 데이터 고유키
 * @param {string} latitude 데이터 고유키
 * @param {string} longitude 데이터 고유키
 * @param {string} height 데이터 고유키
 */
function drawInsertIssueImageAPI(managerFactoryInstance, drawType, issue_id, issue_type, data_key, latitude, longitude, height) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("drawInsertIssueImage");
	api.setDrawType(drawType);
	api.setIssueId(issue_id);
	api.setIssueId(issue_type);
	api.setDataKey(data_key);
	api.setLatitude(latitude);
	api.setLongitude(longitude);
	api.setElevation(height);
	managerFactoryInstance.callAPI(api);
}

/**
 * 해당 프로젝트를 로딩하고 이동하기
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId project id
 * @param {string} latitude 데이터 고유키
 * @param {string} longitude 데이터 고유키
 * @param {string} height 데이터 고유키
 * @param {string} duration 이동하는 시간
 */
function gotoProjectAPI(managerFactoryInstance, projectId, projectData, projectDataFolder, longitude, latitude, height, duration) 
{
	if (managerFactoryInstance === null) { return; } 
	
	Mago3D.MagoConfig.setData(Mago3D.CODE.PROJECT_ID_PREFIX + projectId, projectData);
	Mago3D.MagoConfig.setProjectDataFolder(Mago3D.CODE.PROJECT_DATA_FOLDER_PREFIX + projectDataFolder, projectDataFolder);
	
	var api = new Mago3D.API("gotoProject");
	api.setProjectId(projectId);
	api.setProjectDataFolder(projectDataFolder);
	api.setLatitude(latitude);
	api.setLongitude(longitude);
	api.setElevation(height);
	api.setDuration(duration);
	managerFactoryInstance.callAPI(api);
}

/**
 * 해당 프로젝트를 로딩하고 Issue 등록 지점으로 이동하기
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId project id
 * @param {string} issueId issue id
 * @param {string} issueType issue type
 * @param {string} latitude 데이터 고유키
 * @param {string} longitude 데이터 고유키
 * @param {string} height 데이터 고유키
 * @param {string} duration 이동하는 시간
 */
function gotoIssueAPI(managerFactoryInstance, projectId, projectData, projectDataFolder, issueId, issueType, longitude, latitude, height, duration)
{
	if (managerFactoryInstance === null) { return; } 
	
	Mago3D.MagoConfig.setData(Mago3D.CODE.PROJECT_ID_PREFIX + projectId, projectData);
	Mago3D.MagoConfig.setProjectDataFolder(Mago3D.CODE.PROJECT_DATA_FOLDER_PREFIX + projectDataFolder, projectDataFolder);
	
	var api = new Mago3D.API("gotoIssue");
	api.setProjectId(projectId);
	api.setProjectDataFolder(projectDataFolder);
	api.setIssueId(issueId);
	api.setIssueType(issueType);
	api.setLatitude(latitude);
	api.setLongitude(longitude);
	api.setElevation(height);
	api.setDuration(duration);
	managerFactoryInstance.callAPI(api);
}

/**
 * 고려 소프트웨어: 바로가기
 */
function gotoFlyAPI(managerFactoryInstance, longitude, latitude, height, duration)
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("gotoFly");
	api.setLongitude(longitude);
	api.setLatitude(latitude);
	api.setElevation(height);
	api.setDuration(duration);
	managerFactoryInstance.callAPI(api);
}

/**
 * 마우스를 사용할 수 없는 환경에서 버튼 이벤트로 대체
 * 삭제 예정
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} eventType 어떤 마우스 동작을 원하는지를 구분
 */
function mouseMoveAPI(managerFactoryInstance, eventType) 
{
	if (managerFactoryInstance === null) { return; } 
	
	managerFactoryInstance.mouseMove(eventType);
}

/**
 * 데이터 검색
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId 데이터 고유키
 * @param {string} dataKey 데이터 고유키
 */
function searchDataAPI(managerFactoryInstance, projectId, dataKey) 
{
	if (managerFactoryInstance === null) { return; } 
	
	var api = new Mago3D.API("searchData");
	api.setProjectId(projectId);
	api.setDataKey(dataKey);
	managerFactoryInstance.callAPI(api);
}

/**
 * 환경 설정 data Object에 key 값의 존재 유무를 판별
 * @param {string} key 검색 키
 * @param 
 */
function isDataExistAPI(key) 
{
	if (Mago3D.MagoConfig.isDataExist(key)) { return true; }
	else { return false; }
}

/**
 * 환경 설정 data map에서 key 값을 취득
 * @param {string} key 검색 키
 * @param 
 */
function getDataAPI(key) 
{
	return Mago3D.MagoConfig.getData(key);
}

/**
 * Data Key 를 이용하여 Geo Spatial Info를 취득
 * @param {ManagerFactory} managerFactoryInstance
 * @param {String} projectId 고유키
 * @param {String} dataKey Data 고유키
 * @param
 */
function getDataInfoByDataKeyAPI(managerFactoryInstance, projectId, dataKey)
{
	if (managerFactoryInstance === null) { return; }

	var api = new Mago3D.API("getDataInfoByDataKey");
	api.setReturnable(true);
	api.setProjectId(projectId);
	api.setDataKey(dataKey);
	return managerFactoryInstance.callAPI(api);
}

/**
 * 데이터를 Rendering
 * @param {ManagerFactory} managerFactoryInstance
 * @param {Object[]} projectIdArray 프로젝트 이름들
 * @param {Object[]} projectDataArray 프로젝트 데이터들
 * @param {Object[]} projectDataFolderArray 프로젝트 f4d 파일 경로
 * @param 
 */
function drawAppendDataAPI(managerFactoryInstance, projectIdArray, projectDataArray, projectDataFolderArray) 
{
	if (managerFactoryInstance === null) { return; } 
	
	if (projectIdArray.length <= 0) { return; }
	
	var api = new Mago3D.API("drawAppendData");
	projectIdArray.forEach(function(dataName, index) 
	{
			
		Mago3D.MagoConfig.setData(Mago3D.CODE.PROJECT_ID_PREFIX + dataName, projectDataArray[index]);
		Mago3D.MagoConfig.setProjectDataFolder(Mago3D.CODE.PROJECT_DATA_FOLDER_PREFIX + projectDataFolderArray[index], projectDataFolderArray[index]);
		
		api.setProjectId(dataName);
		api.setProjectDataFolder(projectDataFolderArray[index]);
		managerFactoryInstance.callAPI(api);
	});
}

/**
 * get coodinate relative to building
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId project primary key
 * @param {string} dataKey data key
 * @param {string} inputPoint input x, y, z
 * @param {string} resultPoint return point
 */
function getCoordinateRelativeToBuildingAPI(managerFactoryInstance, projectId, dataKey, inputPoint, resultPoint)
{
	if (managerFactoryInstance === null) { return; }

	var api = new Mago3D.API("getCoordinateRelativeToBuilding");
	api.setReturnable(true);
	api.setProjectId(projectId);
	api.setDataKey(dataKey);
	api.setInputPoint(inputPoint);
	api.setResultPoint(resultPoint);

	return managerFactoryInstance.callAPI(api);
}

/**
 * get absolte coodinate of building point
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId project primary key
 * @param {string} dataKey data key
 * @param {string} inputPoint input x, y, z
 * @param {string} resultPoint return point
 */
function getAbsoluteCoodinateOfBuildingPointAPI(managerFactoryInstance, projectId, dataKey, inputPoint, resultPoint)
{
	if (managerFactoryInstance === null) { return; }

	var api = new Mago3D.API("getAbsoluteCoodinateOfBuildingPoint");
	api.setReturnable(true);
	api.setProjectId(projectId);
	api.setDataKey(dataKey);
	api.setInputPoint(inputPoint);
	api.setResultPoint(resultPoint);

	return managerFactoryInstance.callAPI(api);
}

/**
 * get current camera position
 * @param {ManagerFactory} managerFactoryInstance
 * @param {Number} unit position unit. if not define, default value is Mago3D.CODE.units.DEGREE. 0 : Mago3D.CODE.units.METRE, 1 : Mago3D.CODE.units.DEGREE, 2 : Mago3D.CODE.units.RADIAN
 * @returns {Object|Cartesian3|Cartographic}
 */
function getCameraCurrentPositionAPI(managerFactoryInstance, unit)
{
	var api = new Mago3D.API("getCameraCurrentPosition");
	
	api.setReturnable(true);
	api.setUnit(unit);
	
	return managerFactoryInstance.callAPI(api);
}

/**
 * get current camera orientaion
 * @param {ManagerFactory} managerFactoryInstance
 * @returns {Object}
 */
function getCameraCurrentOrientaionAPI(managerFactoryInstance)
{
	var api = new Mago3D.API("getCameraCurrentOrientaion");
	
	api.setReturnable(true);
	return managerFactoryInstance.callAPI(api);
}

/**
 * change camera orientation
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string|undefined|null} heading 좌, 우. needs degree. default value is current camera's heading value.
 * @param {string|undefined|null} pitch 위, 아래. needs degree. default value is current camera's pitch value.
 * @param {string|undefined|null} roll 좌, 우 기울기. needs degree. default value is current camera's roll value.
 * @param {string|undefined|null} duration 이동하는 시간. default value is 0.
 */
function changeCameraOrientationAPI(managerFactoryInstance, heading, pitch, roll, duration)
{
	var api = new Mago3D.API("changeCameraOrientation");

	api.setHeading(heading);
	api.setPitch(pitch);
	api.setRoll(roll);
	api.setDuration(duration);

	managerFactoryInstance.callAPI(api);
}


/**
 * Object literal with config options for instantiate static model.
 * @typedef {Object} instantiateOption
 * @property {string} projectId Required. projectId. static model key.
 * @property {string} instanceId Required. instance Id.
 * @property {number} longitude Required. initial longitude.
 * @property {number} latitude Required. initial latitude.
 * @property {number} height Optional. Default value is 0.
 * @property {number} heading Optional. Default value is 0.
 * @property {number} pitch Optional. Default value is 0.
 * @property {number} roll Optional. Default value is 0.
 */

/**
 * instantiate static model
 * @param {ManagerFactory} managerFactoryInstance
 * @param {instantiateOption} attributes
 */
function instantiateStaticModelAPI(managerFactoryInstance, attributes)
{
	var api = new Mago3D.API("instantiateStaticModel");
	
	api.setInstantiateObj(attributes);
	managerFactoryInstance.callAPI(api);
}

/**
 * Object literal with config options for add static model.
 * @typedef {Object} staticModelOption
 * @property {string} projectId Required. projectId. Static model key.
 * @property {string} projectFolderName Required. Static Model Folder Name.
 * @property {string} buildingFolderName Required. Static Model data Folder Name.
 */

/**
 * add static model
 * @param {ManagerFactory} managerFactoryInstance
 * @param {staticModelOption} attributes
 */
function addStaticModelAPI(managerFactoryInstance, attributes)
{
	var api = new Mago3D.API("addStaticModel");
	
	api.setStaticModelAttributeObj(attributes);
	managerFactoryInstance.callAPI(api);
}

/**
 * 트래킹 옵션.
 * @typedef {Object} trackOption
 * @property {number} type Required.  if not define, default value is CODE.trackMode.TRACKING. 0 : CODE.trackMode.TRACKING, 1 : CODE.trackMode.DRIVER
 * @property {number} targetOffset if type is 1 (CODE.trackMode.DRIVER), use this offset. Default is 10.0;
 * @property {trackCameraOffset} trackCameraOffset if type is 1 (CODE.trackMode.DRIVER), use this.
 */

/**
 * 트래킹 카메라 옵셋 
 * @typedef {Object} trackCameraOffset
 * @property {number} y Default is -1;
 * @property {number} z Default is 12;
 */

/**
 * set track target node.
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId project primary key
 * @param {string} dataKey data key
 * @param {trackOption} option Optional. 비어있을 시 TRACKING 모드로 설정
 */
function setTrackNodeAPI(managerFactoryInstance, projectId, dataKey, option)
{
	var api = new Mago3D.API("setTrackNode");
	
	api.setProjectId(projectId);
	api.setDataKey(dataKey);
	api.setTrackOption(option);
	managerFactoryInstance.callAPI(api);
}

/**
 * set track target node.
 * @param {ManagerFactory} managerFactoryInstance
 */
function stopTrackAPI(managerFactoryInstance)
{
	var api = new Mago3D.API("stopTrack");
	
	managerFactoryInstance.callAPI(api);
}

/**
 * check static model is exist
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId
 * @returns {Boolean} isExist
 */
function isExistStaticModelAPI(managerFactoryInstance, projectId)
{
	var api = new Mago3D.API("isExistStaticModel");
	api.setReturnable(true);
	api.setProjectId(projectId);
	return managerFactoryInstance.callAPI(api);
}

/**
 * check data is exist
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId project primary key
 * @param {string} dataKey data key
 * @returns {Boolean} isExist
 */
function isExistDataAPI(managerFactoryInstance, projectId, dataKey)
{
	var api = new Mago3D.API("isExistData");
	api.setReturnable(true);
	api.setProjectId(projectId);
	api.setDataKey(dataKey);
	return managerFactoryInstance.callAPI(api);
}

/**
 * check data is ready to render
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId project primary key
 * @param {string} dataKey data key
 * @return {Boolean} is ready to render 
 */
function isDataReadyToRenderAPI(managerFactoryInstance, projectId, dataKey)
{
	var api = new Mago3D.API("isDataReadyToRender");
	api.setReturnable(true);
	api.setProjectId(projectId);
	api.setDataKey(dataKey);
	return managerFactoryInstance.callAPI(api);
}

/**
 * check data is ready to render
 * @param {ManagerFactory} managerFactoryInstance
 * @param {string} projectId project primary key
 * @param {string} dataKey data key
 * @param {nodeAttribute} option data key
 */
function setNodeAttributeAPI(managerFactoryInstance, projectId, dataKey, option)
{
	var api = new Mago3D.API("setNodeAttribute");
	api.setProjectId(projectId);
	api.setDataKey(dataKey);
	api.setNodeAttribute(option);
	managerFactoryInstance.callAPI(api);
}

/**
 * toggle point cloud color mode.
 * @param {ManagerFactory} managerFactoryInstance
 */
function togglePointCloudColorAPI(managerFactoryInstance)
{
	var api = new Mago3D.API("togglePointCloudColor");
	managerFactoryInstance.callAPI(api);
}

/**
 * select f4d
 * @param {ManagerFactory} managerFactoryInstance
 */
function selectF4dAPI(managerFactoryInstance, projectId, dataKey) 
{
	var api = new Mago3D.API("selectF4d");
	api.setProjectId(projectId);
	api.setDataKey(dataKey);
	managerFactoryInstance.callAPI(api);

	
}
'use strict';

/**
 * api 처리 결과를 담당하는 callback function
 * @param functionName policy json의 geo_callback_apiresult 속성값
 * @param apiName 호출한 api 이름
 * @param result 결과값
 */
function apiResultCallback(functionName, apiName, result) 
{
	window[functionName](apiName, result);
}

/**
 * 선택한 object 정보를 화면에 표시
 * @param functionName callback
 * @param projectId
 * @param data_key
 * @param objectId
 * @param latitude
 * @param longitude
 * @param elevation
 * @param heading
 * @param pitch
 * @param roll
 * @param
 */
function selectedObjectCallback(functionName, projectId, dataKey, objectId, latitude, longitude, elevation, heading, pitch, roll)
{
	window[functionName](projectId, dataKey, objectId, latitude, longitude, elevation, heading, pitch, roll);
}

/**
 * 이동한 data 정보를 화면에 표시
 * @param functionName callback
 * @param projectId
 * @param data_key
 * @param objectId
 * @param latitude
 * @param longitude
 * @param elevation
 * @param heading
 * @param pitch
 * @param roll
 * @param
 */
function movedDataCallback(functionName, projectId, dataKey, objectId, latitude, longitude, elevation, heading, pitch, roll)
{
	window[functionName](projectId, dataKey, objectId, latitude, longitude, elevation, heading, pitch, roll);
}

/**
 * Data Key 를 이용하여 Geo Spatial Info를 획득하여 화면에 표시
 * @param functionName callback
 * @param projectId
 * @param data_key
 * @param dataName
 * @param latitude
 * @param longitude
 * @param elevation
 * @param heading
 * @param pitch
 * @param roll
 * @param
 */
function dataInfoCallback(functionName, projectId, dataKey, dataName, latitude, longitude, elevation, heading, pitch, roll)
{
	window[functionName](projectId, dataKey, dataName, latitude, longitude, elevation, heading, pitch, roll);
}

/**
 * 선택한 object 정보를 화면에 표시
 * @param functionName
 * @param projectId
 * @param data_key
 * @param objectId
 * @param latitude
 * @param longitude
 * @param elevation
 */
function insertIssueCallback(functionName, projectId, dataKey, objectId, latitude, longitude, elevation)
{
	window[functionName](projectId, dataKey, objectId, latitude, longitude, elevation);
}

/**
 * mouse click 위치 정보를 화면에 표시
 * @param functionName
 * @param position
 */
function clickPositionCallback(functionName, position) 
{
	window[functionName](position);
}

/**
  DataStream reads scalars, arrays and structs of data from an ArrayBuffer.
  It's like a file-like DataView on steroids.

  @param {ArrayBuffer} arrayBuffer ArrayBuffer to read from.
  @param {?Number} byteOffset Offset from arrayBuffer beginning for the DataStream.
  @param {?Boolean} endianness DataStream.BIG_ENDIAN or DataStream.LITTLE_ENDIAN (the default).
  */
var DataStream = function(arrayBuffer, byteOffset, endianness) {
  this._byteOffset = byteOffset || 0;
  if (arrayBuffer instanceof ArrayBuffer) {
    this.buffer = arrayBuffer;
  } else if (typeof arrayBuffer == "object") {
    this.dataView = arrayBuffer;
    if (byteOffset) {
      this._byteOffset += byteOffset;
    }
  } else {
    this.buffer = new ArrayBuffer(arrayBuffer || 1);
  }
  this.position = 0;
  this.endianness = endianness == null ? DataStream.LITTLE_ENDIAN : endianness;
};
DataStream.prototype = {};

/* Fix for Opera 12 not defining BYTES_PER_ELEMENT in typed array prototypes. */
if (Uint8Array.prototype.BYTES_PER_ELEMENT === undefined) {
    Uint8Array.prototype.BYTES_PER_ELEMENT = Uint8Array.BYTES_PER_ELEMENT; 
    Int8Array.prototype.BYTES_PER_ELEMENT = Int8Array.BYTES_PER_ELEMENT; 
    Uint8ClampedArray.prototype.BYTES_PER_ELEMENT = Uint8ClampedArray.BYTES_PER_ELEMENT; 
    Uint16Array.prototype.BYTES_PER_ELEMENT = Uint16Array.BYTES_PER_ELEMENT; 
    Int16Array.prototype.BYTES_PER_ELEMENT = Int16Array.BYTES_PER_ELEMENT; 
    Uint32Array.prototype.BYTES_PER_ELEMENT = Uint32Array.BYTES_PER_ELEMENT; 
    Int32Array.prototype.BYTES_PER_ELEMENT = Int32Array.BYTES_PER_ELEMENT; 
    Float64Array.prototype.BYTES_PER_ELEMENT = Float64Array.BYTES_PER_ELEMENT; 
}

/**
  Saves the DataStream contents to the given filename.
  Uses Chrome's anchor download property to initiate download.

  @param {string} filename Filename to save as.
  @return {null}
  */
DataStream.prototype.save = function(filename) {
  var blob = new Blob(this.buffer);
  var URL = (window.webkitURL || window.URL);
  if (URL && URL.createObjectURL) {
      var url = URL.createObjectURL(blob);
      var a = document.createElement('a');
      a.setAttribute('href', url);
      a.setAttribute('download', filename);
      a.click();
      URL.revokeObjectURL(url);
  } else {
      throw("DataStream.save: Can't create object URL.");
  }
};

/**
  Big-endian const to use as default endianness.
  @type {boolean}
  */
DataStream.BIG_ENDIAN = false;

/**
  Little-endian const to use as default endianness.
  @type {boolean}
  */
DataStream.LITTLE_ENDIAN = true;

/**
  Whether to extend DataStream buffer when trying to write beyond its size.
  If set, the buffer is reallocated to twice its current size until the
  requested write fits the buffer.
  @type {boolean}
  */
DataStream.prototype._dynamicSize = true;
Object.defineProperty(DataStream.prototype, 'dynamicSize',
  { get: function() {
      return this._dynamicSize;
    },
    set: function(v) {
      if (!v) {
        this._trimAlloc();
      }
      this._dynamicSize = v;
    } });

/**
  Virtual byte length of the DataStream backing buffer.
  Updated to be max of original buffer size and last written size.
  If dynamicSize is false is set to buffer size.
  @type {number}
  */
DataStream.prototype._byteLength = 0;

/**
  Returns the byte length of the DataStream object.
  @type {number}
  */
Object.defineProperty(DataStream.prototype, 'byteLength',
  { get: function() {
    return this._byteLength - this._byteOffset;
  }});

/**
  Set/get the backing ArrayBuffer of the DataStream object.
  The setter updates the DataView to point to the new buffer.
  @type {Object}
  */
Object.defineProperty(DataStream.prototype, 'buffer',
  { get: function() {
      this._trimAlloc();
      return this._buffer;
    },
    set: function(v) {
      this._buffer = v;
      this._dataView = new DataView(this._buffer, this._byteOffset);
      this._byteLength = this._buffer.byteLength;
    } });

/**
  Set/get the byteOffset of the DataStream object.
  The setter updates the DataView to point to the new byteOffset.
  @type {number}
  */
Object.defineProperty(DataStream.prototype, 'byteOffset',
  { get: function() {
      return this._byteOffset;
    },
    set: function(v) {
      this._byteOffset = v;
      this._dataView = new DataView(this._buffer, this._byteOffset);
      this._byteLength = this._buffer.byteLength;
    } });

/**
  Set/get the backing DataView of the DataStream object.
  The setter updates the buffer and byteOffset to point to the DataView values.
  @type {Object}
  */
Object.defineProperty(DataStream.prototype, 'dataView',
  { get: function() {
      return this._dataView;
    },
    set: function(v) {
      this._byteOffset = v.byteOffset;
      this._buffer = v.buffer;
      this._dataView = new DataView(this._buffer, this._byteOffset);
      this._byteLength = this._byteOffset + v.byteLength;
    } });

/**
  Internal function to resize the DataStream buffer when required.
  @param {number} extra Number of bytes to add to the buffer allocation.
  @return {null}
  */
DataStream.prototype._realloc = function(extra) {
  if (!this._dynamicSize) {
    return;
  }
  var req = this._byteOffset + this.position + extra;
  var blen = this._buffer.byteLength;
  if (req <= blen) {
    if (req > this._byteLength) {
      this._byteLength = req;
    }
    return;
  }
  if (blen < 1) {
    blen = 1;
  }
  while (req > blen) {
    blen *= 2;
  }
  var buf = new ArrayBuffer(blen);
  var src = new Uint8Array(this._buffer);
  var dst = new Uint8Array(buf, 0, src.length);
  dst.set(src);
  this.buffer = buf;
  this._byteLength = req;
};

/**
  Internal function to trim the DataStream buffer when required.
  Used for stripping out the extra bytes from the backing buffer when
  the virtual byteLength is smaller than the buffer byteLength (happens after
  growing the buffer with writes and not filling the extra space completely).

  @return {null}
  */
DataStream.prototype._trimAlloc = function() {
  if (this._byteLength == this._buffer.byteLength) {
    return;
  }
  var buf = new ArrayBuffer(this._byteLength);
  var dst = new Uint8Array(buf);
  var src = new Uint8Array(this._buffer, 0, dst.length);
  dst.set(src);
  this.buffer = buf;
};

/**
  Sets the DataStream read/write position to given position.
  Clamps between 0 and DataStream length.

  @param {number} pos Position to seek to.
  @return {null}
  */
DataStream.prototype.seek = function(pos) {
  var npos = Math.max(0, Math.min(this.byteLength, pos));
  this.position = (isNaN(npos) || !isFinite(npos)) ? 0 : npos;
};

/**
  Returns true if the DataStream seek pointer is at the end of buffer and
  there's no more data to read.

  @return {boolean} True if the seek pointer is at the end of the buffer.
  */
DataStream.prototype.isEof = function() {
  return (this.position >= this.byteLength);
};

/**
  Maps an Int32Array into the DataStream buffer, swizzling it to native
  endianness in-place. The current offset from the start of the buffer needs to
  be a multiple of element size, just like with typed array views.

  Nice for quickly reading in data. Warning: potentially modifies the buffer
  contents.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} Int32Array to the DataStream backing buffer.
  */
DataStream.prototype.mapInt32Array = function(length, e) {
  this._realloc(length * 4);
  var arr = new Int32Array(this._buffer, this.byteOffset+this.position, length);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += length * 4;
  return arr;
};

/**
  Maps an Int16Array into the DataStream buffer, swizzling it to native
  endianness in-place. The current offset from the start of the buffer needs to
  be a multiple of element size, just like with typed array views.

  Nice for quickly reading in data. Warning: potentially modifies the buffer
  contents.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} Int16Array to the DataStream backing buffer.
  */
DataStream.prototype.mapInt16Array = function(length, e) {
  this._realloc(length * 2);
  var arr = new Int16Array(this._buffer, this.byteOffset+this.position, length);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += length * 2;
  return arr;
};

/**
  Maps an Int8Array into the DataStream buffer.

  Nice for quickly reading in data.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} Int8Array to the DataStream backing buffer.
  */
DataStream.prototype.mapInt8Array = function(length) {
  this._realloc(length * 1);
  var arr = new Int8Array(this._buffer, this.byteOffset+this.position, length);
  this.position += length * 1;
  return arr;
};

/**
  Maps a Uint32Array into the DataStream buffer, swizzling it to native
  endianness in-place. The current offset from the start of the buffer needs to
  be a multiple of element size, just like with typed array views.

  Nice for quickly reading in data. Warning: potentially modifies the buffer
  contents.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} Uint32Array to the DataStream backing buffer.
  */
DataStream.prototype.mapUint32Array = function(length, e) {
  this._realloc(length * 4);
  var arr = new Uint32Array(this._buffer, this.byteOffset+this.position, length);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += length * 4;
  return arr;
};

/**
  Maps a Uint16Array into the DataStream buffer, swizzling it to native
  endianness in-place. The current offset from the start of the buffer needs to
  be a multiple of element size, just like with typed array views.

  Nice for quickly reading in data. Warning: potentially modifies the buffer
  contents.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} Uint16Array to the DataStream backing buffer.
  */
DataStream.prototype.mapUint16Array = function(length, e) {
  this._realloc(length * 2);
  var arr = new Uint16Array(this._buffer, this.byteOffset+this.position, length);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += length * 2;
  return arr;
};

/**
  Maps a Uint8Array into the DataStream buffer.

  Nice for quickly reading in data.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} Uint8Array to the DataStream backing buffer.
  */
DataStream.prototype.mapUint8Array = function(length) {
  this._realloc(length * 1);
  var arr = new Uint8Array(this._buffer, this.byteOffset+this.position, length);
  this.position += length * 1;
  return arr;
};

/**
  Maps a Float64Array into the DataStream buffer, swizzling it to native
  endianness in-place. The current offset from the start of the buffer needs to
  be a multiple of element size, just like with typed array views.

  Nice for quickly reading in data. Warning: potentially modifies the buffer
  contents.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} Float64Array to the DataStream backing buffer.
  */
DataStream.prototype.mapFloat64Array = function(length, e) {
  this._realloc(length * 8);
  var arr = new Float64Array(this._buffer, this.byteOffset+this.position, length);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += length * 8;
  return arr;
};

/**
  Maps a Float32Array into the DataStream buffer, swizzling it to native
  endianness in-place. The current offset from the start of the buffer needs to
  be a multiple of element size, just like with typed array views.

  Nice for quickly reading in data. Warning: potentially modifies the buffer
  contents.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} Float32Array to the DataStream backing buffer.
  */
DataStream.prototype.mapFloat32Array = function(length, e) {
  this._realloc(length * 4);
  var arr = new Float32Array(this._buffer, this.byteOffset+this.position, length);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += length * 4;
  return arr;
};

/**
  Reads an Int32Array of desired length and endianness from the DataStream.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} The read Int32Array.
 */
DataStream.prototype.readInt32Array = function(length, e) {
  length = length == null ? (this.byteLength-this.position / 4) : length;
  var arr = new Int32Array(length);
  DataStream.memcpy(arr.buffer, 0,
                    this.buffer, this.byteOffset+this.position,
                    length*arr.BYTES_PER_ELEMENT);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += arr.byteLength;
  return arr;
};

/**
  Reads an Int16Array of desired length and endianness from the DataStream.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} The read Int16Array.
 */
DataStream.prototype.readInt16Array = function(length, e) {
  length = length == null ? (this.byteLength-this.position / 2) : length;
  var arr = new Int16Array(length);
  DataStream.memcpy(arr.buffer, 0,
                    this.buffer, this.byteOffset+this.position,
                    length*arr.BYTES_PER_ELEMENT);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += arr.byteLength;
  return arr;
};

/**
  Reads an Int8Array of desired length from the DataStream.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} The read Int8Array.
 */
DataStream.prototype.readInt8Array = function(length) {
  length = length == null ? (this.byteLength-this.position) : length;
  var arr = new Int8Array(length);
  DataStream.memcpy(arr.buffer, 0,
                    this.buffer, this.byteOffset+this.position,
                    length*arr.BYTES_PER_ELEMENT);
  this.position += arr.byteLength;
  return arr;
};

/**
  Reads a Uint32Array of desired length and endianness from the DataStream.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} The read Uint32Array.
 */
DataStream.prototype.readUint32Array = function(length, e) {
  length = length == null ? (this.byteLength-this.position / 4) : length;
  var arr = new Uint32Array(length);
  DataStream.memcpy(arr.buffer, 0,
                    this.buffer, this.byteOffset+this.position,
                    length*arr.BYTES_PER_ELEMENT);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += arr.byteLength;
  return arr;
};

/**
  Reads a Uint16Array of desired length and endianness from the DataStream.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} The read Uint16Array.
 */
DataStream.prototype.readUint16Array = function(length, e) {
  length = length == null ? (this.byteLength-this.position / 2) : length;
  var arr = new Uint16Array(length);
  DataStream.memcpy(arr.buffer, 0,
                    this.buffer, this.byteOffset+this.position,
                    length*arr.BYTES_PER_ELEMENT);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += arr.byteLength;
  return arr;
};

/**
  Reads a Uint8Array of desired length from the DataStream.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} The read Uint8Array.
 */
DataStream.prototype.readUint8Array = function(length) {
  length = length == null ? (this.byteLength-this.position) : length;
  var arr = new Uint8Array(length);
  DataStream.memcpy(arr.buffer, 0,
                    this.buffer, this.byteOffset+this.position,
                    length*arr.BYTES_PER_ELEMENT);
  this.position += arr.byteLength;
  return arr;
};

/**
  Reads a Float64Array of desired length and endianness from the DataStream.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} The read Float64Array.
 */
DataStream.prototype.readFloat64Array = function(length, e) {
  length = length == null ? (this.byteLength-this.position / 8) : length;
  var arr = new Float64Array(length);
  DataStream.memcpy(arr.buffer, 0,
                    this.buffer, this.byteOffset+this.position,
                    length*arr.BYTES_PER_ELEMENT);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += arr.byteLength;
  return arr;
};

/**
  Reads a Float32Array of desired length and endianness from the DataStream.

  @param {number} length Number of elements to map.
  @param {?boolean} e Endianness of the data to read.
  @return {Object} The read Float32Array.
 */
DataStream.prototype.readFloat32Array = function(length, e) {
  length = length == null ? (this.byteLength-this.position / 4) : length;
  var arr = new Float32Array(length);
  DataStream.memcpy(arr.buffer, 0,
                    this.buffer, this.byteOffset+this.position,
                    length*arr.BYTES_PER_ELEMENT);
  DataStream.arrayToNative(arr, e == null ? this.endianness : e);
  this.position += arr.byteLength;
  return arr;
};

/**
  Writes an Int32Array of specified endianness to the DataStream.

  @param {Object} arr The array to write.
  @param {?boolean} e Endianness of the data to write.
 */
DataStream.prototype.writeInt32Array = function(arr, e) {
  this._realloc(arr.length * 4);
  if (arr instanceof Int32Array &&
      (this.byteOffset+this.position) % arr.BYTES_PER_ELEMENT == 0) {
    DataStream.memcpy(this._buffer, this.byteOffset+this.position,
                      arr.buffer, arr.byteOffset,
                      arr.byteLength);
    this.mapInt32Array(arr.length, e);
  } else {
    for (var i=0; i<arr.length; i++) {
      this.writeInt32(arr[i], e);
    }
  }
};

/**
  Writes an Int16Array of specified endianness to the DataStream.

  @param {Object} arr The array to write.
  @param {?boolean} e Endianness of the data to write.
 */
DataStream.prototype.writeInt16Array = function(arr, e) {
  this._realloc(arr.length * 2);
  if (arr instanceof Int16Array &&
      (this.byteOffset+this.position) % arr.BYTES_PER_ELEMENT == 0) {
    DataStream.memcpy(this._buffer, this.byteOffset+this.position,
                      arr.buffer, arr.byteOffset,
                      arr.byteLength);
    this.mapInt16Array(arr.length, e);
  } else {
    for (var i=0; i<arr.length; i++) {
      this.writeInt16(arr[i], e);
    }
  }
};

/**
  Writes an Int8Array to the DataStream.

  @param {Object} arr The array to write.
 */
DataStream.prototype.writeInt8Array = function(arr) {
  this._realloc(arr.length * 1);
  if (arr instanceof Int8Array &&
      (this.byteOffset+this.position) % arr.BYTES_PER_ELEMENT == 0) {
    DataStream.memcpy(this._buffer, this.byteOffset+this.position,
                      arr.buffer, arr.byteOffset,
                      arr.byteLength);
    this.mapInt8Array(arr.length);
  } else {
    for (var i=0; i<arr.length; i++) {
      this.writeInt8(arr[i]);
    }
  }
};

/**
  Writes a Uint32Array of specified endianness to the DataStream.

  @param {Object} arr The array to write.
  @param {?boolean} e Endianness of the data to write.
 */
DataStream.prototype.writeUint32Array = function(arr, e) {
  this._realloc(arr.length * 4);
  if (arr instanceof Uint32Array &&
      (this.byteOffset+this.position) % arr.BYTES_PER_ELEMENT == 0) {
    DataStream.memcpy(this._buffer, this.byteOffset+this.position,
                      arr.buffer, arr.byteOffset,
                      arr.byteLength);
    this.mapUint32Array(arr.length, e);
  } else {
    for (var i=0; i<arr.length; i++) {
      this.writeUint32(arr[i], e);
    }
  }
};

/**
  Writes a Uint16Array of specified endianness to the DataStream.

  @param {Object} arr The array to write.
  @param {?boolean} e Endianness of the data to write.
 */
DataStream.prototype.writeUint16Array = function(arr, e) {
  this._realloc(arr.length * 2);
  if (arr instanceof Uint16Array &&
      (this.byteOffset+this.position) % arr.BYTES_PER_ELEMENT == 0) {
    DataStream.memcpy(this._buffer, this.byteOffset+this.position,
                      arr.buffer, arr.byteOffset,
                      arr.byteLength);
    this.mapUint16Array(arr.length, e);
  } else {
    for (var i=0; i<arr.length; i++) {
      this.writeUint16(arr[i], e);
    }
  }
};

/**
  Writes a Uint8Array to the DataStream.

  @param {Object} arr The array to write.
 */
DataStream.prototype.writeUint8Array = function(arr) {
  this._realloc(arr.length * 1);
  if (arr instanceof Uint8Array &&
      (this.byteOffset+this.position) % arr.BYTES_PER_ELEMENT == 0) {
    DataStream.memcpy(this._buffer, this.byteOffset+this.position,
                      arr.buffer, arr.byteOffset,
                      arr.byteLength);
    this.mapUint8Array(arr.length);
  } else {
    for (var i=0; i<arr.length; i++) {
      this.writeUint8(arr[i]);
    }
  }
};

/**
  Writes a Float64Array of specified endianness to the DataStream.

  @param {Object} arr The array to write.
  @param {?boolean} e Endianness of the data to write.
 */
DataStream.prototype.writeFloat64Array = function(arr, e) {
  this._realloc(arr.length * 8);
  if (arr instanceof Float64Array &&
      (this.byteOffset+this.position) % arr.BYTES_PER_ELEMENT == 0) {
    DataStream.memcpy(this._buffer, this.byteOffset+this.position,
                      arr.buffer, arr.byteOffset,
                      arr.byteLength);
    this.mapFloat64Array(arr.length, e);
  } else {
    for (var i=0; i<arr.length; i++) {
      this.writeFloat64(arr[i], e);
    }
  }
};

/**
  Writes a Float32Array of specified endianness to the DataStream.

  @param {Object} arr The array to write.
  @param {?boolean} e Endianness of the data to write.
 */
DataStream.prototype.writeFloat32Array = function(arr, e) {
  this._realloc(arr.length * 4);
  if (arr instanceof Float32Array &&
      (this.byteOffset+this.position) % arr.BYTES_PER_ELEMENT == 0) {
    DataStream.memcpy(this._buffer, this.byteOffset+this.position,
                      arr.buffer, arr.byteOffset,
                      arr.byteLength);
    this.mapFloat32Array(arr.length, e);
  } else {
    for (var i=0; i<arr.length; i++) {
      this.writeFloat32(arr[i], e);
    }
  }
};


/**
  Reads a 32-bit int from the DataStream with the desired endianness.

  @param {?boolean} e Endianness of the number.
  @return {number} The read number.
 */
DataStream.prototype.readInt32 = function(e) {
  var v = this._dataView.getInt32(this.position, e == null ? this.endianness : e);
  this.position += 4;
  return v;
};

/**
  Reads a 16-bit int from the DataStream with the desired endianness.

  @param {?boolean} e Endianness of the number.
  @return {number} The read number.
 */
DataStream.prototype.readInt16 = function(e) {
  var v = this._dataView.getInt16(this.position, e == null ? this.endianness : e);
  this.position += 2;
  return v;
};

/**
  Reads an 8-bit int from the DataStream.

  @return {number} The read number.
 */
DataStream.prototype.readInt8 = function() {
  var v = this._dataView.getInt8(this.position);
  this.position += 1;
  return v;
};

/**
  Reads a 32-bit unsigned int from the DataStream with the desired endianness.

  @param {?boolean} e Endianness of the number.
  @return {number} The read number.
 */
DataStream.prototype.readUint32 = function(e) {
  var v = this._dataView.getUint32(this.position, e == null ? this.endianness : e);
  this.position += 4;
  return v;
};

/**
  Reads a 16-bit unsigned int from the DataStream with the desired endianness.

  @param {?boolean} e Endianness of the number.
  @return {number} The read number.
 */
DataStream.prototype.readUint16 = function(e) {
  var v = this._dataView.getUint16(this.position, e == null ? this.endianness : e);
  this.position += 2;
  return v;
};

/**
  Reads an 8-bit unsigned int from the DataStream.

  @return {number} The read number.
 */
DataStream.prototype.readUint8 = function() {
  var v = this._dataView.getUint8(this.position);
  this.position += 1;
  return v;
};

/**
  Reads a 32-bit float from the DataStream with the desired endianness.

  @param {?boolean} e Endianness of the number.
  @return {number} The read number.
 */
DataStream.prototype.readFloat32 = function(e) {
  var v = this._dataView.getFloat32(this.position, e == null ? this.endianness : e);
  this.position += 4;
  return v;
};

/**
  Reads a 64-bit float from the DataStream with the desired endianness.

  @param {?boolean} e Endianness of the number.
  @return {number} The read number.
 */
DataStream.prototype.readFloat64 = function(e) {
  var v = this._dataView.getFloat64(this.position, e == null ? this.endianness : e);
  this.position += 8;
  return v;
};


/**
  Writes a 32-bit int to the DataStream with the desired endianness.

  @param {number} v Number to write.
  @param {?boolean} e Endianness of the number.
 */
DataStream.prototype.writeInt32 = function(v, e) {
  this._realloc(4);
  this._dataView.setInt32(this.position, v, e == null ? this.endianness : e);
  this.position += 4;
};

/**
  Writes a 16-bit int to the DataStream with the desired endianness.

  @param {number} v Number to write.
  @param {?boolean} e Endianness of the number.
 */
DataStream.prototype.writeInt16 = function(v, e) {
  this._realloc(2);
  this._dataView.setInt16(this.position, v, e == null ? this.endianness : e);
  this.position += 2;
};

/**
  Writes an 8-bit int to the DataStream.

  @param {number} v Number to write.
 */
DataStream.prototype.writeInt8 = function(v) {
  this._realloc(1);
  this._dataView.setInt8(this.position, v);
  this.position += 1;
};

/**
  Writes a 32-bit unsigned int to the DataStream with the desired endianness.

  @param {number} v Number to write.
  @param {?boolean} e Endianness of the number.
 */
DataStream.prototype.writeUint32 = function(v, e) {
  this._realloc(4);
  this._dataView.setUint32(this.position, v, e == null ? this.endianness : e);
  this.position += 4;
};

/**
  Writes a 16-bit unsigned int to the DataStream with the desired endianness.

  @param {number} v Number to write.
  @param {?boolean} e Endianness of the number.
 */
DataStream.prototype.writeUint16 = function(v, e) {
  this._realloc(2);
  this._dataView.setUint16(this.position, v, e == null ? this.endianness : e);
  this.position += 2;
};

/**
  Writes an 8-bit unsigned  int to the DataStream.

  @param {number} v Number to write.
 */
DataStream.prototype.writeUint8 = function(v) {
  this._realloc(1);
  this._dataView.setUint8(this.position, v);
  this.position += 1;
};

/**
  Writes a 32-bit float to the DataStream with the desired endianness.

  @param {number} v Number to write.
  @param {?boolean} e Endianness of the number.
 */
DataStream.prototype.writeFloat32 = function(v, e) {
  this._realloc(4);
  this._dataView.setFloat32(this.position, v, e == null ? this.endianness : e);
  this.position += 4;
};

/**
  Writes a 64-bit float to the DataStream with the desired endianness.

  @param {number} v Number to write.
  @param {?boolean} e Endianness of the number.
 */
DataStream.prototype.writeFloat64 = function(v, e) {
  this._realloc(8);
  this._dataView.setFloat64(this.position, v, e == null ? this.endianness : e);
  this.position += 8;
};

/**
  Native endianness. Either DataStream.BIG_ENDIAN or DataStream.LITTLE_ENDIAN
  depending on the platform endianness.

  @type {boolean}
 */
DataStream.endianness = new Int8Array(new Int16Array([1]).buffer)[0] > 0;

/**
  Copies byteLength bytes from the src buffer at srcOffset to the
  dst buffer at dstOffset.

  @param {Object} dst Destination ArrayBuffer to write to.
  @param {number} dstOffset Offset to the destination ArrayBuffer.
  @param {Object} src Source ArrayBuffer to read from.
  @param {number} srcOffset Offset to the source ArrayBuffer.
  @param {number} byteLength Number of bytes to copy.
 */
DataStream.memcpy = function(dst, dstOffset, src, srcOffset, byteLength) {
  var dstU8 = new Uint8Array(dst, dstOffset, byteLength);
  var srcU8 = new Uint8Array(src, srcOffset, byteLength);
  dstU8.set(srcU8);
};

/**
  Converts array to native endianness in-place.

  @param {Object} array Typed array to convert.
  @param {boolean} arrayIsLittleEndian True if the data in the array is
                                       little-endian. Set false for big-endian.
  @return {Object} The converted typed array.
 */
DataStream.arrayToNative = function(array, arrayIsLittleEndian) {
  if (arrayIsLittleEndian == this.endianness) {
    return array;
  } else {
    return this.flipArrayEndianness(array);
  }
};

/**
  Converts native endianness array to desired endianness in-place.

  @param {Object} array Typed array to convert.
  @param {boolean} littleEndian True if the converted array should be
                                little-endian. Set false for big-endian.
  @return {Object} The converted typed array.
 */
DataStream.nativeToEndian = function(array, littleEndian) {
  if (this.endianness == littleEndian) {
    return array;
  } else {
    return this.flipArrayEndianness(array);
  }
};

/**
  Flips typed array endianness in-place.

  @param {Object} array Typed array to flip.
  @return {Object} The converted typed array.
 */
DataStream.flipArrayEndianness = function(array) {
  var u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
  for (var i=0; i<array.byteLength; i+=array.BYTES_PER_ELEMENT) {
    for (var j=i+array.BYTES_PER_ELEMENT-1, k=i; j>k; j--, k++) {
      var tmp = u8[k];
      u8[k] = u8[j];
      u8[j] = tmp;
    }
  }
  return array;
};

/**
  Creates an array from an array of character codes.
  Uses String.fromCharCode in chunks for memory efficiency and then concatenates
  the resulting string chunks.

  @param {array} array Array of character codes.
  @return {string} String created from the character codes.
**/
DataStream.createStringFromArray = function(array) {
  var chunk_size = 0x8000;
  var chunks = [];
  for (var i=0; i < array.length; i += chunk_size) {
    chunks.push(String.fromCharCode.apply(null, array.subarray(i, i + chunk_size)));
  }
  return chunks.join("");
};

/**
  Seek position where DataStream#readStruct ran into a problem.
  Useful for debugging struct parsing.

  @type {number}
 */
DataStream.prototype.failurePosition = 0;

/**
  Reads a struct of data from the DataStream. The struct is defined as
  a flat array of [name, type]-pairs. See the example below:

  ds.readStruct([
    'headerTag', 'uint32', // Uint32 in DataStream endianness.
    'headerTag2', 'uint32be', // Big-endian Uint32.
    'headerTag3', 'uint32le', // Little-endian Uint32.
    'array', ['[]', 'uint32', 16], // Uint32Array of length 16.
    'array2Length', 'uint32',
    'array2', ['[]', 'uint32', 'array2Length'] // Uint32Array of length array2Length
  ]);

  The possible values for the type are as follows:

  // Number types

  // Unsuffixed number types use DataStream endianness.
  // To explicitly specify endianness, suffix the type with
  // 'le' for little-endian or 'be' for big-endian,
  // e.g. 'int32be' for big-endian int32.

  'uint8' -- 8-bit unsigned int
  'uint16' -- 16-bit unsigned int
  'uint32' -- 32-bit unsigned int
  'int8' -- 8-bit int
  'int16' -- 16-bit int
  'int32' -- 32-bit int
  'float32' -- 32-bit float
  'float64' -- 64-bit float

  // String types
  'cstring' -- ASCII string terminated by a zero byte.
  'string:N' -- ASCII string of length N, where N is a literal integer.
  'string:variableName' -- ASCII string of length $variableName,
    where 'variableName' is a previously parsed number in the current struct.
  'string,CHARSET:N' -- String of byteLength N encoded with given CHARSET.
  'u16string:N' -- UCS-2 string of length N in DataStream endianness.
  'u16stringle:N' -- UCS-2 string of length N in little-endian.
  'u16stringbe:N' -- UCS-2 string of length N in big-endian.

  // Complex types
  [name, type, name_2, type_2, ..., name_N, type_N] -- Struct
  function(dataStream, struct) {} -- Callback function to read and return data.
  {get: function(dataStream, struct) {},
   set: function(dataStream, struct) {}}
  -- Getter/setter functions to read and return data, handy for using the same
     struct definition for reading and writing structs.
  ['[]', type, length] -- Array of given type and length. The length can be either
                        a number, a string that references a previously-read
                        field, or a callback function(struct, dataStream, type){}.
                        If length is '*', reads in as many elements as it can.

  @param {Object} structDefinition Struct definition object.
  @return {Object} The read struct. Null if failed to read struct.
 */
DataStream.prototype.readStruct = function(structDefinition) {
  var struct = {}, t, v, n;
  var p = this.position;
  for (var i=0; i<structDefinition.length; i+=2) {
    t = structDefinition[i+1];
    v = this.readType(t, struct);
    if (v == null) {
      if (this.failurePosition == 0) {
        this.failurePosition = this.position;
      }
      this.position = p;
      return null;
    }
    struct[structDefinition[i]] = v;
  }
  return struct;
};

/**
  Read UCS-2 string of desired length and endianness from the DataStream.

  @param {number} length The length of the string to read.
  @param {boolean} endianness The endianness of the string data in the DataStream.
  @return {string} The read string.
 */
DataStream.prototype.readUCS2String = function(length, endianness) {
  return DataStream.createStringFromArray(this.readUint16Array(length, endianness));
};

/**
  Write a UCS-2 string of desired endianness to the DataStream. The
  lengthOverride argument lets you define the number of characters to write.
  If the string is shorter than lengthOverride, the extra space is padded with
  zeroes.

  @param {string} str The string to write.
  @param {?boolean} endianness The endianness to use for the written string data.
  @param {?number} lengthOverride The number of characters to write.
 */
DataStream.prototype.writeUCS2String = function(str, endianness, lengthOverride) {
  if (lengthOverride == null) {
    lengthOverride = str.length;
  }
  for (var i = 0; i < str.length && i < lengthOverride; i++) {
    this.writeUint16(str.charCodeAt(i), endianness);
  }
  for (; i<lengthOverride; i++) {
    this.writeUint16(0);
  }
};

/**
  Read a string of desired length and encoding from the DataStream.

  @param {number} length The length of the string to read in bytes.
  @param {?string} encoding The encoding of the string data in the DataStream.
                            Defaults to ASCII.
  @return {string} The read string.
 */
DataStream.prototype.readString = function(length, encoding) {
  if (encoding == null || encoding == "ASCII") {
    return DataStream.createStringFromArray(this.mapUint8Array(length == null ? this.byteLength-this.position : length));
  } else {
    return (new TextDecoder(encoding)).decode(this.mapUint8Array(length));
  }
};

/**
  Writes a string of desired length and encoding to the DataStream.

  @param {string} s The string to write.
  @param {?string} encoding The encoding for the written string data.
                            Defaults to ASCII.
  @param {?number} length The number of characters to write.
 */
DataStream.prototype.writeString = function(s, encoding, length) {
  if (encoding == null || encoding == "ASCII") {
    if (length != null) {
      var i = 0;
      var len = Math.min(s.length, length);
      for (i=0; i<len; i++) {
        this.writeUint8(s.charCodeAt(i));
      }
      for (; i<length; i++) {
        this.writeUint8(0);
      }
    } else {
      for (var i=0; i<s.length; i++) {
        this.writeUint8(s.charCodeAt(i));
      }
    }
  } else {
    this.writeUint8Array((new TextEncoder(encoding)).encode(s.substring(0, length)));
  }
};


/**
  Read null-terminated string of desired length from the DataStream. Truncates
  the returned string so that the null byte is not a part of it.

  @param {?number} length The length of the string to read.
  @return {string} The read string.
 */
DataStream.prototype.readCString = function(length) {
  var blen = this.byteLength-this.position;
  var u8 = new Uint8Array(this._buffer, this._byteOffset + this.position);
  var len = blen;
  if (length != null) {
    len = Math.min(length, blen);
  }
  for (var i = 0; i < len && u8[i] != 0; i++); // find first zero byte
  var s = DataStream.createStringFromArray(this.mapUint8Array(i));
  if (length != null) {
    this.position += len-i;
  } else if (i != blen) {
    this.position += 1; // trailing zero if not at end of buffer
  }
  return s;
};

/**
  Writes a null-terminated string to DataStream and zero-pads it to length
  bytes. If length is not given, writes the string followed by a zero.
  If string is longer than length, the written part of the string does not have
  a trailing zero.

  @param {string} s The string to write.
  @param {?number} length The number of characters to write.
 */
DataStream.prototype.writeCString = function(s, length) {
  if (length != null) {
    var i = 0;
    var len = Math.min(s.length, length);
    for (i=0; i<len; i++) {
      this.writeUint8(s.charCodeAt(i));
    }
    for (; i<length; i++) {
      this.writeUint8(0);
    }
  } else {
    for (var i=0; i<s.length; i++) {
      this.writeUint8(s.charCodeAt(i));
    }
    this.writeUint8(0);
  }
};

/**
  Reads an object of type t from the DataStream, passing struct as the thus-far
  read struct to possible callbacks that refer to it. Used by readStruct for
  reading in the values, so the type is one of the readStruct types.

  @param {Object} t Type of the object to read.
  @param {?Object} struct Struct to refer to when resolving length references
                          and for calling callbacks.
  @return {?Object} Returns the object on successful read, null on unsuccessful.
 */
DataStream.prototype.readType = function(t, struct) {
  if (typeof t == "function") {
    return t(this, struct);
  } else if (typeof t == "object" && !(t instanceof Array)) {
    return t.get(this, struct);
  } else if (t instanceof Array && t.length != 3) {
    return this.readStruct(t, struct);
  }
  var v = null;
  var lengthOverride = null;
  var charset = "ASCII";
  var pos = this.position;
  var len;
  if (typeof t == 'string' && /:/.test(t)) {
    var tp = t.split(":");
    t = tp[0];
    len = tp[1];

    // allow length to be previously parsed variable
    // e.g. 'string:fieldLength', if `fieldLength` has
    // been parsed previously.
    if (struct[len] != null) {
      lengthOverride = parseInt(struct[len]);
    } else {
      // assume literal integer e.g., 'string:4'
      lengthOverride = parseInt(tp[1]);
    }
  }
  if (typeof t == 'string' && /,/.test(t)) {
    var tp = t.split(",");
    t = tp[0];
    charset = parseInt(tp[1]);
  }
  switch(t) {

    case 'uint8':
      v = this.readUint8(); break;
    case 'int8':
      v = this.readInt8(); break;

    case 'uint16':
      v = this.readUint16(this.endianness); break;
    case 'int16':
      v = this.readInt16(this.endianness); break;
    case 'uint32':
      v = this.readUint32(this.endianness); break;
    case 'int32':
      v = this.readInt32(this.endianness); break;
    case 'float32':
      v = this.readFloat32(this.endianness); break;
    case 'float64':
      v = this.readFloat64(this.endianness); break;

    case 'uint16be':
      v = this.readUint16(DataStream.BIG_ENDIAN); break;
    case 'int16be':
      v = this.readInt16(DataStream.BIG_ENDIAN); break;
    case 'uint32be':
      v = this.readUint32(DataStream.BIG_ENDIAN); break;
    case 'int32be':
      v = this.readInt32(DataStream.BIG_ENDIAN); break;
    case 'float32be':
      v = this.readFloat32(DataStream.BIG_ENDIAN); break;
    case 'float64be':
      v = this.readFloat64(DataStream.BIG_ENDIAN); break;

    case 'uint16le':
      v = this.readUint16(DataStream.LITTLE_ENDIAN); break;
    case 'int16le':
      v = this.readInt16(DataStream.LITTLE_ENDIAN); break;
    case 'uint32le':
      v = this.readUint32(DataStream.LITTLE_ENDIAN); break;
    case 'int32le':
      v = this.readInt32(DataStream.LITTLE_ENDIAN); break;
    case 'float32le':
      v = this.readFloat32(DataStream.LITTLE_ENDIAN); break;
    case 'float64le':
      v = this.readFloat64(DataStream.LITTLE_ENDIAN); break;

    case 'cstring':
      v = this.readCString(lengthOverride); break;

    case 'string':
      v = this.readString(lengthOverride, charset); break;

    case 'u16string':
      v = this.readUCS2String(lengthOverride, this.endianness); break;

    case 'u16stringle':
      v = this.readUCS2String(lengthOverride, DataStream.LITTLE_ENDIAN); break;

    case 'u16stringbe':
      v = this.readUCS2String(lengthOverride, DataStream.BIG_ENDIAN); break;

    default:
      if (t.length == 3) {
        var ta = t[1];
        var len = t[2];
        var length = 0;
        if (typeof len == 'function') {
          length = len(struct, this, t);
        } else if (typeof len == 'string' && struct[len] != null) {
          length = parseInt(struct[len]);
        } else {
          length = parseInt(len);
        }
        if (typeof ta == "string") {
          var tap = ta.replace(/(le|be)$/, '');
          var endianness = null;
          if (/le$/.test(ta)) {
            endianness = DataStream.LITTLE_ENDIAN;
          } else if (/be$/.test(ta)) {
            endianness = DataStream.BIG_ENDIAN;
          }
          if (len == '*') {
            length = null;
          }
          switch(tap) {
            case 'uint8':
              v = this.readUint8Array(length); break;
            case 'uint16':
              v = this.readUint16Array(length, endianness); break;
            case 'uint32':
              v = this.readUint32Array(length, endianness); break;
            case 'int8':
              v = this.readInt8Array(length); break;
            case 'int16':
              v = this.readInt16Array(length, endianness); break;
            case 'int32':
              v = this.readInt32Array(length, endianness); break;
            case 'float32':
              v = this.readFloat32Array(length, endianness); break;
            case 'float64':
              v = this.readFloat64Array(length, endianness); break;
            case 'cstring':
            case 'utf16string':
            case 'string':
              if (length == null) {
                v = [];
                while (!this.isEof()) {
                  var u = this.readType(ta, struct);
                  if (u == null) break;
                  v.push(u);
                }
              } else {
                v = new Array(length);
                for (var i=0; i<length; i++) {
                  v[i] = this.readType(ta, struct);
                }
              }
              break;
          }
        } else {
          if (len == '*') {
            v = [];
            this.buffer;
            while (true) {
              var p = this.position;
              try {
                var o = this.readType(ta, struct);
                if (o == null) {
                  this.position = p;
                  break;
                }
                v.push(o);
              } catch(e) {
                this.position = p;
                break;
              }
            }
          } else {
            v = new Array(length);
            for (var i=0; i<length; i++) {
              var u = this.readType(ta, struct);
              if (u == null) return null;
              v[i] = u;
            }
          }
        }
        break;
      }
  }
  if (lengthOverride != null) {
    this.position = pos + lengthOverride;
  }
  return v;
};

/**
  Writes a struct to the DataStream. Takes a structDefinition that gives the
  types and a struct object that gives the values. Refer to readStruct for the
  structure of structDefinition.

  @param {Object} structDefinition Type definition of the struct.
  @param {Object} struct The struct data object.
  */
DataStream.prototype.writeStruct = function(structDefinition, struct) {
  for (var i = 0; i < structDefinition.length; i+=2) {
    var t = structDefinition[i+1];
    this.writeType(t, struct[structDefinition[i]], struct);
  }
};

/**
  Writes object v of type t to the DataStream.

  @param {Object} t Type of data to write.
  @param {Object} v Value of data to write.
  @param {Object} struct Struct to pass to write callback functions.
  */
DataStream.prototype.writeType = function(t, v, struct) {
  if (typeof t == "function") {
    return t(this, v);
  } else if (typeof t == "object" && !(t instanceof Array)) {
    return t.set(this, v, struct);
  }
  var lengthOverride = null;
  var charset = "ASCII";
  var pos = this.position;
  if (typeof(t) == 'string' && /:/.test(t)) {
    var tp = t.split(":");
    t = tp[0];
    lengthOverride = parseInt(tp[1]);
  }
  if (typeof t == 'string' && /,/.test(t)) {
    var tp = t.split(",");
    t = tp[0];
    charset = parseInt(tp[1]);
  }

  switch(t) {
    case 'uint8':
      this.writeUint8(v);
      break;
    case 'int8':
      this.writeInt8(v);
      break;

    case 'uint16':
      this.writeUint16(v, this.endianness);
      break;
    case 'int16':
      this.writeInt16(v, this.endianness);
      break;
    case 'uint32':
      this.writeUint32(v, this.endianness);
      break;
    case 'int32':
      this.writeInt32(v, this.endianness);
      break;
    case 'float32':
      this.writeFloat32(v, this.endianness);
      break;
    case 'float64':
      this.writeFloat64(v, this.endianness);
      break;

    case 'uint16be':
      this.writeUint16(v, DataStream.BIG_ENDIAN);
      break;
    case 'int16be':
      this.writeInt16(v, DataStream.BIG_ENDIAN);
      break;
    case 'uint32be':
      this.writeUint32(v, DataStream.BIG_ENDIAN);
      break;
    case 'int32be':
      this.writeInt32(v, DataStream.BIG_ENDIAN);
      break;
    case 'float32be':
      this.writeFloat32(v, DataStream.BIG_ENDIAN);
      break;
    case 'float64be':
      this.writeFloat64(v, DataStream.BIG_ENDIAN);
      break;

    case 'uint16le':
      this.writeUint16(v, DataStream.LITTLE_ENDIAN);
      break;
    case 'int16le':
      this.writeInt16(v, DataStream.LITTLE_ENDIAN);
      break;
    case 'uint32le':
      this.writeUint32(v, DataStream.LITTLE_ENDIAN);
      break;
    case 'int32le':
      this.writeInt32(v, DataStream.LITTLE_ENDIAN);
      break;
    case 'float32le':
      this.writeFloat32(v, DataStream.LITTLE_ENDIAN);
      break;
    case 'float64le':
      this.writeFloat64(v, DataStream.LITTLE_ENDIAN);
      break;

    case 'cstring':
      this.writeCString(v, lengthOverride);
      break;

    case 'string':
      this.writeString(v, charset, lengthOverride);
      break;

    case 'u16string':
      this.writeUCS2String(v, this.endianness, lengthOverride);
      break;

    case 'u16stringle':
      this.writeUCS2String(v, DataStream.LITTLE_ENDIAN, lengthOverride);
      break;

    case 'u16stringbe':
      this.writeUCS2String(v, DataStream.BIG_ENDIAN, lengthOverride);
      break;

    default:
      if (t.length == 3) {
        var ta = t[1];
        for (var i=0; i<v.length; i++) {
          this.writeType(ta, v[i]);
        }
        break;
      } else {
        this.writeStruct(t, v);
        break;
      }
  }
  if (lengthOverride != null) {
    this.position = pos;
    this._realloc(lengthOverride);
    this.position = pos + lengthOverride;
  }
};

// Export DataStream for amd environments
if (typeof define === 'function' && define.amd) {
    define('DataStream', [], function() {
      return DataStream;
    });
  }
  
// Export DataStream for CommonJS
if (typeof module === 'object' && module && module.exports) {
  module.exports = DataStream;
}


/*!
@fileoverview gl-matrix - High performance matrix and vector operations
@author Brandon Jones
@author Colin MacKenzie IV
@version 3.0.0-0

Copyright (c) 2015-2019, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.glMatrix = {})));
}(this, (function (exports) { 'use strict';

  /**
   * Common utilities
   * @module glMatrix
   */
  // Configuration Constants
  var EPSILON = 0.000001;
  var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
  var RANDOM = Math.random;
  /**
   * Sets the type of array used when creating new vectors and matrices
   *
   * @param {Type} type Array type, such as Float32Array or Array
   */

  function setMatrixArrayType(type) {
    ARRAY_TYPE = type;
  }
  var degree = Math.PI / 180;
  /**
   * Convert Degree To Radian
   *
   * @param {Number} a Angle in Degrees
   */

  function toRadian(a) {
    return a * degree;
  }
  /**
   * Tests whether or not the arguments have approximately the same value, within an absolute
   * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
   * than or equal to 1.0, and a relative tolerance is used for larger values)
   *
   * @param {Number} a The first number to test.
   * @param {Number} b The second number to test.
   * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
   */

  function equals(a, b) {
    return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
  }

  var common = /*#__PURE__*/Object.freeze({
    EPSILON: EPSILON,
    get ARRAY_TYPE () { return ARRAY_TYPE; },
    RANDOM: RANDOM,
    setMatrixArrayType: setMatrixArrayType,
    toRadian: toRadian,
    equals: equals
  });

  /**
   * 2x2 Matrix
   * @module mat2
   */

  /**
   * Creates a new identity mat2
   *
   * @returns {mat2} a new 2x2 matrix
   */

  function create() {
    var out = new ARRAY_TYPE(4);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
    }

    out[0] = 1;
    out[3] = 1;
    return out;
  }
  /**
   * Creates a new mat2 initialized with values from an existing matrix
   *
   * @param {mat2} a matrix to clone
   * @returns {mat2} a new 2x2 matrix
   */

  function clone(a) {
    var out = new ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Copy the values from one mat2 to another
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the source matrix
   * @returns {mat2} out
   */

  function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Set a mat2 to the identity matrix
   *
   * @param {mat2} out the receiving matrix
   * @returns {mat2} out
   */

  function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  /**
   * Create a new mat2 with the given values
   *
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m10 Component in column 1, row 0 position (index 2)
   * @param {Number} m11 Component in column 1, row 1 position (index 3)
   * @returns {mat2} out A new 2x2 matrix
   */

  function fromValues(m00, m01, m10, m11) {
    var out = new ARRAY_TYPE(4);
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
  }
  /**
   * Set the components of a mat2 to the given values
   *
   * @param {mat2} out the receiving matrix
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m10 Component in column 1, row 0 position (index 2)
   * @param {Number} m11 Component in column 1, row 1 position (index 3)
   * @returns {mat2} out
   */

  function set(out, m00, m01, m10, m11) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
  }
  /**
   * Transpose the values of a mat2
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the source matrix
   * @returns {mat2} out
   */

  function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache
    // some values
    if (out === a) {
      var a1 = a[1];
      out[1] = a[2];
      out[2] = a1;
    } else {
      out[0] = a[0];
      out[1] = a[2];
      out[2] = a[1];
      out[3] = a[3];
    }

    return out;
  }
  /**
   * Inverts a mat2
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the source matrix
   * @returns {mat2} out
   */

  function invert(out, a) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3]; // Calculate the determinant

    var det = a0 * a3 - a2 * a1;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] = a0 * det;
    return out;
  }
  /**
   * Calculates the adjugate of a mat2
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the source matrix
   * @returns {mat2} out
   */

  function adjoint(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] = a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a0;
    return out;
  }
  /**
   * Calculates the determinant of a mat2
   *
   * @param {mat2} a the source matrix
   * @returns {Number} determinant of a
   */

  function determinant(a) {
    return a[0] * a[3] - a[2] * a[1];
  }
  /**
   * Multiplies two mat2's
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the first operand
   * @param {mat2} b the second operand
   * @returns {mat2} out
   */

  function multiply(out, a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
  }
  /**
   * Rotates a mat2 by the given angle
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat2} out
   */

  function rotate(out, a, rad) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = a0 * c + a2 * s;
    out[1] = a1 * c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
  }
  /**
   * Scales the mat2 by the dimensions in the given vec2
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the matrix to rotate
   * @param {vec2} v the vec2 to scale the matrix by
   * @returns {mat2} out
   **/

  function scale(out, a, v) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var v0 = v[0],
        v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
  }
  /**
   * Creates a matrix from a given angle
   * This is equivalent to (but much faster than):
   *
   *     mat2.identity(dest);
   *     mat2.rotate(dest, dest, rad);
   *
   * @param {mat2} out mat2 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat2} out
   */

  function fromRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat2.identity(dest);
   *     mat2.scale(dest, dest, vec);
   *
   * @param {mat2} out mat2 receiving operation result
   * @param {vec2} v Scaling vector
   * @returns {mat2} out
   */

  function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    return out;
  }
  /**
   * Returns a string representation of a mat2
   *
   * @param {mat2} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */

  function str(a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
  }
  /**
   * Returns Frobenius norm of a mat2
   *
   * @param {mat2} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */

  function frob(a) {
    return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
  }
  /**
   * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
   * @param {mat2} L the lower triangular matrix
   * @param {mat2} D the diagonal matrix
   * @param {mat2} U the upper triangular matrix
   * @param {mat2} a the input matrix to factorize
   */

  function LDU(L, D, U, a) {
    L[2] = a[2] / a[0];
    U[0] = a[0];
    U[1] = a[1];
    U[3] = a[3] - L[2] * U[1];
    return [L, D, U];
  }
  /**
   * Adds two mat2's
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the first operand
   * @param {mat2} b the second operand
   * @returns {mat2} out
   */

  function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the first operand
   * @param {mat2} b the second operand
   * @returns {mat2} out
   */

  function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
  }
  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {mat2} a The first matrix.
   * @param {mat2} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
  }
  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {mat2} a The first matrix.
   * @param {mat2} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function equals$1(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
  }
  /**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat2} out the receiving matrix
   * @param {mat2} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat2} out
   */

  function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
  }
  /**
   * Adds two mat2's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat2} out the receiving vector
   * @param {mat2} a the first operand
   * @param {mat2} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat2} out
   */

  function multiplyScalarAndAdd(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    return out;
  }
  /**
   * Alias for {@link mat2.multiply}
   * @function
   */

  var mul = multiply;
  /**
   * Alias for {@link mat2.subtract}
   * @function
   */

  var sub = subtract;

  var mat2 = /*#__PURE__*/Object.freeze({
    create: create,
    clone: clone,
    copy: copy,
    identity: identity,
    fromValues: fromValues,
    set: set,
    transpose: transpose,
    invert: invert,
    adjoint: adjoint,
    determinant: determinant,
    multiply: multiply,
    rotate: rotate,
    scale: scale,
    fromRotation: fromRotation,
    fromScaling: fromScaling,
    str: str,
    frob: frob,
    LDU: LDU,
    add: add,
    subtract: subtract,
    exactEquals: exactEquals,
    equals: equals$1,
    multiplyScalar: multiplyScalar,
    multiplyScalarAndAdd: multiplyScalarAndAdd,
    mul: mul,
    sub: sub
  });

  /**
   * 2x3 Matrix
   * @module mat2d
   *
   * @description
   * A mat2d contains six elements defined as:
   * <pre>
   * [a, c, tx,
   *  b, d, ty]
   * </pre>
   * This is a short form for the 3x3 matrix:
   * <pre>
   * [a, c, tx,
   *  b, d, ty,
   *  0, 0, 1]
   * </pre>
   * The last row is ignored so the array is shorter and operations are faster.
   */

  /**
   * Creates a new identity mat2d
   *
   * @returns {mat2d} a new 2x3 matrix
   */

  function create$1() {
    var out = new ARRAY_TYPE(6);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[4] = 0;
      out[5] = 0;
    }

    out[0] = 1;
    out[3] = 1;
    return out;
  }
  /**
   * Creates a new mat2d initialized with values from an existing matrix
   *
   * @param {mat2d} a matrix to clone
   * @returns {mat2d} a new 2x3 matrix
   */

  function clone$1(a) {
    var out = new ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
  }
  /**
   * Copy the values from one mat2d to another
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the source matrix
   * @returns {mat2d} out
   */

  function copy$1(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
  }
  /**
   * Set a mat2d to the identity matrix
   *
   * @param {mat2d} out the receiving matrix
   * @returns {mat2d} out
   */

  function identity$1(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
  }
  /**
   * Create a new mat2d with the given values
   *
   * @param {Number} a Component A (index 0)
   * @param {Number} b Component B (index 1)
   * @param {Number} c Component C (index 2)
   * @param {Number} d Component D (index 3)
   * @param {Number} tx Component TX (index 4)
   * @param {Number} ty Component TY (index 5)
   * @returns {mat2d} A new mat2d
   */

  function fromValues$1(a, b, c, d, tx, ty) {
    var out = new ARRAY_TYPE(6);
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
  }
  /**
   * Set the components of a mat2d to the given values
   *
   * @param {mat2d} out the receiving matrix
   * @param {Number} a Component A (index 0)
   * @param {Number} b Component B (index 1)
   * @param {Number} c Component C (index 2)
   * @param {Number} d Component D (index 3)
   * @param {Number} tx Component TX (index 4)
   * @param {Number} ty Component TY (index 5)
   * @returns {mat2d} out
   */

  function set$1(out, a, b, c, d, tx, ty) {
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
  }
  /**
   * Inverts a mat2d
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the source matrix
   * @returns {mat2d} out
   */

  function invert$1(out, a) {
    var aa = a[0],
        ab = a[1],
        ac = a[2],
        ad = a[3];
    var atx = a[4],
        aty = a[5];
    var det = aa * ad - ab * ac;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
  }
  /**
   * Calculates the determinant of a mat2d
   *
   * @param {mat2d} a the source matrix
   * @returns {Number} determinant of a
   */

  function determinant$1(a) {
    return a[0] * a[3] - a[1] * a[2];
  }
  /**
   * Multiplies two mat2d's
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the first operand
   * @param {mat2d} b the second operand
   * @returns {mat2d} out
   */

  function multiply$1(out, a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
  }
  /**
   * Rotates a mat2d by the given angle
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat2d} out
   */

  function rotate$1(out, a, rad) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = a0 * c + a2 * s;
    out[1] = a1 * c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
  }
  /**
   * Scales the mat2d by the dimensions in the given vec2
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the matrix to translate
   * @param {vec2} v the vec2 to scale the matrix by
   * @returns {mat2d} out
   **/

  function scale$1(out, a, v) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var v0 = v[0],
        v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
  }
  /**
   * Translates the mat2d by the dimensions in the given vec2
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the matrix to translate
   * @param {vec2} v the vec2 to translate the matrix by
   * @returns {mat2d} out
   **/

  function translate(out, a, v) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var v0 = v[0],
        v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
  }
  /**
   * Creates a matrix from a given angle
   * This is equivalent to (but much faster than):
   *
   *     mat2d.identity(dest);
   *     mat2d.rotate(dest, dest, rad);
   *
   * @param {mat2d} out mat2d receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat2d} out
   */

  function fromRotation$1(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    out[4] = 0;
    out[5] = 0;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat2d.identity(dest);
   *     mat2d.scale(dest, dest, vec);
   *
   * @param {mat2d} out mat2d receiving operation result
   * @param {vec2} v Scaling vector
   * @returns {mat2d} out
   */

  function fromScaling$1(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    out[4] = 0;
    out[5] = 0;
    return out;
  }
  /**
   * Creates a matrix from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat2d.identity(dest);
   *     mat2d.translate(dest, dest, vec);
   *
   * @param {mat2d} out mat2d receiving operation result
   * @param {vec2} v Translation vector
   * @returns {mat2d} out
   */

  function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = v[0];
    out[5] = v[1];
    return out;
  }
  /**
   * Returns a string representation of a mat2d
   *
   * @param {mat2d} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */

  function str$1(a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ')';
  }
  /**
   * Returns Frobenius norm of a mat2d
   *
   * @param {mat2d} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */

  function frob$1(a) {
    return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1);
  }
  /**
   * Adds two mat2d's
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the first operand
   * @param {mat2d} b the second operand
   * @returns {mat2d} out
   */

  function add$1(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the first operand
   * @param {mat2d} b the second operand
   * @returns {mat2d} out
   */

  function subtract$1(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    return out;
  }
  /**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat2d} out the receiving matrix
   * @param {mat2d} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat2d} out
   */

  function multiplyScalar$1(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    return out;
  }
  /**
   * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat2d} out the receiving vector
   * @param {mat2d} a the first operand
   * @param {mat2d} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat2d} out
   */

  function multiplyScalarAndAdd$1(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    out[4] = a[4] + b[4] * scale;
    out[5] = a[5] + b[5] * scale;
    return out;
  }
  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {mat2d} a The first matrix.
   * @param {mat2d} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function exactEquals$1(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
  }
  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {mat2d} a The first matrix.
   * @param {mat2d} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function equals$2(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));
  }
  /**
   * Alias for {@link mat2d.multiply}
   * @function
   */

  var mul$1 = multiply$1;
  /**
   * Alias for {@link mat2d.subtract}
   * @function
   */

  var sub$1 = subtract$1;

  var mat2d = /*#__PURE__*/Object.freeze({
    create: create$1,
    clone: clone$1,
    copy: copy$1,
    identity: identity$1,
    fromValues: fromValues$1,
    set: set$1,
    invert: invert$1,
    determinant: determinant$1,
    multiply: multiply$1,
    rotate: rotate$1,
    scale: scale$1,
    translate: translate,
    fromRotation: fromRotation$1,
    fromScaling: fromScaling$1,
    fromTranslation: fromTranslation,
    str: str$1,
    frob: frob$1,
    add: add$1,
    subtract: subtract$1,
    multiplyScalar: multiplyScalar$1,
    multiplyScalarAndAdd: multiplyScalarAndAdd$1,
    exactEquals: exactEquals$1,
    equals: equals$2,
    mul: mul$1,
    sub: sub$1
  });

  /**
   * 3x3 Matrix
   * @module mat3
   */

  /**
   * Creates a new identity mat3
   *
   * @returns {mat3} a new 3x3 matrix
   */

  function create$2() {
    var out = new ARRAY_TYPE(9);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }

    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  /**
   * Copies the upper-left 3x3 values into the given mat3.
   *
   * @param {mat3} out the receiving 3x3 matrix
   * @param {mat4} a   the source 4x4 matrix
   * @returns {mat3} out
   */

  function fromMat4(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
  }
  /**
   * Creates a new mat3 initialized with values from an existing matrix
   *
   * @param {mat3} a matrix to clone
   * @returns {mat3} a new 3x3 matrix
   */

  function clone$2(a) {
    var out = new ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  /**
   * Copy the values from one mat3 to another
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the source matrix
   * @returns {mat3} out
   */

  function copy$2(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  /**
   * Create a new mat3 with the given values
   *
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m10 Component in column 1, row 0 position (index 3)
   * @param {Number} m11 Component in column 1, row 1 position (index 4)
   * @param {Number} m12 Component in column 1, row 2 position (index 5)
   * @param {Number} m20 Component in column 2, row 0 position (index 6)
   * @param {Number} m21 Component in column 2, row 1 position (index 7)
   * @param {Number} m22 Component in column 2, row 2 position (index 8)
   * @returns {mat3} A new mat3
   */

  function fromValues$2(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  /**
   * Set the components of a mat3 to the given values
   *
   * @param {mat3} out the receiving matrix
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m10 Component in column 1, row 0 position (index 3)
   * @param {Number} m11 Component in column 1, row 1 position (index 4)
   * @param {Number} m12 Component in column 1, row 2 position (index 5)
   * @param {Number} m20 Component in column 2, row 0 position (index 6)
   * @param {Number} m21 Component in column 2, row 1 position (index 7)
   * @param {Number} m22 Component in column 2, row 2 position (index 8)
   * @returns {mat3} out
   */

  function set$2(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  /**
   * Set a mat3 to the identity matrix
   *
   * @param {mat3} out the receiving matrix
   * @returns {mat3} out
   */

  function identity$2(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  /**
   * Transpose the values of a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the source matrix
   * @returns {mat3} out
   */

  function transpose$1(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
      var a01 = a[1],
          a02 = a[2],
          a12 = a[5];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a01;
      out[5] = a[7];
      out[6] = a02;
      out[7] = a12;
    } else {
      out[0] = a[0];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a[1];
      out[4] = a[4];
      out[5] = a[7];
      out[6] = a[2];
      out[7] = a[5];
      out[8] = a[8];
    }

    return out;
  }
  /**
   * Inverts a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the source matrix
   * @returns {mat3} out
   */

  function invert$2(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

    var det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }
  /**
   * Calculates the adjugate of a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the source matrix
   * @returns {mat3} out
   */

  function adjoint$1(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    out[0] = a11 * a22 - a12 * a21;
    out[1] = a02 * a21 - a01 * a22;
    out[2] = a01 * a12 - a02 * a11;
    out[3] = a12 * a20 - a10 * a22;
    out[4] = a00 * a22 - a02 * a20;
    out[5] = a02 * a10 - a00 * a12;
    out[6] = a10 * a21 - a11 * a20;
    out[7] = a01 * a20 - a00 * a21;
    out[8] = a00 * a11 - a01 * a10;
    return out;
  }
  /**
   * Calculates the determinant of a mat3
   *
   * @param {mat3} a the source matrix
   * @returns {Number} determinant of a
   */

  function determinant$2(a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  }
  /**
   * Multiplies two mat3's
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the first operand
   * @param {mat3} b the second operand
   * @returns {mat3} out
   */

  function multiply$2(out, a, b) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    var b00 = b[0],
        b01 = b[1],
        b02 = b[2];
    var b10 = b[3],
        b11 = b[4],
        b12 = b[5];
    var b20 = b[6],
        b21 = b[7],
        b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  /**
   * Translate a mat3 by the given vector
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the matrix to translate
   * @param {vec2} v vector to translate by
   * @returns {mat3} out
   */

  function translate$1(out, a, v) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a10 = a[3],
        a11 = a[4],
        a12 = a[5],
        a20 = a[6],
        a21 = a[7],
        a22 = a[8],
        x = v[0],
        y = v[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
  }
  /**
   * Rotates a mat3 by the given angle
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat3} out
   */

  function rotate$2(out, a, rad) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a10 = a[3],
        a11 = a[4],
        a12 = a[5],
        a20 = a[6],
        a21 = a[7],
        a22 = a[8],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;
    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
  }
  /**
   * Scales the mat3 by the dimensions in the given vec2
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the matrix to rotate
   * @param {vec2} v the vec2 to scale the matrix by
   * @returns {mat3} out
   **/

  function scale$2(out, a, v) {
    var x = v[0],
        y = v[1];
    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];
    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  /**
   * Creates a matrix from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.translate(dest, dest, vec);
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {vec2} v Translation vector
   * @returns {mat3} out
   */

  function fromTranslation$1(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
  }
  /**
   * Creates a matrix from a given angle
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.rotate(dest, dest, rad);
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat3} out
   */

  function fromRotation$2(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = -s;
    out[4] = c;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.scale(dest, dest, vec);
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {vec2} v Scaling vector
   * @returns {mat3} out
   */

  function fromScaling$2(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  /**
   * Copies the values from a mat2d into a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {mat2d} a the matrix to copy
   * @returns {mat3} out
   **/

  function fromMat2d(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;
    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;
    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
  }
  /**
  * Calculates a 3x3 matrix from the given quaternion
  *
  * @param {mat3} out mat3 receiving operation result
  * @param {quat} q Quaternion to create matrix from
  *
  * @returns {mat3} out
  */

  function fromQuat(out, q) {
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
  }
  /**
  * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
  *
  * @param {mat3} out mat3 receiving operation result
  * @param {mat4} a Mat4 to derive the normal matrix from
  *
  * @returns {mat3} out
  */

  function normalFromMat4(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    return out;
  }
  /**
   * Generates a 2D projection matrix with the given bounds
   *
   * @param {mat3} out mat3 frustum matrix will be written into
   * @param {number} width Width of your gl context
   * @param {number} height Height of gl context
   * @returns {mat3} out
   */

  function projection(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
  }
  /**
   * Returns a string representation of a mat3
   *
   * @param {mat3} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */

  function str$2(a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
  }
  /**
   * Returns Frobenius norm of a mat3
   *
   * @param {mat3} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */

  function frob$2(a) {
    return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
  }
  /**
   * Adds two mat3's
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the first operand
   * @param {mat3} b the second operand
   * @returns {mat3} out
   */

  function add$2(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the first operand
   * @param {mat3} b the second operand
   * @returns {mat3} out
   */

  function subtract$2(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
  }
  /**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat3} out the receiving matrix
   * @param {mat3} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat3} out
   */

  function multiplyScalar$2(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
  }
  /**
   * Adds two mat3's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat3} out the receiving vector
   * @param {mat3} a the first operand
   * @param {mat3} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat3} out
   */

  function multiplyScalarAndAdd$2(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    out[4] = a[4] + b[4] * scale;
    out[5] = a[5] + b[5] * scale;
    out[6] = a[6] + b[6] * scale;
    out[7] = a[7] + b[7] * scale;
    out[8] = a[8] + b[8] * scale;
    return out;
  }
  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {mat3} a The first matrix.
   * @param {mat3} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function exactEquals$2(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
  }
  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {mat3} a The first matrix.
   * @param {mat3} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function equals$3(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5],
        a6 = a[6],
        a7 = a[7],
        a8 = a[8];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5],
        b6 = b[6],
        b7 = b[7],
        b8 = b[8];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
  }
  /**
   * Alias for {@link mat3.multiply}
   * @function
   */

  var mul$2 = multiply$2;
  /**
   * Alias for {@link mat3.subtract}
   * @function
   */

  var sub$2 = subtract$2;

  var mat3 = /*#__PURE__*/Object.freeze({
    create: create$2,
    fromMat4: fromMat4,
    clone: clone$2,
    copy: copy$2,
    fromValues: fromValues$2,
    set: set$2,
    identity: identity$2,
    transpose: transpose$1,
    invert: invert$2,
    adjoint: adjoint$1,
    determinant: determinant$2,
    multiply: multiply$2,
    translate: translate$1,
    rotate: rotate$2,
    scale: scale$2,
    fromTranslation: fromTranslation$1,
    fromRotation: fromRotation$2,
    fromScaling: fromScaling$2,
    fromMat2d: fromMat2d,
    fromQuat: fromQuat,
    normalFromMat4: normalFromMat4,
    projection: projection,
    str: str$2,
    frob: frob$2,
    add: add$2,
    subtract: subtract$2,
    multiplyScalar: multiplyScalar$2,
    multiplyScalarAndAdd: multiplyScalarAndAdd$2,
    exactEquals: exactEquals$2,
    equals: equals$3,
    mul: mul$2,
    sub: sub$2
  });

  /**
   * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
   * @module mat4
   */

  /**
   * Creates a new identity mat4
   *
   * @returns {mat4} a new 4x4 matrix
   */

  function create$3() {
    var out = new ARRAY_TYPE(16);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
    }

    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a new mat4 initialized with values from an existing matrix
   *
   * @param {mat4} a matrix to clone
   * @returns {mat4} a new 4x4 matrix
   */

  function clone$3(a) {
    var out = new ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Copy the values from one mat4 to another
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the source matrix
   * @returns {mat4} out
   */

  function copy$3(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Create a new mat4 with the given values
   *
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m03 Component in column 0, row 3 position (index 3)
   * @param {Number} m10 Component in column 1, row 0 position (index 4)
   * @param {Number} m11 Component in column 1, row 1 position (index 5)
   * @param {Number} m12 Component in column 1, row 2 position (index 6)
   * @param {Number} m13 Component in column 1, row 3 position (index 7)
   * @param {Number} m20 Component in column 2, row 0 position (index 8)
   * @param {Number} m21 Component in column 2, row 1 position (index 9)
   * @param {Number} m22 Component in column 2, row 2 position (index 10)
   * @param {Number} m23 Component in column 2, row 3 position (index 11)
   * @param {Number} m30 Component in column 3, row 0 position (index 12)
   * @param {Number} m31 Component in column 3, row 1 position (index 13)
   * @param {Number} m32 Component in column 3, row 2 position (index 14)
   * @param {Number} m33 Component in column 3, row 3 position (index 15)
   * @returns {mat4} A new mat4
   */

  function fromValues$3(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  /**
   * Set the components of a mat4 to the given values
   *
   * @param {mat4} out the receiving matrix
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m03 Component in column 0, row 3 position (index 3)
   * @param {Number} m10 Component in column 1, row 0 position (index 4)
   * @param {Number} m11 Component in column 1, row 1 position (index 5)
   * @param {Number} m12 Component in column 1, row 2 position (index 6)
   * @param {Number} m13 Component in column 1, row 3 position (index 7)
   * @param {Number} m20 Component in column 2, row 0 position (index 8)
   * @param {Number} m21 Component in column 2, row 1 position (index 9)
   * @param {Number} m22 Component in column 2, row 2 position (index 10)
   * @param {Number} m23 Component in column 2, row 3 position (index 11)
   * @param {Number} m30 Component in column 3, row 0 position (index 12)
   * @param {Number} m31 Component in column 3, row 1 position (index 13)
   * @param {Number} m32 Component in column 3, row 2 position (index 14)
   * @param {Number} m33 Component in column 3, row 3 position (index 15)
   * @returns {mat4} out
   */

  function set$3(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  /**
   * Set a mat4 to the identity matrix
   *
   * @param {mat4} out the receiving matrix
   * @returns {mat4} out
   */

  function identity$3(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Transpose the values of a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the source matrix
   * @returns {mat4} out
   */

  function transpose$2(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
      var a01 = a[1],
          a02 = a[2],
          a03 = a[3];
      var a12 = a[6],
          a13 = a[7];
      var a23 = a[11];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a01;
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a[0];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a[1];
      out[5] = a[5];
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a[2];
      out[9] = a[6];
      out[10] = a[10];
      out[11] = a[14];
      out[12] = a[3];
      out[13] = a[7];
      out[14] = a[11];
      out[15] = a[15];
    }

    return out;
  }
  /**
   * Inverts a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the source matrix
   * @returns {mat4} out
   */

  function invert$3(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  /**
   * Calculates the adjugate of a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the source matrix
   * @returns {mat4} out
   */

  function adjoint$2(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
    out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
    out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
    out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
    out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
    out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
    return out;
  }
  /**
   * Calculates the determinant of a mat4
   *
   * @param {mat4} a the source matrix
   * @returns {Number} determinant of a
   */

  function determinant$3(a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  }
  /**
   * Multiplies two mat4s
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the first operand
   * @param {mat4} b the second operand
   * @returns {mat4} out
   */

  function multiply$3(out, a, b) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15]; // Cache only the current line of the second matrix

    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  /**
   * Translate a mat4 by the given vector
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to translate
   * @param {vec3} v vector to translate by
   * @returns {mat4} out
   */

  function translate$2(out, a, v) {
    var x = v[0],
        y = v[1],
        z = v[2];
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;

    if (a === out) {
      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
      a00 = a[0];
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a10 = a[4];
      a11 = a[5];
      a12 = a[6];
      a13 = a[7];
      a20 = a[8];
      a21 = a[9];
      a22 = a[10];
      a23 = a[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x + a10 * y + a20 * z + a[12];
      out[13] = a01 * x + a11 * y + a21 * z + a[13];
      out[14] = a02 * x + a12 * y + a22 * z + a[14];
      out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
  }
  /**
   * Scales the mat4 by the dimensions in the given vec3 not using vectorization
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to scale
   * @param {vec3} v the vec3 to scale the matrix by
   * @returns {mat4} out
   **/

  function scale$3(out, a, v) {
    var x = v[0],
        y = v[1],
        z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Rotates a mat4 by the given angle around the given axis
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @param {vec3} axis the axis to rotate around
   * @returns {mat4} out
   */

  function rotate$3(out, a, rad, axis) {
    var x = axis[0],
        y = axis[1],
        z = axis[2];
    var len = Math.sqrt(x * x + y * y + z * z);
    var s, c, t;
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    var b00, b01, b02;
    var b10, b11, b12;
    var b20, b21, b22;

    if (len < EPSILON) {
      return null;
    }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11]; // Construct the elements of the rotation matrix

    b00 = x * x * t + c;
    b01 = y * x * t + z * s;
    b02 = z * x * t - y * s;
    b10 = x * y * t - z * s;
    b11 = y * y * t + c;
    b12 = z * y * t + x * s;
    b20 = x * z * t + y * s;
    b21 = y * z * t - x * s;
    b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) {
      // If the source and destination differ, copy the unchanged last row
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }

    return out;
  }
  /**
   * Rotates a matrix by the given angle around the X axis
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function rotateX(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];

    if (a !== out) {
      // If the source and destination differ, copy the unchanged rows
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    } // Perform axis-specific matrix multiplication


    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
  }
  /**
   * Rotates a matrix by the given angle around the Y axis
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function rotateY(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];

    if (a !== out) {
      // If the source and destination differ, copy the unchanged rows
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    } // Perform axis-specific matrix multiplication


    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
  }
  /**
   * Rotates a matrix by the given angle around the Z axis
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function rotateZ(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];

    if (a !== out) {
      // If the source and destination differ, copy the unchanged last row
      out[8] = a[8];
      out[9] = a[9];
      out[10] = a[10];
      out[11] = a[11];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    } // Perform axis-specific matrix multiplication


    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
  }
  /**
   * Creates a matrix from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, dest, vec);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {vec3} v Translation vector
   * @returns {mat4} out
   */

  function fromTranslation$2(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.scale(dest, dest, vec);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {vec3} v Scaling vector
   * @returns {mat4} out
   */

  function fromScaling$3(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a given angle around a given axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotate(dest, dest, rad, axis);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @param {vec3} axis the axis to rotate around
   * @returns {mat4} out
   */

  function fromRotation$3(out, rad, axis) {
    var x = axis[0],
        y = axis[1],
        z = axis[2];
    var len = Math.sqrt(x * x + y * y + z * z);
    var s, c, t;

    if (len < EPSILON) {
      return null;
    }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c; // Perform rotation-specific matrix multiplication

    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the X axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateX(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function fromXRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication

    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the Y axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateY(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function fromYRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication

    out[0] = c;
    out[1] = 0;
    out[2] = -s;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the Z axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateZ(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function fromZRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication

    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation and vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {vec3} v Translation vector
   * @returns {mat4} out
   */

  function fromRotationTranslation(out, q, v) {
    // Quaternion math
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a new mat4 from a dual quat.
   *
   * @param {mat4} out Matrix
   * @param {quat2} a Dual Quaternion
   * @returns {mat4} mat4 receiving operation result
   */

  function fromQuat2(out, a) {
    var translation = new ARRAY_TYPE(3);
    var bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3],
        ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7];
    var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

    if (magnitude > 0) {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }

    fromRotationTranslation(out, a, translation);
    return out;
  }
  /**
   * Returns the translation vector component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslation,
   *  the returned vector will be the same as the translation vector
   *  originally supplied.
   * @param  {vec3} out Vector to receive translation component
   * @param  {mat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */

  function getTranslation(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
  }
  /**
   * Returns the scaling factor component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslationScale
   *  with a normalized Quaternion paramter, the returned vector will be
   *  the same as the scaling vector
   *  originally supplied.
   * @param  {vec3} out Vector to receive scaling factor component
   * @param  {mat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */

  function getScaling(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
    out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
    out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
    return out;
  }
  /**
   * Returns a quaternion representing the rotational component
   *  of a transformation matrix. If a matrix is built with
   *  fromRotationTranslation, the returned quaternion will be the
   *  same as the quaternion originally supplied.
   * @param {quat} out Quaternion to receive the rotation component
   * @param {mat4} mat Matrix to be decomposed (input)
   * @return {quat} out
   */

  function getRotation(out, mat) {
    // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
    var trace = mat[0] + mat[5] + mat[10];
    var S = 0;

    if (trace > 0) {
      S = Math.sqrt(trace + 1.0) * 2;
      out[3] = 0.25 * S;
      out[0] = (mat[6] - mat[9]) / S;
      out[1] = (mat[8] - mat[2]) / S;
      out[2] = (mat[1] - mat[4]) / S;
    } else if (mat[0] > mat[5] && mat[0] > mat[10]) {
      S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
      out[3] = (mat[6] - mat[9]) / S;
      out[0] = 0.25 * S;
      out[1] = (mat[1] + mat[4]) / S;
      out[2] = (mat[8] + mat[2]) / S;
    } else if (mat[5] > mat[10]) {
      S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
      out[3] = (mat[8] - mat[2]) / S;
      out[0] = (mat[1] + mat[4]) / S;
      out[1] = 0.25 * S;
      out[2] = (mat[6] + mat[9]) / S;
    } else {
      S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
      out[3] = (mat[1] - mat[4]) / S;
      out[0] = (mat[8] + mat[2]) / S;
      out[1] = (mat[6] + mat[9]) / S;
      out[2] = 0.25 * S;
    }

    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale)
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {vec3} v Translation vector
   * @param {vec3} s Scaling vector
   * @returns {mat4} out
   */

  function fromRotationTranslationScale(out, q, v, s) {
    // Quaternion math
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     mat4.translate(dest, origin);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale)
   *     mat4.translate(dest, negativeOrigin);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {vec3} v Translation vector
   * @param {vec3} s Scaling vector
   * @param {vec3} o The origin vector around which to scale and rotate
   * @returns {mat4} out
   */

  function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
    // Quaternion math
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    var ox = o[0];
    var oy = o[1];
    var oz = o[2];
    var out0 = (1 - (yy + zz)) * sx;
    var out1 = (xy + wz) * sx;
    var out2 = (xz - wy) * sx;
    var out4 = (xy - wz) * sy;
    var out5 = (1 - (xx + zz)) * sy;
    var out6 = (yz + wx) * sy;
    var out8 = (xz + wy) * sz;
    var out9 = (yz - wx) * sz;
    var out10 = (1 - (xx + yy)) * sz;
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = 0;
    out[4] = out4;
    out[5] = out5;
    out[6] = out6;
    out[7] = 0;
    out[8] = out8;
    out[9] = out9;
    out[10] = out10;
    out[11] = 0;
    out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
    out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
    out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
    out[15] = 1;
    return out;
  }
  /**
   * Calculates a 4x4 matrix from the given quaternion
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat} q Quaternion to create matrix from
   *
   * @returns {mat4} out
   */

  function fromQuat$1(out, q) {
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Generates a frustum matrix with the given bounds
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {Number} left Left bound of the frustum
   * @param {Number} right Right bound of the frustum
   * @param {Number} bottom Bottom bound of the frustum
   * @param {Number} top Top bound of the frustum
   * @param {Number} near Near bound of the frustum
   * @param {Number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  /**
   * Generates a perspective projection matrix with the given bounds.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} fovy Vertical field of view in radians
   * @param {number} aspect Aspect ratio. typically viewport width/height
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum, can be null or Infinity
   * @returns {mat4} out
   */

  function perspective(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;

    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }

    return out;
  }
  /**
   * Generates a perspective projection matrix with the given field of view.
   * This is primarily useful for generating projection matrices to be used
   * with the still experiemental WebVR API.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
    var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
    var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
    var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
    var xScale = 2.0 / (leftTan + rightTan);
    var yScale = 2.0 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = far * near / (near - far);
    out[15] = 0.0;
    return out;
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} left Left bound of the frustum
   * @param {number} right Right bound of the frustum
   * @param {number} bottom Bottom bound of the frustum
   * @param {number} top Top bound of the frustum
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function ortho(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  /**
   * Generates a look-at matrix with the given eye position, focal point, and up axis.
   * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {vec3} eye Position of the viewer
   * @param {vec3} center Point the viewer is looking at
   * @param {vec3} up vec3 pointing up
   * @returns {mat4} out
   */

  function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];

    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
      return identity$3(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);

    if (!len) {
      x0 = 0;
      x1 = 0;
      x2 = 0;
    } else {
      len = 1 / len;
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);

    if (!len) {
      y0 = 0;
      y1 = 0;
      y2 = 0;
    } else {
      len = 1 / len;
      y0 *= len;
      y1 *= len;
      y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }
  /**
   * Generates a matrix that makes something look at something else.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {vec3} eye Position of the viewer
   * @param {vec3} center Point the viewer is looking at
   * @param {vec3} up vec3 pointing up
   * @returns {mat4} out
   */

  function targetTo(out, eye, target, up) {
    var eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2];
    var z0 = eyex - target[0],
        z1 = eyey - target[1],
        z2 = eyez - target[2];
    var len = z0 * z0 + z1 * z1 + z2 * z2;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      z0 *= len;
      z1 *= len;
      z2 *= len;
    }

    var x0 = upy * z2 - upz * z1,
        x1 = upz * z0 - upx * z2,
        x2 = upx * z1 - upy * z0;
    len = x0 * x0 + x1 * x1 + x2 * x2;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }

    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
  }
  /**
   * Returns a string representation of a mat4
   *
   * @param {mat4} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */

  function str$3(a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
  }
  /**
   * Returns Frobenius norm of a mat4
   *
   * @param {mat4} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */

  function frob$3(a) {
    return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));
  }
  /**
   * Adds two mat4's
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the first operand
   * @param {mat4} b the second operand
   * @returns {mat4} out
   */

  function add$3(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the first operand
   * @param {mat4} b the second operand
   * @returns {mat4} out
   */

  function subtract$3(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
  }
  /**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat4} out
   */

  function multiplyScalar$3(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
  }
  /**
   * Adds two mat4's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat4} out the receiving vector
   * @param {mat4} a the first operand
   * @param {mat4} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat4} out
   */

  function multiplyScalarAndAdd$3(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    out[4] = a[4] + b[4] * scale;
    out[5] = a[5] + b[5] * scale;
    out[6] = a[6] + b[6] * scale;
    out[7] = a[7] + b[7] * scale;
    out[8] = a[8] + b[8] * scale;
    out[9] = a[9] + b[9] * scale;
    out[10] = a[10] + b[10] * scale;
    out[11] = a[11] + b[11] * scale;
    out[12] = a[12] + b[12] * scale;
    out[13] = a[13] + b[13] * scale;
    out[14] = a[14] + b[14] * scale;
    out[15] = a[15] + b[15] * scale;
    return out;
  }
  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {mat4} a The first matrix.
   * @param {mat4} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function exactEquals$3(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
  }
  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {mat4} a The first matrix.
   * @param {mat4} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function equals$4(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var a4 = a[4],
        a5 = a[5],
        a6 = a[6],
        a7 = a[7];
    var a8 = a[8],
        a9 = a[9],
        a10 = a[10],
        a11 = a[11];
    var a12 = a[12],
        a13 = a[13],
        a14 = a[14],
        a15 = a[15];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    var b4 = b[4],
        b5 = b[5],
        b6 = b[6],
        b7 = b[7];
    var b8 = b[8],
        b9 = b[9],
        b10 = b[10],
        b11 = b[11];
    var b12 = b[12],
        b13 = b[13],
        b14 = b[14],
        b15 = b[15];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
  }
  /**
   * Alias for {@link mat4.multiply}
   * @function
   */

  var mul$3 = multiply$3;
  /**
   * Alias for {@link mat4.subtract}
   * @function
   */

  var sub$3 = subtract$3;

  var mat4 = /*#__PURE__*/Object.freeze({
    create: create$3,
    clone: clone$3,
    copy: copy$3,
    fromValues: fromValues$3,
    set: set$3,
    identity: identity$3,
    transpose: transpose$2,
    invert: invert$3,
    adjoint: adjoint$2,
    determinant: determinant$3,
    multiply: multiply$3,
    translate: translate$2,
    scale: scale$3,
    rotate: rotate$3,
    rotateX: rotateX,
    rotateY: rotateY,
    rotateZ: rotateZ,
    fromTranslation: fromTranslation$2,
    fromScaling: fromScaling$3,
    fromRotation: fromRotation$3,
    fromXRotation: fromXRotation,
    fromYRotation: fromYRotation,
    fromZRotation: fromZRotation,
    fromRotationTranslation: fromRotationTranslation,
    fromQuat2: fromQuat2,
    getTranslation: getTranslation,
    getScaling: getScaling,
    getRotation: getRotation,
    fromRotationTranslationScale: fromRotationTranslationScale,
    fromRotationTranslationScaleOrigin: fromRotationTranslationScaleOrigin,
    fromQuat: fromQuat$1,
    frustum: frustum,
    perspective: perspective,
    perspectiveFromFieldOfView: perspectiveFromFieldOfView,
    ortho: ortho,
    lookAt: lookAt,
    targetTo: targetTo,
    str: str$3,
    frob: frob$3,
    add: add$3,
    subtract: subtract$3,
    multiplyScalar: multiplyScalar$3,
    multiplyScalarAndAdd: multiplyScalarAndAdd$3,
    exactEquals: exactEquals$3,
    equals: equals$4,
    mul: mul$3,
    sub: sub$3
  });

  /**
   * 3 Dimensional Vector
   * @module vec3
   */

  /**
   * Creates a new, empty vec3
   *
   * @returns {vec3} a new 3D vector
   */

  function create$4() {
    var out = new ARRAY_TYPE(3);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }

    return out;
  }
  /**
   * Creates a new vec3 initialized with values from an existing vector
   *
   * @param {vec3} a vector to clone
   * @returns {vec3} a new 3D vector
   */

  function clone$4(a) {
    var out = new ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
  }
  /**
   * Calculates the length of a vec3
   *
   * @param {vec3} a vector to calculate length of
   * @returns {Number} length of a
   */

  function length(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return Math.sqrt(x * x + y * y + z * z);
  }
  /**
   * Creates a new vec3 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @returns {vec3} a new 3D vector
   */

  function fromValues$4(x, y, z) {
    var out = new ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  /**
   * Copy the values from one vec3 to another
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the source vector
   * @returns {vec3} out
   */

  function copy$4(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
  }
  /**
   * Set the components of a vec3 to the given values
   *
   * @param {vec3} out the receiving vector
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @returns {vec3} out
   */

  function set$4(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  /**
   * Adds two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function add$4(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
  }
  /**
   * Subtracts vector b from vector a
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function subtract$4(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
  }
  /**
   * Multiplies two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function multiply$4(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
  }
  /**
   * Divides two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
  }
  /**
   * Math.ceil the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to ceil
   * @returns {vec3} out
   */

  function ceil(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
  }
  /**
   * Math.floor the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to floor
   * @returns {vec3} out
   */

  function floor(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
  }
  /**
   * Returns the minimum of two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function min(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
  }
  /**
   * Returns the maximum of two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function max(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
  }
  /**
   * Math.round the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to round
   * @returns {vec3} out
   */

  function round(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
  }
  /**
   * Scales a vec3 by a scalar number
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec3} out
   */

  function scale$4(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
  }
  /**
   * Adds two vec3's after scaling the second operand by a scalar value
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @param {Number} scale the amount to scale b by before adding
   * @returns {vec3} out
   */

  function scaleAndAdd(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    return out;
  }
  /**
   * Calculates the euclidian distance between two vec3's
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {Number} distance between a and b
   */

  function distance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return Math.sqrt(x * x + y * y + z * z);
  }
  /**
   * Calculates the squared euclidian distance between two vec3's
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {Number} squared distance between a and b
   */

  function squaredDistance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return x * x + y * y + z * z;
  }
  /**
   * Calculates the squared length of a vec3
   *
   * @param {vec3} a vector to calculate squared length of
   * @returns {Number} squared length of a
   */

  function squaredLength(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return x * x + y * y + z * z;
  }
  /**
   * Negates the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to negate
   * @returns {vec3} out
   */

  function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
  }
  /**
   * Returns the inverse of the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to invert
   * @returns {vec3} out
   */

  function inverse(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    out[2] = 1.0 / a[2];
    return out;
  }
  /**
   * Normalize a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to normalize
   * @returns {vec3} out
   */

  function normalize(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var len = x * x + y * y + z * z;

    if (len > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len = 1 / Math.sqrt(len);
    }

    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
    return out;
  }
  /**
   * Calculates the dot product of two vec3's
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {Number} dot product of a and b
   */

  function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  /**
   * Computes the cross product of two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function cross(out, a, b) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    var bx = b[0],
        by = b[1],
        bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  /**
   * Performs a linear interpolation between two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec3} out
   */

  function lerp(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
  }
  /**
   * Performs a hermite interpolation with two control points
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @param {vec3} c the third operand
   * @param {vec3} d the fourth operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec3} out
   */

  function hermite(out, a, b, c, d, t) {
    var factorTimes2 = t * t;
    var factor1 = factorTimes2 * (2 * t - 3) + 1;
    var factor2 = factorTimes2 * (t - 2) + t;
    var factor3 = factorTimes2 * (t - 1);
    var factor4 = factorTimes2 * (3 - 2 * t);
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
  }
  /**
   * Performs a bezier interpolation with two control points
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @param {vec3} c the third operand
   * @param {vec3} d the fourth operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec3} out
   */

  function bezier(out, a, b, c, d, t) {
    var inverseFactor = 1 - t;
    var inverseFactorTimesTwo = inverseFactor * inverseFactor;
    var factorTimes2 = t * t;
    var factor1 = inverseFactorTimesTwo * inverseFactor;
    var factor2 = 3 * t * inverseFactorTimesTwo;
    var factor3 = 3 * factorTimes2 * inverseFactor;
    var factor4 = factorTimes2 * t;
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
  }
  /**
   * Generates a random vector with the given scale
   *
   * @param {vec3} out the receiving vector
   * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
   * @returns {vec3} out
   */

  function random(out, scale) {
    scale = scale || 1.0;
    var r = RANDOM() * 2.0 * Math.PI;
    var z = RANDOM() * 2.0 - 1.0;
    var zScale = Math.sqrt(1.0 - z * z) * scale;
    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
  }
  /**
   * Transforms the vec3 with a mat4.
   * 4th vector component is implicitly '1'
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the vector to transform
   * @param {mat4} m matrix to transform with
   * @returns {vec3} out
   */

  function transformMat4(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
  }
  /**
   * Transforms the vec3 with a mat3.
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the vector to transform
   * @param {mat3} m the 3x3 matrix to transform with
   * @returns {vec3} out
   */

  function transformMat3(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
  }
  /**
   * Transforms the vec3 with a quat
   * Can also be used for dual quaternions. (Multiply it with the real part)
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the vector to transform
   * @param {quat} q quaternion to transform with
   * @returns {vec3} out
   */

  function transformQuat(out, a, q) {
    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
    var qx = q[0],
        qy = q[1],
        qz = q[2],
        qw = q[3];
    var x = a[0],
        y = a[1],
        z = a[2]; // var qvec = [qx, qy, qz];
    // var uv = vec3.cross([], qvec, a);

    var uvx = qy * z - qz * y,
        uvy = qz * x - qx * z,
        uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

    var uuvx = qy * uvz - qz * uvy,
        uuvy = qz * uvx - qx * uvz,
        uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2; // vec3.scale(uuv, uuv, 2);

    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

    out[0] = x + uvx + uuvx;
    out[1] = y + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
  }
  /**
   * Rotate a 3D vector around the x-axis
   * @param {vec3} out The receiving vec3
   * @param {vec3} a The vec3 point to rotate
   * @param {vec3} b The origin of the rotation
   * @param {Number} c The angle of rotation
   * @returns {vec3} out
   */

  function rotateX$1(out, a, b, c) {
    var p = [],
        r = []; //Translate point to the origin

    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation

    r[0] = p[0];
    r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
    r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c); //translate to correct position

    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  /**
   * Rotate a 3D vector around the y-axis
   * @param {vec3} out The receiving vec3
   * @param {vec3} a The vec3 point to rotate
   * @param {vec3} b The origin of the rotation
   * @param {Number} c The angle of rotation
   * @returns {vec3} out
   */

  function rotateY$1(out, a, b, c) {
    var p = [],
        r = []; //Translate point to the origin

    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation

    r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
    r[1] = p[1];
    r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c); //translate to correct position

    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  /**
   * Rotate a 3D vector around the z-axis
   * @param {vec3} out The receiving vec3
   * @param {vec3} a The vec3 point to rotate
   * @param {vec3} b The origin of the rotation
   * @param {Number} c The angle of rotation
   * @returns {vec3} out
   */

  function rotateZ$1(out, a, b, c) {
    var p = [],
        r = []; //Translate point to the origin

    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation

    r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
    r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
    r[2] = p[2]; //translate to correct position

    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  /**
   * Get the angle between two 3D vectors
   * @param {vec3} a The first operand
   * @param {vec3} b The second operand
   * @returns {Number} The angle in radians
   */

  function angle(a, b) {
    var tempA = fromValues$4(a[0], a[1], a[2]);
    var tempB = fromValues$4(b[0], b[1], b[2]);
    normalize(tempA, tempA);
    normalize(tempB, tempB);
    var cosine = dot(tempA, tempB);

    if (cosine > 1.0) {
      return 0;
    } else if (cosine < -1.0) {
      return Math.PI;
    } else {
      return Math.acos(cosine);
    }
  }
  /**
   * Set the components of a vec3 to zero
   *
   * @param {vec3} out the receiving vector
   * @returns {vec3} out
   */

  function zero(out) {
    out[0] = 0.0;
    out[1] = 0.0;
    out[2] = 0.0;
    return out;
  }
  /**
   * Returns a string representation of a vector
   *
   * @param {vec3} a vector to represent as a string
   * @returns {String} string representation of the vector
   */

  function str$4(a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
  }
  /**
   * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
   *
   * @param {vec3} a The first vector.
   * @param {vec3} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function exactEquals$4(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   *
   * @param {vec3} a The first vector.
   * @param {vec3} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function equals$5(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
  }
  /**
   * Alias for {@link vec3.subtract}
   * @function
   */

  var sub$4 = subtract$4;
  /**
   * Alias for {@link vec3.multiply}
   * @function
   */

  var mul$4 = multiply$4;
  /**
   * Alias for {@link vec3.divide}
   * @function
   */

  var div = divide;
  /**
   * Alias for {@link vec3.distance}
   * @function
   */

  var dist = distance;
  /**
   * Alias for {@link vec3.squaredDistance}
   * @function
   */

  var sqrDist = squaredDistance;
  /**
   * Alias for {@link vec3.length}
   * @function
   */

  var len = length;
  /**
   * Alias for {@link vec3.squaredLength}
   * @function
   */

  var sqrLen = squaredLength;
  /**
   * Perform some operation over an array of vec3s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  var forEach = function () {
    var vec = create$4();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 3;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
      }

      return a;
    };
  }();

  var vec3 = /*#__PURE__*/Object.freeze({
    create: create$4,
    clone: clone$4,
    length: length,
    fromValues: fromValues$4,
    copy: copy$4,
    set: set$4,
    add: add$4,
    subtract: subtract$4,
    multiply: multiply$4,
    divide: divide,
    ceil: ceil,
    floor: floor,
    min: min,
    max: max,
    round: round,
    scale: scale$4,
    scaleAndAdd: scaleAndAdd,
    distance: distance,
    squaredDistance: squaredDistance,
    squaredLength: squaredLength,
    negate: negate,
    inverse: inverse,
    normalize: normalize,
    dot: dot,
    cross: cross,
    lerp: lerp,
    hermite: hermite,
    bezier: bezier,
    random: random,
    transformMat4: transformMat4,
    transformMat3: transformMat3,
    transformQuat: transformQuat,
    rotateX: rotateX$1,
    rotateY: rotateY$1,
    rotateZ: rotateZ$1,
    angle: angle,
    zero: zero,
    str: str$4,
    exactEquals: exactEquals$4,
    equals: equals$5,
    sub: sub$4,
    mul: mul$4,
    div: div,
    dist: dist,
    sqrDist: sqrDist,
    len: len,
    sqrLen: sqrLen,
    forEach: forEach
  });

  /**
   * 4 Dimensional Vector
   * @module vec4
   */

  /**
   * Creates a new, empty vec4
   *
   * @returns {vec4} a new 4D vector
   */

  function create$5() {
    var out = new ARRAY_TYPE(4);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }

    return out;
  }
  /**
   * Creates a new vec4 initialized with values from an existing vector
   *
   * @param {vec4} a vector to clone
   * @returns {vec4} a new 4D vector
   */

  function clone$5(a) {
    var out = new ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Creates a new vec4 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {vec4} a new 4D vector
   */

  function fromValues$5(x, y, z, w) {
    var out = new ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
  }
  /**
   * Copy the values from one vec4 to another
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the source vector
   * @returns {vec4} out
   */

  function copy$5(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Set the components of a vec4 to the given values
   *
   * @param {vec4} out the receiving vector
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {vec4} out
   */

  function set$5(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
  }
  /**
   * Adds two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {vec4} out
   */

  function add$5(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
  }
  /**
   * Subtracts vector b from vector a
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {vec4} out
   */

  function subtract$5(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
  }
  /**
   * Multiplies two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {vec4} out
   */

  function multiply$5(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
  }
  /**
   * Divides two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {vec4} out
   */

  function divide$1(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
  }
  /**
   * Math.ceil the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a vector to ceil
   * @returns {vec4} out
   */

  function ceil$1(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
  }
  /**
   * Math.floor the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a vector to floor
   * @returns {vec4} out
   */

  function floor$1(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
  }
  /**
   * Returns the minimum of two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {vec4} out
   */

  function min$1(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
  }
  /**
   * Returns the maximum of two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {vec4} out
   */

  function max$1(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
  }
  /**
   * Math.round the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a vector to round
   * @returns {vec4} out
   */

  function round$1(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
  }
  /**
   * Scales a vec4 by a scalar number
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec4} out
   */

  function scale$5(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
  }
  /**
   * Adds two vec4's after scaling the second operand by a scalar value
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @param {Number} scale the amount to scale b by before adding
   * @returns {vec4} out
   */

  function scaleAndAdd$1(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    return out;
  }
  /**
   * Calculates the euclidian distance between two vec4's
   *
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {Number} distance between a and b
   */

  function distance$1(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return Math.sqrt(x * x + y * y + z * z + w * w);
  }
  /**
   * Calculates the squared euclidian distance between two vec4's
   *
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {Number} squared distance between a and b
   */

  function squaredDistance$1(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return x * x + y * y + z * z + w * w;
  }
  /**
   * Calculates the length of a vec4
   *
   * @param {vec4} a vector to calculate length of
   * @returns {Number} length of a
   */

  function length$1(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return Math.sqrt(x * x + y * y + z * z + w * w);
  }
  /**
   * Calculates the squared length of a vec4
   *
   * @param {vec4} a vector to calculate squared length of
   * @returns {Number} squared length of a
   */

  function squaredLength$1(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return x * x + y * y + z * z + w * w;
  }
  /**
   * Negates the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a vector to negate
   * @returns {vec4} out
   */

  function negate$1(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
  }
  /**
   * Returns the inverse of the components of a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a vector to invert
   * @returns {vec4} out
   */

  function inverse$1(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    out[2] = 1.0 / a[2];
    out[3] = 1.0 / a[3];
    return out;
  }
  /**
   * Normalize a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a vector to normalize
   * @returns {vec4} out
   */

  function normalize$1(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    var len = x * x + y * y + z * z + w * w;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
    }

    out[0] = x * len;
    out[1] = y * len;
    out[2] = z * len;
    out[3] = w * len;
    return out;
  }
  /**
   * Calculates the dot product of two vec4's
   *
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @returns {Number} dot product of a and b
   */

  function dot$1(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  /**
   * Returns the cross-product of three vectors in a 4-dimensional space
   *
   * @param {vec4} result the receiving vector
   * @param {vec4} U the first vector
   * @param {vec4} V the second vector
   * @param {vec4} W the third vector
   * @returns {vec4} result
   */

  function cross$1(out, u, v, w) {
    var A = v[0] * w[1] - v[1] * w[0],
        B = v[0] * w[2] - v[2] * w[0],
        C = v[0] * w[3] - v[3] * w[0],
        D = v[1] * w[2] - v[2] * w[1],
        E = v[1] * w[3] - v[3] * w[1],
        F = v[2] * w[3] - v[3] * w[2];
    var G = u[0];
    var H = u[1];
    var I = u[2];
    var J = u[3];
    out[0] = H * F - I * E + J * D;
    out[1] = -(G * F) + I * C - J * B;
    out[2] = G * E - H * C + J * A;
    out[3] = -(G * D) + H * B - I * A;
    return out;
  }
  /**
   * Performs a linear interpolation between two vec4's
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the first operand
   * @param {vec4} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec4} out
   */

  function lerp$1(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    var aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
  }
  /**
   * Generates a random vector with the given scale
   *
   * @param {vec4} out the receiving vector
   * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
   * @returns {vec4} out
   */

  function random$1(out, scale) {
    scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
    // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
    // http://projecteuclid.org/euclid.aoms/1177692644;

    var v1, v2, v3, v4;
    var s1, s2;

    do {
      v1 = RANDOM() * 2 - 1;
      v2 = RANDOM() * 2 - 1;
      s1 = v1 * v1 + v2 * v2;
    } while (s1 >= 1);

    do {
      v3 = RANDOM() * 2 - 1;
      v4 = RANDOM() * 2 - 1;
      s2 = v3 * v3 + v4 * v4;
    } while (s2 >= 1);

    var d = Math.sqrt((1 - s1) / s2);
    out[0] = scale * v1;
    out[1] = scale * v2;
    out[2] = scale * v3 * d;
    out[3] = scale * v4 * d;
    return out;
  }
  /**
   * Transforms the vec4 with a mat4.
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the vector to transform
   * @param {mat4} m matrix to transform with
   * @returns {vec4} out
   */

  function transformMat4$1(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
  }
  /**
   * Transforms the vec4 with a quat
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the vector to transform
   * @param {quat} q quaternion to transform with
   * @returns {vec4} out
   */

  function transformQuat$1(out, a, q) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var qx = q[0],
        qy = q[1],
        qz = q[2],
        qw = q[3]; // calculate quat * vec

    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
  }
  /**
   * Set the components of a vec4 to zero
   *
   * @param {vec4} out the receiving vector
   * @returns {vec4} out
   */

  function zero$1(out) {
    out[0] = 0.0;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    return out;
  }
  /**
   * Returns a string representation of a vector
   *
   * @param {vec4} a vector to represent as a string
   * @returns {String} string representation of the vector
   */

  function str$5(a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
  }
  /**
   * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
   *
   * @param {vec4} a The first vector.
   * @param {vec4} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function exactEquals$5(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   *
   * @param {vec4} a The first vector.
   * @param {vec4} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function equals$6(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
  }
  /**
   * Alias for {@link vec4.subtract}
   * @function
   */

  var sub$5 = subtract$5;
  /**
   * Alias for {@link vec4.multiply}
   * @function
   */

  var mul$5 = multiply$5;
  /**
   * Alias for {@link vec4.divide}
   * @function
   */

  var div$1 = divide$1;
  /**
   * Alias for {@link vec4.distance}
   * @function
   */

  var dist$1 = distance$1;
  /**
   * Alias for {@link vec4.squaredDistance}
   * @function
   */

  var sqrDist$1 = squaredDistance$1;
  /**
   * Alias for {@link vec4.length}
   * @function
   */

  var len$1 = length$1;
  /**
   * Alias for {@link vec4.squaredLength}
   * @function
   */

  var sqrLen$1 = squaredLength$1;
  /**
   * Perform some operation over an array of vec4s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  var forEach$1 = function () {
    var vec = create$5();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 4;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        vec[3] = a[i + 3];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
        a[i + 3] = vec[3];
      }

      return a;
    };
  }();

  var vec4 = /*#__PURE__*/Object.freeze({
    create: create$5,
    clone: clone$5,
    fromValues: fromValues$5,
    copy: copy$5,
    set: set$5,
    add: add$5,
    subtract: subtract$5,
    multiply: multiply$5,
    divide: divide$1,
    ceil: ceil$1,
    floor: floor$1,
    min: min$1,
    max: max$1,
    round: round$1,
    scale: scale$5,
    scaleAndAdd: scaleAndAdd$1,
    distance: distance$1,
    squaredDistance: squaredDistance$1,
    length: length$1,
    squaredLength: squaredLength$1,
    negate: negate$1,
    inverse: inverse$1,
    normalize: normalize$1,
    dot: dot$1,
    cross: cross$1,
    lerp: lerp$1,
    random: random$1,
    transformMat4: transformMat4$1,
    transformQuat: transformQuat$1,
    zero: zero$1,
    str: str$5,
    exactEquals: exactEquals$5,
    equals: equals$6,
    sub: sub$5,
    mul: mul$5,
    div: div$1,
    dist: dist$1,
    sqrDist: sqrDist$1,
    len: len$1,
    sqrLen: sqrLen$1,
    forEach: forEach$1
  });

  /**
   * Quaternion
   * @module quat
   */

  /**
   * Creates a new identity quat
   *
   * @returns {quat} a new quaternion
   */

  function create$6() {
    var out = new ARRAY_TYPE(4);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }

    out[3] = 1;
    return out;
  }
  /**
   * Set a quat to the identity quaternion
   *
   * @param {quat} out the receiving quaternion
   * @returns {quat} out
   */

  function identity$4(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  /**
   * Sets a quat from the given angle and rotation axis,
   * then returns it.
   *
   * @param {quat} out the receiving quaternion
   * @param {vec3} axis the axis around which to rotate
   * @param {Number} rad the angle in radians
   * @returns {quat} out
   **/

  function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
  }
  /**
   * Gets the rotation axis and angle for a given
   *  quaternion. If a quaternion is created with
   *  setAxisAngle, this method will return the same
   *  values as providied in the original parameter list
   *  OR functionally equivalent values.
   * Example: The quaternion formed by axis [0, 0, 1] and
   *  angle -90 is the same as the quaternion formed by
   *  [0, 0, 1] and 270. This method favors the latter.
   * @param  {vec3} out_axis  Vector receiving the axis of rotation
   * @param  {quat} q     Quaternion to be decomposed
   * @return {Number}     Angle, in radians, of the rotation
   */

  function getAxisAngle(out_axis, q) {
    var rad = Math.acos(q[3]) * 2.0;
    var s = Math.sin(rad / 2.0);

    if (s > EPSILON) {
      out_axis[0] = q[0] / s;
      out_axis[1] = q[1] / s;
      out_axis[2] = q[2] / s;
    } else {
      // If s is zero, return any axis (no rotation - axis does not matter)
      out_axis[0] = 1;
      out_axis[1] = 0;
      out_axis[2] = 0;
    }

    return rad;
  }
  /**
   * Multiplies two quat's
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @returns {quat} out
   */

  function multiply$6(out, a, b) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bx = b[0],
        by = b[1],
        bz = b[2],
        bw = b[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  /**
   * Rotates a quaternion by the given angle about the X axis
   *
   * @param {quat} out quat receiving operation result
   * @param {quat} a quat to rotate
   * @param {number} rad angle (in radians) to rotate
   * @returns {quat} out
   */

  function rotateX$2(out, a, rad) {
    rad *= 0.5;
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bx = Math.sin(rad),
        bw = Math.cos(rad);
    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
  }
  /**
   * Rotates a quaternion by the given angle about the Y axis
   *
   * @param {quat} out quat receiving operation result
   * @param {quat} a quat to rotate
   * @param {number} rad angle (in radians) to rotate
   * @returns {quat} out
   */

  function rotateY$2(out, a, rad) {
    rad *= 0.5;
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var by = Math.sin(rad),
        bw = Math.cos(rad);
    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
  }
  /**
   * Rotates a quaternion by the given angle about the Z axis
   *
   * @param {quat} out quat receiving operation result
   * @param {quat} a quat to rotate
   * @param {number} rad angle (in radians) to rotate
   * @returns {quat} out
   */

  function rotateZ$2(out, a, rad) {
    rad *= 0.5;
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bz = Math.sin(rad),
        bw = Math.cos(rad);
    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
  }
  /**
   * Calculates the W component of a quat from the X, Y, and Z components.
   * Assumes that quaternion is 1 unit in length.
   * Any existing W component will be ignored.
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a quat to calculate W component of
   * @returns {quat} out
   */

  function calculateW(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
  }
  /**
   * Performs a spherical linear interpolation between two quat
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   */

  function slerp(out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bx = b[0],
        by = b[1],
        bz = b[2],
        bw = b[3];
    var omega, cosom, sinom, scale0, scale1; // calc cosine

    cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

    if (cosom < 0.0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    } // calculate coefficients


    if (1.0 - cosom > EPSILON) {
      // standard case (slerp)
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1.0 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      // "from" and "to" quaternions are very close
      //  ... so we can do a linear interpolation
      scale0 = 1.0 - t;
      scale1 = t;
    } // calculate final values


    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
  /**
   * Generates a random quaternion
   *
   * @param {quat} out the receiving quaternion
   * @returns {quat} out
   */

  function random$2(out) {
    // Implementation of http://planning.cs.uiuc.edu/node198.html
    // TODO: Calling random 3 times is probably not the fastest solution
    var u1 = RANDOM();
    var u2 = RANDOM();
    var u3 = RANDOM();
    var sqrt1MinusU1 = Math.sqrt(1 - u1);
    var sqrtU1 = Math.sqrt(u1);
    out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
    out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
    out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
    out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
    return out;
  }
  /**
   * Calculates the inverse of a quat
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a quat to calculate inverse of
   * @returns {quat} out
   */

  function invert$4(out, a) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var dot$$1 = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
    var invDot = dot$$1 ? 1.0 / dot$$1 : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a2 * invDot;
    out[3] = a3 * invDot;
    return out;
  }
  /**
   * Calculates the conjugate of a quat
   * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a quat to calculate conjugate of
   * @returns {quat} out
   */

  function conjugate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Creates a quaternion from the given 3x3 rotation matrix.
   *
   * NOTE: The resultant quaternion is not normalized, so you should be sure
   * to renormalize the quaternion yourself where necessary.
   *
   * @param {quat} out the receiving quaternion
   * @param {mat3} m rotation matrix
   * @returns {quat} out
   * @function
   */

  function fromMat3(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if (fTrace > 0.0) {
      // |w| > 1/2, may as well choose w > 1/2
      fRoot = Math.sqrt(fTrace + 1.0); // 2w

      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot; // 1/(4w)

      out[0] = (m[5] - m[7]) * fRoot;
      out[1] = (m[6] - m[2]) * fRoot;
      out[2] = (m[1] - m[3]) * fRoot;
    } else {
      // |w| <= 1/2
      var i = 0;
      if (m[4] > m[0]) i = 1;
      if (m[8] > m[i * 3 + i]) i = 2;
      var j = (i + 1) % 3;
      var k = (i + 2) % 3;
      fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
      out[i] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
      out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
      out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
    }

    return out;
  }
  /**
   * Creates a quaternion from the given euler angle x, y, z.
   *
   * @param {quat} out the receiving quaternion
   * @param {x} Angle to rotate around X axis in degrees.
   * @param {y} Angle to rotate around Y axis in degrees.
   * @param {z} Angle to rotate around Z axis in degrees.
   * @returns {quat} out
   * @function
   */

  function fromEuler(out, x, y, z) {
    var halfToRad = 0.5 * Math.PI / 180.0;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;
    var sx = Math.sin(x);
    var cx = Math.cos(x);
    var sy = Math.sin(y);
    var cy = Math.cos(y);
    var sz = Math.sin(z);
    var cz = Math.cos(z);
    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;
    return out;
  }
  /**
   * Returns a string representation of a quatenion
   *
   * @param {quat} a vector to represent as a string
   * @returns {String} string representation of the vector
   */

  function str$6(a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
  }
  /**
   * Creates a new quat initialized with values from an existing quaternion
   *
   * @param {quat} a quaternion to clone
   * @returns {quat} a new quaternion
   * @function
   */

  var clone$6 = clone$5;
  /**
   * Creates a new quat initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {quat} a new quaternion
   * @function
   */

  var fromValues$6 = fromValues$5;
  /**
   * Copy the values from one quat to another
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the source quaternion
   * @returns {quat} out
   * @function
   */

  var copy$6 = copy$5;
  /**
   * Set the components of a quat to the given values
   *
   * @param {quat} out the receiving quaternion
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {quat} out
   * @function
   */

  var set$6 = set$5;
  /**
   * Adds two quat's
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @returns {quat} out
   * @function
   */

  var add$6 = add$5;
  /**
   * Alias for {@link quat.multiply}
   * @function
   */

  var mul$6 = multiply$6;
  /**
   * Scales a quat by a scalar number
   *
   * @param {quat} out the receiving vector
   * @param {quat} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {quat} out
   * @function
   */

  var scale$6 = scale$5;
  /**
   * Calculates the dot product of two quat's
   *
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @returns {Number} dot product of a and b
   * @function
   */

  var dot$2 = dot$1;
  /**
   * Performs a linear interpolation between two quat's
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   * @function
   */

  var lerp$2 = lerp$1;
  /**
   * Calculates the length of a quat
   *
   * @param {quat} a vector to calculate length of
   * @returns {Number} length of a
   */

  var length$2 = length$1;
  /**
   * Alias for {@link quat.length}
   * @function
   */

  var len$2 = length$2;
  /**
   * Calculates the squared length of a quat
   *
   * @param {quat} a vector to calculate squared length of
   * @returns {Number} squared length of a
   * @function
   */

  var squaredLength$2 = squaredLength$1;
  /**
   * Alias for {@link quat.squaredLength}
   * @function
   */

  var sqrLen$2 = squaredLength$2;
  /**
   * Normalize a quat
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a quaternion to normalize
   * @returns {quat} out
   * @function
   */

  var normalize$2 = normalize$1;
  /**
   * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
   *
   * @param {quat} a The first quaternion.
   * @param {quat} b The second quaternion.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  var exactEquals$6 = exactEquals$5;
  /**
   * Returns whether or not the quaternions have approximately the same elements in the same position.
   *
   * @param {quat} a The first vector.
   * @param {quat} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  var equals$7 = equals$6;
  /**
   * Sets a quaternion to represent the shortest rotation from one
   * vector to another.
   *
   * Both vectors are assumed to be unit length.
   *
   * @param {quat} out the receiving quaternion.
   * @param {vec3} a the initial vector
   * @param {vec3} b the destination vector
   * @returns {quat} out
   */

  var rotationTo = function () {
    var tmpvec3 = create$4();
    var xUnitVec3 = fromValues$4(1, 0, 0);
    var yUnitVec3 = fromValues$4(0, 1, 0);
    return function (out, a, b) {
      var dot$$1 = dot(a, b);

      if (dot$$1 < -0.999999) {
        cross(tmpvec3, xUnitVec3, a);
        if (len(tmpvec3) < 0.000001) cross(tmpvec3, yUnitVec3, a);
        normalize(tmpvec3, tmpvec3);
        setAxisAngle(out, tmpvec3, Math.PI);
        return out;
      } else if (dot$$1 > 0.999999) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      } else {
        cross(tmpvec3, a, b);
        out[0] = tmpvec3[0];
        out[1] = tmpvec3[1];
        out[2] = tmpvec3[2];
        out[3] = 1 + dot$$1;
        return normalize$2(out, out);
      }
    };
  }();
  /**
   * Performs a spherical linear interpolation with two control points
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @param {quat} c the third operand
   * @param {quat} d the fourth operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   */

  var sqlerp = function () {
    var temp1 = create$6();
    var temp2 = create$6();
    return function (out, a, b, c, d, t) {
      slerp(temp1, a, d, t);
      slerp(temp2, b, c, t);
      slerp(out, temp1, temp2, 2 * t * (1 - t));
      return out;
    };
  }();
  /**
   * Sets the specified quaternion with values corresponding to the given
   * axes. Each axis is a vec3 and is expected to be unit length and
   * perpendicular to all other specified axes.
   *
   * @param {vec3} view  the vector representing the viewing direction
   * @param {vec3} right the vector representing the local "right" direction
   * @param {vec3} up    the vector representing the local "up" direction
   * @returns {quat} out
   */

  var setAxes = function () {
    var matr = create$2();
    return function (out, view, right, up) {
      matr[0] = right[0];
      matr[3] = right[1];
      matr[6] = right[2];
      matr[1] = up[0];
      matr[4] = up[1];
      matr[7] = up[2];
      matr[2] = -view[0];
      matr[5] = -view[1];
      matr[8] = -view[2];
      return normalize$2(out, fromMat3(out, matr));
    };
  }();

  var quat = /*#__PURE__*/Object.freeze({
    create: create$6,
    identity: identity$4,
    setAxisAngle: setAxisAngle,
    getAxisAngle: getAxisAngle,
    multiply: multiply$6,
    rotateX: rotateX$2,
    rotateY: rotateY$2,
    rotateZ: rotateZ$2,
    calculateW: calculateW,
    slerp: slerp,
    random: random$2,
    invert: invert$4,
    conjugate: conjugate,
    fromMat3: fromMat3,
    fromEuler: fromEuler,
    str: str$6,
    clone: clone$6,
    fromValues: fromValues$6,
    copy: copy$6,
    set: set$6,
    add: add$6,
    mul: mul$6,
    scale: scale$6,
    dot: dot$2,
    lerp: lerp$2,
    length: length$2,
    len: len$2,
    squaredLength: squaredLength$2,
    sqrLen: sqrLen$2,
    normalize: normalize$2,
    exactEquals: exactEquals$6,
    equals: equals$7,
    rotationTo: rotationTo,
    sqlerp: sqlerp,
    setAxes: setAxes
  });

  /**
   * Dual Quaternion<br>
   * Format: [real, dual]<br>
   * Quaternion format: XYZW<br>
   * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
   * @module quat2
   */

  /**
   * Creates a new identity dual quat
   *
   * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
   */

  function create$7() {
    var dq = new ARRAY_TYPE(8);

    if (ARRAY_TYPE != Float32Array) {
      dq[0] = 0;
      dq[1] = 0;
      dq[2] = 0;
      dq[4] = 0;
      dq[5] = 0;
      dq[6] = 0;
      dq[7] = 0;
    }

    dq[3] = 1;
    return dq;
  }
  /**
   * Creates a new quat initialized with values from an existing quaternion
   *
   * @param {quat2} a dual quaternion to clone
   * @returns {quat2} new dual quaternion
   * @function
   */

  function clone$7(a) {
    var dq = new ARRAY_TYPE(8);
    dq[0] = a[0];
    dq[1] = a[1];
    dq[2] = a[2];
    dq[3] = a[3];
    dq[4] = a[4];
    dq[5] = a[5];
    dq[6] = a[6];
    dq[7] = a[7];
    return dq;
  }
  /**
   * Creates a new dual quat initialized with the given values
   *
   * @param {Number} x1 X component
   * @param {Number} y1 Y component
   * @param {Number} z1 Z component
   * @param {Number} w1 W component
   * @param {Number} x2 X component
   * @param {Number} y2 Y component
   * @param {Number} z2 Z component
   * @param {Number} w2 W component
   * @returns {quat2} new dual quaternion
   * @function
   */

  function fromValues$7(x1, y1, z1, w1, x2, y2, z2, w2) {
    var dq = new ARRAY_TYPE(8);
    dq[0] = x1;
    dq[1] = y1;
    dq[2] = z1;
    dq[3] = w1;
    dq[4] = x2;
    dq[5] = y2;
    dq[6] = z2;
    dq[7] = w2;
    return dq;
  }
  /**
   * Creates a new dual quat from the given values (quat and translation)
   *
   * @param {Number} x1 X component
   * @param {Number} y1 Y component
   * @param {Number} z1 Z component
   * @param {Number} w1 W component
   * @param {Number} x2 X component (translation)
   * @param {Number} y2 Y component (translation)
   * @param {Number} z2 Z component (translation)
   * @returns {quat2} new dual quaternion
   * @function
   */

  function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
    var dq = new ARRAY_TYPE(8);
    dq[0] = x1;
    dq[1] = y1;
    dq[2] = z1;
    dq[3] = w1;
    var ax = x2 * 0.5,
        ay = y2 * 0.5,
        az = z2 * 0.5;
    dq[4] = ax * w1 + ay * z1 - az * y1;
    dq[5] = ay * w1 + az * x1 - ax * z1;
    dq[6] = az * w1 + ax * y1 - ay * x1;
    dq[7] = -ax * x1 - ay * y1 - az * z1;
    return dq;
  }
  /**
   * Creates a dual quat from a quaternion and a translation
   *
   * @param {quat2} dual quaternion receiving operation result
   * @param {quat} q quaternion
   * @param {vec3} t tranlation vector
   * @returns {quat2} dual quaternion receiving operation result
   * @function
   */

  function fromRotationTranslation$1(out, q, t) {
    var ax = t[0] * 0.5,
        ay = t[1] * 0.5,
        az = t[2] * 0.5,
        bx = q[0],
        by = q[1],
        bz = q[2],
        bw = q[3];
    out[0] = bx;
    out[1] = by;
    out[2] = bz;
    out[3] = bw;
    out[4] = ax * bw + ay * bz - az * by;
    out[5] = ay * bw + az * bx - ax * bz;
    out[6] = az * bw + ax * by - ay * bx;
    out[7] = -ax * bx - ay * by - az * bz;
    return out;
  }
  /**
   * Creates a dual quat from a translation
   *
   * @param {quat2} dual quaternion receiving operation result
   * @param {vec3} t translation vector
   * @returns {quat2} dual quaternion receiving operation result
   * @function
   */

  function fromTranslation$3(out, t) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = t[0] * 0.5;
    out[5] = t[1] * 0.5;
    out[6] = t[2] * 0.5;
    out[7] = 0;
    return out;
  }
  /**
   * Creates a dual quat from a quaternion
   *
   * @param {quat2} dual quaternion receiving operation result
   * @param {quat} q the quaternion
   * @returns {quat2} dual quaternion receiving operation result
   * @function
   */

  function fromRotation$4(out, q) {
    out[0] = q[0];
    out[1] = q[1];
    out[2] = q[2];
    out[3] = q[3];
    out[4] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    return out;
  }
  /**
   * Creates a new dual quat from a matrix (4x4)
   *
   * @param {quat2} out the dual quaternion
   * @param {mat4} a the matrix
   * @returns {quat2} dual quat receiving operation result
   * @function
   */

  function fromMat4$1(out, a) {
    //TODO Optimize this
    var outer = create$6();
    getRotation(outer, a);
    var t = new ARRAY_TYPE(3);
    getTranslation(t, a);
    fromRotationTranslation$1(out, outer, t);
    return out;
  }
  /**
   * Copy the values from one dual quat to another
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the source dual quaternion
   * @returns {quat2} out
   * @function
   */

  function copy$7(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    return out;
  }
  /**
   * Set a dual quat to the identity dual quaternion
   *
   * @param {quat2} out the receiving quaternion
   * @returns {quat2} out
   */

  function identity$5(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    return out;
  }
  /**
   * Set the components of a dual quat to the given values
   *
   * @param {quat2} out the receiving quaternion
   * @param {Number} x1 X component
   * @param {Number} y1 Y component
   * @param {Number} z1 Z component
   * @param {Number} w1 W component
   * @param {Number} x2 X component
   * @param {Number} y2 Y component
   * @param {Number} z2 Z component
   * @param {Number} w2 W component
   * @returns {quat2} out
   * @function
   */

  function set$7(out, x1, y1, z1, w1, x2, y2, z2, w2) {
    out[0] = x1;
    out[1] = y1;
    out[2] = z1;
    out[3] = w1;
    out[4] = x2;
    out[5] = y2;
    out[6] = z2;
    out[7] = w2;
    return out;
  }
  /**
   * Gets the real part of a dual quat
   * @param  {quat} out real part
   * @param  {quat2} a Dual Quaternion
   * @return {quat} real part
   */

  var getReal = copy$6;
  /**
   * Gets the dual part of a dual quat
   * @param  {quat} out dual part
   * @param  {quat2} a Dual Quaternion
   * @return {quat} dual part
   */

  function getDual(out, a) {
    out[0] = a[4];
    out[1] = a[5];
    out[2] = a[6];
    out[3] = a[7];
    return out;
  }
  /**
   * Set the real component of a dual quat to the given quaternion
   *
   * @param {quat2} out the receiving quaternion
   * @param {quat} q a quaternion representing the real part
   * @returns {quat2} out
   * @function
   */

  var setReal = copy$6;
  /**
   * Set the dual component of a dual quat to the given quaternion
   *
   * @param {quat2} out the receiving quaternion
   * @param {quat} q a quaternion representing the dual part
   * @returns {quat2} out
   * @function
   */

  function setDual(out, q) {
    out[4] = q[0];
    out[5] = q[1];
    out[6] = q[2];
    out[7] = q[3];
    return out;
  }
  /**
   * Gets the translation of a normalized dual quat
   * @param  {vec3} out translation
   * @param  {quat2} a Dual Quaternion to be decomposed
   * @return {vec3} translation
   */

  function getTranslation$1(out, a) {
    var ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7],
        bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3];
    out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    return out;
  }
  /**
   * Translates a dual quat by the given vector
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the dual quaternion to translate
   * @param {vec3} v vector to translate by
   * @returns {quat2} out
   */

  function translate$3(out, a, v) {
    var ax1 = a[0],
        ay1 = a[1],
        az1 = a[2],
        aw1 = a[3],
        bx1 = v[0] * 0.5,
        by1 = v[1] * 0.5,
        bz1 = v[2] * 0.5,
        ax2 = a[4],
        ay2 = a[5],
        az2 = a[6],
        aw2 = a[7];
    out[0] = ax1;
    out[1] = ay1;
    out[2] = az1;
    out[3] = aw1;
    out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
    out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
    out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
    out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
    return out;
  }
  /**
   * Rotates a dual quat around the X axis
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the dual quaternion to rotate
   * @param {number} rad how far should the rotation be
   * @returns {quat2} out
   */

  function rotateX$3(out, a, rad) {
    var bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3],
        ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7],
        ax1 = ax * bw + aw * bx + ay * bz - az * by,
        ay1 = ay * bw + aw * by + az * bx - ax * bz,
        az1 = az * bw + aw * bz + ax * by - ay * bx,
        aw1 = aw * bw - ax * bx - ay * by - az * bz;
    rotateX$2(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
  }
  /**
   * Rotates a dual quat around the Y axis
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the dual quaternion to rotate
   * @param {number} rad how far should the rotation be
   * @returns {quat2} out
   */

  function rotateY$3(out, a, rad) {
    var bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3],
        ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7],
        ax1 = ax * bw + aw * bx + ay * bz - az * by,
        ay1 = ay * bw + aw * by + az * bx - ax * bz,
        az1 = az * bw + aw * bz + ax * by - ay * bx,
        aw1 = aw * bw - ax * bx - ay * by - az * bz;
    rotateY$2(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
  }
  /**
   * Rotates a dual quat around the Z axis
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the dual quaternion to rotate
   * @param {number} rad how far should the rotation be
   * @returns {quat2} out
   */

  function rotateZ$3(out, a, rad) {
    var bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3],
        ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7],
        ax1 = ax * bw + aw * bx + ay * bz - az * by,
        ay1 = ay * bw + aw * by + az * bx - ax * bz,
        az1 = az * bw + aw * bz + ax * by - ay * bx,
        aw1 = aw * bw - ax * bx - ay * by - az * bz;
    rotateZ$2(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
  }
  /**
   * Rotates a dual quat by a given quaternion (a * q)
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the dual quaternion to rotate
   * @param {quat} q quaternion to rotate by
   * @returns {quat2} out
   */

  function rotateByQuatAppend(out, a, q) {
    var qx = q[0],
        qy = q[1],
        qz = q[2],
        qw = q[3],
        ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax * qw + aw * qx + ay * qz - az * qy;
    out[1] = ay * qw + aw * qy + az * qx - ax * qz;
    out[2] = az * qw + aw * qz + ax * qy - ay * qx;
    out[3] = aw * qw - ax * qx - ay * qy - az * qz;
    ax = a[4];
    ay = a[5];
    az = a[6];
    aw = a[7];
    out[4] = ax * qw + aw * qx + ay * qz - az * qy;
    out[5] = ay * qw + aw * qy + az * qx - ax * qz;
    out[6] = az * qw + aw * qz + ax * qy - ay * qx;
    out[7] = aw * qw - ax * qx - ay * qy - az * qz;
    return out;
  }
  /**
   * Rotates a dual quat by a given quaternion (q * a)
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat} q quaternion to rotate by
   * @param {quat2} a the dual quaternion to rotate
   * @returns {quat2} out
   */

  function rotateByQuatPrepend(out, q, a) {
    var qx = q[0],
        qy = q[1],
        qz = q[2],
        qw = q[3],
        bx = a[0],
        by = a[1],
        bz = a[2],
        bw = a[3];
    out[0] = qx * bw + qw * bx + qy * bz - qz * by;
    out[1] = qy * bw + qw * by + qz * bx - qx * bz;
    out[2] = qz * bw + qw * bz + qx * by - qy * bx;
    out[3] = qw * bw - qx * bx - qy * by - qz * bz;
    bx = a[4];
    by = a[5];
    bz = a[6];
    bw = a[7];
    out[4] = qx * bw + qw * bx + qy * bz - qz * by;
    out[5] = qy * bw + qw * by + qz * bx - qx * bz;
    out[6] = qz * bw + qw * bz + qx * by - qy * bx;
    out[7] = qw * bw - qx * bx - qy * by - qz * bz;
    return out;
  }
  /**
   * Rotates a dual quat around a given axis. Does the normalisation automatically
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the dual quaternion to rotate
   * @param {vec3} axis the axis to rotate around
   * @param {Number} rad how far the rotation should be
   * @returns {quat2} out
   */

  function rotateAroundAxis(out, a, axis, rad) {
    //Special case for rad = 0
    if (Math.abs(rad) < EPSILON) {
      return copy$7(out, a);
    }

    var axisLength = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);
    rad = rad * 0.5;
    var s = Math.sin(rad);
    var bx = s * axis[0] / axisLength;
    var by = s * axis[1] / axisLength;
    var bz = s * axis[2] / axisLength;
    var bw = Math.cos(rad);
    var ax1 = a[0],
        ay1 = a[1],
        az1 = a[2],
        aw1 = a[3];
    out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    var ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7];
    out[4] = ax * bw + aw * bx + ay * bz - az * by;
    out[5] = ay * bw + aw * by + az * bx - ax * bz;
    out[6] = az * bw + aw * bz + ax * by - ay * bx;
    out[7] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  /**
   * Adds two dual quat's
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the first operand
   * @param {quat2} b the second operand
   * @returns {quat2} out
   * @function
   */

  function add$7(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    return out;
  }
  /**
   * Multiplies two dual quat's
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a the first operand
   * @param {quat2} b the second operand
   * @returns {quat2} out
   */

  function multiply$7(out, a, b) {
    var ax0 = a[0],
        ay0 = a[1],
        az0 = a[2],
        aw0 = a[3],
        bx1 = b[4],
        by1 = b[5],
        bz1 = b[6],
        bw1 = b[7],
        ax1 = a[4],
        ay1 = a[5],
        az1 = a[6],
        aw1 = a[7],
        bx0 = b[0],
        by0 = b[1],
        bz0 = b[2],
        bw0 = b[3];
    out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
    out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
    out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
    out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
    out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
    out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
    out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
    out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
    return out;
  }
  /**
   * Alias for {@link quat2.multiply}
   * @function
   */

  var mul$7 = multiply$7;
  /**
   * Scales a dual quat by a scalar number
   *
   * @param {quat2} out the receiving dual quat
   * @param {quat2} a the dual quat to scale
   * @param {Number} b amount to scale the dual quat by
   * @returns {quat2} out
   * @function
   */

  function scale$7(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    return out;
  }
  /**
   * Calculates the dot product of two dual quat's (The dot product of the real parts)
   *
   * @param {quat2} a the first operand
   * @param {quat2} b the second operand
   * @returns {Number} dot product of a and b
   * @function
   */

  var dot$3 = dot$2;
  /**
   * Performs a linear interpolation between two dual quats's
   * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
   *
   * @param {quat2} out the receiving dual quat
   * @param {quat2} a the first operand
   * @param {quat2} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat2} out
   */

  function lerp$3(out, a, b, t) {
    var mt = 1 - t;
    if (dot$3(a, b) < 0) t = -t;
    out[0] = a[0] * mt + b[0] * t;
    out[1] = a[1] * mt + b[1] * t;
    out[2] = a[2] * mt + b[2] * t;
    out[3] = a[3] * mt + b[3] * t;
    out[4] = a[4] * mt + b[4] * t;
    out[5] = a[5] * mt + b[5] * t;
    out[6] = a[6] * mt + b[6] * t;
    out[7] = a[7] * mt + b[7] * t;
    return out;
  }
  /**
   * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a dual quat to calculate inverse of
   * @returns {quat2} out
   */

  function invert$5(out, a) {
    var sqlen = squaredLength$3(a);
    out[0] = -a[0] / sqlen;
    out[1] = -a[1] / sqlen;
    out[2] = -a[2] / sqlen;
    out[3] = a[3] / sqlen;
    out[4] = -a[4] / sqlen;
    out[5] = -a[5] / sqlen;
    out[6] = -a[6] / sqlen;
    out[7] = a[7] / sqlen;
    return out;
  }
  /**
   * Calculates the conjugate of a dual quat
   * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
   *
   * @param {quat2} out the receiving quaternion
   * @param {quat2} a quat to calculate conjugate of
   * @returns {quat2} out
   */

  function conjugate$1(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    out[4] = -a[4];
    out[5] = -a[5];
    out[6] = -a[6];
    out[7] = a[7];
    return out;
  }
  /**
   * Calculates the length of a dual quat
   *
   * @param {quat2} a dual quat to calculate length of
   * @returns {Number} length of a
   * @function
   */

  var length$3 = length$2;
  /**
   * Alias for {@link quat2.length}
   * @function
   */

  var len$3 = length$3;
  /**
   * Calculates the squared length of a dual quat
   *
   * @param {quat2} a dual quat to calculate squared length of
   * @returns {Number} squared length of a
   * @function
   */

  var squaredLength$3 = squaredLength$2;
  /**
   * Alias for {@link quat2.squaredLength}
   * @function
   */

  var sqrLen$3 = squaredLength$3;
  /**
   * Normalize a dual quat
   *
   * @param {quat2} out the receiving dual quaternion
   * @param {quat2} a dual quaternion to normalize
   * @returns {quat2} out
   * @function
   */

  function normalize$3(out, a) {
    var magnitude = squaredLength$3(a);

    if (magnitude > 0) {
      magnitude = Math.sqrt(magnitude);
      var a0 = a[0] / magnitude;
      var a1 = a[1] / magnitude;
      var a2 = a[2] / magnitude;
      var a3 = a[3] / magnitude;
      var b0 = a[4];
      var b1 = a[5];
      var b2 = a[6];
      var b3 = a[7];
      var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
      out[0] = a0;
      out[1] = a1;
      out[2] = a2;
      out[3] = a3;
      out[4] = (b0 - a0 * a_dot_b) / magnitude;
      out[5] = (b1 - a1 * a_dot_b) / magnitude;
      out[6] = (b2 - a2 * a_dot_b) / magnitude;
      out[7] = (b3 - a3 * a_dot_b) / magnitude;
    }

    return out;
  }
  /**
   * Returns a string representation of a dual quatenion
   *
   * @param {quat2} a dual quaternion to represent as a string
   * @returns {String} string representation of the dual quat
   */

  function str$7(a) {
    return 'quat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ')';
  }
  /**
   * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
   *
   * @param {quat2} a the first dual quaternion.
   * @param {quat2} b the second dual quaternion.
   * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
   */

  function exactEquals$7(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
  }
  /**
   * Returns whether or not the dual quaternions have approximately the same elements in the same position.
   *
   * @param {quat2} a the first dual quat.
   * @param {quat2} b the second dual quat.
   * @returns {Boolean} true if the dual quats are equal, false otherwise.
   */

  function equals$8(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5],
        a6 = a[6],
        a7 = a[7];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5],
        b6 = b[6],
        b7 = b[7];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7));
  }

  var quat2 = /*#__PURE__*/Object.freeze({
    create: create$7,
    clone: clone$7,
    fromValues: fromValues$7,
    fromRotationTranslationValues: fromRotationTranslationValues,
    fromRotationTranslation: fromRotationTranslation$1,
    fromTranslation: fromTranslation$3,
    fromRotation: fromRotation$4,
    fromMat4: fromMat4$1,
    copy: copy$7,
    identity: identity$5,
    set: set$7,
    getReal: getReal,
    getDual: getDual,
    setReal: setReal,
    setDual: setDual,
    getTranslation: getTranslation$1,
    translate: translate$3,
    rotateX: rotateX$3,
    rotateY: rotateY$3,
    rotateZ: rotateZ$3,
    rotateByQuatAppend: rotateByQuatAppend,
    rotateByQuatPrepend: rotateByQuatPrepend,
    rotateAroundAxis: rotateAroundAxis,
    add: add$7,
    multiply: multiply$7,
    mul: mul$7,
    scale: scale$7,
    dot: dot$3,
    lerp: lerp$3,
    invert: invert$5,
    conjugate: conjugate$1,
    length: length$3,
    len: len$3,
    squaredLength: squaredLength$3,
    sqrLen: sqrLen$3,
    normalize: normalize$3,
    str: str$7,
    exactEquals: exactEquals$7,
    equals: equals$8
  });

  /**
   * 2 Dimensional Vector
   * @module vec2
   */

  /**
   * Creates a new, empty vec2
   *
   * @returns {vec2} a new 2D vector
   */

  function create$8() {
    var out = new ARRAY_TYPE(2);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }

    return out;
  }
  /**
   * Creates a new vec2 initialized with values from an existing vector
   *
   * @param {vec2} a vector to clone
   * @returns {vec2} a new 2D vector
   */

  function clone$8(a) {
    var out = new ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
  }
  /**
   * Creates a new vec2 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @returns {vec2} a new 2D vector
   */

  function fromValues$8(x, y) {
    var out = new ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
  }
  /**
   * Copy the values from one vec2 to another
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the source vector
   * @returns {vec2} out
   */

  function copy$8(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
  }
  /**
   * Set the components of a vec2 to the given values
   *
   * @param {vec2} out the receiving vector
   * @param {Number} x X component
   * @param {Number} y Y component
   * @returns {vec2} out
   */

  function set$8(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
  }
  /**
   * Adds two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec2} out
   */

  function add$8(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
  }
  /**
   * Subtracts vector b from vector a
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec2} out
   */

  function subtract$6(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
  }
  /**
   * Multiplies two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec2} out
   */

  function multiply$8(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
  }
  /**
   * Divides two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec2} out
   */

  function divide$2(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
  }
  /**
   * Math.ceil the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a vector to ceil
   * @returns {vec2} out
   */

  function ceil$2(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
  }
  /**
   * Math.floor the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a vector to floor
   * @returns {vec2} out
   */

  function floor$2(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
  }
  /**
   * Returns the minimum of two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec2} out
   */

  function min$2(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
  }
  /**
   * Returns the maximum of two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec2} out
   */

  function max$2(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
  }
  /**
   * Math.round the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a vector to round
   * @returns {vec2} out
   */

  function round$2(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
  }
  /**
   * Scales a vec2 by a scalar number
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec2} out
   */

  function scale$8(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
  }
  /**
   * Adds two vec2's after scaling the second operand by a scalar value
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @param {Number} scale the amount to scale b by before adding
   * @returns {vec2} out
   */

  function scaleAndAdd$2(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    return out;
  }
  /**
   * Calculates the euclidian distance between two vec2's
   *
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {Number} distance between a and b
   */

  function distance$2(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x * x + y * y);
  }
  /**
   * Calculates the squared euclidian distance between two vec2's
   *
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {Number} squared distance between a and b
   */

  function squaredDistance$2(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x * x + y * y;
  }
  /**
   * Calculates the length of a vec2
   *
   * @param {vec2} a vector to calculate length of
   * @returns {Number} length of a
   */

  function length$4(a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x * x + y * y);
  }
  /**
   * Calculates the squared length of a vec2
   *
   * @param {vec2} a vector to calculate squared length of
   * @returns {Number} squared length of a
   */

  function squaredLength$4(a) {
    var x = a[0],
        y = a[1];
    return x * x + y * y;
  }
  /**
   * Negates the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a vector to negate
   * @returns {vec2} out
   */

  function negate$2(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
  }
  /**
   * Returns the inverse of the components of a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a vector to invert
   * @returns {vec2} out
   */

  function inverse$2(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    return out;
  }
  /**
   * Normalize a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a vector to normalize
   * @returns {vec2} out
   */

  function normalize$4(out, a) {
    var x = a[0],
        y = a[1];
    var len = x * x + y * y;

    if (len > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len = 1 / Math.sqrt(len);
    }

    out[0] = a[0] * len;
    out[1] = a[1] * len;
    return out;
  }
  /**
   * Calculates the dot product of two vec2's
   *
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {Number} dot product of a and b
   */

  function dot$4(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  /**
   * Computes the cross product of two vec2's
   * Note that the cross product must by definition produce a 3D vector
   *
   * @param {vec3} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec3} out
   */

  function cross$2(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
  }
  /**
   * Performs a linear interpolation between two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec2} out
   */

  function lerp$4(out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
  }
  /**
   * Generates a random vector with the given scale
   *
   * @param {vec2} out the receiving vector
   * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
   * @returns {vec2} out
   */

  function random$3(out, scale) {
    scale = scale || 1.0;
    var r = RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
  }
  /**
   * Transforms the vec2 with a mat2
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the vector to transform
   * @param {mat2} m matrix to transform with
   * @returns {vec2} out
   */

  function transformMat2(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
  }
  /**
   * Transforms the vec2 with a mat2d
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the vector to transform
   * @param {mat2d} m matrix to transform with
   * @returns {vec2} out
   */

  function transformMat2d(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
  }
  /**
   * Transforms the vec2 with a mat3
   * 3rd vector component is implicitly '1'
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the vector to transform
   * @param {mat3} m matrix to transform with
   * @returns {vec2} out
   */

  function transformMat3$1(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
  }
  /**
   * Transforms the vec2 with a mat4
   * 3rd vector component is implicitly '0'
   * 4th vector component is implicitly '1'
   *
   * @param {vec2} out the receiving vector
   * @param {vec2} a the vector to transform
   * @param {mat4} m matrix to transform with
   * @returns {vec2} out
   */

  function transformMat4$2(out, a, m) {
    var x = a[0];
    var y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
  }
  /**
   * Rotate a 2D vector
   * @param {vec2} out The receiving vec2
   * @param {vec2} a The vec2 point to rotate
   * @param {vec2} b The origin of the rotation
   * @param {Number} c The angle of rotation
   * @returns {vec2} out
   */

  function rotate$4(out, a, b, c) {
    //Translate point to the origin
    var p0 = a[0] - b[0],
        p1 = a[1] - b[1],
        sinC = Math.sin(c),
        cosC = Math.cos(c); //perform rotation and translate to correct position

    out[0] = p0 * cosC - p1 * sinC + b[0];
    out[1] = p0 * sinC + p1 * cosC + b[1];
    return out;
  }
  /**
   * Get the angle between two 2D vectors
   * @param {vec2} a The first operand
   * @param {vec2} b The second operand
   * @returns {Number} The angle in radians
   */

  function angle$1(a, b) {
    var x1 = a[0],
        y1 = a[1],
        x2 = b[0],
        y2 = b[1];
    var len1 = x1 * x1 + y1 * y1;

    if (len1 > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len1 = 1 / Math.sqrt(len1);
    }

    var len2 = x2 * x2 + y2 * y2;

    if (len2 > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len2 = 1 / Math.sqrt(len2);
    }

    var cosine = (x1 * x2 + y1 * y2) * len1 * len2;

    if (cosine > 1.0) {
      return 0;
    } else if (cosine < -1.0) {
      return Math.PI;
    } else {
      return Math.acos(cosine);
    }
  }
  /**
   * Set the components of a vec2 to zero
   *
   * @param {vec2} out the receiving vector
   * @returns {vec2} out
   */

  function zero$2(out) {
    out[0] = 0.0;
    out[1] = 0.0;
    return out;
  }
  /**
   * Returns a string representation of a vector
   *
   * @param {vec2} a vector to represent as a string
   * @returns {String} string representation of the vector
   */

  function str$8(a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
  }
  /**
   * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
   *
   * @param {vec2} a The first vector.
   * @param {vec2} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function exactEquals$8(a, b) {
    return a[0] === b[0] && a[1] === b[1];
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   *
   * @param {vec2} a The first vector.
   * @param {vec2} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function equals$9(a, b) {
    var a0 = a[0],
        a1 = a[1];
    var b0 = b[0],
        b1 = b[1];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
  }
  /**
   * Alias for {@link vec2.length}
   * @function
   */

  var len$4 = length$4;
  /**
   * Alias for {@link vec2.subtract}
   * @function
   */

  var sub$6 = subtract$6;
  /**
   * Alias for {@link vec2.multiply}
   * @function
   */

  var mul$8 = multiply$8;
  /**
   * Alias for {@link vec2.divide}
   * @function
   */

  var div$2 = divide$2;
  /**
   * Alias for {@link vec2.distance}
   * @function
   */

  var dist$2 = distance$2;
  /**
   * Alias for {@link vec2.squaredDistance}
   * @function
   */

  var sqrDist$2 = squaredDistance$2;
  /**
   * Alias for {@link vec2.squaredLength}
   * @function
   */

  var sqrLen$4 = squaredLength$4;
  /**
   * Perform some operation over an array of vec2s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  var forEach$2 = function () {
    var vec = create$8();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 2;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
      }

      return a;
    };
  }();

  var vec2 = /*#__PURE__*/Object.freeze({
    create: create$8,
    clone: clone$8,
    fromValues: fromValues$8,
    copy: copy$8,
    set: set$8,
    add: add$8,
    subtract: subtract$6,
    multiply: multiply$8,
    divide: divide$2,
    ceil: ceil$2,
    floor: floor$2,
    min: min$2,
    max: max$2,
    round: round$2,
    scale: scale$8,
    scaleAndAdd: scaleAndAdd$2,
    distance: distance$2,
    squaredDistance: squaredDistance$2,
    length: length$4,
    squaredLength: squaredLength$4,
    negate: negate$2,
    inverse: inverse$2,
    normalize: normalize$4,
    dot: dot$4,
    cross: cross$2,
    lerp: lerp$4,
    random: random$3,
    transformMat2: transformMat2,
    transformMat2d: transformMat2d,
    transformMat3: transformMat3$1,
    transformMat4: transformMat4$2,
    rotate: rotate$4,
    angle: angle$1,
    zero: zero$2,
    str: str$8,
    exactEquals: exactEquals$8,
    equals: equals$9,
    len: len$4,
    sub: sub$6,
    mul: mul$8,
    div: div$2,
    dist: dist$2,
    sqrDist: sqrDist$2,
    sqrLen: sqrLen$4,
    forEach: forEach$2
  });

  exports.glMatrix = common;
  exports.mat2 = mat2;
  exports.mat2d = mat2d;
  exports.mat3 = mat3;
  exports.mat4 = mat4;
  exports.quat = quat;
  exports.quat2 = quat2;
  exports.vec2 = vec2;
  exports.vec3 = vec3;
  exports.vec4 = vec4;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.i18next = factory());
}(this, function () { 'use strict';

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  var consoleLogger = {
    type: 'logger',
    log: function log(args) {
      this.output('log', args);
    },
    warn: function warn(args) {
      this.output('warn', args);
    },
    error: function error(args) {
      this.output('error', args);
    },
    output: function output(type, args) {
      var _console;

      /* eslint no-console: 0 */
      if (console && console[type]) (_console = console)[type].apply(_console, _toConsumableArray(args));
    }
  };

  var Logger =
  /*#__PURE__*/
  function () {
    function Logger(concreteLogger) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Logger);

      this.init(concreteLogger, options);
    }

    _createClass(Logger, [{
      key: "init",
      value: function init(concreteLogger) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        this.prefix = options.prefix || 'i18next:';
        this.logger = concreteLogger || consoleLogger;
        this.options = options;
        this.debug = options.debug;
      }
    }, {
      key: "setDebug",
      value: function setDebug(bool) {
        this.debug = bool;
      }
    }, {
      key: "log",
      value: function log() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return this.forward(args, 'log', '', true);
      }
    }, {
      key: "warn",
      value: function warn() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return this.forward(args, 'warn', '', true);
      }
    }, {
      key: "error",
      value: function error() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        return this.forward(args, 'error', '');
      }
    }, {
      key: "deprecate",
      value: function deprecate() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);
      }
    }, {
      key: "forward",
      value: function forward(args, lvl, prefix, debugOnly) {
        if (debugOnly && !this.debug) return null;
        if (typeof args[0] === 'string') args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0]);
        return this.logger[lvl](args);
      }
    }, {
      key: "create",
      value: function create(moduleName) {
        return new Logger(this.logger, _objectSpread({}, {
          prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
        }, this.options));
      }
    }]);

    return Logger;
  }();

  var baseLogger = new Logger();

  var EventEmitter =
  /*#__PURE__*/
  function () {
    function EventEmitter() {
      _classCallCheck(this, EventEmitter);

      this.observers = {};
    }

    _createClass(EventEmitter, [{
      key: "on",
      value: function on(events, listener) {
        var _this = this;

        events.split(' ').forEach(function (event) {
          _this.observers[event] = _this.observers[event] || [];

          _this.observers[event].push(listener);
        });
        return this;
      }
    }, {
      key: "off",
      value: function off(event, listener) {
        var _this2 = this;

        if (!this.observers[event]) {
          return;
        }

        this.observers[event].forEach(function () {
          if (!listener) {
            delete _this2.observers[event];
          } else {
            var index = _this2.observers[event].indexOf(listener);

            if (index > -1) {
              _this2.observers[event].splice(index, 1);
            }
          }
        });
      }
    }, {
      key: "emit",
      value: function emit(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        if (this.observers[event]) {
          var cloned = [].concat(this.observers[event]);
          cloned.forEach(function (observer) {
            observer.apply(void 0, args);
          });
        }

        if (this.observers['*']) {
          var _cloned = [].concat(this.observers['*']);

          _cloned.forEach(function (observer) {
            observer.apply(observer, [event].concat(args));
          });
        }
      }
    }]);

    return EventEmitter;
  }();

  // http://lea.verou.me/2016/12/resolve-promises-externally-with-this-one-weird-trick/
  function defer() {
    var res;
    var rej;
    var promise = new Promise(function (resolve, reject) {
      res = resolve;
      rej = reject;
    });
    promise.resolve = res;
    promise.reject = rej;
    return promise;
  }
  function makeString(object) {
    if (object == null) return '';
    /* eslint prefer-template: 0 */

    return '' + object;
  }
  function copy(a, s, t) {
    a.forEach(function (m) {
      if (s[m]) t[m] = s[m];
    });
  }

  function getLastOfPath(object, path, Empty) {
    function cleanKey(key) {
      return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;
    }

    function canNotTraverseDeeper() {
      return !object || typeof object === 'string';
    }

    var stack = typeof path !== 'string' ? [].concat(path) : path.split('.');

    while (stack.length > 1) {
      if (canNotTraverseDeeper()) return {};
      var key = cleanKey(stack.shift());
      if (!object[key] && Empty) object[key] = new Empty();
      object = object[key];
    }

    if (canNotTraverseDeeper()) return {};
    return {
      obj: object,
      k: cleanKey(stack.shift())
    };
  }

  function setPath(object, path, newValue) {
    var _getLastOfPath = getLastOfPath(object, path, Object),
        obj = _getLastOfPath.obj,
        k = _getLastOfPath.k;

    obj[k] = newValue;
  }
  function pushPath(object, path, newValue, concat) {
    var _getLastOfPath2 = getLastOfPath(object, path, Object),
        obj = _getLastOfPath2.obj,
        k = _getLastOfPath2.k;

    obj[k] = obj[k] || [];
    if (concat) obj[k] = obj[k].concat(newValue);
    if (!concat) obj[k].push(newValue);
  }
  function getPath(object, path) {
    var _getLastOfPath3 = getLastOfPath(object, path),
        obj = _getLastOfPath3.obj,
        k = _getLastOfPath3.k;

    if (!obj) return undefined;
    return obj[k];
  }
  function deepExtend(target, source, overwrite) {
    /* eslint no-restricted-syntax: 0 */
    for (var prop in source) {
      if (prop in target) {
        // If we reached a leaf string in target or source then replace with source or skip depending on the 'overwrite' switch
        if (typeof target[prop] === 'string' || target[prop] instanceof String || typeof source[prop] === 'string' || source[prop] instanceof String) {
          if (overwrite) target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }

    return target;
  }
  function regexEscape(str) {
    /* eslint no-useless-escape: 0 */
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
  }
  /* eslint-disable */

  var _entityMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;'
  };
  /* eslint-enable */

  function escape(data) {
    if (typeof data === 'string') {
      return data.replace(/[&<>"'\/]/g, function (s) {
        return _entityMap[s];
      });
    }

    return data;
  }

  var ResourceStore =
  /*#__PURE__*/
  function (_EventEmitter) {
    _inherits(ResourceStore, _EventEmitter);

    function ResourceStore(data) {
      var _this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        ns: ['translation'],
        defaultNS: 'translation'
      };

      _classCallCheck(this, ResourceStore);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ResourceStore).call(this));
      EventEmitter.call(_assertThisInitialized(_assertThisInitialized(_this))); // <=IE10 fix (unable to call parent constructor)

      _this.data = data || {};
      _this.options = options;

      if (_this.options.keySeparator === undefined) {
        _this.options.keySeparator = '.';
      }

      return _this;
    }

    _createClass(ResourceStore, [{
      key: "addNamespaces",
      value: function addNamespaces(ns) {
        if (this.options.ns.indexOf(ns) < 0) {
          this.options.ns.push(ns);
        }
      }
    }, {
      key: "removeNamespaces",
      value: function removeNamespaces(ns) {
        var index = this.options.ns.indexOf(ns);

        if (index > -1) {
          this.options.ns.splice(index, 1);
        }
      }
    }, {
      key: "getResource",
      value: function getResource(lng, ns, key) {
        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
        var path = [lng, ns];
        if (key && typeof key !== 'string') path = path.concat(key);
        if (key && typeof key === 'string') path = path.concat(keySeparator ? key.split(keySeparator) : key);

        if (lng.indexOf('.') > -1) {
          path = lng.split('.');
        }

        return getPath(this.data, path);
      }
    }, {
      key: "addResource",
      value: function addResource(lng, ns, key, value) {
        var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
          silent: false
        };
        var keySeparator = this.options.keySeparator;
        if (keySeparator === undefined) keySeparator = '.';
        var path = [lng, ns];
        if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);

        if (lng.indexOf('.') > -1) {
          path = lng.split('.');
          value = ns;
          ns = path[1];
        }

        this.addNamespaces(ns);
        setPath(this.data, path, value);
        if (!options.silent) this.emit('added', lng, ns, key, value);
      }
    }, {
      key: "addResources",
      value: function addResources(lng, ns, resources) {
        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
          silent: false
        };

        /* eslint no-restricted-syntax: 0 */
        for (var m in resources) {
          if (typeof resources[m] === 'string' || Object.prototype.toString.apply(resources[m]) === '[object Array]') this.addResource(lng, ns, m, resources[m], {
            silent: true
          });
        }

        if (!options.silent) this.emit('added', lng, ns, resources);
      }
    }, {
      key: "addResourceBundle",
      value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
        var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {
          silent: false
        };
        var path = [lng, ns];

        if (lng.indexOf('.') > -1) {
          path = lng.split('.');
          deep = resources;
          resources = ns;
          ns = path[1];
        }

        this.addNamespaces(ns);
        var pack = getPath(this.data, path) || {};

        if (deep) {
          deepExtend(pack, resources, overwrite);
        } else {
          pack = _objectSpread({}, pack, resources);
        }

        setPath(this.data, path, pack);
        if (!options.silent) this.emit('added', lng, ns, resources);
      }
    }, {
      key: "removeResourceBundle",
      value: function removeResourceBundle(lng, ns) {
        if (this.hasResourceBundle(lng, ns)) {
          delete this.data[lng][ns];
        }

        this.removeNamespaces(ns);
        this.emit('removed', lng, ns);
      }
    }, {
      key: "hasResourceBundle",
      value: function hasResourceBundle(lng, ns) {
        return this.getResource(lng, ns) !== undefined;
      }
    }, {
      key: "getResourceBundle",
      value: function getResourceBundle(lng, ns) {
        if (!ns) ns = this.options.defaultNS; // COMPATIBILITY: remove extend in v2.1.0

        if (this.options.compatibilityAPI === 'v1') return _objectSpread({}, {}, this.getResource(lng, ns));
        return this.getResource(lng, ns);
      }
    }, {
      key: "getDataByLanguage",
      value: function getDataByLanguage(lng) {
        return this.data[lng];
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return this.data;
      }
    }]);

    return ResourceStore;
  }(EventEmitter);

  var postProcessor = {
    processors: {},
    addPostProcessor: function addPostProcessor(module) {
      this.processors[module.name] = module;
    },
    handle: function handle(processors, value, key, options, translator) {
      var _this = this;

      processors.forEach(function (processor) {
        if (_this.processors[processor]) value = _this.processors[processor].process(value, key, options, translator);
      });
      return value;
    }
  };

  var Translator =
  /*#__PURE__*/
  function (_EventEmitter) {
    _inherits(Translator, _EventEmitter);

    function Translator(services) {
      var _this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Translator);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Translator).call(this));
      EventEmitter.call(_assertThisInitialized(_assertThisInitialized(_this))); // <=IE10 fix (unable to call parent constructor)

      copy(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat'], services, _assertThisInitialized(_assertThisInitialized(_this)));
      _this.options = options;

      if (_this.options.keySeparator === undefined) {
        _this.options.keySeparator = '.';
      }

      _this.logger = baseLogger.create('translator');
      return _this;
    }

    _createClass(Translator, [{
      key: "changeLanguage",
      value: function changeLanguage(lng) {
        if (lng) this.language = lng;
      }
    }, {
      key: "exists",
      value: function exists(key) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
          interpolation: {}
        };
        var resolved = this.resolve(key, options);
        return resolved && resolved.res !== undefined;
      }
    }, {
      key: "extractFromKey",
      value: function extractFromKey(key, options) {
        var nsSeparator = options.nsSeparator || this.options.nsSeparator;
        if (nsSeparator === undefined) nsSeparator = ':';
        var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
        var namespaces = options.ns || this.options.defaultNS;

        if (nsSeparator && key.indexOf(nsSeparator) > -1) {
          var parts = key.split(nsSeparator);
          if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
          key = parts.join(keySeparator);
        }

        if (typeof namespaces === 'string') namespaces = [namespaces];
        return {
          key: key,
          namespaces: namespaces
        };
      }
    }, {
      key: "translate",
      value: function translate(keys, options) {
        var _this2 = this;

        if (_typeof(options) !== 'object' && this.options.overloadTranslationOptionHandler) {
          /* eslint prefer-rest-params: 0 */
          options = this.options.overloadTranslationOptionHandler(arguments);
        }

        if (!options) options = {}; // non valid keys handling

        if (keys === undefined || keys === null) return '';
        if (!Array.isArray(keys)) keys = [String(keys)]; // separators

        var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator; // get namespace(s)

        var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options),
            key = _this$extractFromKey.key,
            namespaces = _this$extractFromKey.namespaces;

        var namespace = namespaces[namespaces.length - 1]; // return key on CIMode

        var lng = options.lng || this.language;
        var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;

        if (lng && lng.toLowerCase() === 'cimode') {
          if (appendNamespaceToCIMode) {
            var nsSeparator = options.nsSeparator || this.options.nsSeparator;
            return namespace + nsSeparator + key;
          }

          return key;
        } // resolve from store


        var resolved = this.resolve(keys, options);
        var res = resolved && resolved.res;
        var resUsedKey = resolved && resolved.usedKey || key;
        var resExactUsedKey = resolved && resolved.exactUsedKey || key;
        var resType = Object.prototype.toString.apply(res);
        var noObject = ['[object Number]', '[object Function]', '[object RegExp]'];
        var joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays; // object

        var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
        var handleAsObject = typeof res !== 'string' && typeof res !== 'boolean' && typeof res !== 'number';

        if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === 'string' && resType === '[object Array]')) {
          if (!options.returnObjects && !this.options.returnObjects) {
            this.logger.warn('accessing an object - but returnObjects options is not enabled!');
            return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, options) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
          } // if we got a separator we loop over children - else we just return object as is
          // as having it set to false means no hierarchy so no lookup for nested values


          if (keySeparator) {
            var resTypeIsArray = resType === '[object Array]';
            var copy$$1 = resTypeIsArray ? [] : {}; // apply child translation on a copy

            /* eslint no-restricted-syntax: 0 */

            var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;

            for (var m in res) {
              if (Object.prototype.hasOwnProperty.call(res, m)) {
                var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m);
                copy$$1[m] = this.translate(deepKey, _objectSpread({}, options, {
                  joinArrays: false,
                  ns: namespaces
                }));
                if (copy$$1[m] === deepKey) copy$$1[m] = res[m]; // if nothing found use orginal value as fallback
              }
            }

            res = copy$$1;
          }
        } else if (handleAsObjectInI18nFormat && typeof joinArrays === 'string' && resType === '[object Array]') {
          // array special treatment
          res = res.join(joinArrays);
          if (res) res = this.extendTranslation(res, keys, options);
        } else {
          // string, empty or null
          var usedDefault = false;
          var usedKey = false; // fallback value

          if (!this.isValidLookup(res) && options.defaultValue !== undefined) {
            usedDefault = true;

            if (options.count !== undefined) {
              var suffix = this.pluralResolver.getSuffix(lng, options.count);
              res = options["defaultValue".concat(suffix)];
            }

            if (!res) res = options.defaultValue;
          }

          if (!this.isValidLookup(res)) {
            usedKey = true;
            res = key;
          } // save missing


          var updateMissing = options.defaultValue && options.defaultValue !== res && this.options.updateMissing;

          if (usedKey || usedDefault || updateMissing) {
            this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? options.defaultValue : res);
            var lngs = [];
            var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);

            if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {
              for (var i = 0; i < fallbackLngs.length; i++) {
                lngs.push(fallbackLngs[i]);
              }
            } else if (this.options.saveMissingTo === 'all') {
              lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
            } else {
              lngs.push(options.lng || this.language);
            }

            var send = function send(l, k) {
              if (_this2.options.missingKeyHandler) {
                _this2.options.missingKeyHandler(l, namespace, k, updateMissing ? options.defaultValue : res, updateMissing, options);
              } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
                _this2.backendConnector.saveMissing(l, namespace, k, updateMissing ? options.defaultValue : res, updateMissing, options);
              }

              _this2.emit('missingKey', l, namespace, k, res);
            };

            if (this.options.saveMissing) {
              var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';

              if (this.options.saveMissingPlurals && needsPluralHandling) {
                lngs.forEach(function (l) {
                  var plurals = _this2.pluralResolver.getPluralFormsOfKey(l, key);

                  plurals.forEach(function (p) {
                    return send([l], p);
                  });
                });
              } else {
                send(lngs, key);
              }
            }
          } // extend


          res = this.extendTranslation(res, keys, options, resolved); // append namespace if still key

          if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = "".concat(namespace, ":").concat(key); // parseMissingKeyHandler

          if (usedKey && this.options.parseMissingKeyHandler) res = this.options.parseMissingKeyHandler(res);
        } // return


        return res;
      }
    }, {
      key: "extendTranslation",
      value: function extendTranslation(res, key, options, resolved) {
        var _this3 = this;

        if (this.i18nFormat && this.i18nFormat.parse) {
          res = this.i18nFormat.parse(res, options, resolved.usedLng, resolved.usedNS, resolved.usedKey, {
            resolved: resolved
          });
        } else if (!options.skipInterpolation) {
          // i18next.parsing
          if (options.interpolation) this.interpolator.init(_objectSpread({}, options, {
            interpolation: _objectSpread({}, this.options.interpolation, options.interpolation)
          })); // interpolate

          var data = options.replace && typeof options.replace !== 'string' ? options.replace : options;
          if (this.options.interpolation.defaultVariables) data = _objectSpread({}, this.options.interpolation.defaultVariables, data);
          res = this.interpolator.interpolate(res, data, options.lng || this.language, options); // nesting

          if (options.nest !== false) res = this.interpolator.nest(res, function () {
            return _this3.translate.apply(_this3, arguments);
          }, options);
          if (options.interpolation) this.interpolator.reset();
        } // post process


        var postProcess = options.postProcess || this.options.postProcess;
        var postProcessorNames = typeof postProcess === 'string' ? [postProcess] : postProcess;

        if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
          res = postProcessor.handle(postProcessorNames, res, key, options, this);
        }

        return res;
      }
    }, {
      key: "resolve",
      value: function resolve(keys) {
        var _this4 = this;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var found;
        var usedKey; // plain key

        var exactUsedKey; // key with context / plural

        var usedLng;
        var usedNS;
        if (typeof keys === 'string') keys = [keys]; // forEach possible key

        keys.forEach(function (k) {
          if (_this4.isValidLookup(found)) return;

          var extracted = _this4.extractFromKey(k, options);

          var key = extracted.key;
          usedKey = key;
          var namespaces = extracted.namespaces;
          if (_this4.options.fallbackNS) namespaces = namespaces.concat(_this4.options.fallbackNS);
          var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';
          var needsContextHandling = options.context !== undefined && typeof options.context === 'string' && options.context !== '';
          var codes = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language, options.fallbackLng);
          namespaces.forEach(function (ns) {
            if (_this4.isValidLookup(found)) return;
            usedNS = ns;
            codes.forEach(function (code) {
              if (_this4.isValidLookup(found)) return;
              usedLng = code;
              var finalKey = key;
              var finalKeys = [finalKey];

              if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
                _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
              } else {
                var pluralSuffix;
                if (needsPluralHandling) pluralSuffix = _this4.pluralResolver.getSuffix(code, options.count); // fallback for plural if context not found

                if (needsPluralHandling && needsContextHandling) finalKeys.push(finalKey + pluralSuffix); // get key for context if needed

                if (needsContextHandling) finalKeys.push(finalKey += "".concat(_this4.options.contextSeparator).concat(options.context)); // get key for plural if needed

                if (needsPluralHandling) finalKeys.push(finalKey += pluralSuffix);
              } // iterate over finalKeys starting with most specific pluralkey (-> contextkey only) -> singularkey only


              var possibleKey;
              /* eslint no-cond-assign: 0 */

              while (possibleKey = finalKeys.pop()) {
                if (!_this4.isValidLookup(found)) {
                  exactUsedKey = possibleKey;
                  found = _this4.getResource(code, ns, possibleKey, options);
                }
              }
            });
          });
        });
        return {
          res: found,
          usedKey: usedKey,
          exactUsedKey: exactUsedKey,
          usedLng: usedLng,
          usedNS: usedNS
        };
      }
    }, {
      key: "isValidLookup",
      value: function isValidLookup(res) {
        return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');
      }
    }, {
      key: "getResource",
      value: function getResource(code, ns, key) {
        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
        return this.resourceStore.getResource(code, ns, key, options);
      }
    }]);

    return Translator;
  }(EventEmitter);

  function capitalize(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  }

  var LanguageUtil =
  /*#__PURE__*/
  function () {
    function LanguageUtil(options) {
      _classCallCheck(this, LanguageUtil);

      this.options = options;
      this.whitelist = this.options.whitelist || false;
      this.logger = baseLogger.create('languageUtils');
    }

    _createClass(LanguageUtil, [{
      key: "getScriptPartFromCode",
      value: function getScriptPartFromCode(code) {
        if (!code || code.indexOf('-') < 0) return null;
        var p = code.split('-');
        if (p.length === 2) return null;
        p.pop();
        return this.formatLanguageCode(p.join('-'));
      }
    }, {
      key: "getLanguagePartFromCode",
      value: function getLanguagePartFromCode(code) {
        if (!code || code.indexOf('-') < 0) return code;
        var p = code.split('-');
        return this.formatLanguageCode(p[0]);
      }
    }, {
      key: "formatLanguageCode",
      value: function formatLanguageCode(code) {
        // http://www.iana.org/assignments/language-tags/language-tags.xhtml
        if (typeof code === 'string' && code.indexOf('-') > -1) {
          var specialCases = ['hans', 'hant', 'latn', 'cyrl', 'cans', 'mong', 'arab'];
          var p = code.split('-');

          if (this.options.lowerCaseLng) {
            p = p.map(function (part) {
              return part.toLowerCase();
            });
          } else if (p.length === 2) {
            p[0] = p[0].toLowerCase();
            p[1] = p[1].toUpperCase();
            if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
          } else if (p.length === 3) {
            p[0] = p[0].toLowerCase(); // if lenght 2 guess it's a country

            if (p[1].length === 2) p[1] = p[1].toUpperCase();
            if (p[0] !== 'sgn' && p[2].length === 2) p[2] = p[2].toUpperCase();
            if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
            if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());
          }

          return p.join('-');
        }

        return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
      }
    }, {
      key: "isWhitelisted",
      value: function isWhitelisted(code) {
        if (this.options.load === 'languageOnly' || this.options.nonExplicitWhitelist) {
          code = this.getLanguagePartFromCode(code);
        }

        return !this.whitelist || !this.whitelist.length || this.whitelist.indexOf(code) > -1;
      }
    }, {
      key: "getFallbackCodes",
      value: function getFallbackCodes(fallbacks, code) {
        if (!fallbacks) return [];
        if (typeof fallbacks === 'string') fallbacks = [fallbacks];
        if (Object.prototype.toString.apply(fallbacks) === '[object Array]') return fallbacks;
        if (!code) return fallbacks.default || []; // asume we have an object defining fallbacks

        var found = fallbacks[code];
        if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
        if (!found) found = fallbacks[this.formatLanguageCode(code)];
        if (!found) found = fallbacks.default;
        return found || [];
      }
    }, {
      key: "toResolveHierarchy",
      value: function toResolveHierarchy(code, fallbackCode) {
        var _this = this;

        var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
        var codes = [];

        var addCode = function addCode(c) {
          if (!c) return;

          if (_this.isWhitelisted(c)) {
            codes.push(c);
          } else {
            _this.logger.warn("rejecting non-whitelisted language code: ".concat(c));
          }
        };

        if (typeof code === 'string' && code.indexOf('-') > -1) {
          if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));
          if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));
          if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));
        } else if (typeof code === 'string') {
          addCode(this.formatLanguageCode(code));
        }

        fallbackCodes.forEach(function (fc) {
          if (codes.indexOf(fc) < 0) addCode(_this.formatLanguageCode(fc));
        });
        return codes;
      }
    }]);

    return LanguageUtil;
  }();

  /* eslint-disable */

  var sets = [{
    lngs: ['ach', 'ak', 'am', 'arn', 'br', 'fil', 'gun', 'ln', 'mfe', 'mg', 'mi', 'oc', 'pt', 'pt-BR', 'tg', 'ti', 'tr', 'uz', 'wa'],
    nr: [1, 2],
    fc: 1
  }, {
    lngs: ['af', 'an', 'ast', 'az', 'bg', 'bn', 'ca', 'da', 'de', 'dev', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fi', 'fo', 'fur', 'fy', 'gl', 'gu', 'ha', 'hi', 'hu', 'hy', 'ia', 'it', 'kn', 'ku', 'lb', 'mai', 'ml', 'mn', 'mr', 'nah', 'nap', 'nb', 'ne', 'nl', 'nn', 'no', 'nso', 'pa', 'pap', 'pms', 'ps', 'pt-PT', 'rm', 'sco', 'se', 'si', 'so', 'son', 'sq', 'sv', 'sw', 'ta', 'te', 'tk', 'ur', 'yo'],
    nr: [1, 2],
    fc: 2
  }, {
    lngs: ['ay', 'bo', 'cgg', 'fa', 'id', 'ja', 'jbo', 'ka', 'kk', 'km', 'ko', 'ky', 'lo', 'ms', 'sah', 'su', 'th', 'tt', 'ug', 'vi', 'wo', 'zh'],
    nr: [1],
    fc: 3
  }, {
    lngs: ['be', 'bs', 'dz', 'hr', 'ru', 'sr', 'uk'],
    nr: [1, 2, 5],
    fc: 4
  }, {
    lngs: ['ar'],
    nr: [0, 1, 2, 3, 11, 100],
    fc: 5
  }, {
    lngs: ['cs', 'sk'],
    nr: [1, 2, 5],
    fc: 6
  }, {
    lngs: ['csb', 'pl'],
    nr: [1, 2, 5],
    fc: 7
  }, {
    lngs: ['cy'],
    nr: [1, 2, 3, 8],
    fc: 8
  }, {
    lngs: ['fr'],
    nr: [1, 2],
    fc: 9
  }, {
    lngs: ['ga'],
    nr: [1, 2, 3, 7, 11],
    fc: 10
  }, {
    lngs: ['gd'],
    nr: [1, 2, 3, 20],
    fc: 11
  }, {
    lngs: ['is'],
    nr: [1, 2],
    fc: 12
  }, {
    lngs: ['jv'],
    nr: [0, 1],
    fc: 13
  }, {
    lngs: ['kw'],
    nr: [1, 2, 3, 4],
    fc: 14
  }, {
    lngs: ['lt'],
    nr: [1, 2, 10],
    fc: 15
  }, {
    lngs: ['lv'],
    nr: [1, 2, 0],
    fc: 16
  }, {
    lngs: ['mk'],
    nr: [1, 2],
    fc: 17
  }, {
    lngs: ['mnk'],
    nr: [0, 1, 2],
    fc: 18
  }, {
    lngs: ['mt'],
    nr: [1, 2, 11, 20],
    fc: 19
  }, {
    lngs: ['or'],
    nr: [2, 1],
    fc: 2
  }, {
    lngs: ['ro'],
    nr: [1, 2, 20],
    fc: 20
  }, {
    lngs: ['sl'],
    nr: [5, 1, 2, 3],
    fc: 21
  }, {
    lngs: ['he'],
    nr: [1, 2, 20, 21],
    fc: 22
  }];
  var _rulesPluralsTypes = {
    1: function _(n) {
      return Number(n > 1);
    },
    2: function _(n) {
      return Number(n != 1);
    },
    3: function _(n) {
      return 0;
    },
    4: function _(n) {
      return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
    },
    5: function _(n) {
      return Number(n === 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
    },
    6: function _(n) {
      return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
    },
    7: function _(n) {
      return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
    },
    8: function _(n) {
      return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
    },
    9: function _(n) {
      return Number(n >= 2);
    },
    10: function _(n) {
      return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
    },
    11: function _(n) {
      return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
    },
    12: function _(n) {
      return Number(n % 10 != 1 || n % 100 == 11);
    },
    13: function _(n) {
      return Number(n !== 0);
    },
    14: function _(n) {
      return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
    },
    15: function _(n) {
      return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
    },
    16: function _(n) {
      return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
    },
    17: function _(n) {
      return Number(n == 1 || n % 10 == 1 ? 0 : 1);
    },
    18: function _(n) {
      return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
    },
    19: function _(n) {
      return Number(n == 1 ? 0 : n === 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
    },
    20: function _(n) {
      return Number(n == 1 ? 0 : n === 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
    },
    21: function _(n) {
      return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
    },
    22: function _(n) {
      return Number(n === 1 ? 0 : n === 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);
    }
  };
  /* eslint-enable */

  function createRules() {
    var rules = {};
    sets.forEach(function (set) {
      set.lngs.forEach(function (l) {
        rules[l] = {
          numbers: set.nr,
          plurals: _rulesPluralsTypes[set.fc]
        };
      });
    });
    return rules;
  }

  var PluralResolver =
  /*#__PURE__*/
  function () {
    function PluralResolver(languageUtils) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, PluralResolver);

      this.languageUtils = languageUtils;
      this.options = options;
      this.logger = baseLogger.create('pluralResolver');
      this.rules = createRules();
    }

    _createClass(PluralResolver, [{
      key: "addRule",
      value: function addRule(lng, obj) {
        this.rules[lng] = obj;
      }
    }, {
      key: "getRule",
      value: function getRule(code) {
        return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
      }
    }, {
      key: "needsPlural",
      value: function needsPlural(code) {
        var rule = this.getRule(code);
        return rule && rule.numbers.length > 1;
      }
    }, {
      key: "getPluralFormsOfKey",
      value: function getPluralFormsOfKey(code, key) {
        var _this = this;

        var ret = [];
        var rule = this.getRule(code);
        if (!rule) return ret;
        rule.numbers.forEach(function (n) {
          var suffix = _this.getSuffix(code, n);

          ret.push("".concat(key).concat(suffix));
        });
        return ret;
      }
    }, {
      key: "getSuffix",
      value: function getSuffix(code, count) {
        var _this2 = this;

        var rule = this.getRule(code);

        if (rule) {
          // if (rule.numbers.length === 1) return ''; // only singular
          var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
          var suffix = rule.numbers[idx]; // special treatment for lngs only having singular and plural

          if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
            if (suffix === 2) {
              suffix = 'plural';
            } else if (suffix === 1) {
              suffix = '';
            }
          }

          var returnSuffix = function returnSuffix() {
            return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
          }; // COMPATIBILITY JSON
          // v1


          if (this.options.compatibilityJSON === 'v1') {
            if (suffix === 1) return '';
            if (typeof suffix === 'number') return "_plural_".concat(suffix.toString());
            return returnSuffix();
          } else if (
          /* v2 */
          this.options.compatibilityJSON === 'v2') {
            return returnSuffix();
          } else if (
          /* v3 - gettext index */
          this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
            return returnSuffix();
          }

          return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
        }

        this.logger.warn("no plural rule found for: ".concat(code));
        return '';
      }
    }]);

    return PluralResolver;
  }();

  var Interpolator =
  /*#__PURE__*/
  function () {
    function Interpolator() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, Interpolator);

      this.logger = baseLogger.create('interpolator');
      this.init(options, true);
    }
    /* eslint no-param-reassign: 0 */


    _createClass(Interpolator, [{
      key: "init",
      value: function init() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var reset = arguments.length > 1 ? arguments[1] : undefined;

        if (reset) {
          this.options = options;

          this.format = options.interpolation && options.interpolation.format || function (value) {
            return value;
          };
        }

        if (!options.interpolation) options.interpolation = {
          escapeValue: true
        };
        var iOpts = options.interpolation;
        this.escape = iOpts.escape !== undefined ? iOpts.escape : escape;
        this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;
        this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;
        this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';
        this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';
        this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';
        this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';
        this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';
        this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape('$t(');
        this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(')');
        this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000; // the regexp

        this.resetRegExp();
      }
    }, {
      key: "reset",
      value: function reset() {
        if (this.options) this.init(this.options);
      }
    }, {
      key: "resetRegExp",
      value: function resetRegExp() {
        // the regexp
        var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
        this.regexp = new RegExp(regexpStr, 'g');
        var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
        this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');
        var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
        this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');
      }
    }, {
      key: "interpolate",
      value: function interpolate(str, data, lng, options) {
        var _this = this;

        var match;
        var value;
        var replaces;

        function regexSafe(val) {
          return val.replace(/\$/g, '$$$$');
        }

        var handleFormat = function handleFormat(key) {
          if (key.indexOf(_this.formatSeparator) < 0) return getPath(data, key);
          var p = key.split(_this.formatSeparator);
          var k = p.shift().trim();
          var f = p.join(_this.formatSeparator).trim();
          return _this.format(getPath(data, k), f, lng);
        };

        this.resetRegExp();
        var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
        replaces = 0; // unescape if has unescapePrefix/Suffix

        /* eslint no-cond-assign: 0 */

        while (match = this.regexpUnescape.exec(str)) {
          value = handleFormat(match[1].trim());
          str = str.replace(match[0], value);
          this.regexpUnescape.lastIndex = 0;
          replaces++;

          if (replaces >= this.maxReplaces) {
            break;
          }
        }

        replaces = 0; // regular escape on demand

        while (match = this.regexp.exec(str)) {
          value = handleFormat(match[1].trim());

          if (value === undefined) {
            if (typeof missingInterpolationHandler === 'function') {
              var temp = missingInterpolationHandler(str, match, options);
              value = typeof temp === 'string' ? temp : '';
            } else {
              this.logger.warn("missed to pass in variable ".concat(match[1], " for interpolating ").concat(str));
              value = '';
            }
          } else if (typeof value !== 'string' && !this.useRawValueToEscape) {
            value = makeString(value);
          }

          value = this.escapeValue ? regexSafe(this.escape(value)) : regexSafe(value);
          str = str.replace(match[0], value);
          this.regexp.lastIndex = 0;
          replaces++;

          if (replaces >= this.maxReplaces) {
            break;
          }
        }

        return str;
      }
    }, {
      key: "nest",
      value: function nest(str, fc) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var match;
        var value;

        var clonedOptions = _objectSpread({}, options);

        clonedOptions.applyPostProcessor = false; // avoid post processing on nested lookup
        // if value is something like "myKey": "lorem $(anotherKey, { "count": {{aValueInOptions}} })"

        function handleHasOptions(key, inheritedOptions) {
          if (key.indexOf(',') < 0) return key;
          var p = key.split(',');
          key = p.shift();
          var optionsString = p.join(',');
          optionsString = this.interpolate(optionsString, clonedOptions);
          optionsString = optionsString.replace(/'/g, '"');

          try {
            clonedOptions = JSON.parse(optionsString);
            if (inheritedOptions) clonedOptions = _objectSpread({}, inheritedOptions, clonedOptions);
          } catch (e) {
            this.logger.error("failed parsing options string in nesting for key ".concat(key), e);
          }

          return key;
        } // regular escape on demand


        while (match = this.nestingRegexp.exec(str)) {
          value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions); // is only the nesting key (key1 = '$(key2)') return the value without stringify

          if (value && match[0] === str && typeof value !== 'string') return value; // no string to include or empty

          if (typeof value !== 'string') value = makeString(value);

          if (!value) {
            this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
            value = '';
          } // Nested keys should not be escaped by default #854
          // value = this.escapeValue ? regexSafe(utils.escape(value)) : regexSafe(value);


          str = str.replace(match[0], value);
          this.regexp.lastIndex = 0;
        }

        return str;
      }
    }]);

    return Interpolator;
  }();

  function remove(arr, what) {
    var found = arr.indexOf(what);

    while (found !== -1) {
      arr.splice(found, 1);
      found = arr.indexOf(what);
    }
  }

  var Connector =
  /*#__PURE__*/
  function (_EventEmitter) {
    _inherits(Connector, _EventEmitter);

    function Connector(backend, store, services) {
      var _this;

      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      _classCallCheck(this, Connector);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Connector).call(this));
      EventEmitter.call(_assertThisInitialized(_assertThisInitialized(_this))); // <=IE10 fix (unable to call parent constructor)

      _this.backend = backend;
      _this.store = store;
      _this.languageUtils = services.languageUtils;
      _this.options = options;
      _this.logger = baseLogger.create('backendConnector');
      _this.state = {};
      _this.queue = [];

      if (_this.backend && _this.backend.init) {
        _this.backend.init(services, options.backend, options);
      }

      return _this;
    }

    _createClass(Connector, [{
      key: "queueLoad",
      value: function queueLoad(languages, namespaces, options, callback) {
        var _this2 = this;

        // find what needs to be loaded
        var toLoad = [];
        var pending = [];
        var toLoadLanguages = [];
        var toLoadNamespaces = [];
        languages.forEach(function (lng) {
          var hasAllNamespaces = true;
          namespaces.forEach(function (ns) {
            var name = "".concat(lng, "|").concat(ns);

            if (!options.reload && _this2.store.hasResourceBundle(lng, ns)) {
              _this2.state[name] = 2; // loaded
            } else if (_this2.state[name] < 0) ; else if (_this2.state[name] === 1) {
              if (pending.indexOf(name) < 0) pending.push(name);
            } else {
              _this2.state[name] = 1; // pending

              hasAllNamespaces = false;
              if (pending.indexOf(name) < 0) pending.push(name);
              if (toLoad.indexOf(name) < 0) toLoad.push(name);
              if (toLoadNamespaces.indexOf(ns) < 0) toLoadNamespaces.push(ns);
            }
          });
          if (!hasAllNamespaces) toLoadLanguages.push(lng);
        });

        if (toLoad.length || pending.length) {
          this.queue.push({
            pending: pending,
            loaded: {},
            errors: [],
            callback: callback
          });
        }

        return {
          toLoad: toLoad,
          pending: pending,
          toLoadLanguages: toLoadLanguages,
          toLoadNamespaces: toLoadNamespaces
        };
      }
    }, {
      key: "loaded",
      value: function loaded(name, err, data) {
        var _name$split = name.split('|'),
            _name$split2 = _slicedToArray(_name$split, 2),
            lng = _name$split2[0],
            ns = _name$split2[1];

        if (err) this.emit('failedLoading', lng, ns, err);

        if (data) {
          this.store.addResourceBundle(lng, ns, data);
        } // set loaded


        this.state[name] = err ? -1 : 2; // consolidated loading done in this run - only emit once for a loaded namespace

        var loaded = {}; // callback if ready

        this.queue.forEach(function (q) {
          pushPath(q.loaded, [lng], ns);
          remove(q.pending, name);
          if (err) q.errors.push(err);

          if (q.pending.length === 0 && !q.done) {
            // only do once per loaded -> this.emit('loaded', q.loaded);
            Object.keys(q.loaded).forEach(function (l) {
              if (!loaded[l]) loaded[l] = [];

              if (q.loaded[l].length) {
                q.loaded[l].forEach(function (ns) {
                  if (loaded[l].indexOf(ns) < 0) loaded[l].push(ns);
                });
              }
            });
            /* eslint no-param-reassign: 0 */

            q.done = true;

            if (q.errors.length) {
              q.callback(q.errors);
            } else {
              q.callback();
            }
          }
        }); // emit consolidated loaded event

        this.emit('loaded', loaded); // remove done load requests

        this.queue = this.queue.filter(function (q) {
          return !q.done;
        });
      }
    }, {
      key: "read",
      value: function read(lng, ns, fcName) {
        var _this3 = this;

        var tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 250;
        var callback = arguments.length > 5 ? arguments[5] : undefined;
        if (!lng.length) return callback(null, {}); // noting to load

        return this.backend[fcName](lng, ns, function (err, data) {
          if (err && data
          /* = retryFlag */
          && tried < 5) {
            setTimeout(function () {
              _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
            }, wait);
            return;
          }

          callback(err, data);
        });
      }
      /* eslint consistent-return: 0 */

    }, {
      key: "prepareLoading",
      value: function prepareLoading(languages, namespaces) {
        var _this4 = this;

        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var callback = arguments.length > 3 ? arguments[3] : undefined;

        if (!this.backend) {
          this.logger.warn('No backend was added via i18next.use. Will not load resources.');
          return callback && callback();
        }

        if (typeof languages === 'string') languages = this.languageUtils.toResolveHierarchy(languages);
        if (typeof namespaces === 'string') namespaces = [namespaces];
        var toLoad = this.queueLoad(languages, namespaces, options, callback);

        if (!toLoad.toLoad.length) {
          if (!toLoad.pending.length) callback(); // nothing to load and no pendings...callback now

          return null; // pendings will trigger callback
        }

        toLoad.toLoad.forEach(function (name) {
          _this4.loadOne(name);
        });
      }
    }, {
      key: "load",
      value: function load(languages, namespaces, callback) {
        this.prepareLoading(languages, namespaces, {}, callback);
      }
    }, {
      key: "reload",
      value: function reload(languages, namespaces, callback) {
        this.prepareLoading(languages, namespaces, {
          reload: true
        }, callback);
      }
    }, {
      key: "loadOne",
      value: function loadOne(name) {
        var _this5 = this;

        var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

        var _name$split3 = name.split('|'),
            _name$split4 = _slicedToArray(_name$split3, 2),
            lng = _name$split4[0],
            ns = _name$split4[1];

        this.read(lng, ns, 'read', null, null, function (err, data) {
          if (err) _this5.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
          if (!err && data) _this5.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng), data);

          _this5.loaded(name, err, data);
        });
      }
    }, {
      key: "saveMissing",
      value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
        var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};

        if (this.backend && this.backend.create) {
          this.backend.create(languages, namespace, key, fallbackValue, null
          /* unused callback */
          , _objectSpread({}, options, {
            isUpdate: isUpdate
          }));
        } // write to store to avoid resending


        if (!languages || !languages[0]) return;
        this.store.addResource(languages[0], namespace, key, fallbackValue);
      }
    }]);

    return Connector;
  }(EventEmitter);

  function get() {
    return {
      debug: false,
      initImmediate: true,
      ns: ['translation'],
      defaultNS: ['translation'],
      fallbackLng: ['dev'],
      fallbackNS: false,
      // string or array of namespaces
      whitelist: false,
      // array with whitelisted languages
      nonExplicitWhitelist: false,
      load: 'all',
      // | currentOnly | languageOnly
      preload: false,
      // array with preload languages
      simplifyPluralSuffix: true,
      keySeparator: '.',
      nsSeparator: ':',
      pluralSeparator: '_',
      contextSeparator: '_',
      partialBundledLanguages: false,
      // allow bundling certain languages that are not remotely fetched
      saveMissing: false,
      // enable to send missing values
      updateMissing: false,
      // enable to update default values if different from translated value (only useful on initial development, or when keeping code as source of truth)
      saveMissingTo: 'fallback',
      // 'current' || 'all'
      saveMissingPlurals: true,
      // will save all forms not only singular key
      missingKeyHandler: false,
      // function(lng, ns, key, fallbackValue) -> override if prefer on handling
      missingInterpolationHandler: false,
      // function(str, match)
      postProcess: false,
      // string or array of postProcessor names
      returnNull: true,
      // allows null value as valid translation
      returnEmptyString: true,
      // allows empty string value as valid translation
      returnObjects: false,
      joinArrays: false,
      // or string to join array
      returnedObjectHandler: function returnedObjectHandler() {},
      // function(key, value, options) triggered if key returns object but returnObjects is set to false
      parseMissingKeyHandler: false,
      // function(key) parsed a key that was not found in t() before returning
      appendNamespaceToMissingKey: false,
      appendNamespaceToCIMode: false,
      overloadTranslationOptionHandler: function handle(args) {
        var ret = {};
        if (_typeof(args[1]) === 'object') ret = args[1];
        if (typeof args[1] === 'string') ret.defaultValue = args[1];
        if (typeof args[2] === 'string') ret.tDescription = args[2];

        if (_typeof(args[2]) === 'object' || _typeof(args[3]) === 'object') {
          var options = args[3] || args[2];
          Object.keys(options).forEach(function (key) {
            ret[key] = options[key];
          });
        }

        return ret;
      },
      interpolation: {
        escapeValue: true,
        format: function format(value, _format, lng) {
          return value;
        },
        prefix: '{{',
        suffix: '}}',
        formatSeparator: ',',
        // prefixEscaped: '{{',
        // suffixEscaped: '}}',
        // unescapeSuffix: '',
        unescapePrefix: '-',
        nestingPrefix: '$t(',
        nestingSuffix: ')',
        // nestingPrefixEscaped: '$t(',
        // nestingSuffixEscaped: ')',
        // defaultVariables: undefined // object that can have values to interpolate on - extends passed in interpolation data
        maxReplaces: 1000 // max replaces to prevent endless loop

      }
    };
  }
  /* eslint no-param-reassign: 0 */

  function transformOptions(options) {
    // create namespace object if namespace is passed in as string
    if (typeof options.ns === 'string') options.ns = [options.ns];
    if (typeof options.fallbackLng === 'string') options.fallbackLng = [options.fallbackLng];
    if (typeof options.fallbackNS === 'string') options.fallbackNS = [options.fallbackNS]; // extend whitelist with cimode

    if (options.whitelist && options.whitelist.indexOf('cimode') < 0) {
      options.whitelist = options.whitelist.concat(['cimode']);
    }

    return options;
  }

  function noop() {}

  var I18n =
  /*#__PURE__*/
  function (_EventEmitter) {
    _inherits(I18n, _EventEmitter);

    function I18n() {
      var _this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : undefined;

      _classCallCheck(this, I18n);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(I18n).call(this));
      EventEmitter.call(_assertThisInitialized(_assertThisInitialized(_this))); // <=IE10 fix (unable to call parent constructor)

      _this.options = transformOptions(options);
      _this.services = {};
      _this.logger = baseLogger;
      _this.modules = {
        external: []
      };

      if (callback && !_this.isInitialized && !options.isClone) {
        // https://github.com/i18next/i18next/issues/879
        if (!_this.options.initImmediate) {
          _this.init(options, callback);

          return _possibleConstructorReturn(_this, _assertThisInitialized(_assertThisInitialized(_this)));
        }

        setTimeout(function () {
          _this.init(options, callback);
        }, 0);
      }

      return _this;
    }

    _createClass(I18n, [{
      key: "init",
      value: function init() {
        var _this2 = this;

        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var callback = arguments.length > 1 ? arguments[1] : undefined;

        if (typeof options === 'function') {
          callback = options;
          options = {};
        }

        this.options = _objectSpread({}, get(), this.options, transformOptions(options));
        this.format = this.options.interpolation.format;
        if (!callback) callback = noop;

        function createClassOnDemand(ClassOrObject) {
          if (!ClassOrObject) return null;
          if (typeof ClassOrObject === 'function') return new ClassOrObject();
          return ClassOrObject;
        } // init services


        if (!this.options.isClone) {
          if (this.modules.logger) {
            baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
          } else {
            baseLogger.init(null, this.options);
          }

          var lu = new LanguageUtil(this.options);
          this.store = new ResourceStore(this.options.resources, this.options);
          var s = this.services;
          s.logger = baseLogger;
          s.resourceStore = this.store;
          s.languageUtils = lu;
          s.pluralResolver = new PluralResolver(lu, {
            prepend: this.options.pluralSeparator,
            compatibilityJSON: this.options.compatibilityJSON,
            simplifyPluralSuffix: this.options.simplifyPluralSuffix
          });
          s.interpolator = new Interpolator(this.options);
          s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options); // pipe events from backendConnector

          s.backendConnector.on('*', function (event) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }

            _this2.emit.apply(_this2, [event].concat(args));
          });

          if (this.modules.languageDetector) {
            s.languageDetector = createClassOnDemand(this.modules.languageDetector);
            s.languageDetector.init(s, this.options.detection, this.options);
          }

          if (this.modules.i18nFormat) {
            s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
            if (s.i18nFormat.init) s.i18nFormat.init(this);
          }

          this.translator = new Translator(this.services, this.options); // pipe events from translator

          this.translator.on('*', function (event) {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }

            _this2.emit.apply(_this2, [event].concat(args));
          });
          this.modules.external.forEach(function (m) {
            if (m.init) m.init(_this2);
          });
        } // append api


        var storeApi = ['getResource', 'addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'];
        storeApi.forEach(function (fcName) {
          _this2[fcName] = function () {
            var _this2$store;

            return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
          };
        });
        var deferred = defer();

        var load = function load() {
          _this2.changeLanguage(_this2.options.lng, function (err, t) {
            _this2.isInitialized = true;

            _this2.logger.log('initialized', _this2.options);

            _this2.emit('initialized', _this2.options);

            deferred.resolve(t); // not rejecting on err (as err is only a loading translation failed warning)

            callback(err, t);
          });
        };

        if (this.options.resources || !this.options.initImmediate) {
          load();
        } else {
          setTimeout(load, 0);
        }

        return deferred;
      }
      /* eslint consistent-return: 0 */

    }, {
      key: "loadResources",
      value: function loadResources() {
        var _this3 = this;

        var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop;

        if (!this.options.resources || this.options.partialBundledLanguages) {
          if (this.language && this.language.toLowerCase() === 'cimode') return callback(); // avoid loading resources for cimode

          var toLoad = [];

          var append = function append(lng) {
            if (!lng) return;

            var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);

            lngs.forEach(function (l) {
              if (toLoad.indexOf(l) < 0) toLoad.push(l);
            });
          };

          if (!this.language) {
            // at least load fallbacks in this case
            var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
            fallbacks.forEach(function (l) {
              return append(l);
            });
          } else {
            append(this.language);
          }

          if (this.options.preload) {
            this.options.preload.forEach(function (l) {
              return append(l);
            });
          }

          this.services.backendConnector.load(toLoad, this.options.ns, callback);
        } else {
          callback(null);
        }
      }
    }, {
      key: "reloadResources",
      value: function reloadResources(lngs, ns, callback) {
        var deferred = defer();
        if (!lngs) lngs = this.languages;
        if (!ns) ns = this.options.ns;
        if (!callback) callback = noop;
        this.services.backendConnector.reload(lngs, ns, function (err) {
          deferred.resolve(); // not rejecting on err (as err is only a loading translation failed warning)

          callback(err);
        });
        return deferred;
      }
    }, {
      key: "use",
      value: function use(module) {
        if (module.type === 'backend') {
          this.modules.backend = module;
        }

        if (module.type === 'logger' || module.log && module.warn && module.error) {
          this.modules.logger = module;
        }

        if (module.type === 'languageDetector') {
          this.modules.languageDetector = module;
        }

        if (module.type === 'i18nFormat') {
          this.modules.i18nFormat = module;
        }

        if (module.type === 'postProcessor') {
          postProcessor.addPostProcessor(module);
        }

        if (module.type === '3rdParty') {
          this.modules.external.push(module);
        }

        return this;
      }
    }, {
      key: "changeLanguage",
      value: function changeLanguage(lng, callback) {
        var _this4 = this;

        var deferred = defer();
        this.emit('languageChanging', lng);

        var done = function done(err, l) {
          _this4.translator.changeLanguage(l);

          if (l) {
            _this4.emit('languageChanged', l);

            _this4.logger.log('languageChanged', l);
          }

          deferred.resolve(function () {
            return _this4.t.apply(_this4, arguments);
          });
          if (callback) callback(err, function () {
            return _this4.t.apply(_this4, arguments);
          });
        };

        var setLng = function setLng(l) {
          if (l) {
            _this4.language = l;
            _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
            if (!_this4.translator.language) _this4.translator.changeLanguage(l);
            if (_this4.services.languageDetector) _this4.services.languageDetector.cacheUserLanguage(l);
          }

          _this4.loadResources(function (err) {
            done(err, l);
          });
        };

        if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
          setLng(this.services.languageDetector.detect());
        } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
          this.services.languageDetector.detect(setLng);
        } else {
          setLng(lng);
        }

        return deferred;
      }
    }, {
      key: "getFixedT",
      value: function getFixedT(lng, ns) {
        var _this5 = this;

        var fixedT = function fixedT(key, opts) {
          var options = _objectSpread({}, opts);

          if (_typeof(opts) !== 'object') {
            for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
              rest[_key3 - 2] = arguments[_key3];
            }

            options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
          }

          options.lng = options.lng || fixedT.lng;
          options.lngs = options.lngs || fixedT.lngs;
          options.ns = options.ns || fixedT.ns;
          return _this5.t(key, options);
        };

        if (typeof lng === 'string') {
          fixedT.lng = lng;
        } else {
          fixedT.lngs = lng;
        }

        fixedT.ns = ns;
        return fixedT;
      }
    }, {
      key: "t",
      value: function t() {
        var _this$translator;

        return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
      }
    }, {
      key: "exists",
      value: function exists() {
        var _this$translator2;

        return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
      }
    }, {
      key: "setDefaultNamespace",
      value: function setDefaultNamespace(ns) {
        this.options.defaultNS = ns;
      }
    }, {
      key: "loadNamespaces",
      value: function loadNamespaces(ns, callback) {
        var _this6 = this;

        var deferred = defer();

        if (!this.options.ns) {
          callback && callback();
          return Promise.resolve();
        }

        if (typeof ns === 'string') ns = [ns];
        ns.forEach(function (n) {
          if (_this6.options.ns.indexOf(n) < 0) _this6.options.ns.push(n);
        });
        this.loadResources(function (err) {
          deferred.resolve();
          if (callback) callback(err);
        });
        return deferred;
      }
    }, {
      key: "loadLanguages",
      value: function loadLanguages(lngs, callback) {
        var deferred = defer();
        if (typeof lngs === 'string') lngs = [lngs];
        var preloaded = this.options.preload || [];
        var newLngs = lngs.filter(function (lng) {
          return preloaded.indexOf(lng) < 0;
        }); // Exit early if all given languages are already preloaded

        if (!newLngs.length) {
          if (callback) callback();
          return Promise.resolve();
        }

        this.options.preload = preloaded.concat(newLngs);
        this.loadResources(function (err) {
          deferred.resolve();
          if (callback) callback(err);
        });
        return deferred;
      }
    }, {
      key: "dir",
      value: function dir(lng) {
        if (!lng) lng = this.languages && this.languages.length > 0 ? this.languages[0] : this.language;
        if (!lng) return 'rtl';
        var rtlLngs = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam'];
        return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) >= 0 ? 'rtl' : 'ltr';
      }
      /* eslint class-methods-use-this: 0 */

    }, {
      key: "createInstance",
      value: function createInstance() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var callback = arguments.length > 1 ? arguments[1] : undefined;
        return new I18n(options, callback);
      }
    }, {
      key: "cloneInstance",
      value: function cloneInstance() {
        var _this7 = this;

        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

        var mergedOptions = _objectSpread({}, this.options, options, {
          isClone: true
        });

        var clone = new I18n(mergedOptions);
        var membersToCopy = ['store', 'services', 'language'];
        membersToCopy.forEach(function (m) {
          clone[m] = _this7[m];
        });
        clone.translator = new Translator(clone.services, clone.options);
        clone.translator.on('*', function (event) {
          for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            args[_key4 - 1] = arguments[_key4];
          }

          clone.emit.apply(clone, [event].concat(args));
        });
        clone.init(mergedOptions, callback);
        clone.translator.options = clone.options; // sync options

        return clone;
      }
    }]);

    return I18n;
  }(EventEmitter);

  var i18next = new I18n();

  return i18next;

}));

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.i18nextBrowserLanguageDetector = factory());
}(this, function () { 'use strict';

  var arr = [];
  var each = arr.forEach;
  var slice = arr.slice;

  function defaults(obj) {
    each.call(slice.call(arguments, 1), function (source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === undefined) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  }

  var cookie = {
    create: function create(name, value, minutes, domain) {
      var expires = void 0;
      if (minutes) {
        var date = new Date();
        date.setTime(date.getTime() + minutes * 60 * 1000);
        expires = '; expires=' + date.toGMTString();
      } else expires = '';
      domain = domain ? 'domain=' + domain + ';' : '';
      document.cookie = name + '=' + value + expires + ';' + domain + 'path=/';
    },

    read: function read(name) {
      var nameEQ = name + '=';
      var ca = document.cookie.split(';');
      for (var i = 0; i < ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0) === ' ') {
          c = c.substring(1, c.length);
        }if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
      }
      return null;
    },

    remove: function remove(name) {
      this.create(name, '', -1);
    }
  };

  var cookie$1 = {
    name: 'cookie',

    lookup: function lookup(options) {
      var found = void 0;

      if (options.lookupCookie && typeof document !== 'undefined') {
        var c = cookie.read(options.lookupCookie);
        if (c) found = c;
      }

      return found;
    },
    cacheUserLanguage: function cacheUserLanguage(lng, options) {
      if (options.lookupCookie && typeof document !== 'undefined') {
        cookie.create(options.lookupCookie, lng, options.cookieMinutes, options.cookieDomain);
      }
    }
  };

  var querystring = {
    name: 'querystring',

    lookup: function lookup(options) {
      var found = void 0;

      if (typeof window !== 'undefined') {
        var query = window.location.search.substring(1);
        var params = query.split('&');
        for (var i = 0; i < params.length; i++) {
          var pos = params[i].indexOf('=');
          if (pos > 0) {
            var key = params[i].substring(0, pos);
            if (key === options.lookupQuerystring) {
              found = params[i].substring(pos + 1);
            }
          }
        }
      }

      return found;
    }
  };

  var hasLocalStorageSupport = void 0;
  try {
    hasLocalStorageSupport = window !== 'undefined' && window.localStorage !== null;
    var testKey = 'i18next.translate.boo';
    window.localStorage.setItem(testKey, 'foo');
    window.localStorage.removeItem(testKey);
  } catch (e) {
    hasLocalStorageSupport = false;
  }

  var localStorage = {
    name: 'localStorage',

    lookup: function lookup(options) {
      var found = void 0;

      if (options.lookupLocalStorage && hasLocalStorageSupport) {
        var lng = window.localStorage.getItem(options.lookupLocalStorage);
        if (lng) found = lng;
      }

      return found;
    },
    cacheUserLanguage: function cacheUserLanguage(lng, options) {
      if (options.lookupLocalStorage && hasLocalStorageSupport) {
        window.localStorage.setItem(options.lookupLocalStorage, lng);
      }
    }
  };

  var navigator$1 = {
    name: 'navigator',

    lookup: function lookup(options) {
      var found = [];

      if (typeof navigator !== 'undefined') {
        if (navigator.languages) {
          // chrome only; not an array, so can't use .push.apply instead of iterating
          for (var i = 0; i < navigator.languages.length; i++) {
            found.push(navigator.languages[i]);
          }
        }
        if (navigator.userLanguage) {
          found.push(navigator.userLanguage);
        }
        if (navigator.language) {
          found.push(navigator.language);
        }
      }

      return found.length > 0 ? found : undefined;
    }
  };

  var htmlTag = {
    name: 'htmlTag',

    lookup: function lookup(options) {
      var found = void 0;
      var htmlTag = options.htmlTag || (typeof document !== 'undefined' ? document.documentElement : null);

      if (htmlTag && typeof htmlTag.getAttribute === 'function') {
        found = htmlTag.getAttribute('lang');
      }

      return found;
    }
  };

  var path = {
    name: 'path',

    lookup: function lookup(options) {
      var found = void 0;
      if (typeof window !== 'undefined') {
        var language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
        if (language instanceof Array) {
          if (typeof options.lookupFromPathIndex === 'number') {
            if (typeof language[options.lookupFromPathIndex] !== 'string') {
              return undefined;
            }
            found = language[options.lookupFromPathIndex].replace('/', '');
          } else {
            found = language[0].replace('/', '');
          }
        }
      }
      return found;
    }
  };

  var subdomain = {
    name: 'subdomain',

    lookup: function lookup(options) {
      var found = void 0;
      if (typeof window !== 'undefined') {
        var language = window.location.href.match(/(?:http[s]*\:\/\/)*(.*?)\.(?=[^\/]*\..{2,5})/gi);
        if (language instanceof Array) {
          if (typeof options.lookupFromSubdomainIndex === 'number') {
            found = language[options.lookupFromSubdomainIndex].replace('http://', '').replace('https://', '').replace('.', '');
          } else {
            found = language[0].replace('http://', '').replace('https://', '').replace('.', '');
          }
        }
      }
      return found;
    }
  };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function getDefaults() {
    return {
      order: ['querystring', 'cookie', 'localStorage', 'navigator', 'htmlTag'],
      lookupQuerystring: 'lng',
      lookupCookie: 'i18next',
      lookupLocalStorage: 'i18nextLng',

      // cache user language
      caches: ['localStorage'],
      excludeCacheFor: ['cimode']
      //cookieMinutes: 10,
      //cookieDomain: 'myDomain'
    };
  }

  var Browser = function () {
    function Browser(services) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Browser);

      this.type = 'languageDetector';
      this.detectors = {};

      this.init(services, options);
    }

    _createClass(Browser, [{
      key: 'init',
      value: function init(services) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var i18nOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        this.services = services;
        this.options = defaults(options, this.options || {}, getDefaults());

        // backwards compatibility
        if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;

        this.i18nOptions = i18nOptions;

        this.addDetector(cookie$1);
        this.addDetector(querystring);
        this.addDetector(localStorage);
        this.addDetector(navigator$1);
        this.addDetector(htmlTag);
        this.addDetector(path);
        this.addDetector(subdomain);
      }
    }, {
      key: 'addDetector',
      value: function addDetector(detector) {
        this.detectors[detector.name] = detector;
      }
    }, {
      key: 'detect',
      value: function detect(detectionOrder) {
        var _this = this;

        if (!detectionOrder) detectionOrder = this.options.order;

        var detected = [];
        detectionOrder.forEach(function (detectorName) {
          if (_this.detectors[detectorName]) {
            var lookup = _this.detectors[detectorName].lookup(_this.options);
            if (lookup && typeof lookup === 'string') lookup = [lookup];
            if (lookup) detected = detected.concat(lookup);
          }
        });

        var found = void 0;
        detected.forEach(function (lng) {
          if (found) return;
          var cleanedLng = _this.services.languageUtils.formatLanguageCode(lng);
          if (_this.services.languageUtils.isWhitelisted(cleanedLng)) found = cleanedLng;
        });

        if (!found) {
          var fallbacks = this.i18nOptions.fallbackLng;
          if (typeof fallbacks === 'string') fallbacks = [fallbacks];
          if (!fallbacks) fallbacks = [];

          if (Object.prototype.toString.apply(fallbacks) === '[object Array]') {
            found = fallbacks[0];
          } else {
            found = fallbacks[0] || fallbacks.default && fallbacks.default[0];
          }
        };

        return found;
      }
    }, {
      key: 'cacheUserLanguage',
      value: function cacheUserLanguage(lng, caches) {
        var _this2 = this;

        if (!caches) caches = this.options.caches;
        if (!caches) return;
        if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;
        caches.forEach(function (cacheName) {
          if (_this2.detectors[cacheName]) _this2.detectors[cacheName].cacheUserLanguage(lng, _this2.options);
        });
      }
    }]);

    return Browser;
  }();

  Browser.type = 'languageDetector';

  return Browser;

}));
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.i18nextXHRBackend = factory());
}(this, (function () { 'use strict';

var arr = [];
var each = arr.forEach;
var slice = arr.slice;

function defaults(obj) {
  each.call(slice.call(arguments, 1), function (source) {
    if (source) {
      for (var prop in source) {
        if (obj[prop] === undefined) obj[prop] = source[prop];
      }
    }
  });
  return obj;
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function addQueryString(url, params) {
  if (params && (typeof params === 'undefined' ? 'undefined' : _typeof(params)) === 'object') {
    var queryString = '',
        e = encodeURIComponent;

    // Must encode data
    for (var paramName in params) {
      queryString += '&' + e(paramName) + '=' + e(params[paramName]);
    }

    if (!queryString) {
      return url;
    }

    url = url + (url.indexOf('?') !== -1 ? '&' : '?') + queryString.slice(1);
  }

  return url;
}

// https://gist.github.com/Xeoncross/7663273
function ajax(url, options, callback, data, cache) {

  if (data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
    if (!cache) {
      data['_t'] = new Date();
    }
    // URL encoded form data must be in querystring format
    data = addQueryString('', data).slice(1);
  }

  if (options.queryStringParams) {
    url = addQueryString(url, options.queryStringParams);
  }

  try {
    var x;
    if (XMLHttpRequest) {
      x = new XMLHttpRequest();
    } else {
      x = new ActiveXObject('MSXML2.XMLHTTP.3.0');
    }
    x.open(data ? 'POST' : 'GET', url, 1);
    if (!options.crossDomain) {
      x.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
    }
    x.withCredentials = !!options.withCredentials;
    if (data) {
      x.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
    }
    if (x.overrideMimeType) {
      x.overrideMimeType("application/json");
    }
    var h = options.customHeaders;
    if (h) {
      for (var i in h) {
        x.setRequestHeader(i, h[i]);
      }
    }
    x.onreadystatechange = function () {
      x.readyState > 3 && callback && callback(x.responseText, x);
    };
    x.send(data);
  } catch (e) {
    console && console.log(e);
  }
}

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function getDefaults() {
  return {
    loadPath: '/locales/{{lng}}/{{ns}}.json',
    addPath: '/locales/add/{{lng}}/{{ns}}',
    allowMultiLoading: false,
    parse: JSON.parse,
    crossDomain: false,
    ajax: ajax
  };
}

var Backend = function () {
  function Backend(services) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Backend);

    this.init(services, options);

    this.type = 'backend';
  }

  _createClass(Backend, [{
    key: 'init',
    value: function init(services) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this.services = services;
      this.options = defaults(options, this.options || {}, getDefaults());
    }
  }, {
    key: 'readMulti',
    value: function readMulti(languages, namespaces, callback) {
      var loadPath = this.options.loadPath;
      if (typeof this.options.loadPath === 'function') {
        loadPath = this.options.loadPath(languages, namespaces);
      }

      var url = this.services.interpolator.interpolate(loadPath, { lng: languages.join('+'), ns: namespaces.join('+') });

      this.loadUrl(url, callback);
    }
  }, {
    key: 'read',
    value: function read(language, namespace, callback) {
      var loadPath = this.options.loadPath;
      if (typeof this.options.loadPath === 'function') {
        loadPath = this.options.loadPath([language], [namespace]);
      }

      var url = this.services.interpolator.interpolate(loadPath, { lng: language, ns: namespace });

      this.loadUrl(url, callback);
    }
  }, {
    key: 'loadUrl',
    value: function loadUrl(url, callback) {
      var _this = this;

      this.options.ajax(url, this.options, function (data, xhr) {
        if (xhr.status >= 500 && xhr.status < 600) return callback('failed loading ' + url, true /* retry */);
        if (xhr.status >= 400 && xhr.status < 500) return callback('failed loading ' + url, false /* no retry */);

        var ret = void 0,
            err = void 0;
        try {
          ret = _this.options.parse(data, url);
        } catch (e) {
          err = 'failed parsing ' + url + ' to json';
        }
        if (err) return callback(err, false);
        callback(null, ret);
      });
    }
  }, {
    key: 'create',
    value: function create(languages, namespace, key, fallbackValue) {
      var _this2 = this;

      if (typeof languages === 'string') languages = [languages];

      var payload = {};
      payload[key] = fallbackValue || '';

      languages.forEach(function (lng) {
        var url = _this2.services.interpolator.interpolate(_this2.options.addPath, { lng: lng, ns: namespace });

        _this2.options.ajax(url, _this2.options, function (data, xhr) {
          //const statusCode = xhr.status.toString();
          // TODO: if statusCode === 4xx do log
        }, payload);
      });
    }
  }]);

  return Backend;
}();

Backend.type = 'backend';

return Backend;

})));

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.rbush = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
    'use strict';
    
    module.exports = rbush;
    
    var quickselect = require('quickselect');
    
    function rbush(maxEntries, format) {
        if (!(this instanceof rbush)) return new rbush(maxEntries, format);
    
        // max entries in a node is 9 by default; min node fill is 40% for best performance
        this._maxEntries = Math.max(4, maxEntries || 9);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
    
        if (format) {
            this._initFormat(format);
        }
    
        this.clear();
    }
    
    rbush.prototype = {
    
        all: function () {
            return this._all(this.data, []);
        },
    
        search: function (bbox) {
    
            var node = this.data,
                result = [],
                toBBox = this.toBBox;
    
            if (!intersects(bbox, node)) return result;
    
            var nodesToSearch = [],
                i, len, child, childBBox;
    
            while (node) {
                for (i = 0, len = node.children.length; i < len; i++) {
    
                    child = node.children[i];
                    childBBox = node.leaf ? toBBox(child) : child;
    
                    if (intersects(bbox, childBBox)) {
                        if (node.leaf){
                            result.push(child);
                        } 
                        else if (contains(bbox, childBBox)){
                            this._all(child, result);
                        } 
                        else {
                            nodesToSearch.push(child);
                        }
                    }
                }
                node = nodesToSearch.pop();
            }
    
            return result;
        },
    
        collides: function (bbox) {
    
            var node = this.data,
                toBBox = this.toBBox;
    
            if (!intersects(bbox, node)) return false;
    
            var nodesToSearch = [],
                i, len, child, childBBox;
    
            while (node) {
                for (i = 0, len = node.children.length; i < len; i++) {
    
                    child = node.children[i];
                    childBBox = node.leaf ? toBBox(child) : child;
    
                    if (intersects(bbox, childBBox)) {
                        if (node.leaf || contains(bbox, childBBox)) return true;
                        nodesToSearch.push(child);
                    }
                }
                node = nodesToSearch.pop();
            }
    
            return false;
        },
    
        load: function (data) {
            if (!(data && data.length)) return this;
    
            if (data.length < this._minEntries) {
                for (var i = 0, len = data.length; i < len; i++) {
                    this.insert(data[i]);
                }
                return this;
            }
    
            // recursively build the tree with the given data from stratch using OMT algorithm
            var node = this._build(data.slice(), 0, data.length - 1, 0);
    
            if (!this.data.children.length) {
                // save as is if tree is empty
                this.data = node;
    
            } else if (this.data.height === node.height) {
                // split root if trees have the same height
                this._splitRoot(this.data, node);
    
            } else {
                if (this.data.height < node.height) {
                    // swap trees if inserted one is bigger
                    var tmpNode = this.data;
                    this.data = node;
                    node = tmpNode;
                }
    
                // insert the small tree into the large tree at appropriate level
                this._insert(node, this.data.height - node.height - 1, true);
            }
    
            return this;
        },
    
        insert: function (item) {
            if (item) this._insert(item, this.data.height - 1);
            return this;
        },
    
        clear: function () {
            this.data = createNode([]);
            return this;
        },
    
        remove: function (item, equalsFn) {
            if (!item) return this;
    
            var node = this.data,
                bbox = this.toBBox(item),
                path = [],
                indexes = [],
                i, parent, index, goingUp;
    
            // depth-first iterative tree traversal
            while (node || path.length) {
    
                if (!node) { // go up
                    node = path.pop();
                    parent = path[path.length - 1];
                    i = indexes.pop();
                    goingUp = true;
                }
    
                if (node.leaf) { // check current node
                    index = findItem(item, node.children, equalsFn);
    
                    if (index !== -1) {
                        // item found, remove the item and condense tree upwards
                        node.children.splice(index, 1);
                        path.push(node);
                        this._condense(path);
                        return this;
                    }
                }
    
                if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                    path.push(node);
                    indexes.push(i);
                    i = 0;
                    parent = node;
                    node = node.children[0];
    
                } else if (parent) { // go right
                    i++;
                    node = parent.children[i];
                    goingUp = false;
    
                } else node = null; // nothing found
            }
    
            return this;
        },
    
        toBBox: function (item) { return item; },
    
        compareMinX: compareNodeMinX,
        compareMinY: compareNodeMinY,
    
        toJSON: function () { return this.data; },
    
        fromJSON: function (data) {
            this.data = data;
            return this;
        },
    
        _all: function (node, result) {
            var nodesToSearch = [];
            while (node) {
                if (node.leaf) result.push.apply(result, node.children);
                else nodesToSearch.push.apply(nodesToSearch, node.children);
    
                node = nodesToSearch.pop();
            }
            return result;
        },
    
        _build: function (items, left, right, height) {
    
            var N = right - left + 1,
                M = this._maxEntries,
                node;
    
            if (N <= M) {
                // reached leaf level; return leaf
                node = createNode(items.slice(left, right + 1));
                calcBBox(node, this.toBBox);
                return node;
            }
    
            if (!height) {
                // target height of the bulk-loaded tree
                height = Math.ceil(Math.log(N) / Math.log(M));
    
                // target number of root entries to maximize storage utilization
                M = Math.ceil(N / Math.pow(M, height - 1));
            }
    
            node = createNode([]);
            node.leaf = false;
            node.height = height;
    
            // split the items into M mostly square tiles
    
            var N2 = Math.ceil(N / M),
                N1 = N2 * Math.ceil(Math.sqrt(M)),
                i, j, right2, right3;
    
            multiSelect(items, left, right, N1, this.compareMinX);
    
            for (i = left; i <= right; i += N1) {
    
                right2 = Math.min(i + N1 - 1, right);
    
                multiSelect(items, i, right2, N2, this.compareMinY);
    
                for (j = i; j <= right2; j += N2) {
    
                    right3 = Math.min(j + N2 - 1, right2);
    
                    // pack each entry recursively
                    node.children.push(this._build(items, j, right3, height - 1));
                }
            }
    
            calcBBox(node, this.toBBox);
    
            return node;
        },
    
        _chooseSubtree: function (bbox, node, level, path) {
    
            var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;
    
            while (true) {
                path.push(node);
    
                if (node.leaf || path.length - 1 === level) break;
    
                minArea = minEnlargement = Infinity;
    
                for (i = 0, len = node.children.length; i < len; i++) {
                    child = node.children[i];
                    area = bboxArea(child);
                    enlargement = enlargedArea(bbox, child) - area;
    
                    // choose entry with the least area enlargement
                    if (enlargement < minEnlargement) {
                        minEnlargement = enlargement;
                        minArea = area < minArea ? area : minArea;
                        targetNode = child;
    
                    } else if (enlargement === minEnlargement) {
                        // otherwise choose one with the smallest area
                        if (area < minArea) {
                            minArea = area;
                            targetNode = child;
                        }
                    }
                }
    
                node = targetNode || node.children[0];
            }
    
            return node;
        },
    
        _insert: function (item, level, isNode) {
    
            var toBBox = this.toBBox,
                bbox = isNode ? item : toBBox(item),
                insertPath = [];
    
            // find the best node for accommodating the item, saving all nodes along the path too
            var node = this._chooseSubtree(bbox, this.data, level, insertPath);
    
            // put the item into the node
            node.children.push(item);
            extend(node, bbox);
    
            // split on node overflow; propagate upwards if necessary
            while (level >= 0) {
                if (insertPath[level].children.length > this._maxEntries) {
                    this._split(insertPath, level);
                    level--;
                } else break;
            }
    
            // adjust bboxes along the insertion path
            this._adjustParentBBoxes(bbox, insertPath, level);
        },
    
        // split overflowed node into two
        _split: function (insertPath, level) {
    
            var node = insertPath[level],
                M = node.children.length,
                m = this._minEntries;
    
            this._chooseSplitAxis(node, m, M);
    
            var splitIndex = this._chooseSplitIndex(node, m, M);
    
            var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
            newNode.height = node.height;
            newNode.leaf = node.leaf;
    
            calcBBox(node, this.toBBox);
            calcBBox(newNode, this.toBBox);
    
            if (level) insertPath[level - 1].children.push(newNode);
            else this._splitRoot(node, newNode);
        },
    
        _splitRoot: function (node, newNode) {
            // split root node
            this.data = createNode([node, newNode]);
            this.data.height = node.height + 1;
            this.data.leaf = false;
            calcBBox(this.data, this.toBBox);
        },
    
        _chooseSplitIndex: function (node, m, M) {
    
            var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;
    
            minOverlap = minArea = Infinity;
    
            for (i = m; i <= M - m; i++) {
                bbox1 = distBBox(node, 0, i, this.toBBox);
                bbox2 = distBBox(node, i, M, this.toBBox);
    
                overlap = intersectionArea(bbox1, bbox2);
                area = bboxArea(bbox1) + bboxArea(bbox2);
    
                // choose distribution with minimum overlap
                if (overlap < minOverlap) {
                    minOverlap = overlap;
                    index = i;
    
                    minArea = area < minArea ? area : minArea;
    
                } else if (overlap === minOverlap) {
                    // otherwise choose distribution with minimum area
                    if (area < minArea) {
                        minArea = area;
                        index = i;
                    }
                }
            }
    
            return index;
        },
    
        // sorts node children by the best axis for split
        _chooseSplitAxis: function (node, m, M) {
    
            var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
                compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
                xMargin = this._allDistMargin(node, m, M, compareMinX),
                yMargin = this._allDistMargin(node, m, M, compareMinY);
    
            // if total distributions margin value is minimal for x, sort by minX,
            // otherwise it's already sorted by minY
            if (xMargin < yMargin) node.children.sort(compareMinX);
        },
    
        // total margin of all possible split distributions where each node is at least m full
        _allDistMargin: function (node, m, M, compare) {
    
            node.children.sort(compare);
    
            var toBBox = this.toBBox,
                leftBBox = distBBox(node, 0, m, toBBox),
                rightBBox = distBBox(node, M - m, M, toBBox),
                margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
                i, child;
    
            for (i = m; i < M - m; i++) {
                child = node.children[i];
                extend(leftBBox, node.leaf ? toBBox(child) : child);
                margin += bboxMargin(leftBBox);
            }
    
            for (i = M - m - 1; i >= m; i--) {
                child = node.children[i];
                extend(rightBBox, node.leaf ? toBBox(child) : child);
                margin += bboxMargin(rightBBox);
            }
    
            return margin;
        },
    
        _adjustParentBBoxes: function (bbox, path, level) {
            // adjust bboxes along the given tree path
            for (var i = level; i >= 0; i--) {
                extend(path[i], bbox);
            }
        },
    
        _condense: function (path) {
            // go through the path, removing empty nodes and updating bboxes
            for (var i = path.length - 1, siblings; i >= 0; i--) {
                if (path[i].children.length === 0) {
                    if (i > 0) {
                        siblings = path[i - 1].children;
                        siblings.splice(siblings.indexOf(path[i]), 1);
    
                    } else this.clear();
    
                } else calcBBox(path[i], this.toBBox);
            }
        },
    
        _initFormat: function (format) {
            // data format (minX, minY, maxX, maxY accessors)
    
            // uses eval-type function compilation instead of just accepting a toBBox function
            // because the algorithms are very sensitive to sorting functions performance,
            // so they should be dead simple and without inner calls
    
            var compareArr = ['return a', ' - b', ';'];
    
            this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
            this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));
    
            this.toBBox = new Function('a',
                'return {minX: a' + format[0] +
                ', minY: a' + format[1] +
                ', maxX: a' + format[2] +
                ', maxY: a' + format[3] + '};');
        }
    };
    
    function findItem(item, items, equalsFn) {
        if (!equalsFn) return items.indexOf(item);
    
        for (var i = 0; i < items.length; i++) {
            if (equalsFn(item, items[i])) return i;
        }
        return -1;
    }
    
    // calculate node's bbox from bboxes of its children
    function calcBBox(node, toBBox) {
        distBBox(node, 0, node.children.length, toBBox, node);
    }
    
    // min bounding rectangle of node children from k to p-1
    function distBBox(node, k, p, toBBox, destNode) {
        if (!destNode) destNode = createNode(null);
        destNode.minX = Infinity;
        destNode.minY = Infinity;
        destNode.maxX = -Infinity;
        destNode.maxY = -Infinity;
    
        for (var i = k, child; i < p; i++) {
            child = node.children[i];
            extend(destNode, node.leaf ? toBBox(child) : child);
        }
    
        return destNode;
    }
    
    function extend(a, b) {
        a.minX = Math.min(a.minX, b.minX);
        a.minY = Math.min(a.minY, b.minY);
        a.maxX = Math.max(a.maxX, b.maxX);
        a.maxY = Math.max(a.maxY, b.maxY);
        return a;
    }
    
    function compareNodeMinX(a, b) { return a.minX - b.minX; }
    function compareNodeMinY(a, b) { return a.minY - b.minY; }
    
    function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
    function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }
    
    function enlargedArea(a, b) {
        return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
               (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
    }
    
    function intersectionArea(a, b) {
        var minX = Math.max(a.minX, b.minX),
            minY = Math.max(a.minY, b.minY),
            maxX = Math.min(a.maxX, b.maxX),
            maxY = Math.min(a.maxY, b.maxY);
    
        return Math.max(0, maxX - minX) *
               Math.max(0, maxY - minY);
    }
    
    function contains(a, b) {
        return a.minX <= b.minX &&
               a.minY <= b.minY &&
               b.maxX <= a.maxX &&
               b.maxY <= a.maxY;
    }
    
    function intersects(a, b) {
        return b.minX <= a.maxX &&
               b.minY <= a.maxY &&
               b.maxX >= a.minX &&
               b.maxY >= a.minY;
    }
    
    function createNode(children) {
        return {
            children: children,
            height: 1,
            leaf: true,
            minX: Infinity,
            minY: Infinity,
            maxX: -Infinity,
            maxY: -Infinity
        };
    }
    
    // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
    // combines selection algorithm with binary divide & conquer approach
    
    function multiSelect(arr, left, right, n, compare) {
        var stack = [left, right],
            mid;
    
        while (stack.length) {
            right = stack.pop();
            left = stack.pop();
    
            if (right - left <= n) continue;
    
            mid = left + Math.ceil((right - left) / n / 2) * n;
            quickselect(arr, mid, left, right, compare);
    
            stack.push(left, mid, mid, right);
        }
    }
    
    },{"quickselect":2}],2:[function(require,module,exports){
    'use strict';
    
    module.exports = partialSort;
    
    // Floyd-Rivest selection algorithm:
    // Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];
    // The k-th element will have the (k - left + 1)th smallest value in [left, right]
    
    function partialSort(arr, k, left, right, compare) {
    
        while (right > left) {
            if (right - left > 600) {
                var n = right - left + 1;
                var m = k - left + 1;
                var z = Math.log(n);
                var s = 0.5 * Math.exp(2 * z / 3);
                var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
                var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
                var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
                partialSort(arr, k, newLeft, newRight, compare);
            }
    
            var t = arr[k];
            var i = left;
            var j = right;
    
            swap(arr, left, k);
            if (compare(arr[right], t) > 0) swap(arr, left, right);
    
            while (i < j) {
                swap(arr, i, j);
                i++;
                j--;
                while (compare(arr[i], t) < 0) i++;
                while (compare(arr[j], t) > 0) j--;
            }
    
            if (compare(arr[left], t) === 0) swap(arr, left, j);
            else {
                j++;
                swap(arr, j, right);
            }
    
            if (j <= k) left = j + 1;
            if (k <= j) right = j - 1;
        }
    }
    
    function swap(arr, i, j) {
        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
    
    function defaultCompare(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
    }
    
    },{}]},{},[1])(1)
    });
/**
 * @file tgajs - Javascript decoder & (experimental) encoder for TGA files
 * @desc tgajs is a fork from https://github.com/vthibault/jsTGALoader
 * @author Vincent Thibault (Original author)
 * @author Lukas Schmitt
 * @version 1.0.0
 */

/* Copyright (c) 2013, Vincent Thibault. All rights reserved.

 Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this
 list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice,
 this list of conditions and the following disclaimer in the documentation
 and/or other materials provided with the distribution.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

(function (_global) {
  'use strict';

  /**
   * @var {object} TGA type constants
   */
  Targa.Type = {
    NO_DATA: 0,
    INDEXED: 1,
    RGB: 2,
    GREY: 3,
    RLE_INDEXED: 9,
    RLE_RGB: 10,
    RLE_GREY: 11
  };

  /**
   * @var {object} TGA origin constants
   */
  Targa.Origin = {
    BOTTOM_LEFT: 0x00,
    BOTTOM_RIGHT: 0x01,
    TOP_LEFT: 0x02,
    TOP_RIGHT: 0x03,
    SHIFT: 0x04,
    MASK: 0x30,
    ALPHA: 0x08
  };

  Targa.HEADER_SIZE = 18;
  Targa.FOOTER_SIZE = 26;
  Targa.LITTLE_ENDIAN = true;
  Targa.RLE_BIT = 0x80;
  Targa.RLE_MASK = 0x7f;
  Targa.RLE_PACKET = 1;
  Targa.RAW_PACKET = 2;
  Targa.SIGNATURE = "TRUEVISION-XFILE.\0";

  /**
   * TGA Namespace
   * @constructor
   */
  function Targa() {
    if (arguments.length == 1) {
      var h = arguments[0];

      this.header = createHeader(h);
      setHeaderBooleans(this.header);
      checkHeader(this.header);
    }
  }

  /**
   * Sets header or default values
   * @param header header
   * @returns {Object}
   */
  function createHeader(header) {
    return {
      /* 0x00  BYTE */  idLength: defaultFor(header.idLength, 0),
      /* 0x01  BYTE */  colorMapType: defaultFor(header.colorMapType, 0),
      /* 0x02  BYTE */  imageType: defaultFor(header.imageType, Targa.Type.RGB),
      /* 0x03  WORD */  colorMapIndex: defaultFor(header.colorMapIndex, 0),
      /* 0x05  WORD */  colorMapLength: defaultFor(header.colorMapLength, 0),
      /* 0x07  BYTE */  colorMapDepth: defaultFor(header.colorMapDepth, 0),
      /* 0x08  WORD */  offsetX: defaultFor(header.offsetX, 0),
      /* 0x0a  WORD */  offsetY: defaultFor(header.offsetY, 0),
      /* 0x0c  WORD */  width: defaultFor(header.width, 0),
      /* 0x0e  WORD */  height: defaultFor(header.height, 0),
      /* 0x10  BYTE */  pixelDepth: defaultFor(header.pixelDepth,32),
      /* 0x11  BYTE */  flags: defaultFor(header.flags, 8)
    };
  }

  function defaultFor(arg, val) { return typeof arg !== 'undefined' ? arg : val; }

  /**
   * Write footer of TGA file to view
   * Byte 0-3 - Extension Area Offset, 0 if no Extension Area exists
   * Byte 4-7 - Developer Directory Offset, 0 if no Developer Area exists
   * Byte 8-25 - Signature
   * @param {Uint8Array} footer
   */
  function writeFooter(footer) {
    var signature = Targa.SIGNATURE;
    var offset = footer.byteLength - signature.length;
    for (var i = 0; i < signature.length; i++) {
      footer[offset + i] = signature.charCodeAt(i);
    }
  }

  /**
   * Write header of TGA file to view
   * @param header
   * @param view DataView
   */
  function writeHeader(header, view) {
    var littleEndian = Targa.LITTLE_ENDIAN;

    view.setUint8(0x00, header.idLength);
    view.setUint8(0x01, header.colorMapType);
    view.setUint8(0x02, header.imageType);
    view.setUint16(0x03, header.colorMapIndex, littleEndian);
    view.setUint16(0x05, header.colorMapLength, littleEndian);
    view.setUint8(0x07, header.colorMapDepth);
    view.setUint16(0x08, header.offsetX, littleEndian);
    view.setUint16(0x0a, header.offsetY, littleEndian);
    view.setUint16(0x0c, header.width, littleEndian);
    view.setUint16(0x0e, header.height, littleEndian);
    view.setUint8(0x10, header.pixelDepth);
    view.setUint8(0x11, header.flags);
  }

  function readHeader(view) {
    var littleEndian = Targa.LITTLE_ENDIAN;

    // Not enough data to contain header ?
    if (view.byteLength  < 0x12) {
      throw new Error('Targa::load() - Not enough data to contain header');
    }

    var header = {};
    header.idLength = view.getUint8(0x00);
    header.colorMapType = view.getUint8(0x01);
    header.imageType =  view.getUint8(0x02);
    header.colorMapIndex = view.getUint16(0x03, littleEndian);
    header.colorMapLength = view.getUint16(0x05, littleEndian);
    header.colorMapDepth = view.getUint8(0x07);
    header.offsetX = view.getUint16(0x08, littleEndian);
    header.offsetY = view.getUint16(0x0a, littleEndian);
    header.width = view.getUint16(0x0c, littleEndian);
    header.height = view.getUint16(0x0e, littleEndian);
    header.pixelDepth = view.getUint8(0x10);
    header.flags = view.getUint8(0x11);

    return header;
  }

  /**
   * Set additional header booleans
   * @param header
   */
  function setHeaderBooleans(header) {
    header.hasEncoding = (header.imageType === Targa.Type.RLE_INDEXED || header.imageType === Targa.Type.RLE_RGB || header.imageType === Targa.Type.RLE_GREY);
    header.hasColorMap = (header.imageType === Targa.Type.RLE_INDEXED || header.imageType === Targa.Type.INDEXED);
    header.isGreyColor = (header.imageType === Targa.Type.RLE_GREY || header.imageType === Targa.Type.GREY);
    header.bytePerPixel = header.pixelDepth >> 3;
    header.origin = (header.flags & Targa.Origin.MASK) >> Targa.Origin.SHIFT;
    header.alphaBits = header.flags & Targa.Origin.ALPHA;
  }

  /**
   * Check the header of TGA file to detect errors
   *
   * @param {object} header tga header structure
   * @throws Error
   */
  function checkHeader(header) {
    // What the need of a file without data ?
    if (header.imageType === Targa.Type.NO_DATA) {
      throw new Error('Targa::checkHeader() - No data');
    }

    // Indexed type
    if (header.hasColorMap) {
      if (header.colorMapLength > 256 || header.colorMapType !== 1) {
        throw new Error('Targa::checkHeader() - Unsupported colormap for indexed type');
      }
      if (header.colorMapDepth !== 16 && header.colorMapDepth !== 24  && header.colorMapDepth !== 32) {
        throw new Error('Targa::checkHeader() - Unsupported colormap depth');
      }
    }
    else {
      if (header.colorMapType) {
        throw new Error('Targa::checkHeader() - Why does the image contain a palette ?');
      }
    }

    // Check image size
    if (header.width <= 0 || header.height <= 0) {
      throw new Error('Targa::checkHeader() - Invalid image size');
    }

    // Check pixel size
    if (header.pixelDepth !== 8 &&
      header.pixelDepth !== 16 &&
      header.pixelDepth !== 24 &&
      header.pixelDepth !== 32) {
      throw new Error('Targa::checkHeader() - Invalid pixel size "' + header.pixelDepth + '"');
    }

    // Check alpha size
    if (header.alphaBits !== 0 &&
        header.alphaBits !== 1 &&
        header.alphaBits !== 8) {
      throw new Error('Targa::checkHeader() - Unsuppported alpha size');
    }
  }


  /**
   * Decode RLE compression
   *
   * @param {Uint8Array} data
   * @param {number} bytesPerPixel bytes per Pixel
   * @param {number} outputSize in byte: width * height * pixelSize
   */
  function decodeRLE(data, bytesPerPixel, outputSize) {
    var pos, c, count, i, offset;
    var pixels, output;

    output = new Uint8Array(outputSize);
    pixels = new Uint8Array(bytesPerPixel);
    offset = 0; // offset in data
    pos = 0; // offset for output

    while (pos < outputSize) {
      c = data[offset++]; // current byte to check
      count = (c & Targa.RLE_MASK) + 1; // repetition count of pixels, the lower 7 bits + 1

      // RLE packet, if highest bit is set to 1.
      if (c & Targa.RLE_BIT) {
        // Copy pixel values to be repeated to tmp array
        for (i = 0; i < bytesPerPixel; ++i) {
          pixels[i] = data[offset++];
        }

        // Copy pixel values * count to output
        for (i = 0; i < count; ++i) {
          output.set(pixels, pos);
          pos += bytesPerPixel;
        }
      }

      // Raw packet (Non-Run-Length Encoded)
      else {
        count *= bytesPerPixel;
        for (i = 0; i < count; ++i) {
          output[pos++] = data[offset++];
        }
      }
    }

    if (pos > outputSize) {
      throw new Error("Targa::decodeRLE() - Read bytes: " + pos + " Expected bytes: " + outputSize);
    }

    return output;
  }

  /**
   * Encode ImageData object with RLE compression
   *
   * @param header
   * @param imageData from canvas to compress
   */
  function encodeRLE(header, imageData) {
    var maxRepetitionCount = 128;
    var i;
    var data = imageData;
    var output = []; // output size is unknown
    var pos = 0; // pos in imageData array
    var bytesPerPixel = header.pixelDepth >> 3;
    var offset = 0;
    var packetType, packetLength, packetHeader;
    var tgaLength = header.width * header.height * bytesPerPixel;
    var isSamePixel = function isSamePixel(pos, offset) {
      for (var i = 0; i < bytesPerPixel; i++) {
        if (data[pos * bytesPerPixel + i] !== data[offset * bytesPerPixel + i]) {
          return false;
        }
      }
      return true;
    };
    var getPacketType = function(pos) {
      if (isSamePixel(pos, pos + 1)) {
        return Targa.RLE_PACKET;
      }
      return Targa.RAW_PACKET;
    };

    while (pos * bytesPerPixel < data.length && pos * bytesPerPixel < tgaLength) {
      // determine packet type
      packetType = getPacketType(pos);

      // determine packet length
      packetLength = 0;
      if (packetType === Targa.RLE_PACKET) {
        while (pos + packetLength < data.length
        && packetLength < maxRepetitionCount
        && isSamePixel(pos, pos + packetLength)) {
          packetLength++;
        }
      } else { // packetType === Targa.RAW_PACKET
        while (pos + packetLength < data.length
        && packetLength < maxRepetitionCount
        && getPacketType(pos + packetLength) === Targa.RAW_PACKET) {
          packetLength++;
        }
      }

      // write packet header
      packetHeader = packetLength - 1;
      if (packetType === Targa.RLE_PACKET) {
        packetHeader |= Targa.RLE_BIT;
      }
      output[offset++] = packetHeader;

      // write rle packet pixel OR raw pixels
      if (packetType === Targa.RLE_PACKET) {
        for (i = 0; i < bytesPerPixel; i++) {
          output[i + offset] = data[i + pos * bytesPerPixel];
        }
        offset += bytesPerPixel;
      } else {
        for (i = 0; i < bytesPerPixel * packetLength; i++) {
          output[i + offset] = data[i + pos * bytesPerPixel];
        }
        offset += bytesPerPixel * packetLength;
      }
      pos += packetLength;
    }

    return new Uint8Array(output);
  }


  /**
   * Return a ImageData object from a TGA file (8bits)
   *
   * @param {Array} imageData - ImageData to bind
   * @param {Array} indexes - index to colorMap
   * @param {Array} colorMap
   * @param {number} width
   * @param {number} y_start - start at y pixel.
   * @param {number} x_start - start at x pixel.
   * @param {number} y_step  - increment y pixel each time.
   * @param {number} y_end   - stop at pixel y.
   * @param {number} x_step  - increment x pixel each time.
   * @param {number} x_end   - stop at pixel x.
   * @returns {Array} imageData
   */
  function getImageData8bits(imageData, indexes, colorMap, width, y_start, y_step, y_end, x_start, x_step, x_end) {
    var color, index, offset, i, x, y;
    var bytePerPixel = this.header.colorMapDepth >> 3;

    for (i = 0, y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i++) {
        offset = (x + width * y) * 4;
        index = indexes[i] * bytePerPixel;
        if (bytePerPixel === 4) {
          imageData[offset    ] = colorMap[index + 2]; // red
          imageData[offset + 1] = colorMap[index + 1]; // green
          imageData[offset + 2] = colorMap[index    ]; // blue
          imageData[offset + 3] = colorMap[index + 3]; // alpha
        } else if (bytePerPixel === 3) {
          imageData[offset    ] = colorMap[index + 2]; // red
          imageData[offset + 1] = colorMap[index + 1]; // green
          imageData[offset + 2] = colorMap[index    ]; // blue
          imageData[offset + 3] = 255; // alpha
        } else if (bytePerPixel === 2) {
          color = colorMap[index] | (colorMap[index + 1] << 8);
          imageData[offset    ] = (color & 0x7C00) >> 7; // red
          imageData[offset + 1] = (color & 0x03E0) >> 2; // green
          imageData[offset + 2] = (color & 0x001F) << 3; // blue
          imageData[offset + 3] = (color & 0x8000) ? 0 : 255; // overlay 0 = opaque and 1 = transparent Discussion at: https://bugzilla.gnome.org/show_bug.cgi?id=683381
        }
      }
    }

    return imageData;
  }


  /**
   * Return a ImageData object from a TGA file (16bits)
   *
   * @param {Array} imageData - ImageData to bind
   * @param {Array} pixels data
   * @param {Array} colormap - not used
   * @param {number} width
   * @param {number} y_start - start at y pixel.
   * @param {number} x_start - start at x pixel.
   * @param {number} y_step  - increment y pixel each time.
   * @param {number} y_end   - stop at pixel y.
   * @param {number} x_step  - increment x pixel each time.
   * @param {number} x_end   - stop at pixel x.
   * @returns {Array} imageData
   */
  function getImageData16bits(imageData, pixels, colormap, width, y_start, y_step, y_end, x_start, x_step, x_end) {
    var color, offset, i, x, y;

    for (i = 0, y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i += 2) {
        color = pixels[i] | (pixels[i + 1] << 8);
        offset = (x + width * y) * 4;
        imageData[offset    ] = (color & 0x7C00) >> 7; // red
        imageData[offset + 1] = (color & 0x03E0) >> 2; // green
        imageData[offset + 2] = (color & 0x001F) << 3; // blue
        imageData[offset + 3] = (color & 0x8000) ? 0 : 255; // overlay 0 = opaque and 1 = transparent Discussion at: https://bugzilla.gnome.org/show_bug.cgi?id=683381
      }
    }

    return imageData;
  }


  /**
   * Return a ImageData object from a TGA file (24bits)
   *
   * @param {Array} imageData - ImageData to bind
   * @param {Array} pixels data
   * @param {Array} colormap - not used
   * @param {number} width
   * @param {number} y_start - start at y pixel.
   * @param {number} x_start - start at x pixel.
   * @param {number} y_step  - increment y pixel each time.
   * @param {number} y_end   - stop at pixel y.
   * @param {number} x_step  - increment x pixel each time.
   * @param {number} x_end   - stop at pixel x.
   * @returns {Array} imageData
   */
  function getImageData24bits(imageData, pixels, colormap, width, y_start, y_step, y_end, x_start, x_step, x_end) {
    var offset, i, x, y;
    var bpp = this.header.pixelDepth >> 3;

    for (i = 0, y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i += bpp) {
        offset = (x + width * y) * 4;
        imageData[offset + 3] = 255;  // alpha
        imageData[offset + 2] = pixels[i    ]; // blue
        imageData[offset + 1] = pixels[i + 1]; // green
        imageData[offset    ] = pixels[i + 2]; // red
      }
    }

    return imageData;
  }


  /**
   * Return a ImageData object from a TGA file (32bits)
   *
   * @param {Array} imageData - ImageData to bind
   * @param {Array} pixels data from TGA file
   * @param {Array} colormap - not used
   * @param {number} width
   * @param {number} y_start - start at y pixel.
   * @param {number} x_start - start at x pixel.
   * @param {number} y_step  - increment y pixel each time.
   * @param {number} y_end   - stop at pixel y.
   * @param {number} x_step  - increment x pixel each time.
   * @param {number} x_end   - stop at pixel x.
   * @returns {Array} imageData
   */
  function getImageData32bits(imageData, pixels, colormap, width, y_start, y_step, y_end, x_start, x_step, x_end) {
    var i, x, y, offset;

    for (i = 0, y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i += 4) {
        offset = (x + width * y) * 4;
        imageData[offset + 2] = pixels[i    ]; // blue
        imageData[offset + 1] = pixels[i + 1]; // green
        imageData[offset    ] = pixels[i + 2]; // red
        imageData[offset + 3] = pixels[i + 3]; // alpha
      }
    }

    return imageData;
  }

  /**
   * Return a ImageData object from a TGA file (32bits). Uses pre multiplied alpha values
   *
   * @param {Array} imageData - ImageData to bind
   * @param {Array} pixels data from TGA file
   * @param {Array} colormap - not used
   * @param {number} width
   * @param {number} y_start - start at y pixel.
   * @param {number} x_start - start at x pixel.
   * @param {number} y_step  - increment y pixel each time.
   * @param {number} y_end   - stop at pixel y.
   * @param {number} x_step  - increment x pixel each time.
   * @param {number} x_end   - stop at pixel x.
   * @returns {Array} imageData
   */
  function getImageData32bitsPre(imageData, pixels, colormap, width, y_start, y_step, y_end, x_start, x_step, x_end) {
    var i, x, y, offset, alpha;

    for (i = 0, y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i += 4) {
        offset = (x + width * y) * 4;
        alpha = pixels[i + 3] * 255; // TODO needs testing
        imageData[offset + 2] = pixels[i    ] / alpha; // blue
        imageData[offset + 1] = pixels[i + 1] / alpha; // green
        imageData[offset    ] = pixels[i + 2] / alpha; // red
        imageData[offset + 3] = pixels[i + 3]; // alpha
      }
    }

    return imageData;
  }


  /**
   * Return a ImageData object from a TGA file (8bits grey)
   *
   * @param {Array} imageData - ImageData to bind
   * @param {Array} pixels data
   * @param {Array} colormap - not used
   * @param {number} width
   * @param {number} y_start - start at y pixel.
   * @param {number} x_start - start at x pixel.
   * @param {number} y_step  - increment y pixel each time.
   * @param {number} y_end   - stop at pixel y.
   * @param {number} x_step  - increment x pixel each time.
   * @param {number} x_end   - stop at pixel x.
   * @returns {Array} imageData
   */
  function getImageDataGrey8bits(imageData, pixels, colormap, width, y_start, y_step, y_end, x_start, x_step, x_end) {
    var color, offset, i, x, y;

    for (i = 0, y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i++) {
        color = pixels[i];
        offset = (x + width * y) * 4;
        imageData[offset    ] = color; // red
        imageData[offset + 1] = color; // green
        imageData[offset + 2] = color; // blue
        imageData[offset + 3] = 255;   // alpha
      }
    }

    return imageData;
  }


  /**
   * Return a ImageData object from a TGA file (16bits grey) 8 Bit RGB and 8 Bit Alpha
   *
   * @param {Array} imageData - ImageData to bind
   * @param {Array} pixels data
   * @param {Array} colormap - not used
   * @param {number} width
   * @param {number} y_start - start at y pixel.
   * @param {number} x_start - start at x pixel.
   * @param {number} y_step  - increment y pixel each time.
   * @param {number} y_end   - stop at pixel y.
   * @param {number} x_step  - increment x pixel each time.
   * @param {number} x_end   - stop at pixel x.
   * @returns {Array} imageData
   */
  function getImageDataGrey16bits(imageData, pixels, colormap, width, y_start, y_step, y_end, x_start, x_step, x_end) {
    var color, offset, i, x, y;

    for (i = 0, y = y_start; y !== y_end; y += y_step) {
      for (x = x_start; x !== x_end; x += x_step, i += 2) {
        color = pixels[i];
        offset = (x + width * y) * 4;
        imageData[offset] = color;
        imageData[offset + 1] = color;
        imageData[offset + 2] = color;
        imageData[offset + 3] = pixels[i + 1];
      }
    }

    return imageData;
  }


  /**
   * Open a targa file using XHR, be aware with Cross Domain files...
   *
   * @param {string} path - Path of the filename to load
   * @param {function} callback - callback to trigger when the file is loaded
   */
  Targa.prototype.open = function targaOpen(path, callback) {
    var req, tga = this;
    req = new XMLHttpRequest();
    req.open('GET', path, true);
    req.responseType = 'arraybuffer';
    req.onload = function () {
      if (this.status === 200) {
        tga.arrayBuffer = req.response;
        tga.load(tga.arrayBuffer);
        if (callback) {
          callback.call(tga);
        }
      }
    };
    req.send(null);
  };


  function readFooter(view) {
    var offset = view.byteLength - Targa.FOOTER_SIZE;
    var signature = Targa.SIGNATURE;

    var footer = {};

    var signatureArray = new Uint8Array(view.buffer, offset + 0x08, signature.length);
    var str = String.fromCharCode.apply(null, signatureArray);

    if (!isSignatureValid(str)) {
      footer.hasFooter = false;
      return footer;
    }

    footer.hasFooter = true;
    footer.extensionOffset = view.getUint32(offset, Targa.LITTLE_ENDIAN);
    footer.developerOffset = view.getUint32(offset + 0x04, Targa.LITTLE_ENDIAN);
    footer.hasExtensionArea = footer.extensionOffset !== 0;
    footer.hasDeveloperArea = footer.developerOffset !== 0;

    if (footer.extensionOffset) {
      footer.attributeType = view.getUint8(footer.extensionOffset + 494);
    }

    return footer;
  }

  function isSignatureValid(str) {
    var signature = Targa.SIGNATURE;

    for (var i = 0; i < signature.length; i++) {
      if (str.charCodeAt(i) !== signature.charCodeAt(i)) {
        return false;
      }
    }

    return true;
  }

  /**
   * Load and parse a TGA file
   *
   * @param {ArrayBuffer} data - TGA file buffer array
   */
  Targa.prototype.load = function targaLoad(data) {
    var dataView = new DataView(data);

    this.headerData = new Uint8Array(data, 0, Targa.HEADER_SIZE);

    this.header = readHeader(dataView); // Parse Header
    setHeaderBooleans(this.header);
    checkHeader(this.header); // Check if a valid TGA file (or if we can load it)

    var offset = Targa.HEADER_SIZE;
    // Move to data
    offset += this.header.idLength;
    if (offset >= data.byteLength) {
      throw new Error('Targa::load() - No data');
    }

    // Read palette
    if (this.header.hasColorMap) {
      var colorMapSize = this.header.colorMapLength * (this.header.colorMapDepth >> 3);
      this.palette = new Uint8Array(data, offset, colorMapSize);
      offset += colorMapSize;
    }

    var bytesPerPixel = this.header.pixelDepth >> 3;
    var imageSize = this.header.width * this.header.height;
    var pixelTotal = imageSize * bytesPerPixel;

    if (this.header.hasEncoding) { // RLE encoded
      var RLELength = data.byteLength - offset - Targa.FOOTER_SIZE;
      var RLEData = new Uint8Array(data, offset, RLELength);
      this.imageData = decodeRLE(RLEData, bytesPerPixel, pixelTotal);
    } else { // RAW pixels
      this.imageData = new Uint8Array(data, offset, this.header.hasColorMap ? imageSize : pixelTotal);
    }
    
    this.footer = readFooter(dataView);

    if (this.header.alphaBits !== 0  || this.footer.hasExtensionArea && (this.footer.attributeType === 3 || this.footer.attributeType === 4)) {
      this.footer.usesAlpha = true;
    }
  };


  /**
   * Return a ImageData object from a TGA file
   *
   * @param {object} imageData - Optional ImageData to work with
   * @returns {object} imageData
   */
  Targa.prototype.getImageData = function targaGetImageData(imageData) {
    var width = this.header.width;
    var height = this.header.height;
    var origin = (this.header.flags & Targa.Origin.MASK) >> Targa.Origin.SHIFT;
    var x_start, x_step, x_end, y_start, y_step, y_end;
    var getImageData;

    // Create an imageData
    if (!imageData) {
      if (document) {
        imageData = document.createElement('canvas').getContext('2d').createImageData(width, height);
      }
      // In Thread context ?
      else {
        imageData = {
          width: width,
          height: height,
          data: new Uint8ClampedArray(width * height * 4)
        };
      }
    }

    if (origin === Targa.Origin.TOP_LEFT || origin === Targa.Origin.TOP_RIGHT) {
      y_start = 0;
      y_step = 1;
      y_end = height;
    }
    else {
      y_start = height - 1;
      y_step = -1;
      y_end = -1;
    }

    if (origin === Targa.Origin.TOP_LEFT || origin === Targa.Origin.BOTTOM_LEFT) {
      x_start = 0;
      x_step = 1;
      x_end = width;
    }
    else {
      x_start = width - 1;
      x_step = -1;
      x_end = -1;
    }

    // TODO: use this.header.offsetX and this.header.offsetY ?

    switch (this.header.pixelDepth) {
      case 8:
        getImageData = this.header.isGreyColor ? getImageDataGrey8bits : getImageData8bits;
        break;

      case 16:
        getImageData = this.header.isGreyColor ? getImageDataGrey16bits : getImageData16bits;
        break;

      case 24:
        getImageData = getImageData24bits;
        break;

      case 32:
        if (this.footer.hasExtensionArea) {
          if (this.footer.attributeType === 3) { // straight alpha
            getImageData = getImageData32bits;
          } else if (this.footer.attributeType === 4) { // pre multiplied alpha
            getImageData = getImageData32bitsPre;
          } else { // ignore alpha values if attributeType set to 0, 1, 2
            getImageData = getImageData24bits;
          }
        } else {
          if (this.header.alphaBits !== 0) {
            getImageData = getImageData32bits;
          } else { // 32 bits Depth, but alpha Bits set to 0
            getImageData = getImageData24bits;
          }
        }

        break;
    }

    getImageData.call(this, imageData.data, this.imageData, this.palette, width, y_start, y_step, y_end, x_start, x_step, x_end);
    return imageData;
  };

  /** (Experimental)
   *  Encodes imageData into TGA format
   *  Only TGA True Color 32 bit with optional RLE encoding is supported for now
   * @param imageData
   */
  Targa.prototype.setImageData = function targaSetImageData(imageData) {

    if (!imageData) {
      throw new Error('Targa::setImageData() - imageData argument missing');
    }

    var width = this.header.width;
    var height = this.header.height;
    var expectedLength = width * height * (this.header.pixelDepth  >> 3);
    var origin = (this.header.flags & Targa.Origin.MASK) >> Targa.Origin.SHIFT;
    var x_start, x_step, x_end, y_start, y_step, y_end;

    if (origin === Targa.Origin.TOP_LEFT || origin === Targa.Origin.TOP_RIGHT) {
      y_start = 0; // start bottom, step upward
      y_step = 1;
      y_end = height;
    } else {
      y_start = height - 1; // start at top, step downward
      y_step = -1;
      y_end = -1;
    }

    if (origin === Targa.Origin.TOP_LEFT || origin === Targa.Origin.BOTTOM_LEFT) {
      x_start = 0; // start left, step right
      x_step = 1;
      x_end = width;
    } else {
      x_start = width - 1; // start right, step left
      x_step = -1;
      x_end = -1;
    }

    if (!this.imageData) {
      this.imageData = new Uint8Array(expectedLength);
    }

    // start top left if origin is bottom left
    // swapping order of first two arguments does the trick for writing
    // this converts canvas data to internal tga representation
    // this.imageData contains tga data
    getImageData32bits(this.imageData, imageData.data, this.palette, width, y_start, y_step, y_end, x_start, x_step, x_end);

    var data = this.imageData;

    if (this.header.hasEncoding) {
      data = encodeRLE(this.header, data);
    }

    var bufferSize = Targa.HEADER_SIZE + data.length + Targa.FOOTER_SIZE;
    var buffer = new ArrayBuffer(bufferSize);

    this.arrayBuffer = buffer;
    // create array, useful for inspecting data while debugging
    this.headerData = new Uint8Array(buffer, 0, Targa.HEADER_SIZE);
    this.RLEData = new Uint8Array(buffer, Targa.HEADER_SIZE, data.length);
    this.footerData = new Uint8Array(buffer, Targa.HEADER_SIZE + data.length, Targa.FOOTER_SIZE);

    var headerView = new DataView(this.headerData.buffer);
    writeHeader(this.header, headerView);
    this.RLEData.set(data);
    writeFooter(this.footerData);
  };

  /**
   * Return a canvas with the TGA render on it
   *
   * @returns {object} CanvasElement
   */
  Targa.prototype.getCanvas = function targaGetCanvas() {
    var canvas, ctx, imageData;

    canvas = document.createElement('canvas');
    ctx = canvas.getContext('2d');
    imageData = ctx.createImageData(this.header.width, this.header.height);

    canvas.width = this.header.width;
    canvas.height = this.header.height;

    ctx.putImageData(this.getImageData(imageData), 0, 0);

    return canvas;
  };


  /**
   * Return a dataURI of the TGA file
   *
   * @param {string} type - Optional image content-type to output (default: image/png)
   * @returns {string} url
   */
  Targa.prototype.getDataURL = function targaGetDatURL(type) {
    return this.getCanvas().toDataURL(type || 'image/png');
  };

  /**
   * Return a objectURL of the TGA file
   * The url can be used in the download attribute of a link
   * @returns {string} url
   */
  Targa.prototype.getBlobURL = function targetGetBlobURL() {
    if (!this.arrayBuffer) {
      throw new Error('Targa::getBlobURL() - No data available for blob');
    }
    var blob = new Blob([this.arrayBuffer], { type: "image/x-tga" });
    return URL.createObjectURL(blob);
  };


  // Find Context
  var shim = {};
  if (typeof(exports) === 'undefined') {
    if (typeof(define) === 'function' && typeof(define.amd) === 'object' && define.amd) {
      define(function () {
        return Targa;
      });
    } else {
      // Browser
      shim.exports = typeof(window) !== 'undefined' ? window : _global;
    }
  }
  else {
    // Commonjs
    shim.exports = exports;
  }


  // Export
  if (shim.exports) {
    shim.exports.TGA = Targa;
  }

})(this);

'use strict';
var Mago3D = (function() 
{
'use strict';

var Emitter = function () 
{
	this._events = {};
};

Emitter.prototype.on = function (event, fn, once) 
{
	if (!this._events[event]) 
	{
		this._events[event] = [];
	}
	this._events[event].push({
		fn   : fn,
		once : once
	});

	return this;
};
Emitter.prototype.once = function (event, fn) 
{
	return this.on(event, fn, true);
};

Emitter.prototype.emit = function (event) 
{
	var callbacks = this._events[event];
	var onces = [];
	if (callbacks) 
	{
		for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) 
		{
			args[_key - 1] = arguments[_key];
		}

		for (var _iterator = callbacks, _isArray = true, _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) 
		{
			var _ref;

			if (_isArray) 
			{
				if (_i >= _iterator.length) { break; }
				_ref = _iterator[_i++];
			}
			else 
			{
				_i = _iterator.next();
				if (_i.done) { break; }
				_ref = _i.value;
			}
			var callbackObj = _ref;
			if (callbackObj.fn && typeof callbackObj.fn === 'function') 
			{
				callbackObj.fn.apply(this, args);
			}

			if (callbackObj.once && _isArray) 
			{
				onces.push(_i-1);
			}
			//
		}
	}
	if (onces.length > 0 && Array.isArray(callbacks)) 
	{
		for (var i=onces.length-1;i>=0;i--) 
		{
			callbacks.splice(onces[i], 1);
		}
	}

	return this;
};

Emitter.prototype.off = function (event, fn) 
{
	if (!this._events || arguments.length === 0) 
	{
		this._events = {};
		return this;
	}

	// specific event
	var callbacks = this._events[event];
	if (!callbacks) 
	{
		return this;
	}

	// remove all handlers
	if (arguments.length === 1) 
	{
		delete this._events[event];
		return this;
	}

	// remove specific handler
	for (var i = 0; i < callbacks.length; i++) 
	{
		var callback = callbacks[i];
		if (callback.fn === fn) 
		{
			callbacks.splice(i, 1);
			break;
		}
	}

	return this;
};
'use strict';

var MagoRenderable = function(options) 
{
	this.objectsArray = [];

	this.id;
	this.name;
	this.owner;

	this.attributes = {
		isVisible: true
	};
	// Use this matrix if this is child.
	this.tMat;
	this.tMatOriginal;

	// use this geoLocDataManager if this is no child.
	this.geoLocDataManager;
	
	this.dirty = true;
	this.color4;
	this.wireframeColor4;
	this.selectedColor4;
	this.objectType = MagoRenderable.OBJECT_TYPE.MESH; // Init as mesh type.

	this.eventObject = {};
	
	this.options = options;
	if (options !== undefined)
	{
		if (options.color && options.color instanceof Color) 
		{
			this.color4 = options.color;
		}
	}
};

MagoRenderable.EVENT_TYPE = {
	'RENDER_END'   : 'renderEnd',
	'RENDER_START' : 'renderStart',
	'MOVE_END'     : 'moveEnd',
	'MOVE_START'   : 'moveStart'
};

MagoRenderable.OBJECT_TYPE = {
	'MESH'       : 0,
	'VECTORMESH' : 1
};

/**
 * 이벤트 등록
 * @param {MagoEvent} event 
 */
MagoRenderable.prototype.addEventListener = function(event) 
{
	if (!event instanceof MagoEvent) 
	{
		throw new Error('args event must MagoEvent!');
	}

	var type = event.getType();

	if (!MagoRenderable.EVENT_TYPE[type]) 
	{
		throw new Error('this type is not support.');
	}

	if (!this.eventObject[type]) 
	{
		this.eventObject[type] = [];
	}

	this.eventObject[type].push(event);
};
/**
 * 이벤트 실행
 * @param {String} type 
 */
MagoRenderable.prototype.dispatchEvent = function(type, magoManager) 
{
	if (!MagoRenderable.EVENT_TYPE[type]) 
	{
		throw new Error('this type is not support.');
	}

	var events = this.eventObject[type];

	if (!events || !Array.isArray(events)) { return; } 
	
	for (var i=0, len=events.length;i<len;i++) 
	{
		var event = events[i];
		var listener = event.getListener();
		if (typeof listener === 'function') 
		{
			listener.apply(this, [this, magoManager]);
		}
	}
};
MagoRenderable.prototype.getRootOwner = function() 
{
	if (this.owner === undefined)
	{ return this; }
	else 
	{
		return this.owner.getRootOwner();
	}
};

MagoRenderable.prototype.getObject = function(idx) 
{
	if (idx > this.objectsArray.length-1) 
	{
		throw new Error('out of bound range.');
		//return undefined;
	}

	return this.objectsArray[idx];
};

MagoRenderable.prototype.render = function(magoManager, shader, renderType, glPrimitive, bIsSelected) 
{
	if (this.attributes) 
	{
		if (this.attributes.isVisible !== undefined && this.attributes.isVisible === false) 
		{
			return;
		}
		
		if (renderType === 2)
		{
			if (this.attributes.isSelectable !== undefined && this.attributes.isSelectable === false) 
			{
				return;
			}
		}
	}

	if (this.dirty)
	{ this.makeMesh(); }
	
	if (this.objectsArray.length === 0)
	{ return false; }

	// Set geoLocation uniforms.***
	var gl = magoManager.getGl();
	var buildingGeoLocation = this.geoLocDataManager.getCurrentGeoLocationData();
	buildingGeoLocation.bindGeoLocationUniforms(gl, shader); // rotMatrix, positionHIGH, positionLOW.
	
	var renderShaded = true;
	if (this.options && this.options.renderShaded === false)
	{
		renderShaded = false;
	}
	
	if (renderShaded)
	{ this.renderAsChild(magoManager, shader, renderType, glPrimitive, bIsSelected, this.options); }
	
	// check options provisionally here.
	if (this.options)
	{
		if (this.options.renderWireframe)
		{
			var shaderThickLine = magoManager.postFxShadersManager.getShader("thickLine");
			shaderThickLine.useProgram();
			shaderThickLine.bindUniformGenerals();
			var gl = magoManager.getGl();

			gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
			gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
			gl.disable(gl.CULL_FACE);
			
			gl.enableVertexAttribArray(shaderThickLine.prev_loc);
			gl.enableVertexAttribArray(shaderThickLine.current_loc);
			gl.enableVertexAttribArray(shaderThickLine.next_loc);
			
			var geoLocData = this.geoLocDataManager.getCurrentGeoLocationData();
			geoLocData.bindGeoLocationUniforms(gl, shaderThickLine);

			var sceneState = magoManager.sceneState;
			var drawingBufferWidth = sceneState.drawingBufferWidth;
			var drawingBufferHeight = sceneState.drawingBufferHeight;
			if (this.wireframeColor4)
			{ gl.uniform4fv(shaderThickLine.oneColor4_loc, [this.wireframeColor4.r, this.wireframeColor4.g, this.wireframeColor4.b, this.wireframeColor4.a]); }
			else
			{ gl.uniform4fv(shaderThickLine.oneColor4_loc, [0.6, 0.8, 0.9, 1.0]); }
			gl.uniform2fv(shaderThickLine.viewport_loc, [drawingBufferWidth[0], drawingBufferHeight[0]]);
			
			var bWireframe = true;
			this.renderAsChild(magoManager, shaderThickLine, renderType, glPrimitive, bIsSelected, this.options, bWireframe);
			
			// Return to the currentShader.
			shader.useProgram();
		}
	}
};

MagoRenderable.prototype.renderAsChild = function(magoManager, shader, renderType, glPrimitive, bIsSelected, options, bWireframe) 
{
	if (this.dirty)
	{ this.makeMesh(); }

	// Set geoLocation uniforms.***
	var gl = magoManager.getGl();
	
	if (renderType === 0)
	{
		// Depth render.***
	}
	else if (renderType === 1)
	{
		// Color render.***
		gl.enable(gl.BLEND);
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.***
		
		// Check if is selected.***
		var selectionManager = magoManager.selectionManager;

		if (selectionManager.isObjectSelected(this))
		{ bIsSelected = true; }
		
		if (bIsSelected)
		{
			var selColor = [0.9, 0.1, 0.1, 1.0];
			if (bWireframe)
			{
				selColor = [0.6, 0.6, 0.99, 1.0];
			}
			else
			{
				if (this.attributes.selectedColor4)
				{
					var selectedColor = this.attributes.selectedColor4;
					selColor = [selectedColor.r, selectedColor.g, selectedColor.b, selectedColor.a];
				}
			}
			
			gl.uniform4fv(shader.oneColor4_loc, selColor);
		}
		else 
		{
			if (bWireframe)
			{
				if (this.wireframeColor4) 
				{
					gl.uniform4fv(shader.oneColor4_loc, [this.wireframeColor4.r, this.wireframeColor4.g, this.wireframeColor4.b, this.wireframeColor4.a]); 
				}
			}
			else
			{
				if (this.color4) 
				{
					gl.uniform4fv(shader.oneColor4_loc, [this.color4.r, this.color4.g, this.color4.b, this.color4.a]);
				}
			}
		}
	}
	else if (renderType === 2)
	{
		// Selection render.***
		var selectionColor = magoManager.selectionColor;
		var colorAux = selectionColor.getAvailableColor(undefined);
		var idxKey = selectionColor.decodeColor3(colorAux.r, colorAux.g, colorAux.b);
		magoManager.selectionManager.setCandidateGeneral(idxKey, this);
		
		gl.uniform4fv(shader.oneColor4_loc, [colorAux.r/255.0, colorAux.g/255.0, colorAux.b/255.0, 1.0]);
		gl.disable(gl.BLEND);
	}

	if (this.tMat) 
	{
		gl.uniformMatrix4fv(shader.buildingRotMatrix_loc, false, this.tMat._floatArrays);
	}
	
	var objectsCount = this.objectsArray.length;
	for (var i=0; i<objectsCount; i++)
	{
		this.objectsArray[i].renderAsChild(magoManager, shader, renderType, glPrimitive, bIsSelected, options, bWireframe);
	}
	
	gl.disable(gl.BLEND);

	this.dispatchEvent('RENDER_END', magoManager);
};

MagoRenderable.prototype.makeMesh = function() 
{
	return abstract();
};

MagoRenderable.prototype.moved = function() 
{
	// do something.
};

MagoRenderable.prototype.updateMatrix = function(ownerMatrix) 
{
	if (!ownerMatrix) 
	{
		if (this.geoLocDataManager === undefined || this.geoLocDataManager === null) 
		{
			return;
		}

		var geoLocDataManager = this.geoLocDataManager;
		var geoLocData = geoLocDataManager.getCurrentGeoLocationData();
		this.tMat = geoLocData.rotMatrix;
	}
	else 
	{
		this.tMat = this.tMatOriginal.getMultipliedByMatrix(ownerMatrix, this.tMat);
	}
    
	if (this.objectsArray === undefined)
	{ return; }
	for (var i=0, len=this.objectsArray.length; i <len;++i) 
	{
		var object = this.objectsArray[i];
		if (object instanceof MagoRenderable)
		{
			this.objectsArray[i].updateMatrix(this.tMat);
		}
	}
};
MagoRenderable.prototype.setDirty = function(dirty) 
{
	this.dirty = dirty;
};
/**
 * Set the unique one color of the box
 * @param {Number} r
 * @param {Number} g
 * @param {Number} b 
 * @param {Number} a
 */
MagoRenderable.prototype.setOneColor = function(r, g, b, a)
{
	// This function sets the unique one color of the mesh.***
	if (this.color4 === undefined)
	{ this.color4 = new Color(); }
	
	this.color4.setRGBA(r, g, b, a);

	//TODO : 좀 더 정교한 근사값 구하기로 변경
	if (a < 1) 
	{
		this.setOpaque(false);
	}
};
/**
 * Set the unique one color of the box
 * @param {Number} r
 * @param {Number} g
 * @param {Number} b 
 * @param {Number} a
 */
MagoRenderable.prototype.setWireframeColor = function(r, g, b, a)
{
	// This function sets the unique one color of the mesh.***
	if (this.wireframeColor4 === undefined)
	{ this.wireframeColor4 = new Color(); }
	
	this.wireframeColor4.setRGBA(r, g, b, a);

	//TODO : 좀 더 정교한 근사값 구하기로 변경
	if (a < 1) 
	{
		this.setOpaque(false);
	}
};

MagoRenderable.prototype.setOpaque = function(opaque)
{
	this.attributes.opaque = opaque;
};
MagoRenderable.prototype.isOpaque = function()
{
	if (this.attributes.opaque === undefined) 
	{
		return true;
	}

	return this.attributes.opaque;
};
MagoRenderable.prototype.getGeoLocDataManager = function()
{
	return this.geoLocDataManager;
};
'use strict';

var ViewerInit = function(containerId, serverPolicy) 
{

	if (!containerId || !document.getElementById(containerId)) 
	{
		throw new Error('containerId is required.');
	}
	serverPolicy.maxPartitionsLod0 = 8;
	serverPolicy.maxPartitionsLod1 = 4;
	serverPolicy.maxPartitionsLod2OrLess = 2;

	serverPolicy.maxRatioPointsDist0m = 1.0;
	serverPolicy.maxRatioPointsDist100m = 10.0;
	serverPolicy.maxRatioPointsDist200m = 20.0;
	serverPolicy.maxRatioPointsDist400m = 40.0;
	serverPolicy.maxRatioPointsDist800m = 80.0;
	serverPolicy.maxRatioPointsDist1600m = 160.0;
	serverPolicy.maxRatioPointsDistOver1600m = 320.0;

	serverPolicy.maxPointSizeForPc = 10.0;
	serverPolicy.minPointSizeForPc = 2.0;
	serverPolicy.pendentPointSizeForPc = 60.0;

	serverPolicy.minHeight_rainbow_loc = 0.0;
	serverPolicy.maxHeight_rainbow_loc = 100.0;

	MagoConfig.init(serverPolicy, null, null);

	this.targetId = containerId;
	this.magoManager;
	this.viewer;
	this.policy = MagoConfig.getPolicy();

	MagoConfig.setContainerId(this.targetId);
	this.init();
};

ViewerInit.prototype.init = function() 
{
	return abstract();
};

ViewerInit.prototype.initMagoManager = function() 
{
	return abstract();
};

ViewerInit.prototype.setEventHandler = function() 
{
	return abstract();
};
'use strict';

/**
 * color 처리 관련 도메인
 * @class ColorAPI
 */
var ColorAPI = {};

ColorAPI.changeColor = function(api, magoManager) 
{
	var projectId = api.getProjectId();
	var dataKey = api.getDataKey();
	var objectIds = api.getObjectIds();
	var property = api.getProperty();
	var propertyKey = null;
	var propertyValue = null;
	if (property !== null && property !== "") 
	{
		var properties = property.split("=");
		propertyKey = properties[0];
		propertyValue = properties[1];
	}
	var colorString = api.getColor();
	if (colorString === undefined || colorString === 0)
	{ return; }
	
	var color = api.getColor().split(",");
	var colorsValueCount = color.length;
	var alpha = 255.0;
	if (colorsValueCount === 4)
	{
		alpha = color[3]/255;
	}
	
	var rgbaColor = [ color[0]/255, color[1]/255, color[2]/255, alpha ] ;
	
	var isExistObjectIds = false;
	if (objectIds !== null && objectIds.length !== 0) 
	{
		isExistObjectIds = true;
	}
	
	var changeHistorys = [];
	if (isExistObjectIds) 
	{
		for (var i=0, objectCount = objectIds.length; i<objectCount; i++) 
		{
			var changeHistory = new ChangeHistory();
			changeHistory.setProjectId(projectId);
			changeHistory.setDataKey(dataKey);
			changeHistory.setObjectId(objectIds[i]);
			changeHistory.setProperty(property);
			changeHistory.setPropertyKey(propertyKey);
			changeHistory.setPropertyValue(propertyValue);
			//changeHistory.setRgbColor(rgbColor);
			changeHistory.setColor(rgbaColor);
			
			changeHistorys.push(changeHistory);
		}
	}
	else 
	{
		var changeHistory = new ChangeHistory();
		changeHistory.setProjectId(projectId);
		changeHistory.setDataKey(dataKey);
		changeHistory.setObjectId(null);
		changeHistory.setProperty(property);
		changeHistory.setPropertyKey(propertyKey);
		changeHistory.setPropertyValue(propertyValue);
		//changeHistory.setRgbColor(rgbColor);
		changeHistory.setColor(rgbaColor);
		changeHistorys.push(changeHistory);
	}

	var changeHistory;
	var historiesCount = changeHistorys.length;
	for (var i=0; i<historiesCount; i++)
	{
		changeHistory = changeHistorys[i];
		MagoConfig.saveColorHistory(projectId, dataKey, changeHistory.getObjectId(), changeHistory);
	}
};
'use strict';

/**
 * Draw 관련 API를 담당하는 클래스
 * 원래는 이렇게 만들려고 한게 아니지만, legacy 파일이랑 이름, function 등이 중복되서 이렇게 만들었음
 * @class DrawAPI
 */
var DrawAPI = {};

DrawAPI.drawAppendData = function(api, magoManager) 
{
	magoManager.getObjectIndexFile(api.getProjectId(), api.getProjectDataFolder());
};

DrawAPI.drawInsertIssueImage = function(api, magoManager) 
{
	// pin 을 표시
	if (magoManager.objMarkerSC === undefined || api.getDrawType() === 0) 
	{
		magoManager.objMarkerSC = new ObjectMarker();
		magoManager.objMarkerSC.geoLocationData.geographicCoord = new GeographicCoord();
		ManagerUtils.calculateGeoLocationData(parseFloat(api.getLongitude()), parseFloat(api.getLatitude()), parseFloat(api.getElevation()), 
			undefined, undefined, undefined, magoManager.objMarkerSC.geoLocationData, magoManager);
	}
	
	var objMarker = magoManager.objMarkerManager.newObjectMarker({
		imageFilePath : 'defaultRed',
		sizeX         : 64,
		sizeY         : 64
	});
	
	magoManager.objMarkerSC.issue_id = api.getIssueId();
	magoManager.objMarkerSC.issue_type = api.getIssueType();
	magoManager.objMarkerSC.geoLocationData.geographicCoord.setLonLatAlt(parseFloat(api.getLongitude()), parseFloat(api.getLatitude()), parseFloat(api.getElevation()));
	
	objMarker.copyFrom(magoManager.objMarkerSC);
	magoManager.objMarkerSC = undefined;
};
'use strict';

/**
 * 변환 행렬 API
 * @class LocationAndRotationAPI
 */
var LocationAndRotationAPI = {};

LocationAndRotationAPI.changeLocationAndRotation = function(api, magoManager) 
{
//	var buildingId = api.getDataKey();
//	var buildingType = "structure";
//	var building = this.getNeoBuildingByTypeId(buildingType, buildingId);

	var changeHistory = new ChangeHistory();
	changeHistory.setProjectId(api.getProjectId());
	changeHistory.setDataKey(api.getDataKey());
	changeHistory.setLatitude(parseFloat(api.getLatitude()));
	changeHistory.setLongitude(parseFloat(api.getLongitude()));
	changeHistory.setElevation(parseFloat(api.getElevation()));
	changeHistory.setHeading(parseFloat(api.getHeading()));
	changeHistory.setPitch(parseFloat(api.getPitch()));
	changeHistory.setRoll(parseFloat(api.getRoll()));
	
	var lat = api.getLatitude();
	var lon = api.getLongitude();
	var elevation = api.getElevation();
	var heading = api.getHeading();
	var pitch = api.getPitch();
	var roll = api.getRoll();


	magoManager.changeLocationAndRotation(	api.getProjectId(),
		api.getDataKey(),
		lat,
		lon,
		elevation,
		heading,
		pitch,
		roll,
		api.getAnimationOption()
	);
	
	// MagoConfig에 저장......?
};
'use strict';

/**
 * lod 처리 관련 도메인
 * @class LodAPI
 */
var LodAPI = {};

LodAPI.changeLod = function(api, magoManager) 
{
	if (api.getLod0DistInMeters() !== null && api.getLod0DistInMeters() !== "") { magoManager.magoPolicy.setLod0DistInMeters(api.getLod0DistInMeters()); }
	if (api.getLod1DistInMeters() !== null && api.getLod1DistInMeters() !== "") { magoManager.magoPolicy.setLod1DistInMeters(api.getLod1DistInMeters()); }
	if (api.getLod2DistInMeters() !== null && api.getLod2DistInMeters() !== "") { magoManager.magoPolicy.setLod2DistInMeters(api.getLod2DistInMeters()); }
	if (api.getLod3DistInMeters() !== null && api.getLod3DistInMeters() !== "") { magoManager.magoPolicy.setLod3DistInMeters(api.getLod3DistInMeters()); }
	if (api.getLod4DistInMeters() !== null && api.getLod4DistInMeters() !== "") { magoManager.magoPolicy.setLod4DistInMeters(api.getLod4DistInMeters()); }
	if (api.getLod5DistInMeters() !== null && api.getLod5DistInMeters() !== "") { magoManager.magoPolicy.setLod5DistInMeters(api.getLod5DistInMeters()); }
};
'use strict';

/**
 * save the data related with making feature move
 * @class AnimationData
 */
var AnimationData = function() 
{
	if (!(this instanceof AnimationData)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.animationType = CODE.animationType.UNKNOWN;
	
	// Linear translation animation.***
	this.birthTime; //the first update time
	this.lastTime; // the last update time.
	this.durationInSeconds;
	
	// Path.***
	this.path; 
	
	// start location.
	this.startLongitude;
	this.startLatitude;
	this.startAltitude;
	
	// target location.
	this.targetLongitude;
	this.targetLatitude;
	this.targetAltitude;
	
	// target rotation.
	this.targetHeading;
	this.targetPitch;
	this.targetRoll;
	
	// linear velocity in m/s.
	this.linearVelocityInMetersSecond;
	
	// angular velocity deg/s.
	this.headingAngDegSecondVelocity;
	this.pitchAngDegSecondVelocity;
	this.rollAngDegSecondVelocity;
};

'use strict';

/**
 * AnimationManager
 * @class AnimationManager
 */
var AnimationManager = function() 
{
	if (!(this instanceof AnimationManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	// Nodes animation. Executed if the node is visible.
	this.nodesMap;	
	
	// General animations array. Executed every time.
	this.objectsMap;
};

/**
 * put the node which will move
 * @param {Node} node
 */
AnimationManager.prototype.putNode = function(node) 
{
	if (this.nodesMap === undefined)
	{ this.nodesMap = {}; }
	
	var nodeId = node.data.nodeId;
	this.nodesMap[nodeId] = node;
};

/**
 * put the node which will move
 * @param {Node} node
 */
AnimationManager.prototype.putObject = function(object) 
{
	if (this.objectsMap === undefined)
	{ this.objectsMap = {}; }
	
	var objectId = object.id;
	this.objectsMap[objectId] = object;
};

/**
 * Check whether this node already moved or not
 * @param {MagoManager} magoManager
 */
AnimationManager.prototype.checkAnimation = function(magoManager) 
{
	if (this.nodesMap !== undefined)
	{
		var node;
		for (var key in this.nodesMap)
		{
			if (Object.prototype.hasOwnProperty.call(this.nodesMap, key))
			{
				node = this.nodesMap[key];
				if (node.finishedAnimation(magoManager))
				{
					delete this.nodesMap[key];
				}
			}
		}
	}
	
	// Now, for general objects.***
	if (this.objectsMap !== undefined)
	{
		var object;
		for (var key in this.objectsMap)
		{
			if (Object.prototype.hasOwnProperty.call(this.objectsMap, key))
			{
				object = this.objectsMap[key];
				if (object.finishedAnimation(magoManager))
				{
					delete this.objectsMap[key];
				}
			}
		}
	}
};

/**
 * This function returns the next position & rotation, depending the animationData type.
 */
AnimationManager.getNextPosition = function(animationData, currTime, magoManager) 
{
	if (animationData === undefined)
	{ return true; }

	// Check animationType.***
	var animType = animationData.animationType;
	if (animType === CODE.animationType.PATH)
	{
		return AnimationManager.getNextPositionByPath(animationData, currTime, magoManager);
	}
};

/**
 * This function returns the next position & rotation, for the path-animationData type.
 */
AnimationManager.getNextPositionByPath = function(animationData, currTime, magoManager) 
{
	if (animationData === undefined)
	{ return true; }

	var path = animationData.path;
	if (path === undefined)
	{ return true; }
	
	// Test for bSplineCubic3D path.***
	if (animationData.linearVelocityInMetersSecond === undefined)
	{ animationData.linearVelocityInMetersSecond = 20; } // 20m/s.***
	
	var speed = animationData.linearVelocityInMetersSecond;
	var increTimeSec = (currTime - animationData.birthTime)/1000;
	
	var linearPos = speed*increTimeSec;
	
	if (Path3D.prototype.isPrototypeOf(path))
	{
		var tangentLine = path.getTangent(linearPos, undefined, magoManager);
		
		return tangentLine;
	}
	else if (BSplineCubic3D.prototype.isPrototypeOf(path))
	{
		// If exist animationData.durationInSeconds, then use it.***
		if (animationData.durationInSeconds)
		{
			if (animationData.currentLinearPos && animationData.currentLinearPos >= animationData.totalLinearLength)
			{ return undefined; }
			
			var interpolationsCount = 20;
			if (animationData.totalLinearLength === undefined)
			{ 
				if (path.knotPoints3dList === undefined)
				{
					var controlPointArmLength = 0.3;
					path.makeControlPoints(controlPointArmLength, magoManager);
				}
				animationData.totalLinearLength = BSplineCubic3D.getLength(path, interpolationsCount); 
			}
			
			var totalLinearLength = animationData.totalLinearLength;
			var percentualTime = increTimeSec/animationData.durationInSeconds;
			linearPos = totalLinearLength*percentualTime;
			animationData.currentLinearPos = linearPos;
			if (linearPos > totalLinearLength)
			{ linearPos = totalLinearLength; }
		}
		return BSplineCubic3D.getTangent(path, linearPos, undefined, magoManager);
	}
};














































'use strict';

/**
 * Bounding box
 * 영역박스
 * 
 * @alias BoundingBox
 * @class BoundingBox
 */
var BoundingBox = function() 
{
	if (!(this instanceof BoundingBox)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.minX = 1000000.0;
	this.minY = 1000000.0;
	this.minZ = 1000000.0;

	this.maxX = -1000000.0;
	this.maxY = -1000000.0;
	this.maxZ = -1000000.0;
};

/**
 * Initiate the value of the bounding box
 * @param {Point3D} point 3차원 점
 */
BoundingBox.prototype.init = function(point) 
{
	point = point || new Point3D();

	this.minX = point.x;
	this.minY = point.y;
	this.minZ = point.z;

	this.maxX = point.x;
	this.maxY = point.y;
	this.maxZ = point.z;
};

/**
 * Reads the boundingBox from an arrayBuffer.
 * @param {typedArray} arrayBuffer
 * @param {Number} bytesReaded current bytesReaded on the arrayBuffer.
 */
BoundingBox.prototype.readData = function(arrayBuffer, bytesReaded) 
{
	this.minX = (new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	this.minY = (new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	this.minZ = (new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	this.maxX = (new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	this.maxY = (new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	this.maxZ = (new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	return bytesReaded;
};

/**
 * Sets the values of the bounding box
 * @param {Number} minX Minimum value of the boundingBox in x axis.
 * @param {Number} minY Minimum value of the boundingBox in y axis.
 * @param {Number} minZ Minimum value of the boundingBox in z axis.
 * @param {Number} maxX Maximum value of the boundingBox in x axis.
 * @param {Number} maxY Maximum value of the boundingBox in y axis.
 * @param {Number} maxZ Maximum value of the boundingBox in z axis.
 */
BoundingBox.prototype.set = function(minX, minY, minZ, maxX, maxY, maxZ) 
{
	this.minX = minX;
	this.minY = minY;
	this.minZ = minZ;

	this.maxX = maxX;
	this.maxY = maxY;
	this.maxZ = maxZ;
};

/**
 * Delete bounding box
 * 영역박스 삭제
 * 
 */
BoundingBox.prototype.deleteObjects = function() 
{
	this.minX = undefined;
	this.minY = undefined;
	this.minZ = undefined;

	this.maxX = undefined;
	this.maxY = undefined;
	this.maxZ = undefined;
};

/**
 *
 * Copy other box
 * @param bbox box
 */
BoundingBox.prototype.copyFrom = function(bbox) 
{
	this.minX = bbox.minX;
	this.minY = bbox.minY;
	this.minZ = bbox.minZ;

	this.maxX = bbox.maxX;
	this.maxY = bbox.maxY;
	this.maxZ = bbox.maxZ;
};

/**
 * Move the center of the box to the origin
 */
BoundingBox.prototype.translateToOrigin = function() 
{
	var semiXLength = this.getXLength() /2;
	var semiYLength = this.getYLength() /2;
	var semiZLength = this.getZLength() /2;
	
	this.minX = -semiXLength;
	this.minY = -semiYLength;
	this.minZ = -semiZLength;

	this.maxX = semiXLength;
	this.maxY = semiYLength;
	this.maxZ = semiZLength;
};

/**
 * Expane the size of the box as double of the given distance
 * 영역박스 확대
 * 
 * @param {Number} distance
 */
BoundingBox.prototype.expand = function(distance) 
{
	distance = distance || 0.0;
	distance = Math.abs(distance);

	this.minX -= distance;
	this.minY -= distance;
	this.minZ -= distance;

	this.maxX += distance;
	this.maxY += distance;
	this.maxZ += distance;
};
/**
 * 중심점과 박스의 변의 길이로 bbox 만들기
 * 
 * @param {Point3D} point 3차원 점
 * @param {number} size 
 * @return {BoundingBox}
 */
BoundingBox.getBBoxByPonintAndSize = function(point, size) 
{

	if (!point || !point instanceof Point3D) 
	{
		throw new Error('point is required');
	}

	if (isNaN(size))
	{
		throw new Error('size must number.');
	}
	
	var bbox = new BoundingBox();
	var maxX = point.x + size;
	var minX = point.x - size;
	var maxY = point.y + size;
	var minY = point.y - size;
	var minZ = point.z - size;
	var maxZ = point.z + size;
	bbox.set(minX, minY, minZ, maxX, maxY, maxZ);

	return bbox;
};

/**
 * 주어진 3차원 점을 포함하는 영역으로 영역박스 크기를 변경
 * 
 * @param {Point3D} point 3차원 점
 */
BoundingBox.getBBoxByXYZDataArray = function(xyzDataArray, resultBBox) 
{
	if (xyzDataArray === undefined)
	{ return undefined; }

	var points3dCount = xyzDataArray.length/3;
	
	if (points3dCount === 0)
	{ return undefined; }

	if (resultBBox === undefined)
	{ resultBBox = new BoundingBox(); }
	
	resultBBox.init(new Point3D(xyzDataArray[0], xyzDataArray[1], xyzDataArray[2]));
	for (var i=0; i<points3dCount; i++)
	{
		resultBBox.addXYZData(xyzDataArray[i*3], xyzDataArray[i*3+1], xyzDataArray[i*3+2]);
	}
	
	return resultBBox;
};

/**
 * 주어진 3차원 점을 포함하는 영역으로 영역박스 크기를 변경
 * 
 * @param {Point3D} point 3차원 점
 */
BoundingBox.prototype.addXYZData = function(x, y, z) 
{
	if (x === undefined || y === undefined || z === undefined )	{ return; }

	if (x < this.minX) { this.minX = x; }
	else if (x > this.maxX) { this.maxX = x; }

	if (y < this.minY) { this.minY = y; }
	else if (y > this.maxY) { this.maxY = y; }

	if (z < this.minZ) { this.minZ = z; }
	else if (z > this.maxZ) { this.maxZ = z; }
};

/**
 * 주어진 3차원 점을 포함하는 영역으로 영역박스 크기를 변경
 * 
 * @param {Point3D} point 3차원 점
 */
BoundingBox.prototype.addPointsArray = function(pointsArray) 
{
	if (pointsArray === undefined)
	{ return; }
	
	var pointsCount = pointsArray.length;
	for (var i=0;i<pointsCount;++i)
	{
		this.addPoint(pointsArray[i]);
	}
};

/**
 * 주어진 3차원 점을 포함하는 영역으로 영역박스 크기를 변경
 * 
 * @param {Point3D} point 3차원 점
 */
BoundingBox.prototype.addPoint = function(point) 
{
	if (point === undefined)	{ return; }

	if (point.x < this.minX) { this.minX = point.x; }
	else if (point.x > this.maxX) { this.maxX = point.x; }

	if (point.y < this.minY) { this.minY = point.y; }
	else if (point.y > this.maxY) { this.maxY = point.y; }

	if (point.z < this.minZ) { this.minZ = point.z; }
	else if (point.z > this.maxZ) { this.maxZ = point.z; }
};

/**
 * Set the range of the box which contain given box
 * 주어진 영역박스를 포함하는 영역으로 영역박스 크기를 변경
 * 
 * @param {BoundingBox} box 영역박스
 */
BoundingBox.prototype.addBox = function(box) 
{
	if (box === undefined)	{ return; }

	if (box.minX < this.minX) { this.minX = box.minX; }
	if (box.maxX > this.maxX) { this.maxX = box.maxX; }

	if (box.minY < this.minY) { this.minY = box.minY; }
	if (box.maxY > this.maxY) { this.maxY = box.maxY; }

	if (box.minZ < this.minZ) { this.minZ = box.minZ; }
	if (box.maxZ > this.maxZ) { this.maxZ = box.maxZ; }
};

/**
 * Get the minimum length among x, y, z edges' lengths
 * 영역박스의 가로, 세로, 높이 중에서 최소값
 * 
 * @returns {Number} 최소값
 */
BoundingBox.prototype.getMinLength = function() 
{
	return Math.min(this.maxX - this.minX, this.maxY - this.minY, this.maxZ - this.minZ);
};

/**
 * Get the maximum length among x, y, z edges' lengths
 * @returns {Number} 최대값
 */
BoundingBox.prototype.getMaxLength = function() 
{
	return Math.max(this.maxX - this.minX, this.maxY - this.minY, this.maxZ - this.minZ);
};

/**
 * Get the length of the edge which is parallel to x axis
 * 영역박스의 X축 방향의 길이
 * 
 * @returns {Number} 길이값
 */
BoundingBox.prototype.getXLength = function() 
{
	return this.maxX - this.minX;
};

/**
 * Get the length of the edge which is parallel to y axis
 * 영역박스의 Y축 방향의 길이
 * 
 * @returns {Number} 길이값
 */
BoundingBox.prototype.getYLength = function() 
{
	return this.maxY - this.minY;
};

/**
 * Get the length of the edge which is parallel to z axis
 * 영역박스의 Z축 방향의 길이
 * 
 * @returns {Number} 길이값
 */
BoundingBox.prototype.getZLength = function() 
{
	return this.maxZ - this.minZ;
};

/**
 * Get the center point of this box
 * 영역박스의 중심점을 구한다.
 * 
 * @param {Point3D} result 영역박스의 중심점
 * 
 * @returns {Point3D} 영역박스의 중심점
 */
BoundingBox.prototype.getCenterPoint = function(result) 
{
	if ( result === undefined ) { result = new Point3D(); }
	result.set((this.maxX + this.minX)/2, (this.maxY + this.minY)/2, (this.maxZ + this.minZ)/2);
	return result;
};

/**
 * Get the center point of this box
 * 영역박스의 중심점을 구한다.
 * 
 * @param {Point3D} result 영역박스의 중심점
 * 
 * @returns {Point3D} 영역박스의 중심점
 */
BoundingBox.prototype.getMinPoint = function(result) 
{
	if ( result === undefined ) { result = new Point3D(); }
	result.set(this.minX, this.minY, this.minZ);
	return result;
};

/**
 * Get the center point of this box
 * 영역박스의 중심점을 구한다.
 * 
 * @param {Point3D} result 영역박스의 중심점
 * 
 * @returns {Point3D} 영역박스의 중심점
 */
BoundingBox.prototype.getMaxPoint = function(result) 
{
	if ( result === undefined ) { result = new Point3D(); }
	result.set(this.maxX, this.maxY, this.maxZ);
	return result;
};

/**
 * Get the center point of this box
 * 영역박스의 중심점을 구한다.
 * 
 * @param {Point3D} result 영역박스의 중심점
 * 
 * @returns {Point3D} 영역박스의 중심점
 */
BoundingBox.prototype.getBottomCenterPoint = function(result) 
{
	if ( result === undefined ) { result = new Point3D(); }

	result.set((this.maxX + this.minX)/2, (this.maxY + this.minY)/2, 0);

	return result;
};

/**
 * 
 * 영역박스의 중심점을 구한다.
 * 
 * @returns {Number} apriximately radius.
 */
BoundingBox.prototype.getRadiusAprox = function() 
{
	var maxLength = this.getMaxLength();
	return maxLength/1.5;
};

/**
 * 
 * 영역박스의 중심점을 구한다.
 * 
 * @returns {Number} apriximately radius.
 */
BoundingBox.prototype.getRadius = function() 
{
	var centerPoint = this.getCenterPoint();
	var minPoint = this.getMinPoint();
	return centerPoint.distToPoint(minPoint);
};

/**
 * 
 * 영역박스의 중심점을 구한다.
 * 
 * @returns {Number} apriximately radius.
 */
BoundingBox.prototype.getBoundingSphere = function(resultBoundingSphere) 
{
	if (resultBoundingSphere === undefined)
	{ resultBoundingSphere = new Sphere(); } 
	
	var centerPos = this.getCenterPoint();
	resultBoundingSphere.setCenterPoint(centerPos.x, centerPos.y, centerPos.z);
	resultBoundingSphere.setRadius(this.getRadiusAprox());
	
	return resultBoundingSphere;
};


/**
 * 영역박스와 점과의 교차 여부를 판단
 * 
 * @param {Point3D} point 3차원 점
 * @returns {Boolean} 교차 여부
 */
BoundingBox.prototype.intersectWithPoint = function(point) 
{
	if (point === undefined)	{ return false; }

	if (point.x < this.minX || point.x > this.maxX || 
		point.y < this.minY || point.y > this.maxY ||
		point.z < this.minZ || point.z > this.maxZ) 
	{
		return false;
	}

	//return this.isPoint3dInside(point.x, point.y, point.z);
	return true;
};

/**
 * Check whether the given point is contained or intersected with this box
 * 영역박스와 점과의 교차 여부를 판단
 * 
 * @param {Number} x x성분
 * @param {Number} y y성분
 * @param {Number} z z성분
 * @returns {Boolean} 교차 여부
 */
BoundingBox.prototype.isPoint3dInside = function(x, y, z) 
{
	if (x < this.minX || x > this.maxX) 
	{
		return false;
	}
	else if (y < this.minY || y > this.maxY) 
	{
		return false;
	}
	else if (z < this.minZ || z > this.maxZ) 
	{
		return false;
	}

	return true;
};

/**
 * 영역박스와 주어진 영역박스와의 교차 여부를 판단
 * 
 * @param {BoundingBox} box 영역박스
 * @returns {Boolean} 교차 여부
 */
BoundingBox.prototype.intersectWithBox = function(box)
{
	if (box === undefined)	{ return false; }

	if (box.minX > this.maxX || box.maxX < this.minX ||
		box.minY > this.maxY || box.maxY < this.minY ||
		box.minZ > this.maxZ || box.maxZ < this.minZ)
	{
		return false;
	}

	return true;
};

/**
 * Check whether this box and the given box are intersected by each others.
 * 영역박스와 주어진 영역박스와의 교차 여부를 판단
 * 
 * @param {Triangle} triangle
 * @returns {Boolean} the flag whether they are intersected or not 교차 여부 
 */
BoundingBox.prototype.getPlaneTop = function(resultPlane) 
{
	if (resultPlane === undefined)
	{ resultPlane = new Plane(); }
	
	var point = this.getMaxPoint();
	resultPlane.setPointAndNormal(point.x, point.y, point.z, 0, 0, 1);
	
	return resultPlane;
};

/**
 * Check whether this box and the given box are intersected by each others.
 * 영역박스와 주어진 영역박스와의 교차 여부를 판단
 * 
 * @param {Triangle} triangle
 * @returns {Boolean} the flag whether they are intersected or not 교차 여부 
 */
BoundingBox.prototype.getPlaneBottom = function(resultPlane) 
{
	if (resultPlane === undefined)
	{ resultPlane = new Plane(); }
	
	var point = this.getMinPoint();
	resultPlane.setPointAndNormal(point.x, point.y, point.z, 0, 0, -1);
	
	return resultPlane;
};

/**
 * Check whether this box and the given box are intersected by each others.
 * 영역박스와 주어진 영역박스와의 교차 여부를 판단
 * 
 * @param {Triangle} triangle
 * @returns {Boolean} the flag whether they are intersected or not 교차 여부 
 */
BoundingBox.prototype.getPlaneFront = function(resultPlane) 
{
	if (resultPlane === undefined)
	{ resultPlane = new Plane(); }
	
	var point = this.getMinPoint();
	resultPlane.setPointAndNormal(point.x, point.y, point.z, 0, -1, 0);
	
	return resultPlane;
};

/**
 * Check whether this box and the given box are intersected by each others.
 * 영역박스와 주어진 영역박스와의 교차 여부를 판단
 * 
 * @param {Triangle} triangle
 * @returns {Boolean} the flag whether they are intersected or not 교차 여부 
 */
BoundingBox.prototype.getPlaneRear = function(resultPlane) 
{
	if (resultPlane === undefined)
	{ resultPlane = new Plane(); }
	
	var point = this.getMaxPoint();
	resultPlane.setPointAndNormal(point.x, point.y, point.z, 0, 1, 0);
	
	return resultPlane;
};

/**
 * Check whether this box and the given box are intersected by each others.
 * 영역박스와 주어진 영역박스와의 교차 여부를 판단
 * 
 * @param {Triangle} triangle
 * @returns {Boolean} the flag whether they are intersected or not 교차 여부 
 */
BoundingBox.prototype.getPlaneLeft = function(resultPlane) 
{
	if (resultPlane === undefined)
	{ resultPlane = new Plane(); }
	
	var point = this.getMinPoint();
	resultPlane.setPointAndNormal(point.x, point.y, point.z, -1, 0, 0);
	
	return resultPlane;
};

/**
 * Check whether this box and the given box are intersected by each others.
 * 영역박스와 주어진 영역박스와의 교차 여부를 판단
 * 
 * @param {Triangle} triangle
 * @returns {Boolean} the flag whether they are intersected or not 교차 여부 
 */
BoundingBox.prototype.getPlaneRight = function(resultPlane) 
{
	if (resultPlane === undefined)
	{ resultPlane = new Plane(); }
	
	var point = this.getMaxPoint();
	resultPlane.setPointAndNormal(point.x, point.y, point.z, 1, 0, 0);
	
	return resultPlane;
};

/**
 * Check whether this box and the given box are intersected by each others.
 * 영역박스와 주어진 영역박스와의 교차 여부를 판단
 * 
 * @param {Triangle} triangle
 * @returns {Boolean} the flag whether they are intersected or not 교차 여부 
 */
BoundingBox.prototype.isPoint3dInsideXYPrism = function(point3d) 
{
	if (point3d === undefined)
	{ return false; }
	
	if (point3d.x < this.minX || point3d.x > this.maxX || 
		point3d.y < this.minY || point3d.y > this.maxY) 
	{
		return false;
	}
	
	return true;
};

/**
 * Check whether this box and the given box are intersected by each others.
 * 영역박스와 주어진 영역박스와의 교차 여부를 판단
 * 
 * @param {Triangle} triangle
 * @returns {Boolean} the flag whether they are intersected or not 교차 여부 
 */
BoundingBox.prototype.isPoint3dInsideXZPrism = function(point3d) 
{
	if (point3d === undefined)
	{ return false; }
	
	if (point3d.x < this.minX || point3d.x > this.maxX || 
		point3d.z < this.minZ || point3d.z > this.maxZ) 
	{
		return false;
	}
	
	return true;
};

/**
 * Check whether this box and the given box are intersected by each others.
 * 영역박스와 주어진 영역박스와의 교차 여부를 판단
 * 
 * @param {Triangle} triangle
 * @returns {Boolean} the flag whether they are intersected or not 교차 여부 
 */
BoundingBox.prototype.isPoint3dInsideYZPrism = function(point3d) 
{
	if (point3d === undefined)
	{ return false; }
	
	if (point3d.y < this.minY || point3d.y > this.maxY ||
		point3d.z < this.minZ || point3d.z > this.maxZ) 
	{
		return false;
	}
	
	return true;
};

/**
 * Check whether this box and the given box are intersected by each others.
 * 영역박스와 주어진 영역박스와의 교차 여부를 판단
 * 
 * @param {Triangle} triangle
 * @returns {Boolean} the flag whether they are intersected or not 교차 여부 
 */
BoundingBox.prototype.intersectsWithSegment3D = function(segment3d) 
{
	if (segment3d === undefined)
	{ return false; }
	
	var line = segment3d.getLine();
	
	// 1) Top.
	var plane = this.getPlaneTop();
	var intersectionPoint = plane.intersectionLine(line, intersectionPoint);
	if (intersectionPoint !== undefined)
	{
		// check if the intersectionPoint is inside of the top rectangle.
		if (this.isPoint3dInsideXYPrism(intersectionPoint))
		{ 
			// check if intersectionPoint is inside of the segment3d.
			if (segment3d.intersectionWithPoint(intersectionPoint))
			{ return true; }
		}
	}
	
	// 2) Bottom.
	var plane = this.getPlaneBottom();
	var intersectionPoint = plane.intersectionLine(line, intersectionPoint);
	if (intersectionPoint !== undefined)
	{
		// check if the intersectionPoint is inside of the top rectangle.
		if (this.isPoint3dInsideXYPrism(intersectionPoint))
		{ 
			// check if intersectionPoint is inside of the segment3d.
			if (segment3d.intersectionWithPoint(intersectionPoint))
			{ return true; }
		}
	}
	
	// 3) Front.
	var plane = this.getPlaneFront();
	var intersectionPoint = plane.intersectionLine(line, intersectionPoint);
	if (intersectionPoint !== undefined)
	{
		// check if the intersectionPoint is inside of the top rectangle.
		if (this.isPoint3dInsideXZPrism(intersectionPoint))
		{ 
			// check if intersectionPoint is inside of the segment3d.
			if (segment3d.intersectionWithPoint(intersectionPoint))
			{ return true; }
		}
	}
	
	// 4) Rear.
	var plane = this.getPlaneRear();
	var intersectionPoint = plane.intersectionLine(line, intersectionPoint);
	if (intersectionPoint !== undefined)
	{
		// check if the intersectionPoint is inside of the top rectangle.
		if (this.isPoint3dInsideXZPrism(intersectionPoint))
		{ 
			// check if intersectionPoint is inside of the segment3d.
			if (segment3d.intersectionWithPoint(intersectionPoint))
			{ return true; }
		}
	}
	
	// 5) Left.
	var plane = this.getPlaneLeft();
	var intersectionPoint = plane.intersectionLine(line, intersectionPoint);
	if (intersectionPoint !== undefined)
	{
		// check if the intersectionPoint is inside of the top rectangle.
		if (this.isPoint3dInsideYZPrism(intersectionPoint))
		{ 
			// check if intersectionPoint is inside of the segment3d.
			if (segment3d.intersectionWithPoint(intersectionPoint))
			{ return true; }
		}
	}
	
	// 6) Right.
	var plane = this.getPlaneRight();
	var intersectionPoint = plane.intersectionLine(line, intersectionPoint);
	if (intersectionPoint !== undefined)
	{
		// check if the intersectionPoint is inside of the top rectangle.
		if (this.isPoint3dInsideYZPrism(intersectionPoint))
		{ 
			// check if intersectionPoint is inside of the segment3d.
			if (segment3d.intersectionWithPoint(intersectionPoint))
			{ return true; }
		}
	}
	
	return false;
};

/**
 * Check whether this box and the given box are intersected by each others.
 * 영역박스와 주어진 영역박스와의 교차 여부를 판단
 * 
 * @param {Triangle} triangle
 * @returns {Boolean} the flag whether they are intersected or not 교차 여부 
 */
BoundingBox.prototype.intersectsWithTriangle = function(triangle) 
{
	if (triangle === undefined)
	{ return false; }

	var normal = triangle.getPlaneNormal();
	if (normal.isNAN())
	{ return false; }
	
	// 1) check if intersects with triangle'sBbox.
	var triBbox = triangle.getBoundingBox();
	if (!this.intersectsWithBBox(triBbox))
	{ return false; }

	// 2) check if some vertex is inside of the this bbox.
	if (this.intersectWithPoint(triangle.vertex0.getPosition()) || this.intersectWithPoint(triangle.vertex1.getPosition()) || this.intersectWithPoint(triangle.vertex2.getPosition()))
	{ return true; }

	// 3) check if the bbox is near of the triangle's plane.
	var trianglesPlane = triangle.getPlane();
	var centerPoint = this.getCenterPoint();
	var projectedPoint = trianglesPlane.getProjectedPoint(centerPoint);
	
	var dist = centerPoint.distToPoint(projectedPoint);
	var radius = this.getRadius();
	if (dist > radius)
	{
		return false;
	}
	
	// 4) check if some edge of the triangle intersects with this bbox.
	for (var i=0; i<3; i++)
	{
		var trianglesSegment3d = triangle.getSegment(i, trianglesSegment3d);
		if (this.intersectsWithSegment3D(trianglesSegment3d))
		{ return true; }
	}
	
	// 5) finally, check if the bbox is inside of the triangle.
	var bestPlane = Face.getBestFacePlaneToProject(normal);
	
	var triangle2d = GeometryUtils.projectTriangle3DInToBestPlaneToProject(triangle, bestPlane, undefined);
	var point2d = GeometryUtils.projectPoint3DInToBestPlaneToProject(centerPoint, bestPlane, undefined);
	
	if (!triangle2d.isPoint2dInside(point2d))
	{ return false; }
	
	return true;
};

/**
 * Check whether this box and the given box are intersected by each others.
 * 영역박스와 주어진 영역박스와의 교차 여부를 판단
 * 
 * @param {BoundingBox} box Bounding box 영역박스
 * @returns {Boolean} the flag whether they are intersected or not 교차 여부 
 */
BoundingBox.prototype.intersectsWithBBox = function(box) 
{
	var intersection = true;

	if (this.maxX < box.minX)
	{
		intersection = false;
	}
	else if (this.minX > box.maxX)
	{
		intersection = false;
	}
	else if (this.maxY < box.minY)
	{
		intersection = false;
	}
	else if (this.minY > box.maxY)
	{
		intersection = false;
	}
	else if (this.maxZ < box.minZ)
	{
		intersection = false;
	}
	else if (this.minZ > box.maxZ)
	{
		intersection = false;
	}

	return intersection;
};

'use strict';

/**
 * This class is needed to be implemented at the future. not yet implemented fully.
 * @class BoundingSphere
 */
var BoundingSphere = function(x, y, z, radius) 
{
	if (!(this instanceof BoundingSphere)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.centerPoint = new Point3D();
	if (x !== undefined && y !== undefined && z !== undefined)
	{ this.centerPoint.set(x, y, z); }
	this.r = 0.0;
	if (radius !== undefined)
	{ this.r = radius; }
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
BoundingSphere.prototype.getCenterPoint = function() 
{
	return this.centerPoint;
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
BoundingSphere.prototype.setCenterPoint = function(x, y, z) 
{
	this.centerPoint.set(x, y, z);
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
BoundingSphere.prototype.getRadius = function() 
{
	return this.r;
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
BoundingSphere.prototype.setRadius = function(radius) 
{
	this.r = radius;
};

BoundingSphere.prototype.intersectsWithBSphere = function(bSphere) 
{
	if (bSphere === undefined)
	{ return Constant.INTERSECTION_OUTSIDE; }
	
	var dist = this.centerPoint.distToPoint(bSphere.centerPoint);
	if (dist < this.r)
	{
		return Constant.INTERSECTION_INSIDE;
	}
	else if (dist < bSphere.r)
	{
		return Constant.INTERSECTION_INSIDE;
	}
	else if (dist < (this.r + bSphere.r))
	{
		return Constant.INTERSECTION_INTERSECT;
	}
	
	return Constant.INTERSECTION_OUTSIDE;
};

BoundingSphere.prototype.copyFrom = function(bSphere) 
{
	this.centerPoint.copyFrom(bSphere.centerPoint);
	this.r = bSphere.r;
};

BoundingSphere.prototype.addBSphere = function(bSphere) 
{
	// must know if any sphere is inside of the other sphere.
	var intersectionType = this.intersectsWithBSphere(bSphere);
	
	if (intersectionType === Constant.INTERSECTION_INSIDE)
	{
		if (this.r < bSphere.r)
		{
			// copy from the bSphere.
			this.copyFrom(bSphere);
		}
	}
	else
	{
		// Calculate the extreme segment from this center to bSphere's center.
		var dir = this.centerPoint.getVectorToPoint(bSphere.centerPoint, undefined);
		dir.unitary();
		
		// find my extreme point.
		var extremePoint1 = new Point3D(this.centerPoint.x - dir.x * this.r, this.centerPoint.y - dir.y * this.r, this.centerPoint.z - dir.z * this.r);
		
		// find the extreme point of bSphere.
		var extremePoint2 = new Point3D(bSphere.centerPoint.x + dir.x * bSphere.r, bSphere.centerPoint.y + dir.y * bSphere.r, bSphere.centerPoint.z + dir.z * bSphere.r);
		
		// the new center of this is in the center of the extreme points.
		var x = (extremePoint1.x + extremePoint2.x)/2.0;
		var y = (extremePoint1.y + extremePoint2.y)/2.0;
		var z = (extremePoint1.z + extremePoint2.z)/2.0;
		this.centerPoint.set(x, y, z);
		
		// the new radius is the extremePoints half distance.
		this.r = 0.5 * extremePoint1.distToPoint(extremePoint2);
	}
};











































'use strict';

/**
 * buildings seed.
 * Represent single building feature.
 * @class BuildingSeed
 */
var BuildingSeed = function() 
{
	if (!(this instanceof BuildingSeed)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	/**
	 * @type {String}
	 */
	this.fisrtName;

	/**
	 * @type {String}
	 */
	this.name = "";

	/**
	 * @type {String}
	 */
	this.buildingId;

	/**
	 * @type {String}
	 */
	this.buildingFileName;

	/**
	 * @type {GeographicCoord}
	 */
	this.geographicCoord;

	/**
	 * heading, pitch, roll
	 * @type {Point3D}
	 */
	this.rotationsDegree;

	/**
	 * @type {BoundingBox}
	 */
	this.bBox;

	/**
	 * @type {GeographicCoord}
	 */
	this.geographicCoordOfBBox; // class : GeographicCoord.

	/**
	 * @type {SmartTile}
	 */
	this.smartTileOwner;
};

/**
 * clear this instance
 */
BuildingSeed.prototype.deleteObjects = function() 
{
	this.fisrtName = undefined;
	this.name = undefined;
	this.buildingId = undefined;
	this.buildingFileName = undefined;
	
	this.geographicCoord.deleteObjects(); 
	this.rotationsDegree.deleteObjects();
	this.bBox.deleteObjects();           
	this.geographicCoordOfBBox.deleteObjects(); 
	
	this.geographicCoord = undefined; 
	this.rotationsDegree = undefined;
	this.bBox = undefined;           
	this.geographicCoordOfBBox = undefined; 
};




























'use strict';

/**
 * buildings seed list
 * @class BuildingSeedList
 */
var BuildingSeedList = function() 
{
	if (!(this instanceof BuildingSeedList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * @type {Array.<BuildingSeed>}
	 */
	this.buildingSeedArray = [];

	/**
	 * @type {GeographicCoord}
	 */
	this.minGeographicCoord;

	/**
	 * @type {GeographicCoord}
	 */
	this.maxGeographicCoord;
	
	/**
	 * @type {ArrayBuffer}
	 */
	this.dataArrayBuffer; // binary data.
};

/**
 * Clear the list of BuildingSeed in this instance
 */
BuildingSeedList.prototype.deleteObjects = function() 
{
	this.minGeographicCoord.deleteObjects(); 
	this.maxGeographicCoord.deleteObjects(); 
	
	this.minGeographicCoord = undefined; 
	this.maxGeographicCoord = undefined;
	
	if (this.buildingSeedArray)
	{
		var buildingSeedsCount = this.buildingSeedArray.length;
		for (var i=0; i<buildingSeedsCount; i++)
		{
			this.buildingSeedArray[i].deleteObjects();
			this.buildingSeedArray[i] = undefined;
		}
		this.buildingSeedArray = undefined;
	}
	
	this.dataArrayBuffer = undefined;
};

/**
 * Create new buildingSeed feature
 * 빌딩시드를 생성 후 buildingSeedArray에 넣은 뒤 반환
 * @returns {BuildingSeed}
 */
BuildingSeedList.prototype.newBuildingSeed = function() 
{
	var buildingSeed = new BuildingSeed();
	this.buildingSeedArray.push(buildingSeed);
	return buildingSeed;
};

/**
 * Parse the binary data sent from server to save the data as building seed 
 * readerwriter를 통해 입력된 ArrayBuffer를 파싱하여 빌딩시드들을 생성
 */
BuildingSeedList.prototype.parseBuildingSeedArrayBuffer = function() 
{
	if (this.dataArrayBuffer === undefined)
	{ return false; }
	
	var arrayBuffer = this.dataArrayBuffer;
	var bytesReaded = 0;
	var buildingNameLength;
	var longitude;
	var latitude;
	var altitude;

	var buildingsCount = new Int32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0];
	bytesReaded += 4;
	for (var i =0; i<buildingsCount; i++) 
	{
		var buildingSeed = this.newBuildingSeed();

		if (buildingSeed.geographicCoord === undefined)
		{ buildingSeed.geographicCoord = new GeographicCoord(); }

		if (buildingSeed.bBox === undefined) 
		{ buildingSeed.bBox = new BoundingBox(); }

		buildingNameLength = new Int32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0];
		bytesReaded += 4;
		var decoder = new TextDecoder('utf-8');
		var buildingName = decoder.decode(new Uint8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ buildingNameLength)));
		//var buildingName = String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ buildingNameLength)));
		bytesReaded += buildingNameLength;

		// now the geographic coords, but this is provisional coords.
		longitude = new Float64Array(arrayBuffer.slice(bytesReaded, bytesReaded+8))[0]; bytesReaded += 8;
		latitude = new Float64Array(arrayBuffer.slice(bytesReaded, bytesReaded+8))[0]; bytesReaded += 8;
		altitude = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;

		buildingSeed.bBox.minX = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;
		buildingSeed.bBox.minY = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;
		buildingSeed.bBox.minZ = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;
		buildingSeed.bBox.maxX = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;
		buildingSeed.bBox.maxY = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;
		buildingSeed.bBox.maxZ = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4))[0]; bytesReaded += 4;

		// create a building and set the location.
		buildingSeed.buildingId = buildingName.substr(4, buildingNameLength-4);
		buildingSeed.buildingFileName = buildingName;
		buildingSeed.geographicCoord.setLonLatAlt(longitude, latitude, altitude);
	}
	
	return true;
};

/**
 * 빌딩시드 갯수 반환
 * @return {Number}
 */
BuildingSeedList.prototype.getBuildingSeedLength = function() 
{
	return this.buildingSeedArray.length;
};

/**
 * 빌딩시드 반환
 * @param {String|Number} idx
 * @return {BuildingSeed}
 */
BuildingSeedList.prototype.getBuildingSeed = function(idx) 
{

	if (typeof idx !== 'string' && typeof idx !== 'number') 
	{
		throw new Error('idx is required to be a string or number.');
	}
	if (!this.buildingSeedArray[idx]) 
	{
		throw new Error('range over.');
	}

	return this.buildingSeedArray[idx];
};
'use strict';

/**
 * 카메라
 * @class Camera
 */
var Camera = function() 
{
	if (!(this instanceof Camera)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.id = "camera";
	this.position = new Point3D(); 
	this.direction = new Point3D(); 
	this.up = new Point3D();
	this.right = new Point3D();
	// current frustum.
	this.frustum = new Frustum(); 
	// sum of all frustums.
	this.bigFrustum = new Frustum();
	this.dirty = true;
	this.frustumsArray = [];
	this.frustumsArray.push(this.frustum);
	
	// frustum points.
	this.nearCenterPoint = new Point3D();
	this.farCenterPoint = new Point3D();
	
	this.farLeftBottomPoint = new Point3D();
	this.farRightTopPoint = new Point3D();
	
	// directions.
	this.leftBottomDir = new Point3D();
	this.rightTopDir = new Point3D();
	
	// normals.
	this.leftNormal = new Point3D();
	this.rightNormal = new Point3D();
	this.bottomNormal = new Point3D();
	this.topNormal = new Point3D();
	
	// movement.
	this.lastMovement; // class Movement.

	/**
	 *  track target node;
	 * @type {Node}
	 */
	this.tracked;

	/**
	 *  track mode
	 * @type {number}
	 * @default CODE.trackMode.TRACKING 0
	 */
	this.trackType = CODE.trackMode.TRACKING;
	
	/**
	 *  targetOffset
	 * @type {number}
	 * @default 10.0
	 */
	this.targetOffset = 10.0;

	/**
	 *  trackCameraOffsetY
	 * @type {number}
	 * @default -1
	 */
	this.trackCameraOffsetY = -1;
	
	/**
	* trackCameraOffsetZ
	* @type {number} 
	* @default 12
	*/
	this.trackCameraOffsetZ = 12;
};

/**
 * Copy the position and the direction and up point of the other camera
 * @param {Camera} camera
 */
Camera.prototype.copyPosDirUpFrom = function(camera)
{
	this.position.copyFrom(camera.position);
	this.direction.copyFrom(camera.direction);
	this.up.copyFrom(camera.up);
};

/**
 * Translate this camera with translation vector
 * @param {Point3D} translationVec
 */
Camera.prototype.translate = function(translationVec)
{
	this.position.add(translationVec.x, translationVec.y, translationVec.z);
};

/**
 * Does the movent.
 * @param {Movement} movement
 */
Camera.prototype.doInertialMovement = function(magoManager)
{
	// Inertial movement is decided in "MagoWorld.prototype.mouseup".
	if (this.lastMovement === undefined)
	{ return false; }

	if (this.lastMovement.movementType === CODE.movementType.NO_MOVEMENT)
	{ return false; }

	var movement = this.lastMovement;
	var deltaTime = movement.deltaTime;
	var magoWorld = magoManager.magoWorld;
	
	var movType = movement.movementType;
	if (movType === CODE.movementType.TRANSLATION) // TRANSLATION.************************************
	{
		var linearVelocity = movement.currLinearVelocity;
		var dir = movement.translationDir;
		var dist = linearVelocity * deltaTime;
		
		if (Math.abs(dist) < 1E-4)
		{ movement.movementType = CODE.movementType.NO_MOVEMENT; }
		
		this.position.add(-dir.x*dist, -dir.y*dist, -dir.z*dist);
		
		magoWorld.updateModelViewMatrixByCamera(this);
		movement.currLinearVelocity *= 0.9;
		if (Math.abs(movement.currLinearVelocity) < 1E-4)
		{ movement.movementType = CODE.movementType.NO_MOVEMENT; }
	}
	else if (movType === CODE.movementType.ROTATION) // ROTATION.************************************
	{
		var angVelocity = movement.currAngularVelocity;
		movement.angRad = angVelocity * deltaTime;
		
		if (Math.abs(movement.angRad) < 1E-11)
		{ movement.movementType = CODE.movementType.NO_MOVEMENT; }
		
		var angRad = movement.angRad;
		var rotAxis = movement.rotationAxis;
		
		// check if there are rotationPoint.
		var rotPoint = movement.rotationPoint;
		if (rotPoint)
		{
			// camera is rotating respect a point of the scene.
			var rotMat = new Matrix4();
			rotMat.rotationAxisAngRad(angRad, rotAxis.x, rotAxis.y, rotAxis.z);

			var translationVec_1 = new Point3D(-rotPoint.x, -rotPoint.y, -rotPoint.z);
			var translationVec_2 = new Point3D(rotPoint.x, rotPoint.y, rotPoint.z);
			
			this.translate(translationVec_1);
			this.transformByMatrix4(rotMat);
			this.translate(translationVec_2);
		}
		else
		{
			// camera is rotating around the world origin.
			var rotMat = new Matrix4();
			rotMat.rotationAxisAngRad(-angRad, rotAxis.x, rotAxis.y, rotAxis.z);
			this.transformByMatrix4(rotMat);
		}
		
		magoWorld.updateModelViewMatrixByCamera(this);
		movement.currAngularVelocity *= 0.9;
		if (Math.abs(movement.currAngularVelocity) < 1E-11)
		{ movement.movementType = CODE.movementType.NO_MOVEMENT; }
	}
	else if (movType === CODE.movementType.ROTATION_ZX) // ROTATION_ZX.************************************
	{
		var angVelocity = movement.currAngularVelocity;
		movement.angRad = angVelocity * deltaTime;
		
		var angRad = movement.angRad;
		var rotAxis = movement.rotationAxis;
		
		// check if there are rotationPoint.
		var rotPoint = movement.rotationPoint;
		if (rotPoint)
		{
			var pivotPointNormal;
			pivotPointNormal = Globe.normalAtCartesianPointWgs84(rotPoint.x, rotPoint.y, rotPoint.z, pivotPointNormal);
			var xAxis = this.getCameraRight();
			
			var zRotAngRad = movement.zAngVelocity * deltaTime;
			var xRotAngRad = movement.xAngVelocity * deltaTime;
			
			if (Math.abs(zRotAngRad) < 1E-11 && Math.abs(xRotAngRad) < 1E-11)
			{ movement.movementType = CODE.movementType.NO_MOVEMENT; }
			
			var quatZRot = glMatrix.quat.create();
			quatZRot = glMatrix.quat.setAxisAngle(quatZRot, pivotPointNormal, zRotAngRad);
			
			var quatXRot = glMatrix.quat.create();
			quatXRot = glMatrix.quat.setAxisAngle(quatXRot, [xAxis.x, xAxis.y, xAxis.z], xRotAngRad);
			
			var quatTotalRot = glMatrix.quat.create();
			quatTotalRot = glMatrix.quat.multiply(quatTotalRot, quatZRot, quatXRot);
			
			var rotMat = new Matrix4();
			rotMat._floatArrays = glMatrix.mat4.fromQuat(rotMat._floatArrays, quatTotalRot);
		

			var translationVec_1 = new Point3D(-rotPoint.x, -rotPoint.y, -rotPoint.z);
			var translationVec_2 = new Point3D(rotPoint.x, rotPoint.y, rotPoint.z);
			
			this.translate(translationVec_1);
			this.transformByMatrix4(rotMat);
			this.translate(translationVec_2);
		}
		else
		{
			// camera is rotating around the world origin.
			var rotMat = new Matrix4();
			rotMat.rotationAxisAngRad(-angRad, rotAxis.x, rotAxis.y, rotAxis.z);
			this.transformByMatrix4(rotMat);
		}
		
		magoWorld.updateModelViewMatrixByCamera(this);
		movement.zAngVelocity *= 0.9;
		movement.xAngVelocity *= 0.9;
		if (Math.abs(movement.zAngVelocity) < 1E-11 && Math.abs(movement.xAngVelocity) < 1E-11)
		{ movement.movementType = CODE.movementType.NO_MOVEMENT; }
	}
	
	return true;
};

/**
 * Transfrom posion, direction and up of the camera
 * @param {Matrix4} mat
 */
Camera.prototype.transformByMatrix4 = function(mat)
{
	// transform position, direction and up.
	this.position = mat.transformPoint3D(this.position, this.position);
	this.direction = mat.rotatePoint3D(this.direction, this.direction);
	this.up = mat.rotatePoint3D(this.up, this.up);
};

/**
 * Get the Camera direction line
 * @param {Line} resultLine 
 * @returns {Line} resultLine Camera direction line
 */
Camera.prototype.getCameraDirectionLine = function(resultLine)
{
	if (resultLine === undefined)
	{ resultLine = new Line(); }
	
	resultLine.point.set(this.position.x, this.position.y, this.position.z);
	resultLine.direction.set(this.direction.x, this.direction.y, this.direction.z);
	
	return resultLine;
};

/**
 * determine camHeight
 * @returns {number} camera Height
 */
Camera.prototype.getCameraElevation = function()
{
	var geographicCoords;
	geographicCoords = Globe.CartesianToGeographicWgs84(this.position.x, this.position.y, this.position.z, geographicCoords);
	var latDeg = geographicCoords.latitude;
	var camModul = this.position.getModul();
	var radius = Globe.radiusAtLatitudeDeg(latDeg);
	return  camModul - radius;
};

/**
 * Get the right(up)
 * @returns {Point3D} Camera right
 */
Camera.prototype.getCameraRight = function()
{
	if (this.right === undefined)
	{ this.right = new Point3D(); }
	
	this.right = this.direction.crossProduct(this.up, this.right);
	return this.right;
};

/**
 * set dirty flag of the object
 * -dirty flag : Avoid unnecessary work by deferring it until the result is needed.
 * @param {Boolean} cameraIsDirty
 */
Camera.prototype.setDirty = function(cameraIsDirty)
{
	this.dirty = cameraIsDirty;
};

/**
 * get dirty flag of the object
 * @returns {Boolean} dirty
 */
Camera.prototype.getDirty = function()
{
	return this.dirty;
};

/**
 * Check whether this camera is moved or not
 * @param {Number} newPosX
 * @param {Number} newPosY
 * @param {Number} newPosZ
 * @param {Number} newDirX
 * @param {Number} newDirY
 * @param {Number} newDirZ
 * @param {Number} newUpX
 * @param {Number} newUpY
 * @param {Number} newUpZ
 * @returns {Boolean} 
 * 
 */
Camera.prototype.isCameraMoved = function(newPosX, newPosY, newPosZ, newDirX, newDirY, newDirZ, newUpX, newUpY, newUpZ )
{
	var positionError = 10E-4;
	var pos = this.position;
	if (Math.abs(pos.x - newPosX) > positionError || Math.abs(pos.y - newPosY) > positionError || Math.abs(pos.z - newPosZ) > positionError )
	{ return true; }
	
	var directionError = 10E-6;
	var dir = this.direction;
	if (Math.abs(dir.x - newDirX) > positionError || Math.abs(dir.y - newDirY) > positionError || Math.abs(dir.z - newDirZ) > directionError )
	{ return true; }
	
	var up = this.up;
	if (Math.abs(up.x - newUpX) > positionError || Math.abs(up.y - newUpY) > positionError || Math.abs(up.z - newUpZ) > directionError )
	{ return true; }
	
	return false;
	
};

/**
 * get the small Frustum in big frustum
 * @param {Number} idx 배열 인덱스
 * @returns {Frustum} 해당하는 배열 인덱스의 frustrum
 */
Camera.prototype.getFrustum = function(idx)
{
	if (this.frustumsArray[idx] === undefined)
	{
		this.frustumsArray[idx] = new Frustum();
		this.frustumsArray[idx].fovRad[0] = this.frustumsArray[0].fovRad[0];
		this.frustumsArray[idx].fovyRad[0]= this.frustumsArray[0].fovyRad[0];
		this.frustumsArray[idx].aspectRatio[0] = this.frustumsArray[0].aspectRatio[0];
		this.frustumsArray[idx].tangentOfHalfFovy[0] = this.frustumsArray[0].tangentOfHalfFovy[0];
	}
	
	return this.frustumsArray[idx];
};

/**
 * Get the lastest frustum of this camera
 * @returns {frustum} lastest frustum of this camera
 */
Camera.prototype.getLastFrustum = function()
{
	return this.getFrustum(this.frustumsArray.length - 1);
};

/**
 * The list of the distance between the divided frustum of visualization volume using each small frustum's near and far
 * @param {Number} numFrustums total of Frustum
 * @param {distancesArray[]} distancesArray
 */
Camera.prototype.setFrustumsDistances = function(numFrustums, distancesArray)
{
	var nearFarDistances;
	var frustum;
	for (var i=0; i<numFrustums; i++)
	{
		nearFarDistances = distancesArray[i];
		frustum = this.getFrustum(i);
		frustum.near[0] = distancesArray[i*2];
		frustum.far[0] = distancesArray[i*2+1];
		if (i === 0)
		{
			this.bigFrustum.near[0] = distancesArray[i*2];
		}
		if (i === numFrustums - 1)
		{
			this.bigFrustum.far[0] = distancesArray[i*2+1];
		}
	}
};

/**
 * 
 * Calculate the value of fovyRad and aspectRatio of each small frustum
 * @param {Float32Array[]} aspectRatio aspect ratio
 * @param {Float32Array[]} fovyRad the radian of FOV(Field Of View) y
 */
Camera.prototype.setAspectRatioAndFovyRad = function(aspectRatio, fovyRad)
{
	var frustum, frustum0;
	
	frustum0 = this.getFrustum(0);
	frustum0.aspectRatio[0] = aspectRatio;
	frustum0.fovyRad[0] = fovyRad; 
	frustum0.fovRad[0] = fovyRad*aspectRatio;
	frustum0.tangentOfHalfFovy[0] = Math.tan(fovyRad/2);
		
	var frustumsCount = this.frustumsArray.length;
	for (var i=1; i<frustumsCount; i++)
	{
		frustum = this.getFrustum(i);
		frustum.aspectRatio[0] = frustum0.aspectRatio[0];
		frustum.fovyRad[0] = frustum0.fovyRad[0]; 
		frustum.fovRad[0] = frustum0.fovRad[0];
		frustum.tangentOfHalfFovy[0] = frustum0.tangentOfHalfFovy[0];
	}
	
	this.bigFrustum.aspectRatio[0] = frustum0.aspectRatio[0];
	this.bigFrustum.fovyRad[0] = frustum0.fovyRad[0]; 
	this.bigFrustum.fovRad[0] = frustum0.fovRad[0];
	this.bigFrustum.tangentOfHalfFovy[0] = frustum0.tangentOfHalfFovy[0];
};

/**
 * Set the current frustum in bigFrustum
 * @param {Number} frustumIdx
 */
Camera.prototype.setCurrentFrustum = function(frustumIdx)
{
	this.frustum = this.getFrustum(frustumIdx);
};

/**
 * Bind the Camera uniforms
 * @param {gl} GL 
 * @param {shader} shader 
 */
Camera.prototype.bindUniforms = function(gl, shader) 
{
	// Bind frustum near & far. far.
	var frustum = this.frustum;
	gl.uniform1f(shader.frustumNear_loc, frustum.near[0]);
	gl.uniform1f(shader.frustumFar_loc, frustum.far[0]);
};

/**
 * Calculate the Frustums planes
 * 
 */
Camera.prototype.calculateFrustumsPlanes = function()
{
	var plane;
	// the 1rst frustum.
	var frustum0; 
	
	// Use the frustum0 to calculate nearWidth, nearHeight, farWidth & farHeight.
	frustum0 = this.getFrustum(0);
	var nearHeight = frustum0.tangentOfHalfFovy * frustum0.near * 2;
	var farHeight = frustum0.tangentOfHalfFovy * frustum0.far * 2;
	var nearWidth = nearHeight * frustum0.aspectRatio[0];
	var farWidht = farHeight * frustum0.aspectRatio[0];
	
	var px = this.position.x;
	var py = this.position.y;
	var pz = this.position.z;

	var dx = this.direction.x;
	var dy = this.direction.y;
	var dz = this.direction.z;
	
	// calculate right direction. "up" and "direction" must be unitaries.
	this.right = this.direction.crossProduct(this.up, this.right);
	
	// calculate the near and far points.
	this.nearCenterPoint.set(px + dx * frustum0.near, py + dy * frustum0.near, pz + dz * frustum0.near);
	this.farCenterPoint.set(px + dx * frustum0.far, py + dy * frustum0.far, pz + dz * frustum0.far);
	
	// far plane points.
	this.farLeftBottomPoint.set(this.farCenterPoint.x - this.right.x*farWidht*0.5 - this.up.x*farHeight*0.5, 
		this.farCenterPoint.y - this.right.y*farWidht*0.5 - this.up.y*farHeight*0.5, 
		this.farCenterPoint.z - this.right.z*farWidht*0.5 - this.up.z*farHeight*0.5);
								
	this.farRightTopPoint.set(this.farLeftBottomPoint.x + this.right.x*farWidht + this.up.x*farHeight, 
		this.farLeftBottomPoint.y + this.right.y*farWidht + this.up.y*farHeight, 
		this.farLeftBottomPoint.z + this.right.z*farWidht + this.up.z*farHeight);				
	
	// calculate directions.
	this.leftBottomDir.set(this.farLeftBottomPoint.x - px, this.farLeftBottomPoint.y - py, this.farLeftBottomPoint.z - pz);
	this.leftBottomDir.unitary(); // no necessary.
	
	this.rightTopDir.set(this.farRightTopPoint.x - px, this.farRightTopPoint.y - py, this.farRightTopPoint.z - pz);
	this.rightTopDir.unitary(); // no necessary.
	
	// near plane.
	plane = frustum0.planesArray[0];
	plane.setPointAndNormal(this.nearCenterPoint.x, this.nearCenterPoint.y, this.nearCenterPoint.z, dx, dy, dz);
							
	// far plane.
	plane = frustum0.planesArray[1];
	plane.setPointAndNormal(this.farCenterPoint.x, this.farCenterPoint.y, this.farCenterPoint.z, -dx, -dy, -dz);

	// The 4 lateral planes are the same for all frustum0s.
	// left plane.
	this.leftNormal = this.leftBottomDir.crossProduct(this.up, this.leftNormal);
	this.leftNormal.unitary();
	plane = frustum0.planesArray[2];
	plane.setPointAndNormal(px, py, pz, this.leftNormal.x, this.leftNormal.y, this.leftNormal.z);
							
	// bottom plane.
	this.bottomNormal = this.right.crossProduct(this.leftBottomDir, this.bottomNormal);
	this.bottomNormal.unitary();
	plane = frustum0.planesArray[3];
	plane.setPointAndNormal(px, py, pz, this.bottomNormal.x, this.bottomNormal.y, this.bottomNormal.z);
							
	// right plane.
	this.rightNormal = this.up.crossProduct(this.rightTopDir, this.rightNormal);
	this.rightNormal.unitary();
	plane = frustum0.planesArray[4];
	plane.setPointAndNormal(px, py, pz, this.rightNormal.x, this.rightNormal.y, this.rightNormal.z);
	
	// top plane.
	this.topNormal = this.rightTopDir.crossProduct(this.right, this.topNormal);
	this.topNormal.unitary();
	plane = frustum0.planesArray[5];
	plane.setPointAndNormal(px, py, pz, this.topNormal.x, this.topNormal.y, this.topNormal.z);
	
	// once finished, calculate the rest of frustums.
	var frustum;
	var frustumsCount = this.frustumsArray.length;
	for (var i=1; i<frustumsCount; i++)
	{
		frustum = this.getFrustum(i);
		
		// calculate the near and far points.
		this.nearCenterPoint.set(px + dx * frustum.near, py + dy * frustum.near, pz + dz * frustum.near);
		this.farCenterPoint.set(px + dx * frustum.far, py + dy * frustum.far, pz + dz * frustum.far);
		
		// near plane.
		plane = frustum.planesArray[0];
		plane.setPointAndNormal(this.nearCenterPoint.x, this.nearCenterPoint.y, this.nearCenterPoint.z, dx, dy, dz);
								
		// far plane.
		plane = frustum.planesArray[1];
		plane.setPointAndNormal(this.farCenterPoint.x, this.farCenterPoint.y, this.farCenterPoint.z, -dx, -dy, -dz);
		
		// the lateral planes.
		for (var j=2; j<6; j++)
		{
			frustum.planesArray[j] = frustum0.planesArray[j];
		}
	}
	
	// finally calculate the totalFrustum(BigFrustum).
	// calculate the near and far points.
	this.nearCenterPoint.set(px + dx * this.bigFrustum.near, py + dy * this.bigFrustum.near, pz + dz * this.bigFrustum.near);
	this.farCenterPoint.set(px + dx * this.bigFrustum.far, py + dy * this.bigFrustum.far, pz + dz * this.bigFrustum.far);
	
	// near plane.
	plane = this.bigFrustum.planesArray[0];
	plane.setPointAndNormal(this.nearCenterPoint.x, this.nearCenterPoint.y, this.nearCenterPoint.z, dx, dy, dz);
							
	// far plane.
	plane = this.bigFrustum.planesArray[1];
	plane.setPointAndNormal(this.farCenterPoint.x, this.farCenterPoint.y, this.farCenterPoint.z, -dx, -dy, -dz);
		
	var lastFrustum = this.getLastFrustum();
	for (var j=2; j<6; j++) // starting in i==2.
	{
		// the bigFrustum is esqual to frustum0 except in the "far".
		this.bigFrustum.planesArray[j] = frustum0.planesArray[j];
	}
};

/**
 * if track node exist, do track.
 * @param {MagoManager} magoManager
 */
Camera.prototype.doTrack = function(magoManager)
{
	if (this.tracked)
	{
		// Set camera position.*
		var trackNode = this.tracked;
		if (magoManager.isCesiumGlobe())
		{
			var camera = magoManager.scene.camera;
			var position = camera.positionWC;
			var movedCamPos;
			var geoLocDatamanager;
			if (trackNode instanceof Node) 
			{
				geoLocDatamanager = trackNode.getNodeGeoLocDataManager();
			}
			else if (trackNode instanceof MagoRenderable)
			{
				geoLocDatamanager = trackNode.geoLocDataManager;
			}
			
			//var geoLocationData = geoLocDatamanager.getTrackGeoLocationData();
			if (geoLocDatamanager === undefined)
			{ return; }
			
			var geoLocationData = geoLocDatamanager.getCurrentGeoLocationData();
			if (geoLocationData === undefined)
			{ return; }

			var prevGeoLocationData = geoLocDatamanager.getGeoLocationData(1);
			if (defined(prevGeoLocationData))
			{
				var currentPos = geoLocationData.positionLOW;
				var prevPos =  prevGeoLocationData.positionLOW;
				var camPosHIGH = new Float32Array([0.0, 0.0, 0.0]);
				var camPosLOW = new Float32Array([0.0, 0.0, 0.0]);
				
				ManagerUtils.calculateSplited3fv([position.x, position.y, position.z], camPosHIGH, camPosLOW);

				var dx = currentPos[0] - prevPos[0];
				var dy = currentPos[1] - prevPos[1];
				var dz  = currentPos[2] - prevPos[2];
				movedCamPos = new Cesium.Cartesian3();

				movedCamPos.x = camPosHIGH[0] + camPosLOW[0] + dx;
				movedCamPos.y = camPosHIGH[1] + camPosLOW[1] + dy;
				movedCamPos.z = camPosHIGH[2] + camPosLOW[2] + dz;
			}
			var targetGeographicCoords = geoLocationData.getGeographicCoords();
			if (targetGeographicCoords === undefined)
			{ return; }
			var target = Cesium.Cartesian3.fromDegrees(targetGeographicCoords.longitude, targetGeographicCoords.latitude, targetGeographicCoords.altitude);

			if (this.trackType === CODE.trackMode.TRACKING)
			{
				var range = Cesium.Cartesian3.distance(movedCamPos ? movedCamPos : position, target);
				var hpr = new Cesium.HeadingPitchRange(camera.heading, camera.pitch, range);

				camera.lookAt(target, hpr);
			}
			//CODE.trackMode.DRIVER
			else
			{
				var rotMat = geoLocationData.rotMatrix;
				var rotPointTarget  = rotMat.rotatePoint3D(new Point3D(0, this.targetOffset, 0));
				var rotPointCamPos = rotMat.rotatePoint3D(new Point3D(0, this.trackCameraOffsetY, this.trackCameraOffsetZ));

				rotPointCamPos.x = target.x + rotPointCamPos.x;
				rotPointCamPos.y = target.y + rotPointCamPos.y;
				rotPointCamPos.z = target.z + rotPointCamPos.z;

				rotPointTarget.x = target.x + rotPointTarget.x;
				rotPointTarget.y = target.y + rotPointTarget.y;
				rotPointTarget.z = target.z + rotPointTarget.z;

				var geoLocMat = geoLocationData.geoLocMatrix._floatArrays;
				var earthNormal = new Point3D(geoLocMat[8], geoLocMat[9], geoLocMat[10]);
				Camera.setByPositionAndTarget(camera, rotPointTarget, rotPointCamPos, earthNormal);
			}
		}
		else
		{
			//this.lookAt() -> we must develope lookAt function in magoworld.
		}
	}
	else if (this.gotoAnimation !== undefined)
	{
		// Do goto-animation.
		
	}
};

/**
 * stop track 
 * @param {MagoManager} magoManager
 */
Camera.prototype.stopTrack = function(magoManager)
{
	this.tracked = undefined;
	if (magoManager.isCesiumGlobe())
	{
		magoManager.scene.camera.lookAtTransform(Cesium.Matrix4.IDENTITY); //set camera transform
	}
	else
	{
		//this.lookAtStop() -> we must develope lookAtStop function in magoworld.
	}
};

/**
 * set track node.
 * Node is a single feature at F4D specification
 * Implement this function for tracking moving objects such as automatically moving vehicle
 * @param {Object} node
 * @param {trackOption} option Optional. 비어있을 시 TRACKING 모드로 설정
 */
Camera.prototype.setTrack = function(node, option)
{
	this.initTrackOption();

	this.tracked = node;
	if (option)
	{
		this.trackType = defaultValue(option.type, this.trackType);
		this.targetOffset = defaultValue(option.targetOffset, this.targetOffset);

		if (option.trackCameraOffset)
		{
			this.trackCameraOffsetY = defaultValueCheckLength(option.trackCameraOffset.y, this.trackCameraOffsetY);
			this.trackCameraOffsetZ = defaultValueCheckLength(option.trackCameraOffset.z, this.trackCameraOffsetZ);
		}
	}
};

/**
 * 카메라 트래킹 옵션 기본값으로 초기화
 */
Camera.prototype.initTrackOption = function()
{
	this.trackType = CODE.trackMode.TRACKING;
	this.targetOffset = 10.0;
	this.trackCameraOffsetY = -1;
	this.trackCameraOffsetZ = 12;
};

/**
 * 두 점을 이용하여 디렉션 정보 계산
 */
Camera.prototype.getPosition = function()
{
	return this.position;
};

/**
 * 두 점을 이용하여 디렉션 정보 계산
 */
Camera.prototype.getDirection = function()
{
	return this.direction;
};

/**
 * 두 점을 이용하여 디렉션 정보 계산
 */
Camera.prototype.getUp = function()
{
	return this.up;
};

/**
 * set position and orientation ( direction, up) of the camera
 * only cesium
 * 
 * @static
 * @param {Cesium.Camera} camera cesium camera object.
 * @param {Point3D} camTarget
 * @param {Point3D} camPos
 * @param {Point3D} aproxCamUp
 */
Camera.setByPositionAndTarget = function (camera, camTarget, camPos, aproxCamUp) 
{
	var direction = new Point3D();
	direction.set(camTarget.x - camPos.x, camTarget.y - camPos.y, camTarget.z - camPos.z);
	direction.unitary();

	var right = direction.crossProduct(aproxCamUp);
	var up = right.crossProduct(direction);
	up.unitary();
	camera.setView({
		destination : camPos,
		orientation : {
			direction : new Cesium.Cartesian3(direction.x, direction.y, direction.z),
			up        : new Cesium.Cartesian3(up.x, up.y, up.z)
		}
	});
};

/**
 * 어떤 일을 하고 있습니까?
 */
Camera.prototype.calculateUp = function(aproxCamUp) 
{
	this.right = this.direction.crossProduct(aproxCamUp, this.right);
	this.right.unitary();
	this.up = this.right.crossProduct(this.direction, this.up);
	this.up.unitary();
};

/**
 * 어떤 일을 하고 있습니까?
 */
Camera.prototype.finishedAnimation = function(magoManager) 
{
	var finished = false;
	var animData = this.animationData;
	
	if (animData === undefined)
	{ return true; }

	var currTime = magoManager.getCurrentTime();
	
	var nextLongitude;
	var nextLatitude;
	var nextAltitude;
	var nextHeading;
	var nextPitch;
	var nextRoll;

	// Check animationType.***
	var animType = animData.animationType;
	if (animType === CODE.animationType.PATH)
	{
		// Test.***
		var nextPosLine = AnimationManager.getNextPosition(animData, currTime, magoManager);
		
		if (nextPosLine === undefined)
		{ 
			animData.finished = true;
			return true; 
		}
	
		var path = animData.path;
		var pathGeoLocDataManager = path.getGeoLocationDataManager();
		var pathGeoLocData = pathGeoLocDataManager.getCurrentGeoLocationData();
		
		// Now, calculate the geographic coords of the position.***
		var posLocal = nextPosLine.point;
		var dir = nextPosLine.direction;

		// calculate worldPos.***
		var tMat = pathGeoLocData.tMatrix;
		var posWC = tMat.transformPoint3D(posLocal, undefined);
		
		this.position.copyFrom(posWC); 
		//this.direction.copyFrom(dir);
		
		// now, must calculate camera-Up by earth normal.***
		var normalEarth = Globe.normalAtCartesianPointWgs84(posWC.x, posWC.y, posWC.z, undefined);
		this.calculateUp(new Point3D(normalEarth[0], normalEarth[1], normalEarth[2]));
		//this.direction; 
		//this.up;
		/*
		var geographicCoords = Globe.CartesianToGeographicWgs84(posWC.x, posWC.y, posWC.z, undefined);
		nextLatitude = geographicCoords.latitude;
		nextLongitude = geographicCoords.longitude;
		nextAltitude = geographicCoords.altitude;
		
		// now calculate heading, pitch & roll.***
		var yAxis = new Point2D(0, 1);
		var dir2d = new Point2D(dir.x, dir.y);
		dir2d.unitary();
		var headingAngle = yAxis.angleDegToVector(dir2d);
		if (dir2d.x > 0.0)
		{
			headingAngle *= -1;
		}
		*/
		var magoWorld = magoManager.magoWorld;
		magoWorld.updateModelViewMatrixByCamera(this);
		
		// finally update "lastTime".
		animData.lastTime = currTime;
		return finished;
	}

	return finished;
};

'use strict';

/**
 * 카메라
 * @class CCTV
 */
var CCTV = function(name) 
{
	if (!(this instanceof CCTV)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.name = "noName";
	if (name !== undefined)
	{ this.name = name; }

	this.geoLocationData = new GeoLocationData();
	this.minHeading = 0.0;
	this.maxHeading = 90.0;
	
	this.heading = 0.0;
	this.pitch = 0.0;
	this.roll = 0.0;
	this.targetHeading;
	this.targetPitch;
	this.targetRoll;
	
	this.rotMat = new Matrix4();
	this.camera = new Camera();
	this.vboKeyContainer; // class: VBOVertexIdxCacheKeyContainer.
	this.vboKeyContainerEdges; // class: VBOVertexIdxCacheKeyContainer.
	this.color = new Color();
	this.color.setRGBA(0.0, 0.5, 0.9, 0.3);
	this.greenFactorSpeed = 1.0;
	this.blueFactorSpeed = 2.0;
	this.alphaFactorSpeed = 2.0;
	
	this.headingAngularSpeed = 25.0; // deg per second.
	this.pitchAngularSpeed;
	this.rollAngularSpeed; 
	this.lastTime;
	
	this.greenFactor = 1.0;
	this.blueFactor = 1.0;
	this.alphaFactor = 1.0;
};

/**
 * Update time as current time
 * @param currTime current time
 */
CCTV.prototype.updateTime = function(currTime)
{
	this.lastTime = currTime;
};

/**
 * Calculate the angularSpped to rotate the CCTV with the three direction : heading, pitch, roll
 * @param headingDeg
 * @param pitchDeg
 * @param rollDeg
 * @param transitionTimeSec
 * 
 */
CCTV.prototype.setOrientation = function(headingDeg, pitchDeg, rollDeg, transitionTimeSec)
{
	this.targetHeading = headingDeg;
	this.targetPitch = pitchDeg;
	this.targetRoll = rollDeg;
	
	// Now, calculate angularSpeeds.
	// Heading.
	if (this.targetHeading !== undefined)
	{
		var increHeading = this.targetHeading - this.heading;
		this.headingAngularSpeed = increHeading/transitionTimeSec;
		
		if (this.headingAngularSpeed === 0)
		{
			this.targetHeading = undefined;
			this.headingAngularSpeed = undefined;
		}
	}
	
	// Pitch.
	if (this.targetPitch !== undefined)
	{
		var increPitch = this.targetPitch - this.pitch;
		this.pitchAngularSpeed = increPitch/transitionTimeSec;
		
		if (this.pitchAngularSpeed === 0)
		{
			this.targetPitch = undefined;
			this.pitchAngularSpeed = undefined;
		}
	}
	
	// Roll.
	if (this.targetRoll !== undefined)
	{
		var increRoll = this.targetRoll - this.roll;
		this.rollAngularSpeed = increRoll/transitionTimeSec;
		
		if (this.rollAngularSpeed === 0)
		{
			this.targetRoll = undefined;
			this.rollAngularSpeed = undefined;
		}
	}
};

/**
 * Rotate the CCTV with current time and pre-calculated angular speed
 * @param currTime current time 
 */
CCTV.prototype.updateOrientation = function(currTime)
{
	// Check if camera is rotating.
	if (this.targetHeading === undefined && this.targetPitch === undefined && this.targetRoll === undefined)
	{ return; }
	
	if (this.lastTime === undefined)
	{ this.lastTime = currTime; }

	var timeAmount = (currTime - this.lastTime)/1000;
	
	// Heading.
	if (this.headingAngularSpeed !== undefined)
	{
		this.heading += timeAmount * this.headingAngularSpeed;
		// Check if heading arrived to targetHeading.
		if (this.headingAngularSpeed > 0)
		{
			// Camera is rotating ccw.
			if (this.heading >= this.targetHeading)
			{
				this.heading = this.targetHeading;
				this.targetHeading = undefined;
			}
		}
		else 
		{
			// Camera is rotating cw.
			if (this.heading <= this.targetHeading)
			{
				this.heading = this.targetHeading;
				this.targetHeading = undefined;
			}
		}
		
		if (this.headingAngularSpeed === 0)
		{
			this.targetHeading = undefined;
			this.headingAngularSpeed = undefined;
		}
	}
	
	// Pitch.
	if (this.pitchAngularSpeed !== undefined)
	{
		this.pitch += timeAmount * this.pitchAngularSpeed;
		
		// Check if pitch arrived to targetPitch.
		if (this.pitchAngularSpeed > 0)
		{
			// Camera is rotating ccw.
			if (this.pitch >= this.targetPitch)
			{
				this.pitch = this.targetPitch;
				this.targetPitch = undefined;
			}
		}
		else
		{
			// Camera is rotating cw.
			if (this.pitch <= this.targetPitch)
			{
				this.pitch = this.targetPitch;
				this.targetPitch = undefined;
			}
		}
		
		if (this.pitchAngularSpeed === 0)
		{
			this.targetPitch = undefined;
			this.pitchAngularSpeed = 0;
		}
	}
	
	// Roll.
	if (this.rollAngularSpeed !== undefined)
	{
		this.roll += timeAmount * this.rollAngularSpeed;
		// Check if pitch arrived to targetPitch.
		if (this.rollAngularSpeed > 0)
		{
			// Camera is rotating ccw.
			if (this.roll >= this.targetRoll)
			{
				this.roll = this.targetRoll;
				this.targetRoll = undefined;
			}
		}
		else 
		{
			// Camera is rotating cw.
			if (this.roll <= this.targetRoll)
			{
				this.roll = this.targetRoll;
				this.targetRoll = undefined;
			}
		}
		
		if (this.rollAngularSpeed === 0)
		{
			this.targetRoll = undefined;
			this.rollAngularSpeed = undefined;
		}
	}
	
	this.calculateRotationMatrix();
};

/**
 * only rotating with the heading direction
 * @param currTime current time
 */
CCTV.prototype.updateHeading = function(currTime)
{
	// Old function.
	if (this.lastTime === undefined)
	{ this.lastTime = currTime; }

	var timeAmount = (currTime - this.lastTime)/1000;
	this.heading += timeAmount * this.headingAngularSpeed;
	
	if (this.heading > this.maxHeading)
	{
		this.heading = this.maxHeading;
		this.headingAngularSpeed *= -1.0;
	}
	else if (this.heading < this.minHeading)
	{
		this.heading = this.minHeading;
		this.headingAngularSpeed *= -1.0;
	}
	
	this.calculateRotationMatrix();
};

/**
 * Update the color of the screen shown at the CCTV
 * @param currTime
 */
CCTV.prototype.updateColor = function(currTime)
{
	if (this.lastTime === undefined)
	{ this.lastTime = currTime; }

	var timeAmount = (currTime - this.lastTime)/1000;
	
	// change color.
	if (this.greenFactor === undefined)
	{ this.greenFactor = 1.0; }
	
	if (this.blueFactor === undefined)
	{ this.blueFactor = 1.0; }
	
	if (this.alphaFactor === undefined)
	{ this.alphaFactor = 1.0; }
	
	this.greenFactor += this.greenFactorSpeed * timeAmount;
	this.blueFactor += this.blueFactorSpeed * timeAmount;
	
	if (this.greenFactor > 0.5 )
	{
		this.greenFactor = 0.5;
		this.greenFactorSpeed *= -1;
	}
	
	if (this.greenFactor < 0.0 )
	{
		this.greenFactor = 0.0;
		this.greenFactorSpeed *= -1;
	}
	
	if (this.blueFactor > 0.9 )
	{
		this.blueFactor = 0.9;
		this.blueFactorSpeed *= -1;
	}
	
	if (this.blueFactor < 0.0 )
	{
		this.blueFactor = 0.0;
		this.blueFactorSpeed *= -1;
	}
	
	
	if (this.alphaFactor > 0.6 )
	{
		this.alphaFactor = 0.6;
		this.alphaFactorSpeed *= -1;
	}
	
	if (this.alphaFactor < 0.0 )
	{
		this.alphaFactor = 0.0;
		this.alphaFactorSpeed *= -1;
	}
	
	this.color.setRGBA(0.0, this.greenFactor, this.blueFactor, this.alphaFactor);
};

/**
 * Calculate the matrix when update the orientation of the matrix
 */
CCTV.prototype.calculateRotationMatrix = function()
{
	var rotMatAux;
	rotMatAux = Matrix4.getRotationDegZXYMatrix(this.heading, this.pitch, this.roll, rotMatAux);
	this.rotMat = rotMatAux.getMultipliedByMatrix(this.geoLocationData.rotMatrix, this.rotMat);
};

/**
 * get the Vbo of the mesh which consist of the frustum of this CCTV
 * @param resultVboContainer
 * @param resultVboContainerEdges
 * @param vboMemManager
 */
CCTV.prototype.getVbo = function(resultVboContainer, resultVboContainerEdges, vboMemManager)
{
	if (resultVboContainer === undefined)
	{ resultVboContainer = new VBOVertexIdxCacheKeysContainer(); }

	if (this.vboKeyContainerEdges === undefined)
	{ this.vboKeyContainerEdges = new VBOVertexIdxCacheKeysContainer(); }

	var frustumMesh;
	
	// make vbo.
	frustumMesh = this.makeFrustumGeometry_2(frustumMesh);
	var bIncludeBottomCap = true;
	var bIncludeTopCap = true;
	
	// now rotate in X axis.
	var rotMatAux = new Matrix4();
	var frustum = this.camera.bigFrustum;
	var halfFovyRad = frustum.fovyRad / 2.0;
	rotMatAux.rotationAxisAngDeg((-halfFovyRad) * 180.0 / Math.PI, 1.0, 0.0, 0.0);
	
	var surfIndepMesh = frustumMesh.getSurfaceIndependentMesh(undefined, bIncludeBottomCap, bIncludeTopCap);
	surfIndepMesh.transformByMatrix4(rotMatAux);
	surfIndepMesh.setColor(0.0, 0.5, 0.9, 0.3);
	
	surfIndepMesh.getVbo(resultVboContainer, vboMemManager);
	surfIndepMesh.getVboEdges(this.vboKeyContainerEdges, vboMemManager);
	
	return resultVboContainer;
};

/**
 * 
 */
CCTV.prototype.render = function(gl, magoManager, shader)
{
	if (this.vboKeyContainer === undefined)
	{ return; }
	
	var cacheKeys_count = this.vboKeyContainer.vboCacheKeysArray.length;
	
	//gl.uniform1i(shader.bApplySpecularLighting_loc, false);
	
	// Must applicate the transformMatrix.
	gl.uniformMatrix4fv(shader.buildingRotMatrix_loc, false, this.geoLocationData.rotMatrix._floatArrays);
	gl.uniform3fv(shader.buildingPosHIGH_loc, this.geoLocationData.positionHIGH);
	gl.uniform3fv(shader.buildingPosLOW_loc, this.geoLocationData.positionLOW);
	
	gl.uniform1i(shader.hasTexture_loc, false); //.
	
	gl.enable(gl.POLYGON_OFFSET_FILL);
	gl.polygonOffset(1, 3);
	
	var renderWireframe;
	
	var refMatrixType = 2;
	gl.uniform1i(shader.refMatrixType_loc, refMatrixType);
	gl.uniformMatrix4fv(shader.refMatrix_loc, false, this.rotMat._floatArrays);
	
	var renderer = magoManager.renderer;
	
	// render wireframe.
	renderWireframe = true;
	renderer.renderNormals = false;
	gl.uniform4fv(shader.oneColor4_loc, [0.0, 0.0, 0.0, 1.0]);
	renderer.renderVboContainer(gl, this.vboKeyContainerEdges, magoManager, shader, renderWireframe);
	
	// now render fill.
	gl.enable(gl.BLEND);
	renderWireframe = false;
	renderer.renderNormals = true;
	//gl.uniform4fv(shader.oneColor4_loc, [this.blueFactor, this.greenFactor, 0.0, this.alphaFactor]);
	gl.uniform4fv(shader.oneColor4_loc, [this.blueFactor, 0.0, 0.0, this.alphaFactor]);
	renderer.renderVboContainer(gl, this.vboKeyContainer, magoManager, shader, renderWireframe);
	gl.disable(gl.BLEND);
	
	gl.disable(gl.POLYGON_OFFSET_FILL);
};

/**
 * Make Frustum Geometry for this CCTV
 * @param resultMesh the frustum
 */
CCTV.prototype.makeFrustumGeometry_2 = function(resultMesh)
{
	// 1rst, make the profile: icecream shape.
	if (resultMesh === undefined)
	{ resultMesh = new ParametricMesh(); }

	resultMesh.profile = new Profile2D(); 
	var profileAux = resultMesh.profile; 
	
	// camera geometry values.
	var frustum = this.camera.bigFrustum;
	var far = frustum.far;
	var halfFovyRad = frustum.fovyRad / 2.0;
	var halfFovxRad = frustum.fovRad / 2.0;
	
	var left = -far * Math.tan(halfFovxRad);
	var right = -left;
	var top = far * Math.tan(halfFovyRad);
	var bottom = -top;
	
	// Outer ring.**
	var outerRing = profileAux.newOuterRing();
	var polyLine, point3d, arc;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(-far * Math.sin(halfFovxRad), far * Math.cos(halfFovxRad)); // 0
	point3d = polyLine.newPoint2d(0.0, 0.0); // 1
	point3d = polyLine.newPoint2d(far * Math.sin(halfFovxRad), far * Math.cos(halfFovxRad)); // 2
	
	var startAngDeg = 90.0 - halfFovxRad * 180.0 / Math.PI;
	var endAngDeg = 90.0 + halfFovxRad * 180.0 / Math.PI;
	arc = outerRing.newElement("ARC");
	this.sweepSense = 1;
	arc.setCenterPosition(0.0, 0.0);
	arc.setRadius(far);
	////arc.setStartPoint(far * Math.sin(halfFovxRad), far * Math.cos(halfFovxRad));
	////arc.setEndPoint(-far * Math.sin(halfFovxRad), far * Math.cos(halfFovxRad));
	arc.setStartAngleDegree(startAngDeg);
	arc.setSweepAngleDegree(endAngDeg - startAngDeg);
	arc.numPointsFor360Deg = 36;
	
	// now revolve.
	var revolveAngDeg, revolveSegmentsCount, revolveSegment2d;
	revolveAngDeg = (halfFovyRad * 2) * 180.0 / Math.PI;
	revolveSegment2d = new Segment2D();
	var strPoint2d = new Point2D(-1, 0);
	var endPoint2d = new Point2D(1, 0);
	revolveSegment2d.setPoints(strPoint2d, endPoint2d);
	revolveSegmentsCount = 6;
	resultMesh.revolve(profileAux, revolveAngDeg, revolveSegmentsCount, revolveSegment2d);
	
	return resultMesh;
};

/**
 * Make Frustum Geometry for this CCTV
 * @param resultMesh the frustum
 */
CCTV.prototype.makeFrustumGeometry = function(resultMesh)
{
	// make a frustum mesh.
	if (resultMesh === undefined)
	{ resultMesh = new Mesh(); }

	if (resultMesh.hedgesList === undefined)
	{ resultMesh.hedgesList = new HalfEdgesList(); }
	
	// 1rst, calculate the positions of 5 vertices.
	var focusPosition = new Point3D(0.0, 0.0, 0.0);
	
	var frustum = this.camera.bigFrustum;
	var far = frustum.far;
	var halfFovyRad = frustum.fovyRad / 2.0;
	var halfFovxRad = frustum.fovRad / 2.0;
	
	var left = -far * Math.tan(halfFovxRad);
	var right = -left;
	var top = far * Math.tan(halfFovyRad);
	var bottom = -top;
	
	var farLeftDown = new Point3D(left, bottom, -far);
	var farRightDown = new Point3D(right, bottom, -far);
	var farRightTop = new Point3D(right, top, -far);
	var farLeftTop = new Point3D(left, top, -far);
	
	// now make vertices. 5 vertices in total.
	var focusVertex = new Vertex(focusPosition);
	var farLeftDownVertex = new Vertex(farLeftDown);
	var farRightDownVertex = new Vertex(farRightDown);
	var farRightTopVertex = new Vertex(farRightTop);
	var farLeftTopVertex = new Vertex(farLeftTop);
	
	// provisionally make wireframe here.
	if (this.vboKeyContainerEdges === undefined)
	{ this.vboKeyContainerEdges = new VBOVertexIdxCacheKeysContainer(); }

	var face;
	
	// there are no near polygon.
	// 1- far polygon.
	var farSurface = resultMesh.newSurface();
	face = farSurface.newFace();
	// ad vertices in ccw order.
	face.addVertex(farLeftDownVertex);
	face.addVertex(farLeftTopVertex);
	face.addVertex(farRightTopVertex);
	face.addVertex(farRightDownVertex);
	
	// make wireframe vbo.
	var vertex_1, vertex_2, pos_1, pos_2;
	var next_idx;
	var curr_edge_idx = 0;
	var posDataArray = [];
	var indicesDataArray = [];
	
	var vertexCount = face.vertexArray.length;
	for (var i=0; i<vertexCount; i++)
	{
		vertex_1 = face.vertexArray[i];
		next_idx = VertexList.getNextIdx(i, face.vertexArray);
		vertex_2 = face.vertexArray[next_idx];
		
		pos_1 = vertex_1.point3d;
		pos_2 = vertex_2.point3d;
		
		posDataArray.push(pos_1.x);
		posDataArray.push(pos_1.y);
		posDataArray.push(pos_1.z);
		
		posDataArray.push(pos_2.x);
		posDataArray.push(pos_2.y);
		posDataArray.push(pos_2.z);
		
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
	}
	// end make wireframe vbo.--------------------------------------------
	
	// 2- top polygon.
	var topSurface = resultMesh.newSurface();
	face = topSurface.newFace();
	// ad vertices in ccw order.
	face.addVertex(focusVertex);
	face.addVertex(farRightTopVertex);
	face.addVertex(farLeftTopVertex);
	
	// make wireframe vbo.
	vertexCount = face.vertexArray.length;
	for (var i=0; i<vertexCount; i++)
	{
		vertex_1 = face.vertexArray[i];
		next_idx = VertexList.getNextIdx(i, face.vertexArray);
		vertex_2 = face.vertexArray[next_idx];
		
		pos_1 = vertex_1.point3d;
		pos_2 = vertex_2.point3d;
		
		posDataArray.push(pos_1.x);
		posDataArray.push(pos_1.y);
		posDataArray.push(pos_1.z);
		
		posDataArray.push(pos_2.x);
		posDataArray.push(pos_2.y);
		posDataArray.push(pos_2.z);
		
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
	}
	// end make wireframe vbo.--------------------------------------------
	
	// 3- left polygon.
	var leftSurface = resultMesh.newSurface();
	face = leftSurface.newFace();
	// ad vertices in ccw order.
	face.addVertex(focusVertex);
	face.addVertex(farLeftTopVertex);
	face.addVertex(farLeftDownVertex);
	
	// make wireframe vbo.
	vertexCount = face.vertexArray.length;
	for (var i=0; i<vertexCount; i++)
	{
		vertex_1 = face.vertexArray[i];
		next_idx = VertexList.getNextIdx(i, face.vertexArray);
		vertex_2 = face.vertexArray[next_idx];
		
		pos_1 = vertex_1.point3d;
		pos_2 = vertex_2.point3d;
		
		posDataArray.push(pos_1.x);
		posDataArray.push(pos_1.y);
		posDataArray.push(pos_1.z);
		
		posDataArray.push(pos_2.x);
		posDataArray.push(pos_2.y);
		posDataArray.push(pos_2.z);
		
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
	}
	// end make wireframe vbo.--------------------------------------------
	
	// 4- bottom polygon.
	var bottomSurface = resultMesh.newSurface();
	face = bottomSurface.newFace();
	// ad vertices in ccw order.
	face.addVertex(focusVertex);
	face.addVertex(farLeftDownVertex);
	face.addVertex(farRightDownVertex);
	
	// make wireframe vbo.
	vertexCount = face.vertexArray.length;
	for (var i=0; i<vertexCount; i++)
	{
		vertex_1 = face.vertexArray[i];
		next_idx = VertexList.getNextIdx(i, face.vertexArray);
		vertex_2 = face.vertexArray[next_idx];
		
		pos_1 = vertex_1.point3d;
		pos_2 = vertex_2.point3d;
		
		posDataArray.push(pos_1.x);
		posDataArray.push(pos_1.y);
		posDataArray.push(pos_1.z);
		
		posDataArray.push(pos_2.x);
		posDataArray.push(pos_2.y);
		posDataArray.push(pos_2.z);
		
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
	}
	// end make wireframe vbo.--------------------------------------------
	
	// 5- right polygon.
	var rightSurface = resultMesh.newSurface();
	face = rightSurface.newFace();
	// ad vertices in ccw order.
	face.addVertex(focusVertex);
	face.addVertex(farRightDownVertex);
	face.addVertex(farRightTopVertex);
	
	// make wireframe vbo.
	vertexCount = face.vertexArray.length;
	for (var i=0; i<vertexCount; i++)
	{
		vertex_1 = face.vertexArray[i];
		next_idx = VertexList.getNextIdx(i, face.vertexArray);
		vertex_2 = face.vertexArray[next_idx];
		
		pos_1 = vertex_1.point3d;
		pos_2 = vertex_2.point3d;
		
		posDataArray.push(pos_1.x);
		posDataArray.push(pos_1.y);
		posDataArray.push(pos_1.z);
		
		posDataArray.push(pos_2.x);
		posDataArray.push(pos_2.y);
		posDataArray.push(pos_2.z);
		
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
		indicesDataArray.push(curr_edge_idx); curr_edge_idx++;
	}
	// end make wireframe vbo.--------------------------------------------
	var vboEdges = this.vboKeyContainerEdges.newVBOVertexIdxCacheKey();
	vboEdges.posVboDataArray = Float32Array.from(posDataArray);
	vboEdges.idxVboDataArray = Int16Array.from(indicesDataArray);
	vboEdges.indicesCount = vboEdges.idxVboDataArray.length;

	resultMesh.calculateVerticesNormals();
	
	return resultMesh;
};

// CCTVList.
/**
 * 카메라
 * @class CCTVList
 */
var CCTVList = function() 
{
	if (!(this instanceof CCTVList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.camerasList = [];
	this.bDrawCCTVNames = true;
	
};

/**
 * Create CCTV with name
 * @param {String} name
 */
CCTVList.prototype.new_CCTV = function(name)
{
	var cctv = new CCTV();
	if (name !== undefined)
	{ cctv.name = name; }
	
	this.camerasList.push(cctv);
	return cctv;
};

/**
 * Get single CCTV instance as the index of the instance in this CCTV list
 * @param {Number} idx
 * @returns {CCTV}
 */
CCTVList.prototype.getCCTV = function(idx)
{
	return this.camerasList[idx];
};

/**
 * Get single CCTV instance as the name of the instance
 * @param {String} cameraName the name of that CCTV
 */
CCTVList.prototype.getCCTVByName = function(cameraName)
{
	var find = false;
	var camerasCount = this.getCCTVCount();
	var i=0;
	var cam, resultCam;
	while (!find && i<camerasCount)
	{
		cam = this.getCCTV(i);
		if (cam.name === cameraName)
		{
			resultCam = cam;
			find = true;
		}
		i++;
	}
	
	return resultCam;
};

/**
 * Get the number of the CCTV in this list 
 * @returns {Number} count
 */
CCTVList.prototype.getCCTVCount = function()
{
	return this.camerasList.length;
};

/**
 * Update the properties of the list of CCTV with current time and render the view that each CCTV show
 * @param {MagoManager} magoManager
 * @param shader
 */
CCTVList.prototype.render = function(magoManager, shader)
{
	var cctvsCount = this.getCCTVCount();
	
	if (cctvsCount === 0)
	{ return; }
	
	var gl = magoManager.sceneState.gl;
	shader.resetLastBuffersBinded();
	var shaderProgram = shader.program;
		
	gl.useProgram(shaderProgram);
	gl.uniform1i(shader.bApplySpecularLighting_loc, false);
	gl.disableVertexAttribArray(shader.texCoord2_loc);
	gl.enableVertexAttribArray(shader.position3_loc);
	gl.enableVertexAttribArray(shader.normal3_loc);
		
	shader.bindUniformGenerals();
	gl.uniform1i(shader.textureFlipYAxis_loc, magoManager.sceneState.textureFlipYAxis);
	
	gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.

	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, magoManager.depthFboNeo.colorBuffer);  // original.
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, magoManager.noiseTexture);
	gl.activeTexture(gl.TEXTURE2);
	gl.bindTexture(gl.TEXTURE_2D, magoManager.textureAux_1x1);
	shader.last_tex_id = magoManager.textureAux_1x1;
		
	magoManager.renderer.renderTexture = false;
	var currTime = new Date().getTime();
		
	for (var i=0; i<cctvsCount; i++)
	{
		var cctv = this.getCCTV(i);
		cctv.updateColor(currTime);
		cctv.updateOrientation(currTime);
		cctv.render(gl, magoManager, shader);
		cctv.updateTime(currTime);
	}
	
	if (this.bDrawCCTVNames !== undefined && this.bDrawCCTVNames === true)
	{
		magoManager.drawCCTVNames(this.camerasList);
	}
	
	shader.disableVertexAttribArrayAll();
};

































'use strict';

// CCTVList.
/**
 * 카메라
 * @class CCTVList
 */
var CCTVList = function() 
{
	if (!(this instanceof CCTVList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.camerasList = [];
	this.bDrawCCTVNames = true;
	
};

/**
 * Create CCTV with name
 * @param {String} name
 */
CCTVList.prototype.new_CCTV = function(name)
{
	var cctv = new CCTV();
	if (name !== undefined)
	{ cctv.name = name; }
	
	this.camerasList.push(cctv);
	return cctv;
};

/**
 * Get single CCTV instance as the index of the instance in this CCTV list
 * @param {Number} idx
 * @returns {CCTV}
 */
CCTVList.prototype.getCCTV = function(idx)
{
	return this.camerasList[idx];
};

/**
 * Get single CCTV instance as the name of the instance
 * @param {String} cameraName the name of that CCTV
 */
CCTVList.prototype.getCCTVByName = function(cameraName)
{
	var find = false;
	var camerasCount = this.getCCTVCount();
	var i=0;
	var cam, resultCam;
	while (!find && i<camerasCount)
	{
		cam = this.getCCTV(i);
		if (cam.name === cameraName)
		{
			resultCam = cam;
			find = true;
		}
		i++;
	}
	
	return resultCam;
};

/**
 * Get the number of the CCTV in this list 
 * @returns {Number} count
 */
CCTVList.prototype.getCCTVCount = function()
{
	return this.camerasList.length;
};

/**
 * Update the properties of the list of CCTV with current time and render the view that each CCTV show
 * @param {MagoManager} magoManager
 * @param shader
 */
CCTVList.prototype.render = function(magoManager, shader)
{
	var cctvsCount = this.getCCTVCount();
	
	if (cctvsCount === 0)
	{ return; }
	
	var gl = magoManager.sceneState.gl;
	shader.resetLastBuffersBinded();
	var shaderProgram = shader.program;
		
	gl.useProgram(shaderProgram);
	gl.uniform1i(shader.bApplySpecularLighting_loc, false);
	gl.disableVertexAttribArray(shader.texCoord2_loc);
	gl.enableVertexAttribArray(shader.position3_loc);
	gl.enableVertexAttribArray(shader.normal3_loc);
		
	shader.bindUniformGenerals();
	gl.uniform1i(shader.textureFlipYAxis_loc, magoManager.sceneState.textureFlipYAxis);
	
	gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.

	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, magoManager.depthFboNeo.colorBuffer);  // original.
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, magoManager.noiseTexture);
	gl.activeTexture(gl.TEXTURE2);
	gl.bindTexture(gl.TEXTURE_2D, magoManager.textureAux_1x1);
	shader.last_tex_id = magoManager.textureAux_1x1;
		
	magoManager.renderer.renderTexture = false;
	var currTime = new Date().getTime();
		
	for (var i=0; i<cctvsCount; i++)
	{
		var cctv = this.getCCTV(i);
		cctv.updateColor(currTime);
		cctv.updateOrientation(currTime);
		cctv.render(gl, magoManager, shader);
		cctv.updateTime(currTime);
	}
	
	if (this.bDrawCCTVNames !== undefined && this.bDrawCCTVNames === true)
	{
		magoManager.drawCCTVNames(this.camerasList);
	}
	
	shader.disableVertexAttribArrayAll();
};
'use strict';

var CesiumViewerInit = function(containerId, serverPolicy, options, legacyViewer) 
{
	if (!Cesium) 
	{
		throw new Error('if basicGlobe is Cesium, add Cesium Library');
	}
	this.options = options || {};
	this.DEFALUT_IMAGE = "ESRI World Imagery";
	this.DEFALUT_TERRAIN = "WGS84 Ellipsoid";

	ViewerInit.call(this, containerId, serverPolicy);

	//this.viewer = (legacyViewer instanceof Cesium.Viewer) ? legacyViewer : null;	
};
CesiumViewerInit.prototype = Object.create(ViewerInit.prototype);
CesiumViewerInit.prototype.constructor = CesiumViewerInit;

CesiumViewerInit.TERRAINTYPE = {
	GEOSERVER          : 'geoserver',
	CESIUM_DEFAULT     : 'cesium-default',
	CESIUM_ION_DEFAULT : 'cesium-ion-default',
	CESIUM_ION_CDN     : 'cesium-ion-cdn',
	CESIUM_CUSTOMER    : 'cesium-customer'
};
CesiumViewerInit.prototype.init = function() 
{
	this.setCanvasEventHandler();

	this.options.animation = this.options.animation || false;
	this.options.timeline = this.options.timeline || false;

	//GEOSERVER BASE LAYER, GEOSERVER TERRAIN SET
	this.providerBuild();

	this.options.shouldAnimate = false;
	this.viewer = new Cesium.Viewer(this.targetId, this.options);

	this.postProcessDataProvider();
	this.initMagoManager();
	//this.setEventHandler();

	if (this.policy.initCameraEnable) 
	{ 
		var destination;

		var lon = parseFloat(this.policy.initLatitude);
		var lat = parseFloat(this.policy.initLongitude);
		var height = parseFloat(this.policy.initAltitude);
		var duration = parseInt(this.policy.initDuration);

		if (isNaN(lon) || isNaN(lat) || isNaN(height)) 
		{
			throw new Error('Longitude, Latitude, Height must number type.');
		}

		if (isNaN(duration)) { duration = 3; }
		destination = Cesium.Cartesian3.fromDegrees(lat, lon, height);

		this.viewer.camera.flyTo({
			destination : destination,
			duration    : duration
		}); 
	}
};
CesiumViewerInit.prototype.setCanvasEventHandler = function() 
{
	var canvas = document.getElementById(this.targetId);
	canvas.addEventListener('webglcontextlost', function(e) 
	{
		console.log(e);
	}, false);
    
	canvas.addEventListener('webglcontextrestored', function(e) 
	{
		console.log(e); 
	}, false);
};

CesiumViewerInit.prototype.providerBuild = function() 
{
	var policy = this.policy;
	var online = policy.online;
	var geoserverEnable = policy.geoserverEnable;
	var terrainType = policy.terrainType;

	if (!online && !geoserverEnable) 
	{
		throw new Error('If your env is offline, must use geoserver.');
	}

	//geoserver 이용시 false로 변경. 현재는 안 쓸 경우 true로 해야함.
	

	if (geoserverEnable && policy.geoserverImageproviderEnable) 
	{
		this.geoserverImageProviderBuild();
	}

	if (geoserverEnable && terrainType === CesiumViewerInit.TERRAINTYPE.GEOSERVER) 
	{
		this.geoserverTerrainProviderBuild();
	}

	
	if (policy.cesiumIonToken && policy.cesiumIonToken.length > 0) 
	{
		Cesium.Ion.defaultAccessToken = policy.cesiumIonToken;
	}
	var terrainType = policy.terrainType;
	var terrainValue = policy.terrainValue;
	if (terrainType !== CesiumViewerInit.TERRAINTYPE.GEOSERVER && !this.options.terrainProvider) 
	{
		this.options.terrainProvider = new Cesium.EllipsoidTerrainProvider();
		switch (terrainType) 
		{
		case CesiumViewerInit.TERRAINTYPE.CESIUM_ION_DEFAULT :{
			if (policy.cesiumIonToken && policy.cesiumIonToken.length > 0) 
			{
				this.options.terrainProvider = Cesium.createWorldTerrain();
			}
			break;
		}
		case CesiumViewerInit.TERRAINTYPE.CESIUM_ION_CDN :{
			if (policy.cesiumIonToken || policy.cesiumIonToken.length > 0) 
			{
				this.options.terrainProvider = new Cesium.CesiumTerrainProvider({
					url: Cesium.IonResource.fromAssetId(parseInt(terrainValue))
				});
			}
			break;
		}
		case CesiumViewerInit.TERRAINTYPE.CESIUM_CUSTOMER :{
			this.options.terrainProvider = new Cesium.CesiumTerrainProvider({
				url: terrainValue
			});
			break;
		}
		}
	}
	
	if (!this.options.imageryProvider) 
	{
		this.options.imageryProvider = new Cesium.ArcGisMapServerImageryProvider({
			url: 'https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer'
		});
	}
};

CesiumViewerInit.prototype.geoserverImageProviderBuild = function() 
{
	var policy = this.policy;
	var geoserver = MagoConfig.getGeoserver();
    
	if (!policy.geoserverImageproviderEnable) 
	{
		//throw new Error('If you use geoserver, geoserverImageproviderEnable must true. Do you want change true auto?');
		policy.geoserverImageproviderEnable = true;
	}
    
	var wmsUrl;
	if (!policy.geoserverImageproviderUrl && geoserver) 
	{
		wmsUrl = geoserver.getDataRequestUrl();
	}

	wmsUrl = policy.geoserverImageproviderUrl;

	if (!wmsUrl) 
	{
		throw new Error('If use geoserverImageprovider, geoserverImageproviderUrl is required or input geoserverDataUrl and geoserverDataWorkspace.');
	}

	var wmsLayer = policy.geoserverImageproviderLayerName;
	if (!wmsLayer) 
	{
		throw new Error('If use geoserverImageprovider, geoserverImageproviderLayerName is required.');
	}

	// Cesium.WebMapServiceImageryProvider.DefaultParameters
	var version = (geoserver && geoserver.getWmsVersion()) ?  geoserver.getWmsVersion() : "1.1.1";
	var style = policy.geoserverImageproviderStyleName ? policy.geoserverImageproviderStyleName : '';
	var format = policy.geoserverImageproviderParametersFormat ? policy.geoserverImageproviderParametersFormat : 'image/jpeg';
	var tileWidth = policy.geoserverImageproviderParametersWidth ? policy.geoserverImageproviderParametersWidth : 256;
	var tileHeight = policy.geoserverImageproviderParametersHeight ? policy.geoserverImageproviderParametersHeight : 256;

	var param = {
		service : "WMS",
		version : version,
		request : "GetMap",
		styles  : style,
		format  : format
	};

	var imageryProvider = new Cesium.WebMapServiceImageryProvider({
		url                : wmsUrl,
		layers             : wmsLayer,
		parameters         : param,
		tileWidth          : tileWidth, 
		tileHeight         : tileHeight,
		enablePickFeatures : false
	});

	this.options.imageryProvider = imageryProvider;
	this.options.baseLayerPicker = false;
};

CesiumViewerInit.prototype.geoserverTerrainProviderBuild = function() 
{
	if (!Cesium.GeoserverTerrainProvider) 
	{
		throw new Error('If you want use GeoserverTerrainProvider, GeoserverTerrainProvider plugin required.');
	}

	var policy = this.policy;

	var terrainParam = {
		service: 'WMTS'
	};

	var terrainUrl = policy.terrainValue;
    
	if (!terrainUrl) 
	{
		throw new Error('If use geoserverTerrainproviderEnable, geoserverTerrainproviderUrl is required.');
	}

	var terrainLayerName = policy.geoserverTerrainproviderLayerName;
	var terrainStyleName = policy.geoserverTerrainproviderStyleName;

	terrainParam.url = terrainUrl;
	terrainParam.layerName = terrainLayerName;
	terrainParam.styleName = terrainStyleName;
	terrainParam.maxLevel = 13;

	this.options.terrainProvider = new Cesium.GeoserverTerrainProvider(terrainParam);
};

CesiumViewerInit.prototype.postProcessDataProvider = function() 
{
	// TODO : 제거 필수!! 세슘의 카메라 매트릭스를 강제로 변환시키기 위하여 우주크기만한 엔티티를 추가.
	this.viewer.entities.add({
		name     : "mago3D",
		position : Cesium.Cartesian3.fromDegrees(37.521168, 126.924185, 3000.0),
		box      : {
			dimensions : new Cesium.Cartesian3(300000.0*1000.0, 300000.0*1000.0, 300000.0*1000.0), // dimensions : new Cesium.Cartesian3(400000.0, 300000.0, 500000.0),
			fill       : true,
			material   : Cesium.Color.BLUE,
			outline    : false
		}
	});

	if (!this.options.imageryProvider) 
	{
		var imageryProvider = null;
		if (this.viewer.baseLayerPicker) 
		{
			var imageryProviderViewModels = this.viewer.baseLayerPicker.viewModel.imageryProviderViewModels;
			for (var i in imageryProviderViewModels) 
			{
				if (!imageryProviderViewModels.hasOwnProperty(i))	{ continue; }

				var provider = imageryProviderViewModels[i];
				if (provider.name === this.DEFALUT_IMAGE)
				{
					imageryProvider = provider;
					break;
				}
			}
			if (imageryProvider) { this.viewer.baseLayerPicker.viewModel.selectedImagery = imageryProvider; }
		}
		else 
		{
			this.viewer.imageryLayers.removeAll();
			this.viewer.imageryLayers.addImageryProvider(new Cesium.ArcGisMapServerImageryProvider({
				url: 'https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer'
			}), 0);
		}
	}
	//삭제예정. 깔끔하게 삭제하는 법 생각좀하고..
	if (!this.options.terrainProvider) 
	{
		if (this.policy.initDefaultTerrain !== null && this.policy.initDefaultTerrain !== "") 
		{
			this.DEFALUT_TERRAIN = this.policy.initDefaultTerrain;
		}
    
		var terrainProvider = null;
		var terrainProviderViewModels = this.viewer.baseLayerPicker.viewModel.terrainProviderViewModels;
		for (var i in terrainProviderViewModels) 
		{
			if (!terrainProviderViewModels.hasOwnProperty(i))	{ continue; }
			var provider = terrainProviderViewModels[i];
			if (provider.name === this.DEFALUT_TERRAIN) 
			{
				terrainProvider = provider;
				break;
			}
		}
		if (terrainProvider) { this.viewer.baseLayerPicker.viewModel.selectedTerrain = terrainProvider; }
	}
};

CesiumViewerInit.prototype.initMagoManager = function() 
{
	var scene;
	var serverPolicy = this.policy;
	var viewer = this.viewer;
	
	this.viewer.scene.magoManager = new MagoManager();
	this.viewer.scene.magoManager.sceneState.textureFlipYAxis = false;

	this.viewer.camera.frustum.fov = Cesium.Math.PI_OVER_THREE*1.8;
	if (serverPolicy.initDefaultFov > 0) 
	{
		this.viewer.camera.frustum.fov = Cesium.Math.PI_OVER_THREE * serverPolicy.initDefaultFov;
	}

	var gl = this.viewer.scene.context._gl;

	this.viewer.scene.magoManager.postFxShadersManager.gl = gl;
	this.viewer.scene.magoManager.postFxShadersManager.createDefaultShaders(gl); // A1-OLD.***
	this.viewer.scene.magoManager.createDefaultShaders(gl);// A1-Use this.***
	this.viewer.scene.magoManager.scene = this.viewer.scene;

	var magoManager = this.viewer.scene.magoManager;
	this.magoManager = magoManager;
	scene = this.viewer.scene;
	
	this.viewer.scene.globe.depthTestAgainstTerrain = false;
	this.viewer.scene.logarithmicDepthBuffer = false; //do not use logarithmic buffer
	this.viewer.scene.highDynamicRange = false; //do not use high dynamic range
	
	viewer.camera.changed.addEventListener(function(e)
	{
		magoManager.cameraChanged(e);
	});
	viewer.camera.moveEnd.addEventListener(function()
	{
		magoManager.cameraMoveEnd();
	});
	viewer.camera.moveStart.addEventListener(function()
	{
		magoManager.cameraMoveStart();
	});
	//this.magoManager.init(gl);
};

CesiumViewerInit.prototype.setEventHandler = function() 
{
	var magoManager = this.magoManager;
	var scene = magoManager.scene;
	var viewer = this.viewer;

	this.viewer.scene.magoManager.handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);
	
	magoManager.handler.setInputAction(function(click) 
	{
		magoManager.mouseActionLeftDown(click.position.x, click.position.y);
	}, Cesium.ScreenSpaceEventType.LEFT_DOWN);

	magoManager.handler.setInputAction(function(click) 
	{
		magoManager.mouseActionMiddleDown(click.position.x, click.position.y);
	}, Cesium.ScreenSpaceEventType.MIDDLE_DOWN);
    
	magoManager.handler.setInputAction(function(click) 
	{
		magoManager.mouseActionRightDown(click.position.x, click.position.y);
	}, Cesium.ScreenSpaceEventType.RIGHT_DOWN);

	magoManager.handler.setInputAction(function(movement) 
	{
		magoManager.mouseActionMove(movement.startPosition, movement.endPosition);
	}, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

	magoManager.handler.setInputAction(function(movement) 
	{
		magoManager.mouseActionLeftUp(movement.position.x, movement.position.y);
	}, Cesium.ScreenSpaceEventType.LEFT_UP);

	magoManager.handler.setInputAction(function(movement) 
	{
		magoManager.mouseActionMiddleUp(movement.position.x, movement.position.y);
	}, Cesium.ScreenSpaceEventType.MIDDLE_UP);
    
	magoManager.handler.setInputAction(function(movement) 
	{
		magoManager.mouseActionRightUp(movement.position.x, movement.position.y);
	}, Cesium.ScreenSpaceEventType.RIGHT_UP);
    
	magoManager.handler.setInputAction(function(movement) 
	{
		magoManager.mouseActionLeftClick(movement.position.x, movement.position.y);
	}, Cesium.ScreenSpaceEventType.LEFT_CLICK);

	magoManager.handler.setInputAction(function(movement) 
	{
		magoManager.mouseActionLeftDoubleClick(movement.position.x, movement.position.y);
	}, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);

	magoManager.handler.setInputAction(function(movement) 
	{
		magoManager.mouseActionRightClick(movement.position.x, movement.position.y);
	}, Cesium.ScreenSpaceEventType.RIGHT_CLICK);

	 
	this.viewer.clock.onTick.addEventListener(function(clock) 
	{
		magoManager.cameraFPV.update(magoManager);
	});
};
'use strict';

/**
 * @class CollisionCheckScene
 * 
 */
var CollisionCheckScene = function() 
{
	if (!(this instanceof CollisionCheckScene)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	// Check hero (node) with others objects (Extras).
	this.hero;
	this.extrasArray;
};

/**
 * 어떤 일을 하고 있습니까?
 */
CollisionCheckScene.prototype.doCheck = function(resultCollidedOctreesArray) 
{
	if (this.hero === undefined)
	{ return false; }
	
	if (this.extrasArray === undefined || this.extrasArray.length === 0)
	{ return false; }

	var heroNeoBuilding = this.hero.data.neoBuilding;
	if (heroNeoBuilding === undefined)
	{ return false; }

	var heroCollisionOctree = heroNeoBuilding.getCollisionCheckOctree();
	if (heroCollisionOctree === undefined)
	{ return false; }
	
	if (resultCollidedOctreesArray === undefined)
	{ resultCollidedOctreesArray = []; }

	var extrasCount = this.extrasArray.length;
	for (var i=0; i<extrasCount; i++)
	{
		var extra = this.extrasArray[i];
		var extraNeoBuilding = extra.data.neoBuilding;
		
		if (extraNeoBuilding === undefined)
		{ continue; }
		
		var extraCollisionOctree = extraNeoBuilding.getCollisionCheckOctree();
		if (extraCollisionOctree === undefined)
		{ continue; }
		
		heroCollisionOctree.checkCollision(extraCollisionOctree, resultCollidedOctreesArray);
	}
	
};



'use strict';



/**
 * Save and calculate the color value as RGB
 * @class Color
 */
var Color = function(red, green, blue, alpha) 
{
	if (!(this instanceof Color)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.r = 0;
	this.g = 0;
	this.b = 0;
	this.a = 1;
	
	if (red !== undefined)
	{ this.r = red; }
	
	if (green !== undefined)
	{ this.g = green; }
	
	if (blue !== undefined)
	{ this.b = blue; }
	
	if (alpha !== undefined)
	{ this.a = alpha; }
};


/**
 * Match gray scale to RGB scale
 * @param gray the percentage of the gray color. normalize the value from 0.0 to 1.0
 * @param {Color} resultColor
 * @returns {Color} 
 */
Color.grayToRGB_MagoStyle = function(gray, resultColor) 
{
	if (resultColor === undefined)
	{ resultColor = new Color(); }
	
	if (gray > 1.0){ gray = 1.0; }
	else if (gray<0.0){ gray = 0.0; }
	
	var r, g, b;
	
	r = -gray + 1.0;
	
	if (gray > 0.5)
	{
		g = -gray*2.0 + 2.0; 
	}
	else 
	{
		g = gray*2.0;
	}
	
	b = gray;
	
	resultColor.setRGB(r, g, b);
	
	return resultColor;
};

Color.grayToRGBYCM_MagoStyle = function(gray, resultColor)
{
	if (resultColor === undefined)
	{ resultColor = new Color(); }

	if (gray > 1.0){ gray = 1.0; }
	else if (gray<0.0){ gray = 0.0; }
	
	var r, g, b;
	
	if (gray < 0.16666)
	{
		b = 0.0;
		g = gray*6.0;
		r = 1.0;
	}
	else if (gray >= 0.16666 && gray < 0.33333)
	{
		b = 0.0;
		g = 1.0;
		r = 2.0 - gray*6.0;
	}
	else if (gray >= 0.33333 && gray < 0.5)
	{
		b = -2.0 + gray*6.0;
		g = 1.0;
		r = 0.0;
	}
	else if (gray >= 0.5 && gray < 0.66666)
	{
		b = 1.0;
		g = 4.0 - gray*6.0;
		r = 0.0;
	}
	else if (gray >= 0.66666 && gray < 0.83333)
	{
		b = 1.0;
		g = 0.0;
		r = -4.0 + gray*6.0;
	}
	else if (gray >= 0.83333)
	{
		b = 6.0 - gray*6.0;
		g = 0.0;
		r = 1.0;
	}
	
	resultColor.setRGB(r, g, b);
	return resultColor;
}; 

/**
 * copy of the value of RGB instance
 * @param {Color} color
 */
Color.prototype.copyFrom = function(color) 
{
	this.r = color.r;
	this.g = color.g;
	this.b = color.b;
	this.a = color.a;
};

/**
 * Clear the RGBA value of this instance
 */
Color.prototype.deleteObjects = function() 
{
	this.r = undefined;
	this.g = undefined;
	this.b = undefined;
	this.a = undefined;
};

/**
 * Linear interpolation between colorA & colorB
 */
Color.mix = function(colorA, colorB, weight, resultColor ) 
{
	if (resultColor === undefined)
	{ resultColor = new Color(); }
	
	var w = weight;
	var r = colorA.r * w + colorB.r * (1.0 - w);
	var g = colorA.g * w + colorB.g * (1.0 - w);
	var b = colorA.b * w + colorB.b * (1.0 - w);
	var a = colorA.a * w + colorB.a * (1.0 - w);
	
	resultColor.setRGBA(r, g, b, a);
	
	return resultColor;
};
  
/**
 * Set the value of RGBA (A means transparancy) as default. 
 * @param red the value of red
 * @param green the value of green
 * @param blue the value of blue
 * @param alpha the value of transparancy
 */
Color.prototype.set = function(red, green, blue, alpha) 
{

	this.r = red; 
	this.g = green; 
	this.b = blue; 
	this.a = alpha;
};
  
/**
 * Set the value of RGB
 * @param red the value of red
 * @param green the value of green
 * @param blue the value of blue
 */
Color.prototype.setRGB = function(red, green, blue) 
{

	this.r = red; 
	this.g = green; 
	this.b = blue;
};
  
/**
 * Set the value of RGBA (A means transparancy)
 * @param red the value of red
 * @param green the value of green
 * @param blue the value of blue
 * @param alpha the value of transparancy
 */
Color.prototype.setRGBA = function(red, green, blue, alpha) 
{
	//this[0] = red;
	//this[1] = green;
	//this[2] = blue;
	//this[3] = alpha;
	this.r = red; this.g = green; this.b = blue; this.a = alpha;
};

/**
 * return hexCode
 * @return {string}
 */
Color.prototype.getHexCode = function() 
{
	var r = this.r * 255;
	var g = this.g * 255;
	var b = this.b * 255;
	
	var hexR = r.toString(16).padStart(2, '0'); //String.padStart i.e no support..TT 
	var hexG = g.toString(16).padStart(2, '0');
	var hexB = b.toString(16).padStart(2, '0');
	
	return '#'+hexR+hexG+hexB;
};
'use strict';

var DynamicColor = function(option) 
{
	Color.call(this);
    
	this.redFactorSpeed = 2.0;
	this.greenFactorSpeed = 2.0;
	this.blueFactorSpeed = 2.0;
	this.alphaFactorSpeed = 2.0;
    
	this.redFactor = 1.0;
	this.greenFactor = 1.0;
	this.blueFactor = 1.0;
	this.alphaFactor = 1.0;
    
	if (option) 
	{
		this.redFactorSpeed = defaultValueCheckLength(option.redFactorSpeed, 1.0);
		this.greenFactorSpeed = defaultValueCheckLength(option.greenFactorSpeed, 1.0);
		this.blueFactorSpeed = defaultValueCheckLength(option.blueFactorSpeed, 2.0);
		this.alphaFactorSpeed = defaultValueCheckLength(option.alphaFactorSpeed, 2.0);
        
		this.redFactor = defaultValueCheckLength(option.redFactor, 1.0);
		this.greenFactor = defaultValueCheckLength(option.greenFactor, 1.0);
		this.blueFactor = defaultValueCheckLength(option.blueFactor, 1.0);
		this.alphaFactor = defaultValueCheckLength(option.alphaFactor, 1.0);
	}
};

DynamicColor.prototype = Object.create(Color.prototype);
DynamicColor.prototype.constructor = DynamicColor;

/**
 * Update the color of the screen shown at the CCTV
 * @param currTime
 */
DynamicColor.prototype.updateColorAlarm = function(currTime)
{
	if (this.lastTime === undefined)
	{ this.lastTime = currTime; }

	var timeAmount = (currTime - this.lastTime)/1000;
	
	// change color.
	if (this.redFactor === undefined)
	{ this.redFactor = 1.0; }
    
	if (this.greenFactor === undefined)
	{ this.greenFactor = 1.0; }
	
	if (this.blueFactor === undefined)
	{ this.blueFactor = 1.0; }
	
	if (this.alphaFactor === undefined)
	{ this.alphaFactor = 1.0; }
    
	this.redFactor += this.redFactorSpeed * timeAmount;
	this.greenFactor += this.greenFactorSpeed * timeAmount;
	this.blueFactor += this.blueFactorSpeed * timeAmount;
    
	var maxRedFactor = 1.0;
	if (this.redFactor > maxRedFactor )
	{
		this.redFactor = maxRedFactor;
		this.redFactorSpeed *= -1;
	}
    
	var minRedFactor = 0.5;
	if (this.redFactor < minRedFactor )
	{
		this.redFactor = minRedFactor;
		this.redFactorSpeed *= -1;
	}
	var maxGreenFactor = 0.5;
	if (this.greenFactor > maxGreenFactor )
	{
		this.greenFactor = maxGreenFactor;
		this.greenFactorSpeed *= -1;
	}
    
	var minGreenFactor = 0.1;
	if (this.greenFactor < minGreenFactor )
	{
		this.greenFactor = minGreenFactor;
		this.greenFactorSpeed *= -1;
	}
	var maxBlueFactor = 0.3;
	if (this.blueFactor > maxBlueFactor )
	{
		this.blueFactor = maxBlueFactor;
		this.blueFactorSpeed *= -1;
	}
    
	var minBlueFactor = 0.1;
	if (this.blueFactor < minBlueFactor )
	{
		this.blueFactor = minBlueFactor;
		this.blueFactorSpeed *= -1;
	}
	
	var maxAlphaFactor = 0.6;
	if (this.alphaFactor > maxAlphaFactor )
	{
		this.alphaFactor = maxAlphaFactor;
		this.alphaFactorSpeed *= -1;
	}
    
	var minAlphaFactor = 0.0;
	if (this.alphaFactor < minAlphaFactor )
	{
		this.alphaFactor = minAlphaFactor;
		this.alphaFactorSpeed *= -1;
	}
    
	if (this.greenFactor > this.redFactor) 
	{
		this.greenFactor = this.redFactor;
	}
	
	this.setRGBA(this.redFactor, this.greenFactor, this.blueFactor, this.alphaFactor);
	this.updateTime(currTime);
};
DynamicColor.prototype.updateTime = function(time) 
{
	this.lastTime = time;
};
'use strict';

/**
 * Mago3d's format 'F4D' type data controller.
 * @class F4dController
 * 
 * @param {MagoManager} magoManager
 */
var F4dController = function(magoManager) 
{

	if (!(this instanceof F4dController)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	if (!magoManager || !magoManager instanceof MagoManager) 
	{
		throw new Error('magoManager is required.');
	}
	Emitter.call(this);

	this.magoManager = magoManager;

	this.smartTilePathInfo = {};

};

F4dController.prototype = Object.create(Emitter.prototype);
F4dController.prototype.constructor = F4dController;

/**
 * f4d smarttile data group 등록
 * @param {Array<object> | object} f4dObject f4d smarttile data group
 */
F4dController.prototype.addSmartTileGroup = function(f4dObject) 
{
	var magoManager = this.magoManager;
	if (Array.isArray(f4dObject)) 
	{
		for (var i=0, len=f4dObject.length;i<len;i++) 
		{
			this.addSmartTileGroup(f4dObject[i]);
		}
	} 
	else 
	{
		var groupId = f4dObject.data_key || f4dObject.dataGroupId;
		var groupDataFolder;
		var groupKey;
		if (f4dObject.data_key) 
		{
			groupDataFolder = groupId;
			groupKey = groupId;
		}
		else 
		{
			groupDataFolder = f4dObject.dataGroupPath;
			groupDataFolder = groupDataFolder.replace(/\/+$/, '');

			groupKey = f4dObject.dataGroupKey;
		}

		if (!this.smartTilePathInfo[groupKey])
		{
			this.smartTilePathInfo[groupKey] = {};
		}

		this.smartTilePathInfo[groupKey].projectId = groupId;
		this.smartTilePathInfo[groupKey].projectFolderPath = groupDataFolder;
		//this.smartTilePathInfo[groupKey].smartTileIndexPath = groupDataFolder + '/' + groupKey + '_TILE';

		if (f4dObject.smartTileIndexPath) 
		{
			magoManager.getObjectIndexFileSmartTileF4d(f4dObject.smartTileIndexPath);
		}
	}
};
/**
 * f4d data group 등록
 * @param {Array<object> | object} f4dObject f4d data definition object
 */
F4dController.prototype.addF4dGroup = function(f4dObject) 
{
	// TODO : validate f4dObject.
	//F4dController.f4dObjectValidate()
	//do add f4d group
	var magoManager = this.magoManager;
	if (Array.isArray(f4dObject)) 
	{
		for (var i=0, len=f4dObject.length;i<len;i++) 
		{
			this.addF4dGroup(f4dObject[i]);
		}
	}
	else 
	{
		var groupId = f4dObject.data_key || f4dObject.dataKey || f4dObject.dataGroupId;
		var groupDataFolder;

		if (f4dObject.data_key) 
		{
			groupDataFolder = groupId;
		}
		else 
		{
			groupDataFolder = f4dObject.dataGroupPath;
			groupDataFolder = groupDataFolder.replace(/\/+$/, '');
		}

		MagoConfig.setData(CODE.PROJECT_ID_PREFIX + groupId, f4dObject);
		MagoConfig.setProjectDataFolder(CODE.PROJECT_DATA_FOLDER_PREFIX + groupDataFolder, groupDataFolder);
        
		magoManager.getObjectIndexFile(groupId, groupDataFolder);
	}
};

/**
 * f4d data를 등록
 * @param {string} groupId required. target group id
 * @param {Array<object> | object} f4dObject f4d data definition object
 */
F4dController.prototype.addF4dMember = function(groupId, f4dObject) 
{
	if (!groupId) 
	{
		throw new Error('groupId is required.');
	}

	this.magoManager.getObjectIndexFileForData(groupId, f4dObject);
};

/**
 * f4d group 삭제
 * @param {string} groupId required. target group id
 * @param {Array<object>} f4dObjectArray f4d data definition object
 */
F4dController.prototype.deleteF4dGroup = function(groupId) 
{
	if (!groupId) 
	{
		throw new Error('groupId is required.');
	}

	var nodeMap = this.magoManager.hierarchyManager.getNodesMap(groupId);
	if (!nodeMap) 
	{
		throw new Error(groupId + ' group is no exists.');
	}

	var keys = Object.keys(nodeMap);
	for (var i=0, len=keys.length;i<len;i++) 
	{
		var key = keys[i];
		if (key === 'attributes') 
		{
			continue;
		}
		
		var item = nodeMap[keys[i]];
		if (!item.data.attributes.isPhysical) 
		{
			continue;
		}

		this.deleteF4dMember(groupId, key);
	}

	delete this.magoManager.hierarchyManager.projectsMap[groupId];
};

/**
 * f4d data를 삭제
 * @param {string} groupId required. target group id
 * @param {string} memberId f4d data definition object
 */
F4dController.prototype.deleteF4dMember = function(groupId, memberId) 
{
	if (!groupId) 
	{
		throw new Error('groupId is required.');
	}
	if (!memberId) 
	{
		throw new Error('memberId is required.');
	}

	var node = this.magoManager.hierarchyManager.getNodeByDataKey(groupId, memberId);
	if (!node) 
	{
		throw new Error('node is no exists.');
	}

	var smartTile = node.data.smartTileOwner;
	if (smartTile) 
	{
		smartTile.eraseNode(node);
	}
	node.deleteObjects(this.magoManager.sceneState.gl, this.magoManager.vboMemoryManager);
	delete this.magoManager.hierarchyManager.projectsMap[groupId][memberId];
};

F4dController.f4dObjectValidate = function(f4dObject) 
{
	console.info(f4dObject);
};
'use strict';

/**
 * Frame Buffer Object
 * @class FBO
 * @param {WebGLRenderingContext} gl WebGL rendering context.
 * @param {Number} width Framebuffer width.
 * @param {Number} height Framebuffer height.
 */
var FBO = function(gl, width, height) 
{
	if (!(this instanceof FBO)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	/**
	 * WebGL rendering context.
	 * @type {WebGLRenderingContext}
	 * @default WebGLRenderingContext
	 */
	this.gl = gl;
	
	/**
	 * Framebuffer width.
	 * @type {Number}
	 * @default 0
	 */
	this.width = new Int32Array(1);
	
	/**
	 * Framebuffer height.
	 * @type {Number}
	 * @default 0
	 */
	this.height = new Int32Array(1);
	
	/**
	 * WebGL Framebuffer.
	 * @type {WebGLFramebuffer}
	 * @default WebGLFramebuffer
	 */
	this.fbo = gl.createFramebuffer();
	
	
	/**
	 * WebGL Renderbuffer.
	 * @type {WebGLRenderbuffer}
	 * @default WebGLRenderbuffer
	 */
	this.depthBuffer = gl.createRenderbuffer();
	
	/**
	 * WebGL texture.
	 * @type {WebGLTexture}
	 * @default WebGLTexture
	 */
	this.colorBuffer = gl.createTexture();
	
	/**
	 * Boolean var that indicates that the parameters must be updated.
	 * @type {Boolean}
	 * @default true
	 */
	this.dirty = true;
	
	// Init process.
	this.width[0] = width;
	this.height[0] = height;
  
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, this.colorBuffer);  
	
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); //LINEAR_MIPMAP_LINEAR
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	//gl.generateMipmap(gl.TEXTURE_2D)

	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width[0], height[0], 0, gl.RGBA, gl.UNSIGNED_BYTE, null); 
  
	gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
	gl.bindRenderbuffer(gl.RENDERBUFFER, this.depthBuffer);
	gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width[0], height[0]);
	gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.depthBuffer);
	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.colorBuffer, 0);
	if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) 
	{
		throw "Incomplete frame buffer object.";
	}

	gl.bindFramebuffer(gl.FRAMEBUFFER, null);
};    

/**
 * Binds the framebuffer.
 */
FBO.prototype.bind = function() 
{
	this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbo);
};

/**
 * Unbinds the framebuffer.
 */
FBO.prototype.unbind = function() 
{
	this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
};

/**
 * Deletes all objects.
 * @param gl
 */
FBO.prototype.deleteObjects = function(gl) 
{
	if (this.depthBuffer)
	{ gl.deleteRenderbuffer(this.depthBuffer); }
	this.depthBuffer = undefined;
	
	if (this.colorBuffer)
	{ gl.deleteTexture(this.colorBuffer); }
	this.colorBuffer = undefined;
	
	if (this.fbo)
	{ gl.deleteFramebuffer(this.fbo); }
	this.fbo = undefined;
	
	
};

/**
 * Returns a new WebGL buffer.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {TypedArray} data Data array to bind.
 * @returns {WebGLBuffer} WebGL Buffer.
 */
FBO.createBuffer = function(gl, data) 
{
	var buffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
	gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
	return buffer;
};

/**
 * Binds a framebuffer and texture to this instance
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {WebGLFramebuffer} framebuffer WebGL Framebuffer.
 * @param {WebGLTexture} texture WebGL Texture.
 */
FBO.bindFramebuffer = function(gl, framebuffer, texture) 
{
	gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
	if (texture) 
	{
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
	}
};
/**
 * Binds the attribute of each 
 */
FBO.bindAttribute = function(gl, buffer, attribute, numComponents) 
{
	gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
	gl.enableVertexAttribArray(attribute);
	gl.vertexAttribPointer(attribute, numComponents, gl.FLOAT, false, 0, 0);
};

FBO.bindTexture = function(gl, texture, unit) 
{
	gl.activeTexture(gl.TEXTURE0 + unit);
	gl.bindTexture(gl.TEXTURE_2D, texture);
};

















































'use strict';

/**
 * xmlhttprequest 요청 개수를 저장하기 위한 객체
 * @class FileRequestControler
 */
var FileRequestControler = function() 
{
	if (!(this instanceof FileRequestControler)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.maxFilesRequestedCount = 1;
	this.filesRequestedCount = 0;
	this.headerFilesRequestedCount = 0;
	this.modelRefFilesRequestedCount = 0;
	this.lowLodDataRequestedCount = 0;
	this.lowLodImagesRequestedCount = 0;
	this.multiBuildingsDataRequestedCount = 0;
};

FileRequestControler.prototype.isFull = function ()
{
	return this.filesRequestedCount >= this.maxFilesRequestedCount; 
};

FileRequestControler.prototype.isFullHeaders = function ()
{
	return this.headerFilesRequestedCount >= 1; 
};

FileRequestControler.prototype.isFullPlus = function (extraCount)
{
	if (extraCount === undefined)
	{ extraCount = 0; }
	
	return this.filesRequestedCount >= (this.maxFilesRequestedCount + extraCount); 
};

FileRequestControler.prototype.isFullPlusModelReferences = function (extraCount)
{
	if (extraCount === undefined)
	{ extraCount = 0; }
	
	return this.modelRefFilesRequestedCount >= (this.maxFilesRequestedCount + extraCount); 
};

FileRequestControler.prototype.isFullPlusLowLodData = function (extraCount)
{
	if (extraCount === undefined)
	{ extraCount = 0; }
	
	return this.lowLodDataRequestedCount >= (this.maxFilesRequestedCount + extraCount); 
};

FileRequestControler.prototype.isFullPlusLowLodImages = function (extraCount)
{
	if (extraCount === undefined)
	{ extraCount = 0; }
	
	return this.lowLodImagesRequestedCount >= (this.maxFilesRequestedCount + extraCount); 
};

'use strict';

var keyFlags = {
	moveForward  : false,
	moveBackward : false,
	moveLeft     : false,
	moveRight    : false
};

function getFlagFromKeyCode(code)
{
	switch (code)
	{
	case 37 :	// Arrow-Left
	{
		//console.log("KeyDown Left");
		return 'moveLeft';
	}
	case 38 :	// Arrow-Up
	{
		//console.log("KeyDown Up");
		return 'moveForward';
	}
	case 39 :	// Arrow-Right
	{
		//console.log("KeyDown Right");
		return 'moveRight';
	}
	case 40 :	// Arrow-Down
	{
		//console.log("KeyDown Down");
		return 'moveBackward';
	}
	default :
	{
		return undefined;
	}
	}
};

function onKeyDown(event)
{
	var flag = getFlagFromKeyCode(event.keyCode);
	if ( typeof flag !== 'undefined')
	{
		keyFlags[flag] = true;
	}
};

function onKeyUp(event)
{
	var flag = getFlagFromKeyCode(event.keyCode);
	if ( typeof flag !== 'undefined')
	{
		keyFlags[flag] = false;
	}
};

/**
 * 카메라 1인칭 시점 모드
 * 
 */
function FirstPersonView ()
{
	this._camera = undefined;
	this._cameraBAK = undefined;
	this._position = new Point3D();
	this._rotation = new Point3D();
	this._positionSpeed = 1.0;
	this._ratationSpeed = 1.0;
}

Object.defineProperties(FirstPersonView.prototype, {
	"camera": {
		get : function () { return this._camera; },
		set : function (value) { this._camera = value; }
	},
	"position": {
		get : function () { return this._position; },
		set : function (value) { this._position = value; }		
	},
	"rotation": {
		get : function () { return this._rotation; },
		set : function (value) { this._rotation = value; }
	},
	"positionSpeed": {
		get : function () { return this._positionSpeed; },
		set : function (value) { this._positionSpeed = value; }
	},
	"rotationSpeed": {
		get : function () { return this._ratationSpeed; },
		set : function (value) { this._ratationSpeed = value; }
	}
});

FirstPersonView.prototype.init = function ()
{
	this._position.set(0.0, 0.0, 0.0);
	this._rotation.set(0.0, 0.0, 0.0);

	document.addEventListener('keydown', onKeyDown, false);
	document.addEventListener('keyup', onKeyUp, false);
};

FirstPersonView.prototype.release = function ()
{
	this._camera = undefined;
	this._cameraBAK = undefined;
	document.removeEventListener('keydown', onKeyDown, false);
	document.removeEventListener('keyup', onKeyUp, false);
};

FirstPersonView.prototype.move = function (vector)
{
	var position = glMatrix.vec3.fromValues(this._position.x, this._position.y, this.position.z);
	var matrix = glMatrix.mat4.create();
	glMatrix.mat4.rotateY(matrix, matrix, this._rotation.y);
	glMatrix.vec3.transformMat4(vector, vector, matrix);
	glMatrix.vec3.add(position, position, vector);
	this._position.set(position[0], position[1], position[2]);
};
FirstPersonView.prototype.update = function(manager)
{
	if (this._camera === undefined)	{ return; }
	if (keyFlags.moveForward)
	{
		//var isBlocked = manager.checkCollision(this._camera.position, this._camera.direction);
		//if (isBlocked)	{ return; }
		this._camera.moveForward(0.5);
		this.move(vec3.fromValues(0.0, 1.0, 0.0));
	}
	if (keyFlags.moveBackward)
	{
		this._camera.moveBackward(0.5);
		this.move(vec3.fromValues(0.0, -1.0, 0.0));
	}
	if (keyFlags.moveLeft)
	{
		this._camera.lookLeft(0.1);
		this.move(vec3.fromValues(-1.0, 0.0, 0.0));	
	}		
	if (keyFlags.moveRight)
	{
		this._camera.lookRight(0.1);
		this.move(vec3.fromValues(1.0, 0.0, 0.0));	
	}
};

'use strict';

/**
 * Furstum used by camera
 * @class Frustum
 */
var Frustum = function() 
{
	if (!(this instanceof Frustum)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.near = new Float32Array([0.1]);
	this.far = new Float32Array([1000.0]);
	this.fovyRad = new Float32Array([0.8037]); //vertical viewing angle
	this.tangentOfHalfFovy = new Float32Array([0.0]); // to get the length of the horizontal angle of fov
	this.fovRad = new Float32Array([1.047]);//horizontal viewing angle
	this.aspectRatio = new Float32Array([1.3584]);
	this.planesArray = [];
	this.dirty = true;
	
	// plane[0] = near, plane[1] = far.
	for (var i=0; i<6; i++)
	{
		var plane = new Plane();
		this.planesArray.push(plane);
	}
};

/**
 * copy the other frustum
 * @param {Frustum} frustum
 */
Frustum.prototype.copyParametersFrom = function(frustum) 
{
	this.near[0] = frustum.near[0];
	this.far[0] = frustum.far[0];
	this.fovyRad[0] = frustum.fovyRad[0];
	this.tangentOfHalfFovy[0] = frustum.tangentOfHalfFovy[0];
	this.fovRad[0] = frustum.fovRad[0];
	this.aspectRatio[0] = frustum.aspectRatio[0];
};

/**
 * Set the near of frustum by distance
 * @param {Float32} near
 */
Frustum.prototype.setNear = function(near) 
{
	this.near[0] = near;
};

/**
 * Set the fart of frustum by distance
 * @param {Float32} far
 */
Frustum.prototype.setFar = function(far) 
{
	this.far[0] = far;
};

/**
 * Check whether the bounding sphere of the feature is intersected with the near and far of the frustum for frustum culling
 * @param {Sphere} sphere
 * @returns {Boolean}
 */
Frustum.prototype.intersectionNearFarSphere = function(sphere) 
{
	var intersects = false;
	for (var i=0; i<2; i++)
	{
		var intersectionType = this.planesArray[i].intersectionSphere(sphere);
		if (intersectionType === Constant.INTERSECTION_OUTSIDE)
		{ return Constant.INTERSECTION_OUTSIDE; }
		else if (intersectionType === Constant.INTERSECTION_INTERSECT)
		{ intersects = true; }
	}
	
	if (intersects)
	{ return Constant.INTERSECTION_INTERSECT; }
	else
	{ return Constant.INTERSECTION_INSIDE; }
};

/**
 * Check whether the bounding sphere of the feature is intersected with this frustum for frustum culling
 * @param {Sphere} sphere
 * @returns {Boolean}
 */
Frustum.prototype.intersectionSphere = function(sphere) 
{
	var intersects = false;
	for (var i=0; i<6; i++)
	{
		var intersectionType = this.planesArray[i].intersectionSphere(sphere);
		if (intersectionType === Constant.INTERSECTION_OUTSIDE)
		{ return Constant.INTERSECTION_OUTSIDE; }
		else if (intersectionType === Constant.INTERSECTION_INTERSECT)
		{ intersects = true; }
	}
	
	if (intersects)
	{ return Constant.INTERSECTION_INTERSECT; }
	else
	{ return Constant.INTERSECTION_INSIDE; }
};






























'use strict';

/**
 * Manage the objects which is shown at each volume of this frustum
 * @class FrustumVolumeControl
 */
var FrustumVolumeControl = function() 
{
	if (!(this instanceof FrustumVolumeControl)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.frustumVolumensMap = {};
};

/**
 * Find the specific volumn by the key of this.frustumVolumensMap
 * @param {Number} key
 * @returns {Frustum} 
 */
FrustumVolumeControl.prototype.getFrustumVolumeCulling = function(key)
{
	// 1rst, check if exist. If no exist create it.
	if (!this.frustumVolumensMap.hasOwnProperty(key))
	{
		this.frustumVolumensMap[key] = {};
		this.frustumVolumensMap[key].intersectedTilesArray = []; // todo: change name to "intersectedTilesArray".***
		this.frustumVolumensMap[key].visibleNodes = new VisibleObjectsController();
	}
	
	return this.frustumVolumensMap[key];
};

/**
 * Initiate and clear all the objects in the array
 */
FrustumVolumeControl.prototype.initArrays = function()
{
	var frustumVolumeObject;
	for (var key in this.frustumVolumensMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.frustumVolumensMap, key)) 
		{
			frustumVolumeObject = this.frustumVolumensMap[key];
			frustumVolumeObject.intersectedTilesArray.length = 0; // todo: change name to "intersectedTilesArray".***
			frustumVolumeObject.visibleNodes.initArrays();
		}
	}
};

/**
 * Returns the near & far considering all frustum partitions.
 */
FrustumVolumeControl.prototype.getTotalBoundingFrustum = function(resultBFrustum)
{
	resultBFrustum = {}; // init.
	
	var frustumVolumeObject;
	for (var key in this.frustumVolumensMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.frustumVolumensMap, key)) 
		{
			frustumVolumeObject = this.frustumVolumensMap[key];
			if (frustumVolumeObject.intersectedTilesArray.length > 0)
			{
				var bFrustumNear = frustumVolumeObject.visibleNodes.bFrustumNear;
				var bFrustumFar = frustumVolumeObject.visibleNodes.bFrustumFar;
				
				if (bFrustumNear !== undefined && bFrustumFar !== undefined)
				{
					if (resultBFrustum.bFrustumNear === undefined)
					{
						resultBFrustum.bFrustumNear = bFrustumNear;
					}
					else
					{
						if (bFrustumNear < resultBFrustum.bFrustumNear)
						{ resultBFrustum.bFrustumNear = bFrustumNear; }
					}
					
					if (resultBFrustum.bFrustumFar === undefined)
					{
						resultBFrustum.bFrustumFar = bFrustumFar;
					}
					else
					{
						if (bFrustumFar > resultBFrustum.bFrustumFar)
						{ resultBFrustum.bFrustumFar = bFrustumFar; }
					}
				}
			}
		}
	}
	
	return resultBFrustum;
};

/**
 * Returns the near & far considering all frustum partitions.
 */
FrustumVolumeControl.prototype.calculateBoundingFrustums = function(camera)
{
	var frustumVolumeObject;
	for (var key in this.frustumVolumensMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.frustumVolumensMap, key)) 
		{
			frustumVolumeObject = this.frustumVolumensMap[key];
			if (frustumVolumeObject.intersectedTilesArray.length > 0)
			{
				frustumVolumeObject.visibleNodes.calculateBoundingFrustum(camera);
			}
		}
	}
};









































'use strict';

/**
 * This class represents the coordinate as geographic coordinate system
 * @class GeographicCoord
 */
var GeographicCoord = function(lon, lat, alt) 
{
	if (!(this instanceof GeographicCoord)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	/**
	 * The "longitude" of a point on Earth's surface is the angle east or west of a reference meridian to another meridian that passes through that point.
	 * The unit of "longitude" is degree.
	 * @type {Number}
	 * @default undefined
	 */
	this.longitude;
	
	/**
	 * The "latitude" of a point on Earth's surface is the angle between the equatorial plane and the straight line that passes through that point and through (or close to) the center of the Earth.
	 * The unit of "latitude" is degree.
	 * @type {Number}
	 * @default undefined
	 */
	this.latitude;
	
	/**
	 * The "altitude" of a point is relative to the sea that is defined by an ellipsoid.
	 * The unit of "altitude" is meters.
	 * @type {Number}
	 * @default undefined
	 */
	this.altitude;
	
	if (lon !== undefined)
	{ this.longitude = lon; }
	
	if (lat !== undefined)
	{ this.latitude = lat; }
	
	if (alt !== undefined)
	{ this.altitude = alt; }

	/**
	 * The cartesian coordinate of a point defined by the longitude, latitude & altitude in the current world coordinate system.
	 * The unit of "altitude" is meters.
	 * @type {Point3D}
	 * @default undefined
	 */
	this.absolutePoint; 
	
	/**
	 * This class is the container which holds the VBO Cache Keys.
	 * Used to render the point on earth.
	 * @type {VBOVertexIdxCacheKeysContainer}
	 */
	this.vboKeysContainer;
	
	/**
	 * GeoLocationDataManager is a class object that contains GeoLocationData objects in an array.
	 * @type {GeoLocationDataManager}
	 */
	this.geoLocDataManager;
	
	/**
	 * Object or class that has this geographicCoord.
	 * @type {Class/Object}
	 */
	this.owner;
};

/**
 * Clear the value of this instance from the vbo key container and geoLocDataManager 
 * @param {VBOMemoryManager}vboMemManager
 */
GeographicCoord.prototype.deleteObjects = function(vboMemManager) 
{
	this.longitude = undefined;
	this.latitude = undefined;
	this.altitude = undefined;
	
	if (this.absolutePoint !== undefined)
	{
		this.absolutePoint.deleteObjects();
		this.absolutePoint = undefined;
	}
	
	if (this.vboKeysContainer !== undefined)
	{
		this.vboKeysContainer.deleteGlObjects(vboMemManager.gl, vboMemManager);
	}
	
	if (this.geoLocDataManager !== undefined)
	{
		this.geoLocDataManager.deleteObjects();
	}
	
	this.owner = undefined;
};

/**
 * Change this GeographicCoord point to Point3D point
 * @param {Point3D} resultPoint3D
 */
GeographicCoord.prototype.getWgs84Point3D = function(resultPoint3d) 
{
	var cartesianAux = Globe.geographicToCartesianWgs84(this.longitude, this.latitude, this.altitude, undefined);
	
	if (resultPoint3d === undefined)
	{ resultPoint3d = new Point3D(); }
	
	resultPoint3d.set(cartesianAux[0], cartesianAux[1], cartesianAux[2]);
	return resultPoint3d;
};

/**
 * Change this GeographicCoord point to Point2D point using Mercator projection
 * @param {Point2D} resultPoint2d
 */
GeographicCoord.prototype.getMercatorProjection = function(resultPoint2d) 
{
	return Globe.geographicToMercatorProjection(this.longitude, this.latitude, resultPoint2d);
};

/**
 * get the GeoLocationDataManager of this feature
 */
GeographicCoord.prototype.makeDefaultGeoLocationData = function() 
{
	if (this.geoLocDataManager === undefined)
	{ this.geoLocDataManager = new GeoLocationDataManager(); }
	
	var geoLocData = this.geoLocDataManager.getCurrentGeoLocationData();
	if (geoLocData === undefined)
	{
		geoLocData = this.geoLocDataManager.newGeoLocationData("default");
		geoLocData = ManagerUtils.calculateGeoLocationData(this.longitude, this.latitude, this.altitude, undefined, undefined, undefined, geoLocData);
	}
};

/**
 * get the GeoLocationDataManager of this feature
 */
GeographicCoord.prototype.getGeoLocationDataManager = function() 
{
	if (this.geoLocDataManager === undefined)
	{ this.geoLocDataManager = new GeoLocationDataManager(); }
	
	return this.geoLocDataManager ;
};

/**
 * Copy the value of the other GeographicCoord feature
 * @param {GeographicCoord} geographicCoord
 */
GeographicCoord.prototype.copyFrom = function(geographicCoord) 
{
	this.longitude = geographicCoord.longitude;
	this.latitude = geographicCoord.latitude;
	this.altitude = geographicCoord.altitude;
};

/**
 * Set lon,lat,alt at this feature
 * @param longitude 경도
 * @param latitude 위도
 * @param altitude 고도
 */
GeographicCoord.prototype.setLonLatAlt = function(longitude, latitude, altitude) 
{
	if (longitude !== undefined)
	{ this.longitude = longitude; }
	if (latitude !== undefined)
	{ this.latitude = latitude; }
	if (altitude !== undefined)
	{ this.altitude = altitude; }
};

/**
 * Set lon at this feature
 * @param longitude 경도
 */
GeographicCoord.prototype.setLongitude = function(longitude) 
{
	this.longitude = longitude; 
};

/**
 * Set lon at this feature
 * @param longitude 경도
 */
GeographicCoord.prototype.setLatitude = function(latitude) 
{
	this.latitude = latitude; 
};

/**
 * Set lon at this feature
 * @param longitude 경도
 */
GeographicCoord.prototype.setAltitude = function(altitude) 
{
	this.altitude = altitude;
};

/**
 * Returns the latitude in radians.
 * @returns {Number}
 */
GeographicCoord.prototype.getLatitudeRad = function() 
{
	if (this.latitude === undefined)
	{ return; }
	
	return this.latitude *Math.PI/180;
};

/**
 * Returns the longitude in radians.
 * @returns {Number}
 */
GeographicCoord.prototype.getLongitudeRad = function() 
{
	if (this.longitude === undefined)
	{ return; }
	
	return this.longitude *Math.PI/180;
};

/**
 * Returns the middle point between two GeopraphicCoord features
 * @param {GeographicCoord} geographicCoordA
 * @param {GeographicCoord} geographicCoordB
 * @param {GeographicCoord} resultGeographicCoord
 * @returns {GeographicCoord}
 */
GeographicCoord.getMidPoint = function(geographicCoordA, geographicCoordB, resultGeographicCoord) 
{
	var midLat = ( geographicCoordA.latitude + geographicCoordB.latitude) / 2.0;
	var midLon = ( geographicCoordA.longitude + geographicCoordB.longitude) / 2.0;
	var midAlt = ( geographicCoordA.altitude + geographicCoordB.altitude) / 2.0;
	
	if (resultGeographicCoord === undefined)
	{ resultGeographicCoord = new GeographicCoord(midLon, midLat, midAlt); }
	else 
	{
		resultGeographicCoord.setLonLatAlt(midLon, midLat, midAlt);
	}
	
	return resultGeographicCoord;
};

/**
 * Returns the module of the vector of geographicCoordA to geographicCoordB, without altitude.
 * @param {GeographicCoord} geographicCoordA
 * @param {GeographicCoord} geographicCoordB
 * @returns {Number}
 */
GeographicCoord.getAngleBetweenCoords = function(geographicCoordA, geographicCoordB) 
{
	var lonDiff = geographicCoordB.longitude - geographicCoordA.longitude;
	var latDiff = geographicCoordB.latitude - geographicCoordA.latitude;
	var result = Math.sqrt(lonDiff*lonDiff + latDiff*latDiff);
	
	return result;
};

/**
 * make the vbo data of this feature
 * @param {VBOMemoryManager} vboMemManager
 */
 
GeographicCoord.prototype.prepareData = function(vboMemManager) 
{
	if (this.vboKeysContainer === undefined)
	{ this.vboKeysContainer = new VBOVertexIdxCacheKeysContainer(); }
	
	if (this.vboKeysContainer.getVbosCount() === 0)
	{
		var vboKey = this.vboKeysContainer.newVBOVertexIdxCacheKey();
		
		// Position.
		var pos = new Float32Array([0.0, 0.0, 0.0]);
		vboKey.setDataArrayPos(pos, vboMemManager);
	}
	
	return true;
};

/**
 * make the vbo data of this feature
 * @param {VBOMemoryManager} vboMemManager
 */
 
GeographicCoord.prototype.readDataFromBuffer = function(dataArrayBuffer, bytesReaded) 
{
	// read longitude(64), latitude(64), altitude(32).
	this.longitude = (new Float64Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+8)))[0]; bytesReaded += 8;
	this.latitude = (new Float64Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+8)))[0]; bytesReaded += 8;
	this.altitude = (new Float32Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	return bytesReaded;
};

/**
 * Render this feature
 */
GeographicCoord.prototype.renderPoint = function(magoManager, shader, gl, renderType) 
{
	if (!this.prepareData(magoManager.vboMemoryManager))
	{ return false; }
	
	var buildingGeoLocation = this.geoLocDataManager.getCurrentGeoLocationData();
	buildingGeoLocation.bindGeoLocationUniforms(gl, shader);
	
	if (renderType === 2)
	{
		var selectionManager = magoManager.selectionManager;
		var selectionColor = magoManager.selectionColor;

		var selColor = selectionColor.getAvailableColor(undefined); 
		var idxKey = selectionColor.decodeColor3(selColor.r, selColor.g, selColor.b);

		selectionManager.setCandidateGeneral(idxKey, this);
		gl.uniform4fv(shader.oneColor4_loc, [selColor.r/255.0, selColor.g/255.0, selColor.b/255.0, 1.0]);
	}
	
	var vbo_vicky = this.vboKeysContainer.vboCacheKeysArray[0]; // there are only one.
	if (!vbo_vicky.bindDataPosition(shader, magoManager.vboMemoryManager))
	{ return false; }

	gl.drawArrays(gl.POINTS, 0, vbo_vicky.vertexCount);
	
	
};
















































'use strict';

/**
 * This class represents the coordinate as geographic coordinate system
 * @class GeographicCoordSegment
 */
var GeographicCoordSegment = function(startGeoCoord, endGeoCoord) 
{
	if (!(this instanceof GeographicCoordSegment)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.strGeoCoord = startGeoCoord;
	this.endGeoCoord = endGeoCoord;
};

/**
 * Returns the angle to North in radians of the segment.
 * @param {GeographicCoordSegment} geoCoordSegment.
 * @param {MagoManager} magoManager worldwind mode removed, this args is not need. 
 * @returns {Number} Angle in radians between the segments.
 */
GeographicCoordSegment.calculateHeadingAngRadToNorthOfSegment = function(geoCoordSegment, magoManager) 
{
	// Note: The heading angle is calculated on the strPoint of the segment.***
	var strGeoCoord = geoCoordSegment.strGeoCoord;
	var endGeoCoord = geoCoordSegment.endGeoCoord;
	
	var strPointWC = ManagerUtils.geographicCoordToWorldPoint(strGeoCoord.longitude, strGeoCoord.latitude, strGeoCoord.altitude, undefined, magoManager);
	var endPointWC = ManagerUtils.geographicCoordToWorldPoint(endGeoCoord.longitude, endGeoCoord.latitude, endGeoCoord.altitude, undefined, magoManager);
	
	// Now, calculate the transformation matrix on the startPoint.***
	var geoLocMatrix = ManagerUtils.calculateGeoLocationMatrixAtWorldPosition(strPointWC, undefined);
	
	// Now calculate the inverse of the geoLocMatrix.***
	var matrixInv = glMatrix.mat4.create(); // from glMatrix library.***
	matrixInv = glMatrix.mat4.invert(matrixInv, geoLocMatrix._floatArrays  );
	
	var geoLocMatrixInv = new Matrix4(); // Mago native matrix.***
	geoLocMatrixInv.setByFloat32Array(matrixInv);
	
	// Now calculate the relative position of the endPoint respect the startPoint.***
	var endPointLC = geoLocMatrixInv.transformPoint3D(endPointWC, undefined);
	
	// Finally calculate heading angle to north.***
	var yAxis = new Point2D(0, 1);
	var dir2d = new Point2D(endPointLC.x, endPointLC.y);
	dir2d.unitary();
	var headingAngleRad = yAxis.angleRadToVector(dir2d);
	if (dir2d.x > 0.0)
	{
		headingAngleRad *= -1;
	}
	
	return headingAngleRad;
};

/**
 * Returns the angle to North in radians of the segment.
 * @param {GeographicCoordSegment} geoCoordSegment.
 * @param {MagoManager} magoManager worldwind mode removed, this args is not need. 
 * @returns {Number} Length of the segments.
 */
GeographicCoordSegment.getLengthInMeters = function(geoCoordSegment, magoManager) 
{
	var strGeoCoord = geoCoordSegment.strGeoCoord;
	var endGeoCoord = geoCoordSegment.endGeoCoord;
	
	var strPointWC = ManagerUtils.geographicCoordToWorldPoint(strGeoCoord.longitude, strGeoCoord.latitude, strGeoCoord.altitude, undefined, magoManager);
	var endPointWC = ManagerUtils.geographicCoordToWorldPoint(endGeoCoord.longitude, endGeoCoord.latitude, endGeoCoord.altitude, undefined, magoManager);
	var length = strPointWC.distToPoint(endPointWC);
	return length;
};

/**
 * Returns the direction of this segment.
 * @param {GeographicCoordSegment} geoCoordSegment.
 * @param {Point3D} resultDirection. 
 */
GeographicCoordSegment.getDirection = function(geoCoordSegment, resultDirection) 
{
	if (geoCoordSegment === undefined)
	{ return resultDirection; }
	
	var lonDiff = geoCoordSegment.endGeoCoord.longitude - geoCoordSegment.strGeoCoord.longitude;
	var latDiff = geoCoordSegment.endGeoCoord.latitude - geoCoordSegment.strGeoCoord.latitude;
	var altDiff = geoCoordSegment.endGeoCoord.altitude - geoCoordSegment.strGeoCoord.altitude;
	
	if (resultDirection === undefined)
	{ resultDirection = new Point3D(); }
	
	resultDirection.set(lonDiff, latDiff, altDiff);
	resultDirection.unitary();
	
	return resultDirection;
};

/**
 * Returns the line3d of the "geoCoordSegment".
 * @param {GeographicCoordSegment} geoCoordSegment.
 * @param {Point3D} resultLine3d. 
 */
GeographicCoordSegment.getLine = function(geoCoordSegment, resultLine3d) 
{
	if (resultLine3d === undefined)
	{
		resultLine3d = new Line();
	}
	// unitary direction.
	var dir = GeographicCoordSegment.getDirection(geoCoordSegment, undefined);
	var strGeoCoord = geoCoordSegment.strGeoCoord;
	resultLine3d.setPointAndDir(strGeoCoord.longitude, strGeoCoord.latitude, strGeoCoord.altitude, dir.x, dir.y, dir.z);
	return resultLine3d;
};

/**
 * Returns the projected coord of "geoCoord" into the line of this segment.
 * @param {GeographicCoordSegment} geoCoordSegment.
 * @param {GeographicCoord} geoCoord.
 * @param {GeographicCoord} resultGeoCoord. 
 */
GeographicCoordSegment.getProjectedCoordToLine = function(geoCoordSegment, geoCoord, resultGeoCoord) 
{
	var line = GeographicCoordSegment.getLine(geoCoordSegment, undefined);
	var point3d = new Point3D(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude);
	var projectedCoord = line.getProjectedPoint(point3d, undefined);
	
	if (resultGeoCoord === undefined)
	{ resultGeoCoord = new GeographicCoord(); }
	
	resultGeoCoord.setLonLatAlt(projectedCoord.x, projectedCoord.y, projectedCoord.z);
	return resultGeoCoord;
};

/**
 * Returns the projected coord of "geoCoord" into the line of this segment.
 * @param {GeographicCoordSegment} geoCoordSegment.
 * @param {GeographicCoord} geoCoord.
 */
GeographicCoordSegment.intersectionWithGeoCoord = function(geoCoordSegment, geoCoord) 
{
	var error = 10E-8;
	var strGeoCoord = geoCoordSegment.strGeoCoord;
	var endGeoCoord = geoCoordSegment.endGeoCoord;
	
	var point3d = new Point3D(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude);
	var strPoint3d = new Point3D(strGeoCoord.longitude, strGeoCoord.latitude, strGeoCoord.altitude);
	var endPoint3d = new Point3D(endGeoCoord.longitude, endGeoCoord.latitude, endGeoCoord.altitude);
	var segment3d = new Segment3D(strPoint3d, endPoint3d);
	
	var totalLength = segment3d.getLength();
	var lengthA = strPoint3d.distToPoint(point3d);
	var lengthB = endPoint3d.distToPoint(point3d);
	var lengthSum = lengthA + lengthB;
	if (Math.abs(totalLength - lengthSum) < error)
	{ return true; }
	else
	{ return false; }
};

/**
 * Returns the nearest geoCoord of this segment to ""geoCoord.
 * @param {GeographicCoord} geoCoord.
 */
GeographicCoordSegment.getNearestGeoCoord = function(geoCoordSegment, geoCoord) 
{
	var strGeoCoord = geoCoordSegment.strGeoCoord;
	var endGeoCoord = geoCoordSegment.endGeoCoord;
	
	var point3d = new Point3D(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude);
	var strPoint3d = new Point3D(strGeoCoord.longitude, strGeoCoord.latitude, strGeoCoord.altitude);
	var endPoint3d = new Point3D(endGeoCoord.longitude, endGeoCoord.latitude, endGeoCoord.altitude);
	
	var lengthA = strPoint3d.distToPoint(point3d);
	var lengthB = endPoint3d.distToPoint(point3d);
	
	if (lengthA < lengthB)
	{ return strGeoCoord; }
	else
	{ return endGeoCoord; }
};

















'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class GeographicCoordsList
 */
var GeographicCoordsList = function(geographicCoordsArray) 
{
	if (!(this instanceof GeographicCoordsList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	if (geographicCoordsArray !== undefined)
	{ this.geographicCoordsArray = geographicCoordsArray; }
	else
	{ this.geographicCoordsArray = []; }
	this.vboKeysContainer;
	this.owner;
	this.id;
	
	// Aux vars.
	this.points3dList; // used to render.
};

/**
 * push single point
 * @param {GeographicCoord}
 */
GeographicCoordsList.prototype.newGeoCoord = function(lon, lat, alt) 
{
	var geoCoord = new GeographicCoord(lon, lat, alt);
	this.addGeoCoord(geoCoord);
	return geoCoord;
};

/**
 * push single point
 * @param {GeographicCoord}
 */
GeographicCoordsList.prototype.addGeoCoord = function(geographicPoint) 
{
	this.geographicCoordsArray.push(geographicPoint);
	geographicPoint.owner = this;
};

/**
 * push single point
 * @param {GeographicCoord}
 */
GeographicCoordsList.prototype.addGeoCoordsArray = function(geographicPointsArray) 
{
	var geoCoordsCount = geographicPointsArray.length;
	for (var i=0; i<geoCoordsCount; i++)
	{
		this.geographicCoordsArray.push(geographicPointsArray[i]);
		geographicPointsArray[i].owner = this;
	}
};

/**
 * get single point
 * @param {Number} idx the index of target
 */
GeographicCoordsList.prototype.getGeoCoord = function(idx) 
{
	if (this.geographicCoordsArray === undefined)
	{ return undefined; }
	
	return this.geographicCoordsArray[idx];
};

/**
 * Get the number of the point in this list
 * @returns {Number} the number of the points
 */
GeographicCoordsList.prototype.getGeoCoordsCount = function() 
{
	if (this.geographicCoordsArray === undefined)
	{ return 0; }
	
	return this.geographicCoordsArray.length;
};

/**
 * get single point
 * @param {Number} idx the index of target
 * @param {GeographicCoordSegment} resultGeoCoordSegment.
 */
GeographicCoordsList.prototype.getGeoCoordSegment = function(idx, resultGeoCoordSegment) 
{
	if (this.geographicCoordsArray === undefined)
	{ return resultGeoCoordSegment; }
	
	var geoCoordsCount = this.geographicCoordsArray.length;
	
	if (geoCoordsCount <= 1)
	{ return resultGeoCoordSegment; }
	
	if (idx > geoCoordsCount - 1)
	{ return resultGeoCoordSegment; }
	
	var nextIdx;
	
	if (idx === geoCoordsCount - 1)
	{ nextIdx = 0; }
	else
	{ nextIdx = idx + 1; }

	var geoCoord1 = this.getGeoCoord(idx);
	var geoCoord2 = this.getGeoCoord(nextIdx);
	
	if (resultGeoCoordSegment === undefined)
	{ resultGeoCoordSegment = new GeographicCoordSegment(); }
	
	resultGeoCoordSegment.strGeoCoord = geoCoord1;
	resultGeoCoordSegment.endGeoCoord = geoCoord2;
	
	return resultGeoCoordSegment;
};

/**
 * 
 * 
 */
GeographicCoordsList.prototype.getCopy = function(resultGeoCoordsListCopy) 
{
	if (resultGeoCoordsListCopy === undefined)
	{ resultGeoCoordsListCopy = new GeographicCoordsList(); }
	
	var geoPointsCount = this.getGeoCoordsCount();
	for (var i=0; i<geoPointsCount; i++)
	{
		var geoCoord = this.getGeoCoord(i);
		var geoCoordCopy = new GeographicCoord(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude);
		resultGeoCoordsListCopy.addGeoCoord(geoCoordCopy);
	}
	
	return resultGeoCoordsListCopy;
};

/**
 * This function returns points3dArray relative to the geoLocIn.
 * @param {GeoLocationData} geoLocIn the information about the axis of this GeographicCoord
 * @param resultPoint3dArray
 * 
 */
GeographicCoordsList.getPointsRelativeToGeoLocation = function(geoLocIn, geoCoordsArray, resultPoints3dArray) 
{
	if (resultPoints3dArray === undefined)
	{ resultPoints3dArray = []; }
	
	var geoPointsCount = geoCoordsArray.length;
	
	for (var i=0; i<geoPointsCount; i++)
	{
		var geoCoord = geoCoordsArray[i];
		var geoLocDataManager = geoCoord.getGeoLocationDataManager();
		var geoLoc = geoLocDataManager.getCurrentGeoLocationData();
		if (geoLoc === undefined)
		{
			geoCoord.makeDefaultGeoLocationData();
			geoLoc = geoLocDataManager.getCurrentGeoLocationData();
		}
		
		var posAbs = geoLoc.position;
		resultPoints3dArray[i] = geoLocIn.getTransformedRelativePosition(posAbs, resultPoints3dArray[i]);
	}
	
	return resultPoints3dArray;
};

/**
 * Returns renderableObject of the geoCoordsList.
 */
GeographicCoordsList.getRenderableObjectOfGeoCoordsArray = function(geoCoordsArray, magoManager, options) 
{
	if (geoCoordsArray === undefined || geoCoordsArray.length === 0)
	{ return undefined; }
	
	// 1rst, make points3dList relative to the 1rst_geoCoord.
	var firstGeoCoord = geoCoordsArray[0];
	var geoLoc = ManagerUtils.calculateGeoLocationData(firstGeoCoord.longitude, firstGeoCoord.latitude, firstGeoCoord.altitude, 0, 0, 0, undefined);
	
	var points3dLCArray = GeographicCoordsList.getPointsRelativeToGeoLocation(geoLoc, geoCoordsArray, undefined);
	
	// Now, for each point, set attributes by speed & others.
	
	
	// Create a vectorMesh.
	if (options === undefined)
	{
		options = {
			thickness: 2.0
		};
	}
	else
	{
		if (options.thickness === undefined)
		{ options.thickness = 2.0; }
	}

	var vectorMesh = new VectorMesh(options);
	
	var optionsThickLine = {
		colorType: "alphaGradient"
	};
	vectorMesh.vboKeysContainer = Point3DList.getVboThickLines(magoManager, points3dLCArray, vectorMesh.vboKeysContainer, options);
	
	var renderableObject = new RenderableObject();
	renderableObject.geoLocDataManager = new GeoLocationDataManager();
	renderableObject.geoLocDataManager.addGeoLocationData(geoLoc);
	renderableObject.objectType = MagoRenderable.OBJECT_TYPE.VECTORMESH;
	renderableObject.objectsArray.push(vectorMesh);
	
	return renderableObject;
};

/**
 * This function returns points3dArray relative to the geoLocIn.
 * @param {GeoLocationData} geoLocIn the information about the axis of this GeographicCoord
 * @param resultPoint3dArray
 * 
 */
GeographicCoordsList.prototype.getPointsWorldCoord = function(resultPoints3dArray) 
{
	if (resultPoints3dArray === undefined)
	{ resultPoints3dArray = []; }
	
	var geoPointsCount = this.getGeoCoordsCount();
	
	for (var i=0; i<geoPointsCount; i++)
	{
		var geoCoord = this.getGeoCoord(i);
		var geoLocDataManager = geoCoord.getGeoLocationDataManager();
		var geoLoc = geoLocDataManager.getCurrentGeoLocationData();
		if (geoLoc === undefined)
		{
			geoCoord.makeDefaultGeoLocationData();
			geoLoc = geoLocDataManager.getCurrentGeoLocationData();
		}
		
		var posAbs = geoLoc.position;
		resultPoints3dArray[i] = posAbs;
	}
	
	return resultPoints3dArray;
};

/**
 * Clear the data in this instance and delete the vbo info of this instance
 */
GeographicCoordsList.prototype.deleteObjects = function(vboMemManager) 
{
	if (this.geographicCoordsArray !== undefined)
	{
		var geoPointsCount = this.getGeoCoordsCount();
		
		for (var i=0; i<geoPointsCount; i++)
		{
			this.geographicCoordsArray[i].deleteGlObjects(vboMemManager);
			this.geographicCoordsArray[i] = undefined;
		}
		this.geographicCoordsArray = undefined;
	}
	
	if (this.vboKeysContainer !== undefined)
	{
		this.vboKeysContainer.deleteGlObjects(vboMemManager);
		this.vboKeysContainer = undefined;
	}
	
	this.owner = undefined;
};



/**
 * Make Lines making the first point as the origin for the other points. Change the points to the GeographicCoords.
 */
GeographicCoordsList.prototype.test__makeThickLines = function(magoManager) 
{
	// 1rst, make lines.
	this.makeLines(magoManager);
	
	if (this.points3dList === undefined)
	{ return; }
	
	// now, make thickLines.
	var resultVboKeysContainer = Point3DList.getVboThickLines(magoManager, this.points3dList.pointsArray, undefined);
	
	this.points3dList.vboKeysContainer = resultVboKeysContainer;
};

/**
 * 
 */
GeographicCoordsList.prototype.getGeographicExtent = function(resultGeographicExtent) 
{
	if (!resultGeographicExtent)
	{ resultGeographicExtent = new GeographicExtent(); }
	
	var geoCoord;
	var geoCoordsCount = this.geographicCoordsArray.length;
	for (var i=0; i<geoCoordsCount; i++)
	{
		geoCoord = this.geographicCoordsArray[i];
		if (i === 0)
		{
			resultGeographicExtent.setInitExtent(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude);
		}
		else 
		{
			resultGeographicExtent.addGeographicCoord(geoCoord);
		}
	}
	
	return resultGeographicExtent;
};

/**
 * 
 */
GeographicCoordsList.prototype.getMiddleGeographicCoords = function(resultMiddleGeoCoords) 
{
	var geoExtent = this.getGeographicExtent();
	return geoExtent.getMidPoint(resultMiddleGeoCoords);
};

/**
 * 
 */
GeographicCoordsList.prototype.addAltitude = function(length) 
{
	var geoCoord;
	var geoCoordsCount = this.geographicCoordsArray.length;
	for (var i=0; i<geoCoordsCount; i++)
	{
		geoCoord = this.geographicCoordsArray[i];
		geoCoord.altitude += length;
	}
};

/**
 * 
 */
GeographicCoordsList.prototype.getExtrudedMeshRenderableObject = function(height, bLoop, resultRenderableObject, magoManager, extrudeDirWC) 
{
	if (!resultRenderableObject)
	{
		resultRenderableObject = new RenderableObject();
	}
	resultRenderableObject.geoLocDataManager = new GeoLocationDataManager();
	var geoLocData = resultRenderableObject.geoLocDataManager.newGeoLocationData();
	
	// The origin of this object is in the middle of this geoCoordsList.
	var midGeoCoord = this.getMiddleGeographicCoords();
	
	// Make the topGeoCoordsList.
	var topGeoCoordsList = this.getCopy();
	
	// Reassign the altitude on the geoCoordsListCopy.
	topGeoCoordsList.addAltitude(height);
	
	// All points3d is referenced to the middleGeoCoord.
	ManagerUtils.calculateGeoLocationData(midGeoCoord.longitude, midGeoCoord.latitude, midGeoCoord.altitude, 0, 0, 0, geoLocData);
	var basePoints3dArray = GeographicCoordsList.getPointsRelativeToGeoLocation(geoLocData, this.geographicCoordsArray, undefined);
	var topPoints3dArray = GeographicCoordsList.getPointsRelativeToGeoLocation(geoLocData, topGeoCoordsList.geographicCoordsArray, undefined);
	
	// Now, with basePoints3dArray & topPoints3dArray make a mesh.
	// Create a VtxProfilesList.
	var vtxProfilesList = new VtxProfilesList();
	var baseVtxProfile = vtxProfilesList.newVtxProfile();
	baseVtxProfile.makeByPoints3DArray(basePoints3dArray, undefined); 
	var topVtxProfile = vtxProfilesList.newVtxProfile();
	topVtxProfile.makeByPoints3DArray(topPoints3dArray, undefined); 
	
	var bIncludeBottomCap = true;
	var bIncludeTopCap = true;
	var solidMesh = vtxProfilesList.getMesh(undefined, bIncludeBottomCap, bIncludeTopCap);
	var surfIndepMesh = solidMesh.getCopySurfaceIndependentMesh();
	surfIndepMesh.calculateVerticesNormals();
	
	resultRenderableObject.objectsArray.push(surfIndepMesh);
	return resultRenderableObject;
};

/**
 * Make Lines making the first point as the origin for the other points. Change the points to the GeographicCoords.
 */
GeographicCoordsList.prototype.makeLines = function(magoManager) 
{
	if (this.geographicCoordsArray === undefined || this.geographicCoordsArray.length === 0)
	{ return false; }
	
	// To render lines, use Point3DList class object.
	if (this.points3dList === undefined)
	{ this.points3dList = new Point3DList(); }
	
	var geoLoc = this.points3dList.getGeographicLocation();
	
	// Take the 1rst geographicCoord's geoLocation.
	var geoCoord = this.getGeoCoord(0);
	var geoLocDataManagerFirst = geoCoord.getGeoLocationDataManager();
	var geoLocFirst = geoLocDataManagerFirst.getCurrentGeoLocationData();
	
	// If has no geoLocationData, then create it.***
	if (geoLocFirst === undefined)
	{ geoLocFirst = ManagerUtils.calculateGeoLocationData(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude, undefined, undefined, undefined, geoLocFirst, magoManager); }
	
	geoLoc.copyFrom(geoLocFirst);
	
	var points3dArray = GeographicCoordsList.getPointsRelativeToGeoLocation(geoLoc, this.geographicCoordsArray, undefined);
	this.points3dList.deleteVboKeysContainer(magoManager);
	this.points3dList.deletePoints3d();
	this.points3dList.addPoint3dArray(points3dArray);
	
};

/**
 * Render lines
 */
GeographicCoordsList.prototype.renderLines = function(magoManager, shader, renderType, bLoop, bEnableDepth) 
{
	if (this.geographicCoordsArray === undefined)
	{ return false; }
	
	if (this.points3dList === undefined)
	{ return false; }
	
	var shader = magoManager.postFxShadersManager.getShader("pointsCloud");
	shader.useProgram();
	shader.disableVertexAttribArrayAll();
	shader.resetLastBuffersBinded();
	shader.enableVertexAttribArray(shader.position3_loc);
	shader.bindUniformGenerals();
	
	var gl = magoManager.sceneState.gl;
	gl.uniform1i(shader.bPositionCompressed_loc, false);
	gl.uniform1i(shader.bUse1Color_loc, true);
	gl.uniform4fv(shader.oneColor4_loc, [1.0, 1.0, 0.1, 1.0]); //.
	gl.uniform1f(shader.fixPointSize_loc, 5.0);
	gl.uniform1i(shader.bUseFixPointSize_loc, true);
	
	this.points3dList.renderLines(magoManager, shader, renderType, bLoop, bEnableDepth);
	
	shader.disableVertexAttribArrayAll();
};

/**
 * Rendering this feature
 * @param magoManager
 * @param shader
 * @param renderType
 * @param bEnableDepth
 * 
 */
GeographicCoordsList.prototype.renderPoints = function(magoManager, shader, renderType, bEnableDepth) 
{
	if (this.geographicCoordsArray === undefined)
	{ return false; }
	
	var gl = magoManager.sceneState.gl;
	
	//var vertexAttribsCount = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
	//for(var i = 0; i<vertexAttribsCount; i++)
	//	gl.disableVertexAttribArray(i);

	var shaderLocal = magoManager.postFxShadersManager.getShader("pointsCloud"); // provisional. Use the currentShader of argument.
	shaderLocal.useProgram();
	
	shaderLocal.disableVertexAttribArrayAll();
	shaderLocal.resetLastBuffersBinded();

	shaderLocal.enableVertexAttribArray(shaderLocal.position3_loc);
	
	shaderLocal.bindUniformGenerals();
	
	gl.uniform1i(shaderLocal.bPositionCompressed_loc, false);
	gl.uniform1i(shaderLocal.bUse1Color_loc, true);
	gl.uniform4fv(shaderLocal.oneColor4_loc, [1.0, 1.0, 0.1, 1.0]); //.
	gl.uniform1f(shaderLocal.fixPointSize_loc, 5.0);
	gl.uniform1i(shaderLocal.bUseFixPointSize_loc, 1);
	
	if (bEnableDepth === undefined)
	{ bEnableDepth = true; }
	
	if (bEnableDepth)
	{ gl.enable(gl.DEPTH_TEST); }
	else
	{ gl.disable(gl.DEPTH_TEST); }

	// Render pClouds.
	var geoCoord;
	var geoCoordsCount = this.geographicCoordsArray.length;
	for (var i=0; i<geoCoordsCount; i++)
	{
		geoCoord = this.geographicCoordsArray[i];
		geoCoord.renderPoint(magoManager, shaderLocal, gl, renderType);
	}
	
	// Check if exist selectedGeoCoord.
	var currSelected = magoManager.selectionManager.getSelectedGeneral();
	if (currSelected !== undefined && currSelected.constructor.name === "GeographicCoord")
	{
		gl.uniform4fv(shaderLocal.oneColor4_loc, [1.0, 0.1, 0.1, 1.0]); //.
		gl.uniform1f(shaderLocal.fixPointSize_loc, 10.0);
		currSelected.renderPoint(magoManager, shaderLocal, gl, renderType);
	}
	
	shaderLocal.disableVertexAttribArrayAll();
	gl.enable(gl.DEPTH_TEST);
	
	// Write coords.
	var canvas = magoManager.getObjectLabel();
	var ctx = canvas.getContext("2d");
	ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
	ctx.font = "13px Arial";

	var gl = magoManager.sceneState.gl;
	var worldPosition;
	var screenCoord;
	for (var i=0; i<geoCoordsCount; i++)
	{
		geoCoord = this.geographicCoordsArray[i];
		var geoLocDataManager = geoCoord.getGeoLocationDataManager();
		var geoLoc = geoLocDataManager.getCurrentGeoLocationData();
		worldPosition = geoLoc.position;
		screenCoord = ManagerUtils.calculateWorldPositionToScreenCoord(gl, worldPosition.x, worldPosition.y, worldPosition.z, screenCoord, magoManager);
		screenCoord.x += 15;
		screenCoord.y -= 15;
		//var geoCoords = geoLoc.geographicCoord;
		if (screenCoord.x >= 0 && screenCoord.y >= 0)
		{
			var word = "lon: " + geoCoord.longitude.toFixed(5) + ", lat: " + geoCoord.latitude.toFixed(5);
			ctx.strokeText(word, screenCoord.x, screenCoord.y);
			ctx.fillText(word, screenCoord.x, screenCoord.y);
		}
	}
	ctx.restore();
	
	// return the current shader.
	shader.useProgram();
};

/**
 * Change Point3D features from WGS84 Points
 * @param resultPoint3DArray the target
 */
GeographicCoordsList.prototype.getWgs84Points3D = function(resultPoint3DArray) 
{
	if (resultPoint3DArray === undefined)
	{ resultPoint3DArray = []; }
	
	var geoCoord;
	var geoCoordsCount = this.geographicCoordsArray.length;
	for (var i=0; i<geoCoordsCount; i++)
	{
		geoCoord = this.geographicCoordsArray[i];
		var wgs84Point3d = geoCoord.getWgs84Point3D(undefined);
		resultPoint3DArray.push(wgs84Point3d);
	}
	
	return resultPoint3DArray;
};










































'use strict';

/**
 * Bouonding box which has vertexs represented as lon,lat,alt.
 * @class GeographicExtent
 */
var GeographicExtent = function(minLon, minLat, minAlt, maxLon, maxLat, maxAlt) 
{
	if (!(this instanceof GeographicExtent)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.minGeographicCoord;
	this.maxGeographicCoord;
	
	if (minLon !== undefined && minLat !== undefined && minAlt !== undefined)
	{
		if (this.minGeographicCoord === undefined)
		{ this.minGeographicCoord = new GeographicCoord(); }
		
		this.minGeographicCoord.setLonLatAlt(minLon, minLat, minAlt);
	}
	
	if (maxLon !== undefined && maxLat !== undefined && maxAlt !== undefined)
	{
		if (this.maxGeographicCoord === undefined)
		{ this.maxGeographicCoord = new GeographicCoord(); }
		
		this.maxGeographicCoord.setLonLatAlt(maxLon, maxLat, maxAlt);
	}
};

/**
 * Clear the value of this instance
 */
GeographicExtent.prototype.deleteObjects = function() 
{
	if (this.minGeographicCoord !== undefined)
	{
		this.minGeographicCoord.deleteObjects();
		this.minGeographicCoord = undefined;
	}
	
	if (this.maxGeographicCoord !== undefined)
	{
		this.maxGeographicCoord.deleteObjects();
		this.maxGeographicCoord = undefined;
	}
};

/**
 * set the value of this instance
 * @param minLon the value of lon of the lower bound
 * @param minLat the value of lat of the lower bound
 * @param minAlt the value of alt of the lower bound
 * @param maxLon the value of lon of the lower bound
 * @param maxLat the value of lat of the lower bound
 * @param maxAlt the value of alt of the lower bound
 */
GeographicExtent.prototype.setExtent = function(minLon, minLat, minAlt, maxLon, maxLat, maxAlt) 
{
	if (this.minGeographicCoord === undefined)
	{ this.minGeographicCoord = new GeographicCoord(); }
	
	this.minGeographicCoord.setLonLatAlt(minLon, minLat, minAlt);
	
	if (this.maxGeographicCoord === undefined)
	{ this.maxGeographicCoord = new GeographicCoord(); }
	
	this.maxGeographicCoord.setLonLatAlt(maxLon, maxLat, maxAlt);
};

/**
 * set the value of this instance
 * @param lon
 * @param lat
 * @param alt
 */
GeographicExtent.prototype.setInitExtent = function(lon, lat, alt) 
{
	this.setExtent(lon, lat, alt, lon, lat, alt);
};

/**
 * set the value of this instance
 * @param lon
 * @param lat
 * @param alt
 */
GeographicExtent.prototype.addGeographicCoord = function(geoCoord) 
{
	var lon = geoCoord.longitude;
	var lat = geoCoord.latitude;
	var alt = geoCoord.altitude;
	
	if (this.minGeographicCoord === undefined)
	{ 
		this.minGeographicCoord = new GeographicCoord(); 
		this.minGeographicCoord.setLonLatAlt(lon, lat, alt);
	}
	else 
	{
		if (lon < this.minGeographicCoord.longitude)
		{ this.minGeographicCoord.setLongitude(lon); }
		
		if (lat < this.minGeographicCoord.latitude)
		{ this.minGeographicCoord.setLatitude(lat); }
		
		if (alt < this.minGeographicCoord.altitude)
		{ this.minGeographicCoord.setAltitude(alt); }
	}
	
	if (this.maxGeographicCoord === undefined)
	{ 
		this.maxGeographicCoord = new GeographicCoord(); 
		this.maxGeographicCoord.setLonLatAlt(lon, lat, alt);
	}
	else 
	{
		if (lon > this.maxGeographicCoord.longitude)
		{ this.maxGeographicCoord.setLongitude(lon); }
		
		if (lat > this.maxGeographicCoord.latitude)
		{ this.maxGeographicCoord.setLatitude(lat); }
		
		if (alt > this.maxGeographicCoord.altitude)
		{ this.maxGeographicCoord.setAltitude(alt); }
	}
};

GeographicExtent.prototype.getCenterLongitude = function() 
{
	var minLon = this.minGeographicCoord.longitude;
	var maxLon = this.maxGeographicCoord.longitude;
	return (maxLon+minLon)/2;
};

GeographicExtent.prototype.getCenterLatitude = function() 
{
	var minLat = this.minGeographicCoord.latitude;
	var maxLat = this.maxGeographicCoord.latitude;
	return (maxLat+minLat)/2;
};

GeographicExtent.prototype.getCenterAltitude = function() 
{
	var minAlt = this.minGeographicCoord.altitude;
	var maxAlt = this.maxGeographicCoord.altitude;
	return (maxAlt+minAlt)/2;
};

/**
 * Returns the middle point of the lower bound point and uppper bound point
 * @param resultGeographicCoord the point which will save the result
 * @returns {GeographicCoord}
 */
GeographicExtent.prototype.getMidPoint = function(resultGeographicCoord) 
{
	return GeographicCoord.getMidPoint(this.minGeographicCoord, this.maxGeographicCoord, resultGeographicCoord);
};

/**
 * Returns the minimum latitude in radians.
 * @returns {Number}
 */
GeographicExtent.prototype.getMinLatitudeRad = function() 
{
	if (this.minGeographicCoord === undefined)
	{ return; }
	
	return this.minGeographicCoord.getLatitudeRad();
};

/**
 * Returns the minimum latitude in radians.
 * @returns {Number}
 */
GeographicExtent.prototype.getMinAltitude = function() 
{
	if (this.minGeographicCoord === undefined)
	{ return; }
	
	return this.minGeographicCoord.altitude;
};

/**
 * Returns the minimum latitude in radians.
 * @returns {Number}
 */
GeographicExtent.prototype.getMaxAltitude = function() 
{
	if (this.maxGeographicCoord === undefined)
	{ return; }
	
	return this.maxGeographicCoord.altitude;
};

/**
 * Returns the minimum longitude in radians.
 * @returns {Number}
 */
GeographicExtent.prototype.getMinLongitudeRad = function() 
{
	if (this.minGeographicCoord === undefined)
	{ return; }
	
	return this.minGeographicCoord.getLongitudeRad();
};

/**
 * Returns the maximum latitude in radians.
 * @returns {Number}
 */
GeographicExtent.prototype.getMaxLatitudeRad = function() 
{
	if (this.maxGeographicCoord === undefined)
	{ return; }
	
	return this.maxGeographicCoord.getLatitudeRad();
};

/**
 * Returns the maximum longitude in radians.
 * @returns {Number}
 */
GeographicExtent.prototype.getMaxLongitudeRad = function() 
{
	if (this.maxGeographicCoord === undefined)
	{ return; }
	
	return this.maxGeographicCoord.getLongitudeRad();
};

GeographicExtent.prototype.intersects2dWithGeoCoord = function(geoCoord) 
{
	// In 2D intersection do not considere "altitude".
	var lon = geoCoord.longitude;
	var lat = geoCoord.latitude;
	
	if (lon > this.minGeographicCoord.longitude && lon < this.maxGeographicCoord.longitude)
	{
		if (lat > this.minGeographicCoord.latitude && lat < this.maxGeographicCoord.latitude)
		{
			return true;
		}
	}
	
	return false;
};


















































'use strict';

/**
 * GeoLocationData is a class object that contains axis information about the location on "geographicCoord".
 * 
 * @class GeoLocationData
 * @constructor 
 * @param {string} geoLocationDataName The name of the geoLocationData.
 */
var GeoLocationData = function(geoLocationDataName) 
{
	if (!(this instanceof GeoLocationData)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	/**
	 * The name of this geographicLocationData.
	 * @type {String}
	 * @default "noName"
	 */
	this.name;
	
	if (geoLocationDataName === undefined) { this.name = "noName"; }
	else { this.name = geoLocationDataName; }
	
	/**
	 * The geographic location (Longitude, Latitude, Altitude). This is the main data of this class.
	 * @type {GeographicCoord}
	 * @default undefined
	 */
	this.geographicCoord; 
	
	/**
	 * The z-axis rotation.
	 * @type {Number}
	 * @default 0
	 */
	this.heading;
	
	/**
	 * The x-axis rotation.
	 * @type {Number}
	 * @default 0
	 */
	this.pitch;
	
	/**
	 * The y-axis rotation.
	 * @type {Number}
	 * @default 0
	 */
	this.roll;
	
	/**
	 * The date relationed with this geoLocationData.
	 * @type {Date}
	 * @default undefined
	 */
	this.date; // year - month - day - hour - min - seg - miliseg.
	
	/**
	 * The position in world coordinates (x, y, z) of this geoLocationData.
	 * @type {Point3D}
	 * @default (0,0,0).
	 */
	this.position;   
	
	/**
	 * The high part of the splitted position.
	 * @type {Float32Array(3)}
	 * @default [0,0,0]
	 */
	this.positionHIGH; 
	
	/**
	 * The low part of the splitted position.
	 * @type {Float32Array(3)}
	 * @default [0,0,0]
	 */
	this.positionLOW; 
	
	/**
	 * The effective absoluteCoord (x, y, z) of this geoLocationData.
	 * @type {Point3D}
	 * @default (0,0,0).
	 */
	this.pivotPoint; // Actual position = pivotPoint.
	
	/**
	 * The transformation matrix of the geographicCoord. This matrix no includes Heading, Pitch or Roll rotations.
	 * @type {Matrix4}
	 * @default Identity matrix.
	 */
	this.geoLocMatrix; 
	
	/**
	 * The inverse of the transformation matrix of the geographicCoord. This matrix no includes Heading, Pitch or Roll rotations.
	 * @type {Matrix4}
	 * @default Identity matrix.
	 */
	this.geoLocMatrixInv; 
	
	/**
	 * The transformation matrix of the geographicCoord. This matrix includes Heading, Pitch or Roll rotations.
	 * @type {Matrix4}
	 * @default Identity matrix.
	 */
	this.tMatrix;      
	
	/**
	 * The inverse of the transformation matrix of the geographicCoord. This matrix includes Heading, Pitch or Roll rotations.
	 * @type {Matrix4}
	 * @default Identity matrix.
	 */
	this.tMatrixInv;   
	
	/**
	 * The rotation matrix of the geographicCoord. This matrix includes Heading, Pitch or Roll rotations.
	 * @type {Matrix4}
	 * @default Identity matrix.
	 */
	this.rotMatrix;    
	
	/**
	 * The inverse of the rotation matrix of the geographicCoord. This matrix includes Heading, Pitch or Roll rotations.
	 * @type {Matrix4}
	 * @default Identity matrix.
	 */
	this.rotMatrixInv; 
	
	/**
	 * The translation in local coordinates(x, y, z) of this geoLocationData.
	 * @type {Point3D}
	 * @default undefined
	 */
	this.pivotPointTraslationLC; 
	
	/**
	 * The local rotation matrix. This matrix uses only Heading, Pitch or Roll rotations.
	 * @type {Matrix4}
	 * @default Identity matrix.
	 */
	this.rotMatrixLC; 
};

/**
 * Sets the parameters Heading, pitch and Roll.
 * @param {Number} heading The heading value in degrees.
 * @param {Number} pitch The pitch value in degrees.
 * @param {Number} roll The roll value in degrees.
 */
GeoLocationData.prototype.setRotationHeadingPitchRoll = function(heading, pitch, roll) 
{
	// Note: Sets the parameters if exist argument.
	if (heading !== undefined)
	{ this.heading = heading; }
	
	if (pitch !== undefined)
	{ this.pitch = pitch; }

	if (roll !== undefined)
	{ this.roll = roll; }
};

/**
 * Returns the geographic coordinates.
 * @Returns {GeographicCoord} this.geographicCoord
 */
GeoLocationData.prototype.getGeographicCoords = function() 
{
	return this.geographicCoord;
};

/**
 * Sets the parameters Longitude, Latitude and Altitude of the geographic coordinates.
 * @param {Number} longitude The longitude in degrees.
 * @param {Number} latitude The latitude in degrees.
 * @param {Number} altitude The altitude in meters.
 */
GeoLocationData.prototype.setGeographicCoordsLonLatAlt = function(longitude, latitude, altitude) 
{
	if (this.geographicCoord === undefined)
	{ this.geographicCoord = new GeographicCoord(); }
	
	this.geographicCoord.setLonLatAlt(longitude, latitude, altitude);
};

/**
 * Deletes all objects of this class.
 @param {VboMemoryManager} vboMemManager The manager and controller of the gpu memory.
 */
GeoLocationData.prototype.deleteObjects = function(vboMemManager) 
{
	this.name = undefined;
	if (this.geographicCoord)
	{ this.geographicCoord.deleteObjects(vboMemManager); }
	this.geographicCoord = undefined;
	
	this.heading = undefined;
	this.pitch = undefined;
	this.roll = undefined;
	
	this.date = undefined; 
	
	if (this.position)
	{ this.position.deleteObjects(); }  
	this.position = undefined;
	this.positionHIGH = undefined;
	this.positionLOW = undefined; 
	if (this.pivotPoint)
	{ this.pivotPoint.deleteObjects(); }  
	this.pivotPoint = undefined;
	
	// F4D Matrix4.*
	if (this.geoLocMatrix)
	{ this.geoLocMatrix.deleteObjects(); }
	if (this.geoLocMatrixInv)
	{ this.geoLocMatrixInv.deleteObjects(); }
	if (this.tMatrix)
	{ this.tMatrix.deleteObjects(); } 
	if (this.tMatrixInv)
	{ this.tMatrixInv.deleteObjects(); } 
	if (this.rotMatrix)
	{ this.rotMatrix.deleteObjects(); }  
	if (this.rotMatrixInv)
	{ this.rotMatrixInv.deleteObjects(); } 
	
	this.geoLocMatrix = undefined;
	this.geoLocMatrixInv = undefined; 
	this.tMatrix = undefined;     
	this.tMatrixInv = undefined;  
	this.rotMatrix = undefined;   
	this.rotMatrixInv = undefined; 
	
	// Aditional.
	if (this.pivotPointTraslationLC)
	{ this.pivotPointTraslationLC.deleteObjects(); }
	this.pivotPointTraslationLC = undefined;
};

/**
 * Adds the translation vector into position.
 */
GeoLocationData.prototype.doEffectivePivotPointTranslation = function() 
{
	// this function adds the "pivotPointTraslation" to the positions.
	// this function is not for move the building on the globe. This function is only for translate the pivot point of the building.
	// Note: the translation vector only must be added into "this.pivotPoint". TODO:
	var traslationVector;
	if (this.pivotPointTraslationLC === undefined)
	{ 
		traslationVector = new Point3D(0, 0, 0);
	}
	else 
	{
		traslationVector = this.tMatrix.rotatePoint3D(this.pivotPointTraslationLC, traslationVector );
	}
	
	// Recalculate the position.
	var geoCoord = this.geographicCoord;
	this.position = ManagerUtils.geographicCoordToWorldPoint(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude, this.position);

	// High and Low values of the position.**
	if (this.positionHIGH === undefined)
	{ this.positionHIGH = new Float32Array([0.0, 0.0, 0.0]); }
	if (this.positionLOW === undefined)
	{ this.positionLOW = new Float32Array([0.0, 0.0, 0.0]); }
	ManagerUtils.calculateSplited3fv([this.position.x, this.position.y, this.position.z], this.positionHIGH, this.positionLOW);
	
	this.position.x += traslationVector.x;
	this.position.y += traslationVector.y;
	this.position.z += traslationVector.z;

	this.positionLOW[0] += traslationVector.x;
	this.positionLOW[1] += traslationVector.y;
	this.positionLOW[2] += traslationVector.z;

	if (this.pivotPoint === undefined)
	{ this.pivotPoint = new Point3D(); }

	this.pivotPoint.set(this.position.x, this.position.y, this.position.z);
};


/**
 * Copies all data of this class into the return geoLoctationData.
 *@param {GeoLocationData} 
 */
GeoLocationData.prototype.copyFrom = function(geoLocData) 
{
	if (geoLocData === undefined)
	{ return; }
	
	this.name = geoLocData.name;
	if (geoLocData.geographicCoord)
	{
		if (this.geographicCoord === undefined)
		{ this.geographicCoord = new GeographicCoord(); }
		
		this.geographicCoord.copyFrom(geoLocData.geographicCoord); // longitude, latitude, altitude.
	}
	
	this.heading = geoLocData.heading;
	this.pitch = geoLocData.pitch;
	this.roll = geoLocData.roll;
	
	this.date = geoLocData.date; // year - month - day - hour - min - seg - miliseg.
	
	if (geoLocData.position)
	{
		if (this.position === undefined)
		{ this.position = new Point3D(); }
		this.position.copyFrom(geoLocData.position);
	}
	if (geoLocData.positionHIGH)
	{
		if (this.positionHIGH === undefined)
		{ this.positionHIGH = new Float32Array(3); }
		
		this.positionHIGH[0]= geoLocData.positionHIGH[0];
		this.positionHIGH[1]= geoLocData.positionHIGH[1];
		this.positionHIGH[2]= geoLocData.positionHIGH[2];
	}
	if (geoLocData.positionLOW)
	{
		if (this.positionLOW === undefined)
		{ this.positionLOW = new Float32Array(3); }
		
		this.positionLOW[0]= geoLocData.positionLOW[0];
		this.positionLOW[1]= geoLocData.positionLOW[1];
		this.positionLOW[2]= geoLocData.positionLOW[2];
	}
	if (geoLocData.pivotPoint)
	{
		if (this.pivotPoint === undefined)
		{ this.pivotPoint = new Point3D(); }
		
		this.pivotPoint.copyFrom(geoLocData.pivotPoint);
	}
	
	// F4D Matrix4.*
	if (geoLocData.geoLocMatrix)
	{
		if (this.geoLocMatrix === undefined)
		{ this.geoLocMatrix = new Matrix4(); }
		
		this.geoLocMatrix.copyFromMatrix4(geoLocData.geoLocMatrix);
	}
	if (geoLocData.geoLocMatrixInv)
	{
		if (this.geoLocMatrixInv === undefined)
		{ this.geoLocMatrixInv = new Matrix4(); }
		
		this.geoLocMatrixInv.copyFromMatrix4(geoLocData.geoLocMatrixInv);
	}
	if (geoLocData.tMatrix)
	{
		if (this.tMatrix === undefined)
		{ this.tMatrix = new Matrix4(); }
		
		this.tMatrix.copyFromMatrix4(geoLocData.tMatrix);
	}
	if (geoLocData.tMatrixInv)
	{
		if (this.tMatrixInv === undefined)
		{ this.tMatrixInv = new Matrix4(); }
		
		this.tMatrixInv.copyFromMatrix4(geoLocData.tMatrixInv);
	}
	if (geoLocData.rotMatrix)
	{
		if (this.rotMatrix === undefined)
		{ this.rotMatrix = new Matrix4(); }
		
		this.rotMatrix.copyFromMatrix4(geoLocData.rotMatrix);
	}
	if (geoLocData.rotMatrixInv)
	{
		if (this.rotMatrixInv === undefined)
		{ this.rotMatrixInv = new Matrix4(); }
		
		this.rotMatrixInv.copyFromMatrix4(geoLocData.rotMatrixInv);
	}
	
	if (geoLocData.aditionalTraslation)
	{
		if (this.aditionalTraslation === undefined)
		{ this.aditionalTraslation = new Point3D(); }
		
		this.aditionalTraslation.copyFrom(geoLocData.aditionalTraslation);
	}
	
};

/**
 * This function transforms a local position of this geoLocation to world position.
 * @param localCoord  instance of Point3D.
 * @param resultWorldCoord. instance of Point3D.
 * @returns resultWorldCoord. instance of Point3D.
 */
GeoLocationData.prototype.localCoordToWorldCoord = function(localCoord, resultWorldCoord) 
{
	if (localCoord === undefined || this.tMatrix === undefined)
	{ return undefined; }
	
	if (resultWorldCoord === undefined)
	{ resultWorldCoord = new Point3D(); }
	
	resultWorldCoord = this.tMatrix.transformPoint3D(localCoord, resultWorldCoord); 
	return resultWorldCoord;
};

/**
 * This function transforms an absolute position to local position for this geoLocation.
 * @param worldCoord  instance of Point3D.
 * @param resultLocalCoord. instance of Point3D.
 * @returns resultLocalCoord. instance of Point3D.
 */
GeoLocationData.prototype.worldCoordToLocalCoord = function(worldCoord, resultLocalCoord) 
{
	var tMatrixInv = this.getTMatrixInv();
	if (worldCoord === undefined || tMatrixInv === undefined)
	{ return undefined; }
	
	if (resultLocalCoord === undefined)
	{ resultLocalCoord = new Point3D(); }
	
	resultLocalCoord = tMatrixInv.transformPoint3D(worldCoord, resultLocalCoord); 
	return resultLocalCoord;
};

/**
 * 
 * @returns this.locMatrixInv.
 */
GeoLocationData.prototype.getLocMatrixInv = function() 
{
	if (this.geoLocMatrixInv === undefined)
	{
		var locMatrixInv = glMatrix.mat4.create();
		locMatrixInv = glMatrix.mat4.invert(locMatrixInv, this.geoLocMatrix._floatArrays );
		
		this.geoLocMatrixInv = new Matrix4();
		this.geoLocMatrixInv.setByFloat32Array(locMatrixInv);
	}
	
	return this.geoLocMatrixInv;
};

/**
 * 
 * @returns this.rotMatrixInv.
 */
GeoLocationData.prototype.getRotMatrixInv = function() 
{
	if (this.rotMatrixInv === undefined)
	{
		var rotMatrixInv = glMatrix.mat4.create();
		rotMatrixInv = glMatrix.mat4.invert(rotMatrixInv, this.rotMatrix._floatArrays );
		
		this.rotMatrixInv = new Matrix4();
		this.rotMatrixInv.setByFloat32Array(rotMatrixInv);
	}
	
	return this.rotMatrixInv;
};

/**
 * 
 * @returns this.tMatrixInv.
 */
GeoLocationData.prototype.getTMatrixInv = function() 
{
	if (this.tMatrixInv === undefined)
	{
		var tMatrixInv = glMatrix.mat4.create();
		tMatrixInv = glMatrix.mat4.invert(tMatrixInv, this.tMatrix._floatArrays);
		
		this.tMatrixInv = new Matrix4();
		this.tMatrixInv.setByFloat32Array(tMatrixInv);
	}
	
	return this.tMatrixInv;
};

/**
 * 
 * @returns this.rotMatrixLC.
 */
GeoLocationData.prototype.getRotMatrixLC = function() 
{
	if (this.rotMatrixLC === undefined)
	{
		var xRotMatrix = new Matrix4();  // created as identity matrix.
		var yRotMatrix = new Matrix4();  // created as identity matrix.
		var zRotMatrix = new Matrix4();  // created as identity matrix.
		var heading = this.heading;
		var pitch = this.pitch;
		var roll = this.roll;
		
		if (heading !== undefined && heading !== 0)
		{ zRotMatrix.rotationAxisAngDeg(heading, 0.0, 0.0, 1.0); }

		if (pitch !== undefined && pitch !== 0)
		{ xRotMatrix.rotationAxisAngDeg(pitch, 1.0, 0.0, 0.0); }

		if (roll !== undefined && roll !== 0)
		{ yRotMatrix.rotationAxisAngDeg(roll, 0.0, 1.0, 0.0); }
		
		var resultTransformMatrix = new Matrix4();   // created as identity matrix.
		
		var zRotatedTMatrix;
		var zxRotatedTMatrix;
		var zxyRotatedTMatrix;

		zRotatedTMatrix = zRotMatrix.getMultipliedByMatrix(resultTransformMatrix, zRotatedTMatrix);
		zxRotatedTMatrix = xRotMatrix.getMultipliedByMatrix(zRotatedTMatrix, zxRotatedTMatrix);
		zxyRotatedTMatrix = yRotMatrix.getMultipliedByMatrix(zxRotatedTMatrix, zxyRotatedTMatrix);
		
		this.rotMatrixLC = zxyRotatedTMatrix;
	}
	
	return this.rotMatrixLC;
};

/**
 * 
 * @returns this.geoLocMatrixInv.
 */
GeoLocationData.prototype.getGeoLocationMatrixInv = function() 
{
	if (this.geoLocMatrixInv === undefined)
	{
		var geoLocMatrixInv = glMatrix.mat4.create();
		geoLocMatrixInv = glMatrix.mat4.invert(geoLocMatrixInv, this.geoLocMatrix._floatArrays  );
		
		this.geoLocMatrixInv = new Matrix4();
		this.geoLocMatrixInv.setByFloat32Array(geoLocMatrixInv);
	}
	
	return this.geoLocMatrixInv;
};

/**
 * This function transforms an absolute camera (world coord) into a relative camera (local coord) for this geoLocation.
 * @param absoluteCamera instance of Camera. 
 * @param resultCamera instance of Camera. This is the transformed camera.
 * @returns resultCamera
 */
GeoLocationData.prototype.getTransformedRelativeCamera = function(absoluteCamera, resultCamera) 
{
	if (resultCamera === undefined)
	{ resultCamera = new Camera(); }
	
	var pointAux = new Point3D();
	
	pointAux.set(absoluteCamera.position.x - this.position.x, 
		absoluteCamera.position.y - this.position.y, 
		absoluteCamera.position.z - this.position.z);
		
	var rotMatInv = this.getRotMatrixInv();
	
	resultCamera.position = rotMatInv.transformPoint3D(pointAux, resultCamera.position);
	
	pointAux.set(absoluteCamera.direction.x, absoluteCamera.direction.y, absoluteCamera.direction.z);
	resultCamera.direction = rotMatInv.transformPoint3D(pointAux, resultCamera.direction);
	
	pointAux.set(absoluteCamera.up.x, absoluteCamera.up.y, absoluteCamera.up.z);
	resultCamera.up = rotMatInv.transformPoint3D(pointAux, resultCamera.up);
  
	pointAux.x = undefined;
	pointAux.y = undefined;
	pointAux.z = undefined;
	pointAux = undefined;
	
	return resultCamera;
};

/**
 * 
 */
GeoLocationData.prototype.getTransformedRelativePositionNoApplyHeadingPitchRoll = function(absolutePosition, resultRelativePosition) 
{
	if (resultRelativePosition === undefined)
	{ resultRelativePosition = new Point3D(); }
	
	var pointAux = new Point3D();
	
	pointAux.set(absolutePosition.x, 
		absolutePosition.y, 
		absolutePosition.z);
	var locMatInv = this.getLocMatrixInv();
	resultRelativePosition = locMatInv.transformPoint3D(pointAux, resultRelativePosition);
	
	return resultRelativePosition;
};

/**
 * Change the absolute coordinate feature to relative coordinate feature
 * @param absolutePosition
 * @param {Point3D} resultRelativePosition
 */
GeoLocationData.prototype.getTransformedRelativePosition = function(absolutePosition, resultRelativePosition) 
{
	if (resultRelativePosition === undefined)
	{ resultRelativePosition = new Point3D(); }
	
	var pointAux = new Point3D();
	
	pointAux.set(absolutePosition.x - this.position.x, 
		absolutePosition.y - this.position.y, 
		absolutePosition.z - this.position.z);
	var rotMatInv = this.getRotMatrixInv();
	resultRelativePosition = rotMatInv.transformPoint3D(pointAux, resultRelativePosition);
	
	return resultRelativePosition;
};

/**
 * Change the absolute direction(vector) feature to relative direction(vector) feature
 * @param absoluteVector
 * @param {Point3D} resultRelativeVector
 */
GeoLocationData.prototype.getRotatedRelativeVector = function(absoluteVector, resultRelativeVector) 
{
	if (resultRelativeVector === undefined)
	{ resultRelativeVector = new Point3D(); }

	var pointAux = new Point3D(absoluteVector[0], absoluteVector[1], absoluteVector[2]);
	
	var rotMatInv = this.getRotMatrixInv();
	resultRelativeVector = rotMatInv.transformPoint3D(pointAux, resultRelativeVector);
	
	return resultRelativeVector;
};

/**
 * This function transforms an absolute camera (world coord) into a relative camera (local coord) for this geoLocation.
 */
GeoLocationData.prototype.getTransformedRelativePositionsArray = function(absolutePositionsArray, resultRelativePositionsArray) 
{
	if (absolutePositionsArray === undefined)
	{ return resultRelativePositionsArray; }
	
	if (resultRelativePositionsArray === undefined)
	{ resultRelativePositionsArray = []; }
	
	var absolutePoints3dCount = absolutePositionsArray.length;
	for (var i=0; i<absolutePoints3dCount; i++)
	{
		var relPoint3d = this.getTransformedRelativePosition(absolutePositionsArray[i], undefined);
		resultRelativePositionsArray.push(relPoint3d);
	}
	
	return resultRelativePositionsArray;
};

/**
 */
GeoLocationData.prototype.bindGeoLocationUniforms = function(gl, shader) 
{
	if (this.rotMatrix === undefined)
	{ var hola = 0; }
	
	gl.uniformMatrix4fv(shader.buildingRotMatrix_loc, false, this.rotMatrix._floatArrays);
	gl.uniform3fv(shader.buildingPosHIGH_loc, [this.positionHIGH[0], this.positionHIGH[1], this.positionHIGH[2]]);
	gl.uniform3fv(shader.buildingPosLOW_loc, [this.positionLOW[0], this.positionLOW[1], this.positionLOW[2]]);
};



'use strict';


/**
 * GeoLocationDataManager is a class object that contains GeoLocationData objects in an array.
 * 
 * @class GeoLocationDataManager
 * @constructor 
 */
var GeoLocationDataManager = function() 
{
	if (!(this instanceof GeoLocationDataManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.geoLocationDataArray = [];
	this.geoLocationDataArrayMaxLengthAllowed = 15;
};

/**
 * Clear all object of GeoLocationDataManager
 */
GeoLocationDataManager.prototype.deleteObjects = function() 
{
	if (this.geoLocationDataArray)
	{
		for (var i=0; i<this.geoLocationDataArray.length; i++)
		{
			this.geoLocationDataArray[i].deleteObjects();
			this.geoLocationDataArray[i] = undefined;
		}
		this.geoLocationDataArray = [];
	}
};

/**
 * Remove the latest GeoLocationData instance
 */
GeoLocationDataManager.prototype.popGeoLocationData = function() 
{
	this.geoLocationDataArray.pop();
};

/**
 * put the geoLocationData from this.geoLocationDataArray
 * @param geoLocationName 변수
 */
GeoLocationDataManager.prototype.newGeoLocationData = function(geoLocationName) 
{
	var currGeoLocData = this.getCurrentGeoLocationData();
	
	if (geoLocationName === undefined)
	{ geoLocationName = "noName" + this.geoLocationDataArray.length.toString(); }
	var geoLocationData = new GeoLocationData(geoLocationName);
	this.geoLocationDataArray.unshift(geoLocationData);
	
	if (this.geoLocationDataArray.length > this.geoLocationDataArrayMaxLengthAllowed)
	{
		this.geoLocationDataArray.pop();
		// delete extracted geoLocdata. TODO:
	}
	
	if (currGeoLocData)
	{
		// If exist a geoLocationData previous, then copy from it.
		geoLocationData.copyFrom(currGeoLocData);
	}

	return geoLocationData;
};

/**
 * put the geoLocationData from this.geoLocationDataArray
 * @param geoLocationName 변수
 */
GeoLocationDataManager.prototype.addGeoLocationData = function(geoLocData) 
{
	this.geoLocationDataArray.unshift(geoLocData);
	
	if (this.geoLocationDataArray.length > this.geoLocationDataArrayMaxLengthAllowed)
	{
		this.geoLocationDataArray.pop();
		// delete extracted geoLocdata. TODO:
	}
};

/**
 * return the length of this geoLocationDataArray
 * @returns {Number} the length of this geoLocationDataArray
 */
GeoLocationDataManager.prototype.getGeoLocationDatasCount = function() 
{
	return this.geoLocationDataArray.length;
};

/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param {Number} idx
 * @returns this.geoLoactionDataArray[idx]
 */
GeoLocationDataManager.prototype.getGeoLocationData = function(idx) 
{
	if (idx > this.geoLocationDataArray.length - 1)
	{ return undefined; }
	return this.geoLocationDataArray[idx];
};

/**
 * provisionally return the first data of GeoLocationDataArray
 * @class GeoLocationData
 * @param {Number}idx
 * @returns {GeoLocationData}this.geoLoactionDataArray[idx]
 */
GeoLocationDataManager.prototype.getCurrentGeoLocationData = function() 
{
	if (this.geoLocationDataArray.length === 0)
	{
		return undefined;
	}
	return this.geoLocationDataArray[0]; // provisionally return the 1rst.
};
'use strict';

/**
 * This class is used to assume the real globe of earth as ellipsoid
 * @class Globe
 */
var Globe = function() 
{
	if (!(this instanceof Globe)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	//WGS 84.
	// Extracted from WikiPedia "Geodetic datum".
	// WGS 84 Defining Parameters
	// semi-major axis	a	6378137.0 m
	// Reciprocal of flattening	1/f	298.257223563
	
	// WGS 84 derived geometric constants
	// Semi-minor axis	b = a(1 − f)	6356752.3142 m
	// First eccentricity squared	e2 = (1 − b2/a2 = 2f − f2) =	6.69437999014 x 10−3
	// Second eccentricity squared	e′2	= (a2/b2 − 1 = f(2 − f)/(1 − f)2) = 6.73949674228 x 10−3
	//----------------------------------------------------------
	
	this.equatorialRadius = 6378137.0; // meters.
	this.polarRadius = 6356752.3142; // meters.
	this.firstEccentricitySquared = 6.69437999014E-3;
	this.secondEccentricitySquared = 6.73949674228E-3;
	this.degToRadFactor = Math.PI/180.0;
};

/**
 * @returns {Number} equatorial Radius
 */
Globe.equatorialRadius = function()
{
	return 6378137.0;
};

/**
 * @returns {Number}
 */
Globe.equatorialRadiusSquared = function()
{
	return 40680631590769.0;
};

/**
 * @returns {Number}
 */
Globe.polarRadius = function()
{
	return 6356752.3142;
};

/**
 * @returns {Number}
 */
Globe.polarRadiusSquared = function()
{
	return 40408299984087.05552164;
};
/**
 * This function returns the radius of earth at the latitude "latDeg".
 * @param latDeg the latitude
 * @returns {Number}
 */
Globe.radiusAtLatitudeDeg = function(latDeg)
{

	// a = equatorialRadius, b = polarRadius.
	// r = a*b / sqrt(a2*sin2(lat) + b2*cos2(lat)).
	//------------------------------------------------------
	
	var latRad = latDeg * Math.PI/180.0;
	var a = Globe.equatorialRadius();
	var b = Globe.polarRadius();
	var a2 = Globe.equatorialRadiusSquared();
	var b2 = Globe.polarRadiusSquared();
	
	var sin = Math.sin(latRad);
	var cos = Math.cos(latRad);
	var sin2 = sin*sin;
	var cos2 = cos*cos;
	
	var radius = (a*b)/(Math.sqrt(a2*sin2 + b2*cos2));
	return radius;
};

/**
 * Normalize the elements of the 3D feature
 * @param {Float32Array} cartesian this can be any feature such as a point or a axis to make unitary
 * 
 */
Globe.normalizeCartesian = function(cartesian)
{
	if (cartesian === undefined)
	{ return; }

	var modul = Math.sqrt(cartesian[0]*cartesian[0] + cartesian[1]*cartesian[1] + cartesian[2]*cartesian[2] );
	cartesian[0] /= modul;
	cartesian[1] /= modul;
	cartesian[2] /= modul;
	
	return cartesian;
};

/**
 * Change cartesian point to WGS84 and normalize that.
 * @param {Number} x the x coord value of input cartesian point
 * @param {Number} y the y coord value of input cartesian point
 * @param {Number} z the z coord value of input cartesian point
 * @param {Float32Array} resultNormal the cartesian point which will hold the calculated result
 * @returns {Float32Array} resultNormal
 */
Globe.normalAtCartesianPointWgs84 = function(x, y, z, resultNormal)
{
	if (resultNormal === undefined)
	{ resultNormal = new Float32Array(3); }
	
	var eqRad = Globe.equatorialRadius();
	var polRad = Globe.polarRadius();
	var equatorialRadiusSquared = eqRad * eqRad;
	var polarRadiusSquared = polRad * polRad;

	resultNormal[0] = x / equatorialRadiusSquared;
	resultNormal[1] = y / equatorialRadiusSquared;
	resultNormal[2] = z / polarRadiusSquared;
	
	// Normalize cartesian.
	resultNormal = Globe.normalizeCartesian(resultNormal);
	
	return resultNormal;
};

/**
 * Change cartesian point to tangent plane.
 * @param {Number} x the x coord value of input cartesian point
 * @param {Number} y the y coord value of input cartesian point
 * @param {Number} z the z coord value of input cartesian point
 * @param {Plane} resultPlane The tangent plane to globe  at x,y,z point.
 * @returns {Plane} resultPlane
 */
Globe.planeAtCartesianPointWgs84 = function(x, y, z, resultPlane)
{
	if (resultPlane === undefined)
	{ resultPlane = new Plane(); }
	
	var normal = Globe.normalAtCartesianPointWgs84(x, y, z, undefined);
	resultPlane.setPointAndNormal(x, y, z, normal[0], normal[1], normal[2]);
	
	return resultPlane;
};

/**
 * Return the transformation matrix which transform the cartesian point to wgs84
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z 
 * @param {Float32Array} float32Array
 * @returns {Float32Array} float32Array
 * 
 */
Globe.transformMatrixAtGeographicCoord = function(geoCoord, float32Array)
{
	if (geoCoord === undefined)
	{ return float32Array; }
	
	var cartesian = Globe.geographicToCartesianWgs84(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude, undefined);
	return Globe.transformMatrixAtCartesianPointWgs84(cartesian[0], cartesian[1], cartesian[2], float32Array);
};

/**
 * Return the transformation matrix which transform the cartesian point to wgs84
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z 
 * @param {Float32Array} float32Array
 * @returns {Float32Array} float32Array
 * 
 */
Globe.transformMatrixAtCartesianPointWgs84 = function(x, y, z, float32Array)
{
	var xAxis, yAxis, zAxis;
	
	zAxis = Globe.normalAtCartesianPointWgs84(x, y, z, zAxis);
	
	// Check if zAxis is vertical vector. PENDENT.
	
	// now, calculate the east direction. 
	// project zAxis to plane XY and calculate the left perpendicular.
	xAxis = new Float32Array(3);
	xAxis[0] = -y;
	xAxis[1] = x;
	xAxis[2] = 0.0;
	xAxis = Globe.normalizeCartesian(xAxis);
	
	// finally calculate the north direction.
	var xAxisVector = new Point3D(xAxis[0], xAxis[1], xAxis[2]);
	var yAxisVector = new Point3D();
	var zAxisVector = new Point3D(zAxis[0], zAxis[1], zAxis[2]);
	
	yAxisVector = zAxisVector.crossProduct(xAxisVector, yAxisVector);
	
	if (float32Array === undefined)
	{ float32Array = new Float32Array(16); }
	
	float32Array[0] = xAxisVector.x;
	float32Array[1] = xAxisVector.y;
	float32Array[2] = xAxisVector.z;
	float32Array[3] = 0.0;
	
	float32Array[4] = yAxisVector.x;
	float32Array[5] = yAxisVector.y;
	float32Array[6] = yAxisVector.z;
	float32Array[7] = 0.0;
	
	float32Array[8] = zAxisVector.x;
	float32Array[9] = zAxisVector.y;
	float32Array[10] = zAxisVector.z;
	float32Array[11] = 0.0;
	
	float32Array[12] = x;
	float32Array[13] = y;
	float32Array[14] = z;
	float32Array[15] = 1.0;
	
	return float32Array;
};

/**
 * Normalize the elements of the 3D feature
 * @param {Float32Array} cartesian this can be any feature such as a point or a axis to make unitary
 * 
 */
Globe.prototype.normalizeCartesian = function(cartesian)
{
	return Globe.normalizeCartesian(cartesian);
	/*
	if (cartesian === undefined)
	{ return; }

	var modul = Math.sqrt(cartesian[0]*cartesian[0] + cartesian[1]*cartesian[1] + cartesian[2]*cartesian[2] );
	cartesian[0] /= modul;
	cartesian[1] /= modul;
	cartesian[2] /= modul;
	
	return cartesian;
	*/
};

/**
 * Return the transformation matrix which transform the cartesian point to wgs84
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z 
 * @param {Float32Array} float32Array
 * @returns {Float32Array} float32Array
 * 
 */
Globe.prototype.transformMatrixAtCartesianPointWgs84 = function(x, y, z, float32Array)
{
	var xAxis, yAxis, zAxis;
	
	zAxis = this.normalAtCartesianPointWgs84(x, y, z, zAxis);
	
	// Check if zAxis is vertical vector. PENDENT.
	
	// now, calculate the east direction. 
	// project zAxis to plane XY and calculate the left perpendicular.
	xAxis = new Float32Array(3);
	xAxis[0] = -y;
	xAxis[1] = x;
	xAxis[2] = 0.0;
	xAxis = this.normalizeCartesian(xAxis);
	
	// finally calculate the north direction.
	var xAxisVector = new Point3D(xAxis[0], xAxis[1], xAxis[2]);
	var yAxisVector = new Point3D();
	var zAxisVector = new Point3D(zAxis[0], zAxis[1], zAxis[2]);
	
	yAxisVector = zAxisVector.crossProduct(xAxisVector, yAxisVector);
	
	if (float32Array === undefined)
	{ float32Array = new Float32Array(16); }
	
	float32Array[0] = xAxisVector.x;
	float32Array[1] = xAxisVector.y;
	float32Array[2] = xAxisVector.z;
	float32Array[3] = 0.0;
	
	float32Array[4] = yAxisVector.x;
	float32Array[5] = yAxisVector.y;
	float32Array[6] = yAxisVector.z;
	float32Array[7] = 0.0;
	
	float32Array[8] = zAxisVector.x;
	float32Array[9] = zAxisVector.y;
	float32Array[10] = zAxisVector.z;
	float32Array[11] = 0.0;
	
	float32Array[12] = x;
	float32Array[13] = y;
	float32Array[14] = z;
	float32Array[15] = 1.0;
	
	return float32Array;
};
/**
 * function used by "MagoWorld" to paning & rotate the globe by dragging mouse.
 * @param {Line} line
 * @param {Float32Array} resultCartesian
 * @param {Number} radius
 * @returns {Float32Array} resultCartesian
 */
Globe.prototype.intersectionLineWgs84 = function(line, resultCartesian, radius)
{
	// 
	// line: (x, y, z) = x1 + t(x2 - x1), y1 + t(y2 - y1), z1 + t(z2 - z1)
	// sphere: (x - x3)^2 + (y - y3)^2 + (z - z3)^2 = r^2, where x3, y3, z3 is the center of the sphere.
	
	// line:
	var p1 = line.point;
	var lineDir = line.direction;
	var dist = 1000.0;// any value is ok.
	var p2 = new Point3D(p1.x + lineDir.x * dist, p1.y + lineDir.y * dist, p1.z + lineDir.z * dist);
	var x1 = p1.x;
	var y1 = p1.y;
	var z1 = p1.z;
	var x2 = p2.x;
	var y2 = p2.y;
	var z2 = p2.z;

	// sphere:
	var x3 = 0;
	var y3 = 0;
	var z3 = 0;
	var r = this.equatorialRadius; // provisionally.
	if (radius !== undefined)
	{ r = radius; }
	
	// resolve:
	var x21 = (x2-x1);
	var y21 = (y2-y1);
	var z21 = (z2-z1);
	
	var a = x21*x21 + y21*y21 + z21*z21;
	
	var x13 = (x1-x3);
	var y13 = (y1-y3);
	var z13 = (z1-z3);
	
	var b = 2*(x21 * x13 + y21 * y13 + z21 * z13);
	
	var c = x3*x3 + y3*y3 + z3*z3 + x1*x1 + y1*y1 + z1*z1 - 2*(x3*x1 + y3*y1+ z3*z1) - r*r;
	
	var discriminant = b*b - 4*a*c;
	
	if (discriminant < 0)
	{
		// no intersection.
		return undefined;
	}
	else if (discriminant === 0)
	{
		// this is tangent.
		if (resultCartesian === undefined)
		{ resultCartesian = []; } // Float32Array has no enough precision.
		
		var t1 = (-b)/(2*a);
		var intersectPoint1 = new Point3D(x1 + (x2 - x1)*t1, y1 + (y2 - y1)*t1, z1 + (z2 - z1)*t1);
		resultCartesian[0] = intersectPoint1.x;
		resultCartesian[1] = intersectPoint1.y;
		resultCartesian[2] = intersectPoint1.z;
		
	}
	else
	{
		// find the nearest to p1.
		var sqrtDiscriminant = Math.sqrt(discriminant);
		var t1 = (-b + sqrtDiscriminant)/(2*a);
		var t2 = (-b - sqrtDiscriminant)/(2*a);
		
		// solution 1.
		var intersectPoint1 = new Point3D(x1 + (x2 - x1)*t1, y1 + (y2 - y1)*t1, z1 + (z2 - z1)*t1);
		var intersectPoint2 = new Point3D(x1 + (x2 - x1)*t2, y1 + (y2 - y1)*t2, z1 + (z2 - z1)*t2);
		
		var dist1 = p1.squareDistToPoint(intersectPoint1);
		var dist2 = p1.squareDistToPoint(intersectPoint2);
		
		if (resultCartesian === undefined)
		{ resultCartesian = []; } // Float32Array has no enough precision.
		
		if (dist1 < dist2)
		{
			resultCartesian[0] = intersectPoint1.x;
			resultCartesian[1] = intersectPoint1.y;
			resultCartesian[2] = intersectPoint1.z;
		}
		else
		{
			resultCartesian[0] = intersectPoint2.x;
			resultCartesian[1] = intersectPoint2.y;
			resultCartesian[2] = intersectPoint2.z;
		}
	}
	
	return resultCartesian;
	
};


/**
 * Change cartesian point to WGS84 and nromalize that.
 * @param {Number} x the x coordi value of input cartesian point
 * @param {Number} y the y coordi value of input cartesian point
 * @param {Number} z the z coordi value of input cartesian point
 * @param {Float32Array} resultNormal the cartesian point which will hold the calculated result
 * @returns {Float32Array} resultNormal
 */
Globe.prototype.normalAtCartesianPointWgs84 = function(x, y, z, resultNormal)
{
	if (resultNormal === undefined)
	{ resultNormal = new Float32Array(3); }

	var equatorialRadiusSquared = this.equatorialRadius * this.equatorialRadius;
	var polarRadiusSquared = this.polarRadius * this.polarRadius;

	resultNormal[0] = x / equatorialRadiusSquared;
	resultNormal[1] = y / equatorialRadiusSquared;
	resultNormal[2] = z / polarRadiusSquared;
	
	// Normalize cartesian.
	resultNormal = this.normalizeCartesian(resultNormal);
	
	return resultNormal;
};

/**
 * Calculate atan
 * @param {Number} y
 * @param {Number} x
 * @returns {Number} 
 */
Globe.atan2Test = function(y, x) 
{
	var M_PI = Math.PI;
	if (x > 0.0)
	{
		return Math.atan(y/x);
	}
	else if (x < 0.0)
	{
		if (y >= 0.0)
		{
			return Math.atan(y/x) + M_PI;
		}
		else 
		{
			return Math.atan(y/x) - M_PI;
		}
	}
	else if (x === 0.0)
	{
		if (y>0.0)
		{
			return M_PI/2.0;
		}
		else if (y<0.0)
		{
			return -M_PI/2.0;
		}
		else 
		{
			return 0.0; // return undefined.
		}
	}
};

/**
 * Change absolute coordinate to WGS84 coordinate 
 * @param {Number} x the x coordi of the point of absolute coordinate
 * @param {Number} y the y coordi of the point of absolute coordinate
 * @param {Number} z the z coordi of the point of absolute coordinate
 * @param {Float32Array} result the cartesian point which will contain the calculated point
 * @param {Boolean} bStoreAbsolutePosition This decide whether store absolute value at the 'result' point or not as the property
 * @param {Float32Array} result
 * 
 */
Globe.CartesianToGeographicWgs84 = function (x, y, z, result, bStoreAbsolutePosition) 
{
	// From WebWorldWind.
	// According to H. Vermeille, "An analytical method to transform geocentric into geodetic coordinates"
	// http://www.springerlink.com/content/3t6837t27t351227/fulltext.pdf
	// Journal of Geodesy, accepted 10/2010, not yet published
	
	/*
	this.equatorialRadius = 6378137.0; // meters.
	this.polarRadius = 6356752.3142; // meters.
	this.firstEccentricitySquared = 6.69437999014E-3;
	this.secondEccentricitySquared = 6.73949674228E-3;
	this.degToRadFactor = Math.PI/180.0;
	*/
	var firstEccentricitySquared = 6.69437999014E-3;
	var equatorialRadius = 6378137.0;
	/*
	var X = z,
		Y = x,
		Z = y,
		*/
	var X = x,
		Y = y,
		Z = z,
		XXpYY = X * X + Y * Y,
		sqrtXXpYY = Math.sqrt(XXpYY),
		a = equatorialRadius,
		ra2 = 1 / (a * a),
		e2 = firstEccentricitySquared,
		e4 = e2 * e2,
		p = XXpYY * ra2,
		q = Z * Z * (1 - e2) * ra2,
		r = (p + q - e4) / 6,
		h,
		phi,
		u,
		evoluteBorderTest = 8 * r * r * r + e4 * p * q,
		rad1,
		rad2,
		rad3,
		atan,
		v,
		w,
		k,
		D,
		sqrtDDpZZ,
		e,
		lambda,
		s2;

	if (evoluteBorderTest > 0 || q !== 0) 
	{
		if (evoluteBorderTest > 0) 
		{
			// Step 2: general case
			rad1 = Math.sqrt(evoluteBorderTest);
			rad2 = Math.sqrt(e4 * p * q);

			// 10*e2 is my arbitrary decision of what Vermeille means by "near... the cusps of the evolute".
			if (evoluteBorderTest > 10 * e2) 
			{
				rad3 = Math.cbrt((rad1 + rad2) * (rad1 + rad2));
				u = r + 0.5 * rad3 + 2 * r * r / rad3;
			}
			else 
			{
				u = r + 0.5 * Math.cbrt((rad1 + rad2) * (rad1 + rad2))
					+ 0.5 * Math.cbrt((rad1 - rad2) * (rad1 - rad2));
			}
		}
		else 
		{
			// Step 3: near evolute
			rad1 = Math.sqrt(-evoluteBorderTest);
			rad2 = Math.sqrt(-8 * r * r * r);
			rad3 = Math.sqrt(e4 * p * q);
			//atan = 2 * Math.atan2(rad3, rad1 + rad2) / 3;
			atan = 2 * Globe.atan2Test(rad3, rad1 + rad2) / 3;

			u = -4 * r * Math.sin(atan) * Math.cos(Math.PI / 6 + atan);
		}

		v = Math.sqrt(u * u + e4 * q);
		w = e2 * (u + v - q) / (2 * v);
		k = (u + v) / (Math.sqrt(w * w + u + v) + w);
		D = k * sqrtXXpYY / (k + e2);
		sqrtDDpZZ = Math.sqrt(D * D + Z * Z);

		h = (k + e2 - 1) * sqrtDDpZZ / k;
		//phi = 2 * Math.atan2(Z, sqrtDDpZZ + D);
		phi = 2 * Globe.atan2Test(Z, sqrtDDpZZ + D);
	}
	else 
	{
		// Step 4: singular disk
		rad1 = Math.sqrt(1 - e2);
		rad2 = Math.sqrt(e2 - p);
		e = Math.sqrt(e2);

		h = -a * rad1 * rad2 / e;
		phi = rad2 / (e * rad2 + rad1 * Math.sqrt(p));
	}

	// Compute lambda
	s2 = Math.sqrt(2);
	if ((s2 - 1) * Y < sqrtXXpYY + X) 
	{
		// case 1 - -135deg < lambda < 135deg
		//lambda = 2 * Math.atan2(Y, sqrtXXpYY + X);
		lambda = 2 * Globe.atan2Test(Y, sqrtXXpYY + X);
	}
	else if (sqrtXXpYY + Y < (s2 + 1) * X) 
	{
		// case 2 - -225deg < lambda < 45deg
		//lambda = -Math.PI * 0.5 + 2 * Math.atan2(X, sqrtXXpYY - Y);
		lambda = -Math.PI * 0.5 + 2 * Globe.atan2Test(X, sqrtXXpYY - Y);
	}
	else 
	{
		// if (sqrtXXpYY-Y<(s2=1)*X) {  // is the test, if needed, but it's not
		// case 3: - -45deg < lambda < 225deg
		//lambda = Math.PI * 0.5 - 2 * Math.atan2(X, sqrtXXpYY + Y);
		lambda = Math.PI * 0.5 - 2 * Globe.atan2Test(X, sqrtXXpYY + Y);
	}

	if (result === undefined)
	{ result = new GeographicCoord(); }

	var factor = 180.0 / Math.PI;
	result.latitude = factor * phi;
	result.longitude = factor * lambda;
	result.altitude = h;
	
	if (bStoreAbsolutePosition !== undefined && bStoreAbsolutePosition === true)
	{
		// In this case, store into result_geographicCoord the x, y, z values.
		if (result.absolutePoint === undefined)
		{ result.absolutePoint = new Point3D(x, y, z); }
		else
		{ result.absolutePoint.set(x, y, z); }
	}

	return result;
};

/**
 * This change the GeographicCoord feature to Point2D feature
 * @param {Number} longitude
 * @param {Number} latitude
 * @param {Point2D} resultPoint2d
 * @returns {Point2D} 
 */
Globe.geographicToMercatorProjection = function(longitude, latitude, resultPoint2d) 
{
	// longitude = [-180, 180].
	// latitude = [-90, 90].
	var degToRadFactor = Math.PI/180.0;
	var lonRad = longitude * degToRadFactor;
	var latRad = latitude * degToRadFactor;
	
	return Globe.geographicRadianToMercatorProjection(lonRad, latRad, resultPoint2d);
};

/**
 * This change the GeographicCoord feature to Point2D feature using Mercator projection
 * @param {Number} lonRad
 * @param {Number} latRad
 * @param {Point2D} resultPoint2d
 * @returns {Point2D}
 */
Globe.geographicRadianToMercatorProjection = function(lonRad, latRad, resultPoint2d) 
{
	// longitude = [-pi, pi].
	// latitude = [-pi/2, pi/2].
	var equatorialRadius = Globe.equatorialRadius();
	if (resultPoint2d === undefined)
	{ resultPoint2d = new Point2D(); }

	resultPoint2d.set(equatorialRadius * lonRad, equatorialRadius * latRad);
	
	return resultPoint2d;
};

/**
 * This change the GeographicCoord feature to the cartesian WGS84 point using the blow method.
 * defined in the LINZ standard LINZS25000 (Standard for New Zealand Geodetic Datum 2000)
 * https://www.linz.govt.nz/data/geodetic-system/coordinate-conversion/geodetic-datum-conversions/equations-used-datum
 * @param {Number} longitude
 * @param {Number} latitude
 * @param {Number} altitude
 * @param {Float32Array} resultCartesian
 * @returns {Float32Array} resultCartesian
 */
Globe.geographicToCartesianWgs84 = function(longitude, latitude, altitude, resultCartesian)
{
	// a = semi-major axis.
	// e2 = firstEccentricitySquared.
	// v = a / sqrt(1 - e2 * sin2(lat)).
	// x = (v+h)*cos(lat)*cos(lon).
	// y = (v+h)*cos(lat)*sin(lon).
	// z = [v*(1-e2)+h]*sin(lat).
	var degToRadFactor = Math.PI/180.0;
	var equatorialRadius = Globe.equatorialRadius();
	var firstEccentricitySquared = 6.69437999014E-3;
	var lonRad = longitude * degToRadFactor;
	var latRad = latitude * degToRadFactor;
	var cosLon = Math.cos(lonRad);
	var cosLat = Math.cos(latRad);
	var sinLon = Math.sin(lonRad);
	var sinLat = Math.sin(latRad);
	var a = equatorialRadius;
	var e2 = firstEccentricitySquared;
	var v = a/Math.sqrt(1.0 - e2 * sinLat * sinLat);
	var h = altitude;
	
	if (resultCartesian === undefined)
	{ resultCartesian = []; }
	
	resultCartesian[0]=(v+h)*cosLat*cosLon;
	resultCartesian[1]=(v+h)*cosLat*sinLon;
	resultCartesian[2]=(v*(1.0-e2)+h)*sinLat;
	
	return resultCartesian;
};
/**
 * This change the array of the absolute coordinates represented as the angle to the array of WGS84
 * @param {Number} longitude
 * @param {Number} latitude
 * @param {Number} altitude
 * @param {Float32Array} resultCartesian
 * @returns {Float32Array} resultCartesian
 */

Globe.geographicRadianArrayToFloat32ArrayWgs84 = function(lonArray, latArray, altArray, resultCartesianArray)
{
	// defined in the LINZ standard LINZS25000 (Standard for New Zealand Geodetic Datum 2000)
	// https://www.linz.govt.nz/data/geodetic-system/coordinate-conversion/geodetic-datum-conversions/equations-used-datum
	// a = semi-major axis.
	// e2 = firstEccentricitySquared.
	// v = a / sqrt(1 - e2 * sin2(lat)).
	// x = (v+h)*cos(lat)*cos(lon).
	// y = (v+h)*cos(lat)*sin(lon).
	// z = [v*(1-e2)+h]*sin(lat).
	var equatorialRadius = 6378137.0; // meters.
	var firstEccentricitySquared = 6.69437999014E-3;
	
	var lonRad;
	var latRad;
	var cosLon;
	var cosLat;
	var sinLon;
	var sinLat;
	var a = equatorialRadius;
	var e2 = firstEccentricitySquared;
	var e2a = 1.0 - e2;
	var v;
	var h;
	
	var coordsCount = lonArray.length;
	if (resultCartesianArray === undefined)
	{
		resultCartesianArray = new Float32Array(coordsCount*3);
	}
	for (var i=0; i<coordsCount; i++)
	{
		lonRad = lonArray[i];
		latRad = latArray[i];
		cosLon = Math.cos(lonRad);
		cosLat = Math.cos(latRad);
		sinLon = Math.sin(lonRad);
		sinLat = Math.sin(latRad);
		v = a/Math.sqrt(1.0 - e2 * sinLat * sinLat);
		h = altArray[i];
		
		resultCartesianArray[i*3] = (v+h)*cosLat*cosLon;
		resultCartesianArray[i*3+1] = (v+h)*cosLat*sinLon;
		resultCartesianArray[i*3+2] = (v*e2a+h)*sinLat;
	}
	
	return resultCartesianArray;
};

		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		

'use strict';


/**
 * Now under implementation
 * @class IdentifierManager
 */
var IdentifierManager = function() 
{
	if (!(this instanceof IdentifierManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.identifierMap = {};
	this.identifiersCount = 0;
};

IdentifierManager.prototype.newId = function()
{
	this.identifiersCount++;
	var id = (this.identifiersCount).toString();
	
	this.identifierMap[id] = 1;
	return id;
};
'use strict';

/**
 * LightSource.
 * 
 * @class LightSource
 * @constructor 
 * @param {Number} lightType The name of the LightSource.
 */
var LightSource = function(lightType) 
{
	if (!(this instanceof LightSource)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	/**
	 * The name of this LightSource.
	 * @type {String}
	 * @default "noName"
	 */
	this.name;
	this.id;
	
	this.lightType = lightType; // omni = 0, spot = 1, directional = 2, area = 3, volume = 4.
	
	this.geoCoord;
	this.position;
	this.positionHIGH;
	this.positionLOW;
	this.tMatrix;
	this.tMatrixInv;
	this.depthFbo;
	this.bSphere;
	this.minDistToCam; // use only in directional lights.
	this.maxDistToCam; // use only in directional lights.
	
	// light is directionType, must have the rectangle size.
	//this.targetTextureWidth = new Int32Array([1024]);
	//this.targetTextureHeight = new Int32Array([1024]);
	
	this.targetTextureWidth = new Int32Array([2048]);
	this.targetTextureHeight = new Int32Array([2048]);
	
	//this.targetTextureWidth = new Int32Array([4096]);
	//this.targetTextureHeight = new Int32Array([4096]);
	
	//this.targetTextureWidth = new Int32Array([8192]);
	//this.targetTextureHeight = new Int32Array([8192]);
};


'use strict';
/**
 * Mago3D return object
 * @property {object} callAPI function. 
 * @property {object} getViewer function. get this map viewr. Cesium.Viewer or Mago3d.MagoWorld
 * @property {object} getMagoManagerState function. get magoManager starte
 * @property {object} getMagoManager function. get magoManager
 * @property {object} setBaseUrl function. set F4d Date base url.
 */

/**
 * callback parameter info 
 * @property {object} loadstart Optional. when mago3d load start trigger. return magostate.
 * @property {object} loadend Optional. when mago3d load end trigger. return magostate.
 */

/**
 * This is mago3d entrypoint.
 * @class Mago3D
 * 
 * @param {Stirng} containerId container div id. required.
 * @param {object} serverPolicy mage3d geopolicy
 * @param {object} callback loadstart callback, loadend callback.
 * @param {object} options Cesium viewer parameter.
 * @param {Cesium.Viewer} legacyViewer 타 시스템과의 연동의 경우 view 객체가 생성되어서 넘어 오는 경우가 있음
 * 
 * @return {object} 
 */
var Mago3d = function(containerId, serverPolicy, callback, options, legacyViewer) 
{
	if (!(this instanceof Mago3d)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
    
	if (!containerId || !document.getElementById(containerId)) 
	{
		throw new Error('containerId is required.');
	}
	Emitter.call(this);

	var viewer = null;
	var magoManager = null;

	if (callback) 
	{
		if (callback.loadstart && typeof callback.loadstart === "function") 
		{
			this.on('loadstart', callback.loadstart);
		}
		
		if (callback.loadend && typeof callback.loadend === "function") 
		{
			this.on('loadend', callback.loadend);
		}
	}

	var magoManagerState = CODE.magoManagerState.INIT;
	//this.emit('loadstart', this);

	var viewerInitializer;

	if (serverPolicy.basicGlobe === Constant.CESIUM) 
	{
		viewerInitializer = new CesiumViewerInit(containerId, serverPolicy, options, legacyViewer);
	}
	else 
	{
		viewerInitializer = new MagoEarthViewerInit(containerId, serverPolicy);
	}

	viewer = viewerInitializer.viewer;
	magoManager = viewerInitializer.magoManager;
	//magoManager.magoPolicy.imagePath = imagePath;

	var returnObj = {
		// api gateway 역할
		callAPI: function(api) 
		{
		    if (api.getReturnable()) 
			{
		        return magoManager.callAPI(api);
			}
			else 
			{
				magoManager.callAPI(api);
			}
		},
		getViewer: function()
		{
			return viewer;
		},
		getMagoManagerState: function() 
		{
			return magoManagerState;
		},
		getMagoManager: function() 
		{
			return magoManager;
		},
		setBaseUrl: function(baseUrl) 
		{
			if (!magoManager) 
			{
				throw new Error('Mago3d is no ready');
			}
			magoManager.readerWriter.geometryDataPath = baseUrl;
		},
		getF4dController: function()
		{
			return magoManager.f4dController;
		}
	};

	magoManagerState = CODE.magoManagerState.READY;
	viewerInitializer.setEventHandler();

	this.emit('loadend', returnObj);

	return returnObj;
};
Mago3d.prototype = Object.create(Emitter.prototype);
Mago3d.prototype.constructor = Mago3d;

'use strict';

var MagoEarthViewerInit = function(containerId, serverPolicy) 
{
	ViewerInit.call(this, containerId, serverPolicy);
};

MagoEarthViewerInit.prototype = Object.create(ViewerInit.prototype);
MagoEarthViewerInit.prototype.constructor = MagoEarthViewerInit;

MagoEarthViewerInit.prototype.init = function() 
{
	var canvas = document.getElementById(containerId);
	var glAttrs = {antialias          : true, 
		stencil            : true,
		premultipliedAlpha : false};
	var gl = canvas.getContext("webgl", glAttrs);
	if (!gl)
	{ gl = canvas.getContext("experimental-webgl", glAttrs); }
    
	// Problem: canvas-width initially is 300 and canvas-height = 150.***
	canvas.width = canvas.clientWidth;
	canvas.height = canvas.clientHeight;
    
	magoManager = new MagoManager();
	var sceneState = magoManager.sceneState;
	sceneState.textureFlipYAxis = true;
	sceneState.gl = gl;
	sceneState.drawingBufferWidth[0] = canvas.clientWidth;
	sceneState.drawingBufferHeight[0] = canvas.clientHeight;
	sceneState.camera.frustum.aspectRatio[0] = canvas.clientWidth/canvas.clientHeight;
	sceneState.camera.frustum.fovRad[0] = Math.PI/3*1.8;
	sceneState.camera.frustum.fovyRad[0] = sceneState.camera.frustum.fovRad[0]/sceneState.camera.frustum.aspectRatio;
	sceneState.camera.frustum.tangentOfHalfFovy[0] = Math.tan(sceneState.camera.frustum.fovyRad[0]/2);
    
	// initial camera position.***
	sceneState.camera.position.set(-7586937.743019165, 10881859.054284709, 5648264.99911627);
	sceneState.camera.direction.set(0.5307589970384617, -0.7598419113077192, -0.3754132585133587);
	sceneState.camera.up.set(0.23477224008249162, -0.29380469331271475, 0.9265855321012102);
    
	// test init camera position.***
	//sphere.r = 6378137.0;
	sceneState.encodedCamPosHigh[0] = -7536640;
	sceneState.encodedCamPosHigh[1] = 10878976;
	sceneState.encodedCamPosHigh[2] = 5636096;
    
	sceneState.encodedCamPosLow[0] = -50297.7421875;
	sceneState.encodedCamPosLow[1] = 2883.05419921875;
	sceneState.encodedCamPosLow[2] = 12168.9990234375;

    
	viewer = new MagoWorld(magoManager);
	magoManager.magoWorld = viewer;
	magoManager.globe = new Globe();
	// init matrices.***
	viewer.updateModelViewMatrixByCamera(sceneState.camera);
	//magoManager.upDateSceneStateMatrices(sceneState);
    
	// Create the tinTerrains(MagoEarth).***
	magoManager.tinTerrainManager = new TinTerrainManager();
    
	// event listener.***
	canvas.addEventListener('mousedown', function(event)
	{
		viewer.mousedown(event);			
	}, false);
    
	canvas.addEventListener('mouseup', function(event)
	{
		viewer.mouseup(event);			
	}, false);
    
	canvas.addEventListener('mousewheel', function(event)
	{
		viewer.mousewheel(event); 
	}, false);
    
	canvas.addEventListener('mousemove', function(event)
	{
		viewer.mousemove(event);
	}, false);
    
	canvas.addEventListener('click', function(event)
	{
		viewer.mouseclick(event);
	}, false);
    
	canvas.addEventListener('resize', function(event)
	{
		// TODO:
		console.log("resize");
	}, false);
    
	canvas.addEventListener('keydown', function(event) // no works.***
	{
		viewer.keydown(event); // no works.***
	}, false);

	var gl = viewer.magoManager.sceneState.gl;
	var manager = viewer.magoManager;
	manager.vboMemoryManager.gl = gl;
	manager.postFxShadersManager.gl = gl;
	manager.postFxShadersManager.createDefaultShaders(gl); // A1-OLD.***
	manager.createDefaultShaders(gl);// A1-Use this.***
};

'use strict';

var MagoEvent = function(type, listener) 
{
	this.type = type;
	this.listener = listener;
};


MagoEvent.prototype.getType = function() 
{
	return this.type;
};

MagoEvent.prototype.getListener = function() 
{
	return this.listener;
};
'use strict';

/**
 * Main Mago class.
 * @class MagoManager
 */
var MagoManager = function() 
{
	if (!(this instanceof MagoManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	Emitter.call(this);
	/**
	 * Auxiliary renderer.
	 * @type {Renderer}
	 * @default Renderer.
	 */
	this.renderer = new Renderer(this);
	
	/**
	 * Manages the selected objects.
	 * @type {SelectionManager}
	 * @default SelectionManager.
	 */
	this.selectionManager = new SelectionManager(this);
	
	/**
	 * Manages the shaders.
	 * @type {PostFxShadersManager}
	 * @default PostFxShadersManager.
	 */
	this.postFxShadersManager = new PostFxShadersManager();
	
	/**
	 * Manages the request & loading files.
	 * @type {ReaderWriter}
	 * @default ReaderWriter.
	 */
	this.readerWriter = new ReaderWriter();
	
	/**
	 * Contains the Mago3D policy data.
	 * @type {Policy}
	 * @default Policy.
	 */
	this.magoPolicy = new Policy();
	
	/**
	 * Manages & controls the movement of the objects in the scene.
	 * @type {AnimationManager}
	 * @default undefined.
	 */
	this.animationManager; 
	
	/**
	 * Manages & controls all the textures.
	 * @type {texturesStore}
	 * @default texturesStore.
	 */
	this.texturesStore = new TexturesStore(this);
	
	/**
	 * Manages & controls the tiles.
	 * @type {SmartTileManager}
	 * @default SmartTileManager.
	 */
	this.smartTileManager = new SmartTileManager();
	
	/**
	 * Manages & controls the deleting objects queue.
	 * @type {ProcessQueue}
	 * @default ProcessQueue.
	 */
	this.processQueue = new ProcessQueue();
	
	/**
	 * Manages & controls the parsing of loaded files.
	 * @type {ParseQueue}
	 * @default ParseQueue.
	 */
	this.parseQueue = new ParseQueue();
	
	/**
	 * Manages & controls the creation of the nodes (node = main object in Mago3D).
	 * @type {HierarchyManager}
	 * @default HierarchyManager.
	 */
	this.hierarchyManager = new HierarchyManager();

	/**
	 * Depth framebuffer object.
	 * @type {FBO}
	 * @default undefined.
	 */
	this.depthFboNeo;
	
	/**
	 * Depth framebuffer object for auxiliary and test use.
	 * @type {FBO}
	 * @default undefined.
	 */
	this.depthFboAux;
	
	/**
	 * Framebuffer object used for color coding selection.
	 * @type {FBO}
	 * @default undefined.
	 */
	this.selectionFbo; 
	
	/**
	 * Current x position of the mouse in screen coordinates.
	 * @type {Number}
	 * @default 0.
	 */
	this.mouse_x = 0;
	
	/**
	 * Current y position of the mouse in screen coordinates.
	 * @type {Number}
	 * @default 0.
	 */
	this.mouse_y = 0;
	
	
	this.mouseLeftDown = false;
	this.mouseMiddleDown = false;
	this.mouseDragging = false;
	this.selObjMovePlane;

	this.objectSelected;
	this.buildingSelected;
	this.octreeSelected;
	this.nodeSelected;

	this.mustCheckIfDragging = true;
	this.thereAreStartMovePoint = false;
	this.startMovPoint = new Point3D();
	
	this.configInformation = MagoConfig.getPolicy();
	this.cameraFPV = new FirstPersonView();
	this.myCameraSCX;
	// var to delete.*********************************************
	this.loadQueue = new LoadQueue(this); // Old. delete.***

	// Vars.****************************************************************
	this.sceneState = new SceneState(); // this contains all scene mtrices and camera position.***
	this.selectionColor = new SelectionColor();
	this.vboMemoryManager = new VBOMemoryManager();
	
	if (this.configInformation !== undefined)
	{
		this.magoPolicy.setLod0DistInMeters(this.configInformation.lod0);
		this.magoPolicy.setLod1DistInMeters(this.configInformation.lod1);
		this.magoPolicy.setLod2DistInMeters(this.configInformation.lod2);
		this.magoPolicy.setLod3DistInMeters(this.configInformation.lod3);
		this.magoPolicy.setLod4DistInMeters(this.configInformation.lod4);
		this.magoPolicy.setLod5DistInMeters(this.configInformation.lod5);

		if (this.configInformation.ssaoRadius)
		{
			this.sceneState.ssaoRadius[0] = Number(this.configInformation.ssaoRadius);
		}
	}

	this.fileRequestControler = new FileRequestControler();
	this.visibleObjControlerOctrees = new VisibleObjectsController(); 
	this.visibleObjControlerNodes = new VisibleObjectsController(); 
	this.visibleObjControlerTerrain = new VisibleObjectsController(); 
	
	this.frustumVolumeControl = new FrustumVolumeControl();
	
	this.boundingSphere_Aux; 
	this.radiusAprox_aux;

	this.lastCamPos = new Point3D();
	this.squareDistUmbral = 22.0;

	this.lowestOctreeArray = [];

	this.backGround_fileReadings_count = 0; // this can be as max = 9.***
	this.backGround_imageReadings_count = 0;
	this.isCameraMoving = false; 
	this.isCameraInsideNeoBuilding = false;
	this.renderingFase = 0;

	this.bPicking = false;
	this.scene;

	this.numFrustums;
	this.isLastFrustum = false;
	this.currentFrustumIdx = 0;
	this.highLightColor4 = new Float32Array([0.2, 1.0, 0.2, 1.0]);
	this.thereAreUrgentOctrees = false;
	
	this.hierarchyManager = new HierarchyManager();
	
	// small object size.
	this.smallObjectSize = 0.153;
	
	// sqrtTable.
	
	this.sqrtTable = new Float32Array(11);
	// make 100 values.
	var increValue = 0.1;
	for (var i=0; i<11; i++)
	{
		this.sqrtTable[i] = Math.sqrt(1+(increValue*i)*(increValue*i));
	}
	
	this.managerUtil = new ManagerUtils();

	this.frustumVolumeControl = new FrustumVolumeControl();

	// CURRENTS.********************************************************************
	this.currentSelectedObj_idx = -1;
	this.currentByteColorPicked = new Uint8Array(4);
	this.currentShader;

	// SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.*** SCRATCH.***
	this.pointSC= new Point3D();
	this.pointSC_2= new Point3D();
	this.arrayAuxSC = [];

	this.currentTimeSC;
	this.dateSC = new Date();
	this.startTimeSC;
	this.maxMilisecondsForRender = 10;

	this.terranTileSC;

	this.resultRaySC = new Float32Array(3);
	this.matrix4SC = new Matrix4();
	this.axisXYZ = new AxisXYZ();

	this.demoBlocksLoaded = false;

	this.objMarkerManager = new ObjectMarkerManager(this);
	
	// renderWithTopology === 0 -> render only CityGML.***
	// renderWithTopology === 1 -> render only IndoorGML.***
	// renderWithTopology === 2 -> render both.***
	this.tempSettings = {};
	this.tempSettings.renderWithTopology = 1;
	this.tempSettings.renderSpaces = true;
	this.tempSettings.spacesAlpha = 0.6;
	
	/**
	 * This class contains general settings.
	 * @type {Settings}
	 */
	this._settings = new Settings();
	
	this.tinTerrainManager;
	
	this.modeler = new Modeler(this);
	this.materialsManager = new MaterialsManager(this);
	this.idManager = new IdentifierManager();
	this.processCounterManager = new ProcessCounterManager();

	
	this.f4dController = new F4dController(this);
	this.effectsManager = new EffectsManager();
	
	//CODE.magoCurrentProcess = {
	//"Unknown"  : 0,
	//"DepthRendering"  : 1,
	//"ColorRendering" : 2,
	//"ColorCodeRendering" : 3,
	//"DepthShadowRendering" : 4

	this.currentProcess = CODE.magoCurrentProcess.Unknown;

};
MagoManager.prototype = Object.create(Emitter.prototype);
MagoManager.prototype.constructor = MagoManager;

MagoManager.EVENT_TYPE = {
	'CLICK'                  	: 'click',
	'DBCLICK'                	: 'dbclick',
	'RIGHTCLICK'             	: 'rightclick',
	'MOUSEMOVE'              	: 'mousemove',
	'SMARTTILELOADSTART'     	: 'smarttileloadstart',
	'SMARTTILELOADEND'       	: 'smarttileloadend',
	'F4DLOADSTART'          		: 'f4dloadstart',
	'F4DLOADEND'           			: 'f4dloadend',
	'F4DRENDERREADY'       			: 'f4drenderready',
	'SELECTEDF4D'          	 	: 'selectedf4d',
	'SELECTEDF4DMOVED'        : 'selectedf4dmoved',
	'SELECTEDF4DOBJECT'      	: 'selectedf4dobject',
	'SELECTEDGENERALOBJECT'   : 'selectedgeneralobject',
	'DESELECTEDF4D'        	 	: 'deselectedf4d',
	'DESELECTEDF4DOBJECT'    	: 'deselectedf4dobject',
	'DESELECTEDGENERALOBJECT' : 'deselectedgeneralobject',
	'CAMERACHANGED'           : 'camerachanged',
	'CAMERAMOVEEND'           : 'cameramoveend',
	'CAMERAMOVESTART'         : 'cameramovestart',
};

/**
 * object 를 그리는 두가지 종류의 function을 호출
 */
MagoManager.prototype.init = function(gl) 
{
	this.bInit = true;
	
	/*
	var canvas = this.scene.canvas;
	var glAttrs = {antialias          : true, 
		stencil            : true,
		premultipliedAlpha : false};
	var gl = canvas.getContext("webgl", glAttrs);
	if (!gl)
	{ gl = canvas.getContext("experimental-webgl", glAttrs); }
	*/
	
	if (this.sceneState.gl === undefined)
	{ this.sceneState.gl = gl; }
	if (this.vboMemoryManager.gl === undefined)
	{ this.vboMemoryManager.gl = gl; }
	if (this.effectsManager.gl === undefined)
	{ this.effectsManager.gl = gl; }
};

/**
 * object 를 그리는 두가지 종류의 function을 호출
 * @param scene 변수 Cesium Scene.
 * @param pass 변수
 * @param frustumIdx 변수
 * @param numFrustums 변수
 */
MagoManager.prototype.start = function(scene, pass, frustumIdx, numFrustums) 
{
	// Calculate FPS.
	//var start = new Date().getTime();
	// this is cesium version.***
	// mago3d 활성화가 아니면 화면을 그리지 않음
	if (!this.magoPolicy.getMagoEnable()) { return; }
	
	var isLastFrustum = false;
	this.numFrustums = numFrustums;
	this.currentFrustumIdx = this.numFrustums-frustumIdx-1;
	if (this.currentFrustumIdx === numFrustums-1) 
	{
		isLastFrustum = true;
		this.isLastFrustum = true;
	}

	// cesium 새 버전에서 지원하지 않음
	var picking = pass.pick;
	if (picking) 
	{
		//
	}
	else 
	{
		if (this.configInformation === undefined)
		{
			this.configInformation = MagoConfig.getPolicy();
		}
		if (scene)
		{
			var gl = scene.context._gl;
			gl.getExtension("EXT_frag_depth");
			
			if (!this.bInit)
			{ this.init(gl); }
		
			if (gl.isContextLost())
			{ return; }
		}

		this.startRender(isLastFrustum, this.currentFrustumIdx, numFrustums);
			
	}
};

MagoManager.prototype.isCesiumGlobe = function() 
{
	return this.configInformation.basicGlobe === Constant.CESIUM;
};

/**
 * Swaps the current rendering Phase.
 * 중복 그리기를 방지하기 위하여... (각기 다른 frustum에 걸쳤을 때 여러번 그리는 것을 방지하기 위하여.)
 */
MagoManager.prototype.swapRenderingFase = function() 
{
	this.renderingFase = !this.renderingFase;
};

/**
 * 빌딩을 준비(새버전)
 * @param {gl} gl
 */
MagoManager.prototype.prepareNeoBuildingsAsimetricVersion = function(gl, visibleObjControlerNodes) 
{
	// for all renderables, prepare data.***
	var neoBuilding;
	var node, rootNode;
	var projectFolderName;
	var neoBuildingFolderName;
	//var geometryDataPath = this.readerWriter.getCurrentDataPath();
	var geometryDataPath = this.readerWriter.geometryDataPath; // default geometryDataPath = "/f4d".***
	if (this.headersRequestedCounter === undefined)
	{ this.headersRequestedCounter = 0; }

	var counter = 0;

	var currentVisibleNodes = [].concat(visibleObjControlerNodes.currentVisibles0, 
		visibleObjControlerNodes.currentVisibles2, 
		visibleObjControlerNodes.currentVisibles3, 
		visibleObjControlerNodes.currentVisiblesAux,
		visibleObjControlerNodes.currentVisiblesToPrepare);
	for (var i=0, length = currentVisibleNodes.length; i<length; i++) 
	{
		node = currentVisibleNodes[i];
		
		// Check if the node is a referenceNode.***
		var attributes = node.data.attributes;
		if (attributes === undefined)
		{ continue; }
	
		neoBuilding = currentVisibleNodes[i].data.neoBuilding;
		
		/*
		if (attributes.objectType === "basicF4d")
		{
			
		}
		else if (attributes.objectType === "multiBuildingsTile")
		{
			
		}
		*/
		
		if (attributes.projectId !== undefined && attributes.isReference !== undefined && attributes.isReference === true)
		{
			StaticModelsManager.manageStaticModel(node, this);
		}
		
		// Check if this node has topologyData.***
		/*
		if(node.data && node.data.attributes && node.data.attributes.hasTopology)
		{
			if(neoBuilding.network === undefined)
			{
				// load topologyData for this node.***
				neoBuilding.network = new Network(node);
				var network = neoBuilding.network;
				var magoManager = this;
				
				var geometryDataPath = this.readerWriter.geometryDataPath;
				var indoorGml_filePath = geometryDataPath + "/"  + projectFolderName + "/"  + neoBuilding.buildingFileName + "/topology.json";
				
				loadWithXhr(indoorGml_filePath).done(function(response) 
				{
					var enc = new TextDecoder("utf-8");
					var stringText = enc.decode(response);
					var SampleIndoorJson = JSON.parse(stringText);
					var gmlDataContainer = new GMLDataContainer(SampleIndoorJson, "1.0.3");
					network.parseTopologyData(magoManager, gmlDataContainer);
					
				}).fail(function(status) 
				{
					
				}).always(function() 
				{
					
				});
			}
	
		}
		*/
		
		var fromSmartTile = node.data.attributes.fromSmartTile;
		if (fromSmartTile === undefined)
		{ fromSmartTile = false; }

		// check if this building is ready to render.***
		if (neoBuilding)
		{
			// 1) MetaData
			var metaData = neoBuilding.metaData;
			if (metaData.fileLoadState === CODE.fileLoadState.READY) 
			{
				if (!fromSmartTile) // load only if this no is NO from a smartTile.***
				{
					projectFolderName = neoBuilding.projectFolderName;
					if (this.fileRequestControler.isFullHeaders())	{ return; }
					var neoBuildingHeaderPath = geometryDataPath + "/" + projectFolderName + "/" + neoBuilding.buildingFileName + "/HeaderAsimetric.hed";
					
					this.readerWriter.getNeoHeaderAsimetricVersion(gl, neoBuildingHeaderPath, neoBuilding, this.readerWriter, this); // Here makes the tree of octree.***
				}
			}
			else if (metaData.fileLoadState === CODE.fileLoadState.LOADING_FINISHED) 
			{
				var bytesReaded = 0;
				neoBuilding.parseHeader(neoBuilding.headerDataArrayBuffer, bytesReaded);
	
				counter++;
				if (counter > 60)
				{ break; }
			}
		}
		
	}
	currentVisibleNodes.length = 0;
};

/**
 * Here updates the modelView matrices.
 * @param {SceneState} sceneState
 */
MagoManager.prototype.upDateSceneStateMatrices = function(sceneState) 
{
	if (this.myCameraSCX === undefined) 
	{ this.myCameraSCX = new Camera(); }

	if (this.configInformation === undefined) 
	{
		// We are on MagoWorld. No need update matrices.***
		return;
	}

	if (this.isCesiumGlobe())
	{
		// * if this is in Cesium:
		var scene = this.scene;
		var uniformState = scene._context.uniformState;
		
		//if(!Matrix4.areEqualArrays(sceneState.modelViewMatrixLast, uniformState.modelView) || !Matrix4.areEqualArrays(sceneState.projectionMatrixLast, uniformState._projection))
		//{
		//	// calculate matrices.
		//	Matrix4.copyArray(uniformState.modelView, sceneState.modelViewMatrixLast);
		//	Matrix4.copyArray(uniformState.modelView, sceneState.modelViewMatrixLast);
		//}
		
		// ModelViewMatrix.
		//sceneState.modelViewMatrix._floatArrays = Cesium.Matrix4.clone(uniformState.modelView, sceneState.modelViewMatrix._floatArrays);
		
		// Calculate modelViewMatrix.
		if (this.isFarestFrustum())
		{
			var camera = scene.camera;
			var camPosX = camera.positionWC.x;
			var camPosY = camera.positionWC.y;
			var camPosZ = camera.positionWC.z;
			var camDirX = camera.directionWC.x;
			var camDirY = camera.directionWC.y;
			var camDirZ = camera.directionWC.z;
			var camUpX = camera.upWC.x;
			var camUpY = camera.upWC.y;
			var camUpZ = camera.upWC.z;
		
			var tergetX = camPosX + camDirX * 1000;
			var tergetY = camPosY + camDirY * 1000;
			var tergetZ = camPosZ + camDirZ * 1000;
		
			var modelViewMatrix = this.sceneState.modelViewMatrix;																	
			modelViewMatrix._floatArrays = Matrix4.lookAt(modelViewMatrix._floatArrays, [camPosX, camPosY, camPosZ], 
				[tergetX, tergetY, tergetZ], 
				[camUpX, camUpY, camUpZ]);
		}
		
		// ProjectionMatrix.***
		Cesium.Matrix4.toArray(uniformState._projection, sceneState.projectionMatrix._floatArrays); // original.***

		// Given ModelViewMatrix & ProjectionMatrix, calculate all sceneState matrix.
		sceneState.modelViewMatrixInv._floatArrays = glMatrix.mat4.invert(sceneState.modelViewMatrixInv._floatArrays, sceneState.modelViewMatrix._floatArrays);
	
		// normalMat.***
		sceneState.normalMatrix4._floatArrays = glMatrix.mat4.transpose(sceneState.normalMatrix4._floatArrays, sceneState.modelViewMatrixInv._floatArrays);
			
		// modelViewRelToEye.***
		sceneState.modelViewRelToEyeMatrix._floatArrays = glMatrix.mat4.copy(sceneState.modelViewRelToEyeMatrix._floatArrays, sceneState.modelViewMatrix._floatArrays);
		sceneState.modelViewRelToEyeMatrix._floatArrays[12] = 0;
		sceneState.modelViewRelToEyeMatrix._floatArrays[13] = 0;
		sceneState.modelViewRelToEyeMatrix._floatArrays[14] = 0;
		sceneState.modelViewRelToEyeMatrix._floatArrays[15] = 1;
		
		sceneState.modelViewRelToEyeMatrixInv._floatArrays = glMatrix.mat4.invert(sceneState.modelViewRelToEyeMatrixInv._floatArrays, sceneState.modelViewRelToEyeMatrix._floatArrays);
			
		// modelViewProjection.***
		sceneState.modelViewProjMatrix._floatArrays = glMatrix.mat4.multiply(sceneState.modelViewProjMatrix._floatArrays, sceneState.projectionMatrix._floatArrays, sceneState.modelViewMatrix._floatArrays);

		// modelViewProjectionRelToEye.***
		sceneState.modelViewProjRelToEyeMatrix._floatArrays = glMatrix.mat4.multiply(sceneState.modelViewProjRelToEyeMatrix._floatArrays, sceneState.projectionMatrix._floatArrays, sceneState.modelViewRelToEyeMatrix._floatArrays);
		
		// Check camera.
		var cameraPosition = scene.context._us._cameraPosition;
		ManagerUtils.calculateSplited3fv([cameraPosition.x, cameraPosition.y, cameraPosition.z], sceneState.encodedCamPosHigh, sceneState.encodedCamPosLow);

		var frustumCommandsList = this.scene._frustumCommandsList;
		if (frustumCommandsList === undefined)
		{ frustumCommandsList = this.scene.frustumCommandsList; }
		
		var camPosX = this.scene.camera.positionWC.x;
		var camPosY = this.scene.camera.positionWC.y;
		var camPosZ = this.scene.camera.positionWC.z;
		var camDirX = this.scene.camera.direction.x;
		var camDirY = this.scene.camera.direction.y;
		var camDirZ = this.scene.camera.direction.z;
		var camUpX = this.scene.camera.up.x;
		var camUpY = this.scene.camera.up.y;
		var camUpZ = this.scene.camera.up.z;
		if (sceneState.camera.isCameraMoved(camPosX, camPosY, camPosZ, camDirX, camDirY, camDirZ, camUpX, camUpY, camUpZ ))
		{
			this.isCameraMoved = true;
		}
		
		// Update sceneState camera.***
		this.upDateCamera(sceneState.camera);
					
		sceneState.drawingBufferWidth[0] = scene.drawingBufferWidth;
		sceneState.drawingBufferHeight[0] = scene.drawingBufferHeight;
	}
	else/* if (this.configInformation.basicGlobe === Constant.MAGOWORLD)*/
	{
		var camera = sceneState.camera;
		var camPos = camera.position;
		var frustum0 = camera.getFrustum(0);
		sceneState.camera.frustum.aspectRatio[0] = sceneState.drawingBufferWidth / sceneState.drawingBufferHeight;
		// determine frustum near & far.***
		var camHeight = camera.getCameraElevation();
		var eqRadius = Globe.equatorialRadius();
		frustum0.far[0] = (eqRadius + camHeight*10);

		//if (camHeight > eqRadius*1.2)
		if (camHeight > 1000000)
		{ frustum0.near[0] = 0.1 + camHeight/1000000; }
		else
		{ frustum0.near[0] = 0.1 + camHeight / 10000000; }
	
		// Test values.****************************
		frustum0.near[0] = 0.1 + camHeight*0.9; // delete.!!!
		//frustum0.far[0] = (camHeight+eqRadius)*10000;
		// End test.-------------------------------
		
		ManagerUtils.calculateSplited3fv([camPos.x, camPos.y, camPos.z], sceneState.encodedCamPosHigh, sceneState.encodedCamPosLow);
		
		// projection.***
		// consider near as zero provisionally.***
		sceneState.projectionMatrix._floatArrays = glMatrix.mat4.perspective(sceneState.projectionMatrix._floatArrays, frustum0.fovyRad[0], frustum0.aspectRatio[0], frustum0.near[0], frustum0.far[0]);
		//sceneState.projectionMatrix._floatArrays = glMatrix.mat4.perspective(sceneState.projectionMatrix._floatArrays, frustum0.fovyRad[0], frustum0.aspectRatio[0], 0.0, frustum0.far[0]);
		
		// modelView.***
		//sceneState.modelViewMatrix._floatArrays; 
		sceneState.modelViewMatrixInv._floatArrays = glMatrix.mat4.invert(sceneState.modelViewMatrixInv._floatArrays, sceneState.modelViewMatrix._floatArrays);
	
		// normalMat.***
		sceneState.normalMatrix4._floatArrays = glMatrix.mat4.transpose(sceneState.normalMatrix4._floatArrays, sceneState.modelViewMatrixInv._floatArrays);
		
		// modelViewRelToEye.***
		///sceneState.modelViewRelToEyeMatrix._floatArrays = glMatrix.mat4.transpose(sceneState.modelViewRelToEyeMatrix._floatArrays, sceneState.modelViewMatrix._floatArrays);
		sceneState.modelViewRelToEyeMatrix._floatArrays = glMatrix.mat4.copy(sceneState.modelViewRelToEyeMatrix._floatArrays, sceneState.modelViewMatrix._floatArrays);
		sceneState.modelViewRelToEyeMatrix._floatArrays[12] = 0;
		sceneState.modelViewRelToEyeMatrix._floatArrays[13] = 0;
		sceneState.modelViewRelToEyeMatrix._floatArrays[14] = 0;
		sceneState.modelViewRelToEyeMatrix._floatArrays[15] = 1;
		sceneState.modelViewRelToEyeMatrixInv._floatArrays = glMatrix.mat4.invert(sceneState.modelViewRelToEyeMatrixInv._floatArrays, sceneState.modelViewRelToEyeMatrix._floatArrays);
		
		// modelViewProjection.***
		sceneState.modelViewProjMatrix._floatArrays = glMatrix.mat4.multiply(sceneState.modelViewProjMatrix._floatArrays, sceneState.projectionMatrix._floatArrays, sceneState.modelViewMatrix._floatArrays);
		
		// modelViewProjectionRelToEye.***
		//sceneState.modelViewProjRelToEyeMatrix._floatArrays = glMatrix.mat4.multiply(sceneState.modelViewProjRelToEyeMatrix._floatArrays, sceneState.projectionMatrix._floatArrays, sceneState.modelViewRelToEyeMatrix._floatArrays);

		// modelViewProjectionRelToEye.***
		sceneState.modelViewProjRelToEyeMatrix.copyFromMatrix4(sceneState.modelViewProjMatrix);
		sceneState.modelViewProjRelToEyeMatrix._floatArrays[12] = 0;
		sceneState.modelViewProjRelToEyeMatrix._floatArrays[13] = 0;
		sceneState.modelViewProjRelToEyeMatrix._floatArrays[14] = 0;
		sceneState.modelViewProjRelToEyeMatrix._floatArrays[15] = 1;
		
		
		frustum0.tangentOfHalfFovy[0] = Math.tan(frustum0.fovyRad[0]/2);
		
		//sceneState.modelViewProjRelToEyeMatrix._floatArrays = glMatrix.mat4.multiply(sceneState.modelViewProjRelToEyeMatrix._floatArrays, sceneState.projectionMatrix._floatArrays, sceneState.modelViewRelToEyeMatrix._floatArrays);

	}
	
	
	sceneState.modelViewProjMatrixInv = undefined; // init. Calculate when necessary.***
	sceneState.projectionMatrixInv = undefined; // init.Calculate when necessary.***
	
	if (this.depthFboNeo !== undefined)
	{
		var noiseTexture = this.texturesStore.getNoiseTexture4x4();
		sceneState.ssaoNoiseScale2[0] = this.depthFboNeo.width[0]/noiseTexture.width;
		sceneState.ssaoNoiseScale2[1] = this.depthFboNeo.height[0]/noiseTexture.height;
	}
	
	// set the auxiliar camera.
	this.myCameraSCX.direction.set(sceneState.camera.direction.x, sceneState.camera.direction.y, sceneState.camera.direction.z);
	this.myCameraSCX.up.set(sceneState.camera.up.x, sceneState.camera.up.y, sceneState.camera.up.z);
	var frustum0 = this.myCameraSCX.getFrustum(0);
	var sceneCamFurustum0 = sceneState.camera.getFrustum(0);
	frustum0.near[0] = sceneCamFurustum0.near[0];
	frustum0.far[0] = sceneCamFurustum0.far[0];
	frustum0.fovyRad[0] = sceneCamFurustum0.fovyRad[0];
	frustum0.tangentOfHalfFovy[0] = sceneCamFurustum0.tangentOfHalfFovy[0];
	frustum0.fovRad[0] = sceneCamFurustum0.fovRad[0];
	frustum0.aspectRatio[0] = sceneCamFurustum0.aspectRatio[0];
	
	// Test.***************************
	/*
	var currFrustumIdx = this.currentFrustumIdx;
	var frustumFar = sceneState.camera.frustumsArray[currFrustumIdx].far[0];
	
	var point = ManagerUtils.geographicCoordToWorldPoint(126.61342381397036, 37.57615052829767, 10, undefined, this);
	var cartesian = [point.x, point.y, point.z, 1.0];
	
	var transformedPoint_MVP = sceneState.modelViewProjMatrix.transformPoint4D__test(cartesian);
	var xDivW = transformedPoint_MVP[0]/transformedPoint_MVP[3];
	var yDivW = transformedPoint_MVP[1]/transformedPoint_MVP[3];
	var zDivW = transformedPoint_MVP[2]/transformedPoint_MVP[3];
	var transformedPoint_MVP_divW = [xDivW, yDivW, zDivW, 1.0];
	var camera = sceneState.camera;
	var frustum = camera.bigFrustum;
		
	var zDivW_divFar = zDivW/frustum.far[0];
	var transformedPoint_MV = sceneState.modelViewMatrix.transformPoint4D__test(cartesian);
	var transformedPoint_P = sceneState.projectionMatrix.transformPoint4D__test(cartesian);
	*/


	// update sun if exist.
	if (!this.isCameraMoving && !this.mouseLeftDown && !this.mouseMiddleDown)
	{
		if (this.sceneState.sunSystem && this.sceneState.applySunShadows && this.isFarestFrustum())
		{
			this.sceneState.sunSystem.updateSun(this);
		}
	}
};

/**
 * Here updates the camera's parameters and frustum planes.
 * @param {Camera} camera
 */
MagoManager.prototype.upDateCamera = function(resultCamera) 
{
	if (this.isCesiumGlobe())
	{
		var scene = this.scene;
		var frustumCommandsList = scene.frustumCommandsList;
		var frustumIdx = this.currentFrustumIdx;
		var camera = this.sceneState.camera;
		var currentFrustumFar = frustumCommandsList[frustumIdx].far;
		var currentFrustumNear = frustumCommandsList[frustumIdx].near;
		
		// take all frustums near-far distances.***
		// In Cesium: If useLogDepth opaqueFrustumNearOffset = 0.9. Else opaqueFrustumNearOffset = 0.9999;
		var nearOffset = scene.opaqueFrustumNearOffset;
		var numFrustums = frustumCommandsList.length;
		var distancesArray = [];
		var tanHalfFovy = undefined;
		for (var i=0; i<numFrustums; i++)
		{
			distancesArray[i*2] = frustumCommandsList[i].near;
			distancesArray[i*2+1] = frustumCommandsList[i].far;
			
			if ( i !== 0 )
			{ distancesArray[i*2] *= nearOffset; }
			
			// Set frustum parameters.***
			var frustum = camera.getFrustum(i);
			frustum.far[0] = frustumCommandsList[i].far; 
			frustum.near[0] = frustumCommandsList[i].near;
			frustum.fovRad[0] = scene.camera.frustum._fov;
			frustum.fovyRad[0]= scene.camera.frustum._fovy;
			frustum.aspectRatio[0] = scene.camera.frustum._aspectRatio;
			if (tanHalfFovy === undefined)
			{ tanHalfFovy = Math.tan(frustum.fovyRad/2); }
			frustum.tangentOfHalfFovy[0] = tanHalfFovy;
		}
		
		// Set cam dir & up by modelViewMatrix.***
		var sceneState = this.sceneState;
		var modelViewMatInv = sceneState.modelViewMatrixInv;
		//var camPosX = modelViewMatInv._floatArrays[12]; // No enough precision. 
		//var camPosY = modelViewMatInv._floatArrays[13]; // No enough precision. 
		//var camPosZ = modelViewMatInv._floatArrays[14]; // No enough precision. 
		
		var camPosX = scene.camera.positionWC.x;
		var camPosY = scene.camera.positionWC.y;
		var camPosZ = scene.camera.positionWC.z;
		
		var camDirX = -modelViewMatInv._floatArrays[8];
		var camDirY = -modelViewMatInv._floatArrays[9];
		var camDirZ = -modelViewMatInv._floatArrays[10];
		
		var camUpX = modelViewMatInv._floatArrays[4];
		var camUpY = modelViewMatInv._floatArrays[5];
		var camUpZ = modelViewMatInv._floatArrays[6];
		
		resultCamera.position.set(camPosX, camPosY, camPosZ);
		resultCamera.direction.set(camDirX, camDirY, camDirZ);
		resultCamera.up.set(camUpX, camUpY, camUpZ);
		
		var aspectRatio = frustum.aspectRatio[0];
		var fovy = frustum.fovyRad;	
		
		frustum = resultCamera.getFrustum(frustumIdx);
		resultCamera.frustum.near[0] = currentFrustumNear;
		resultCamera.frustum.far[0] = currentFrustumFar;
		resultCamera.setFrustumsDistances(numFrustums, distancesArray);
		resultCamera.setAspectRatioAndFovyRad(aspectRatio, fovy);
		resultCamera.calculateFrustumsPlanes();
		
		//resultCamera.currentFrustumFar
	}
	else/* if (this.configInformation.basicGlobe === Constant.MAGOWORLD)*/
	{
		var camera = this.sceneState.camera;
		
		camera.doInertialMovement(this);
		
		var frustumIdx = 0;
		var camera = this.sceneState.camera;
		var frustum = camera.getFrustum(frustumIdx);
		var aspectRatio = frustum.aspectRatio[0];
		var fovy = frustum.fovyRad;

		var currentFrustumFar = frustum.far[0];
		var currentFrustumNear = frustum.near[0];
		
		this.sceneState.camera.frustum.near[0] = currentFrustumNear;
		this.sceneState.camera.frustum.far[0] = currentFrustumFar;
		this.sceneState.camera.frustum.aspectRatio[0] = aspectRatio;
		
		// take all frustums near-far distances.***
		var numFrustums = 1;
		var distancesArray = [];
		for (var i=0; i<numFrustums; i++)
		{
			distancesArray[i*2] = frustum.near;
			distancesArray[i*2+1] = frustum.far;
		}
		
		resultCamera.position.set(camera.position.x, camera.position.y, camera.position.z);
		resultCamera.direction.set(camera.direction.x, camera.direction.y, camera.direction.z);
		resultCamera.up.set(camera.up.x, camera.up.y, camera.up.z);
		frustum = resultCamera.getFrustum(frustumIdx);
		frustum.near[0] = currentFrustumNear;
		frustum.far[0] = currentFrustumFar;
		
		resultCamera.setFrustumsDistances(numFrustums, distancesArray);
		resultCamera.setAspectRatioAndFovyRad(aspectRatio, fovy);
		resultCamera.calculateFrustumsPlanes();
	}
};

/**
 * start rendering.
 * @param scene 변수
 * @param isLastFrustum 변수
 */
MagoManager.prototype.getCurrentTime = function() 
{
	if (this.currTime === undefined) 
	{
		this.dateSC = new Date();
		this.currTime = this.dateSC.getTime();
	}
	return this.currTime;
};

/**
 * Returns WebGL Rendering Context.
 */
MagoManager.prototype.getGl = function() 
{
	if (this.sceneState === undefined)
	{ return undefined; }
	
	return this.sceneState.gl;
};

/**
 * Loads necessary data.
 */
MagoManager.prototype.loadAndPrepareData = function() 
{
	var gl = this.getGl();
	
	// 1) LOD 0.***********************************************************************************
	this.visibleObjControlerOctrees.initArrays(); // init.******

	var node;
	// lod 0 & lod 1.
	this.checkPropertyFilters(this.visibleObjControlerNodes.currentVisibles0);
	this.checkPropertyFilters(this.visibleObjControlerNodes.currentVisibles2);
	this.checkPropertyFilters(this.visibleObjControlerNodes.currentVisibles3);
	var nodesCount = this.visibleObjControlerNodes.currentVisibles0.length;
	for (var i=0; i<nodesCount; i++) 
	{
		node = this.visibleObjControlerNodes.currentVisibles0[i];
		var attributes = node.data.attributes;
		if (attributes.objectType === "basicF4d")
		{
			// lod0 일시 카메라에 들어오는 옥트리들을 추출
			if (!this.getRenderablesDetailedNeoBuildingAsimetricVersion(gl, node, this.visibleObjControlerOctrees, 0))
			{
				// any octree is visible.
				this.visibleObjControlerNodes.currentVisibles0.splice(i, 1);
				i--;
				nodesCount = this.visibleObjControlerNodes.currentVisibles0.length;
			}
		}
		//else if (attributes.objectType === "multiBuildingsTile")
		//{
		//	// Load data if necessary.
		//	var hola = 0;
		//}
	}
	
	this.prepareVisibleOctreesSortedByDistance(gl, this.visibleObjControlerOctrees); 
	this.prepareVisibleOctreesSortedByDistanceLOD2(gl, this.visibleObjControlerOctrees.currentVisibles0); 
	this.prepareVisibleOctreesSortedByDistanceLOD2(gl, this.visibleObjControlerOctrees.currentVisibles1); 
	this.prepareVisibleOctreesSortedByDistanceLOD2(gl, this.visibleObjControlerOctrees.currentVisibles2); 
	
	// lod 2.
	// TODO : maxRequest count to settings
	if (this.readerWriter.referencesList_requested < 5)
	{
		nodesCount = this.visibleObjControlerNodes.currentVisibles2.length;
		for (var i=0; i<nodesCount; i++) 
		{
			node = this.visibleObjControlerNodes.currentVisibles2[i];
			var attributes = node.data.attributes;
			if (attributes.objectType === "basicF4d")
			{
				if (!this.getRenderablesDetailedNeoBuildingAsimetricVersion(gl, node, this.visibleObjControlerOctrees, 2))
				{
					// any octree is visible.
					this.visibleObjControlerNodes.currentVisibles2.splice(i, 1);
					i--;
					nodesCount = this.visibleObjControlerNodes.currentVisibles2.length;
				}
			}
		}

		this.prepareVisibleOctreesSortedByDistanceLOD2(gl, this.visibleObjControlerOctrees.currentVisibles2); 
	}
	
	// lod3, lod4, lod5.***
	this.readerWriter.skinLegos_requested = 0;
	this.prepareVisibleLowLodNodes(this.visibleObjControlerNodes.currentVisibles0);
	this.prepareVisibleLowLodNodes(this.visibleObjControlerNodes.currentVisibles2);
	this.prepareVisibleLowLodNodes(this.visibleObjControlerNodes.currentVisibles3);
	
	// Init the pCloudPartitionsMother_requested.***
	this.readerWriter.pCloudPartitionsMother_requested = 0;
	
	// TinTerrain.*******************************************************************************************************************************
	if (this.isFarestFrustum())
	{
		if (this.tinTerrainManager !== undefined)
		{ this.tinTerrainManager.prepareVisibleTinTerrains(this); }
	}
	//if(this.isFarestFrustum())
	this.manageQueue();
	
};

/**
 * Manages the selection process.
 */
MagoManager.prototype.managePickingProcess = function() 
{
	var gl = this.getGl();
	
	if (this.selectionFbo === undefined) 
	{ this.selectionFbo = new FBO(gl, this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight); }
	
	if (this.isCameraMoved || this.bPicking) // 
	{
		this.selectionFbo.bind(); // framebuffer for color selection.***
		gl.enable(gl.DEPTH_TEST);
		gl.depthFunc(gl.LEQUAL);
		gl.depthRange(0, 1);
		gl.disable(gl.CULL_FACE);
		if (this.isLastFrustum)
		{
			// this is the farest frustum, so init selection process.***
			gl.clearColor(1, 1, 1, 1); // white background.***
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // clear buffer.***
			this.selectionManager.clearCandidates();
			gl.clearColor(0, 0, 0, 1); // return to black background.***
		}
		
		this.renderer.renderGeometryColorCoding(this.visibleObjControlerNodes);
		this.swapRenderingFase();
		
		if (this.currentFrustumIdx === 0)
		{
			this.isCameraMoved = false;

			//TODO : MOVEEND EVENT TRIGGER
			//PSEUDO CODE FOR CLUSTER
			//if (this.modeler && this.modeler.objectsArray) 
			//{
			//	for (var i=0, len=this.modeler.objectsArray.length;i<len;i++) 
			//	{
			//		var obj = this.modeler.objectsArray[i];
			//		if (!obj instanceof Cluster) { continue; }
			//
			//		if (!obj.dirty && !obj.isMaking) { obj.setDirty(true); }
			//	}
			//}
		}
	}
	
	if (this.currentFrustumIdx === 0)
	{
		if ( this.bPicking === true)
		{
			// this is the closest frustum.***
			var selectionManager = this.selectionManager;
			var selectedGeneralObject = selectionManager.currentGeneralObjectSelected ? true : false;
			this.bPicking = false;
			this.arrayAuxSC.length = 0;
			selectionManager.clearCurrents();
			var bSelectObjects = true;

			this.objectSelected = this.getSelectedObjects(gl, this.mouse_x, this.mouse_y, this.arrayAuxSC, bSelectObjects);
			
			var auxBuildingSelected = this.arrayAuxSC[0];
			var auxOctreeSelected = this.arrayAuxSC[1];
			var auxNodeSelected = this.arrayAuxSC[3]; 

			var mode = this.magoPolicy.getObjectMoveMode();

			if (mode === CODE.moveMode.ALL) 
			{
				if (auxBuildingSelected && auxNodeSelected) 
				{
					this.emit(MagoManager.EVENT_TYPE.SELECTEDF4D, {
						type      : MagoManager.EVENT_TYPE.SELECTEDF4D, 
						f4d       : auxNodeSelected, 
						timestamp : new Date()
					});
				}
				else if ((this.buildingSelected && !auxBuildingSelected) && (this.nodeSelected && !auxNodeSelected))
				{
					this.emit(MagoManager.EVENT_TYPE.DESELECTEDF4D, {
						type: MagoManager.EVENT_TYPE.DESELECTEDF4D
					});
				}
			}
			else if (mode === CODE.moveMode.OBJECT) 
			{
				if (auxOctreeSelected && this.objectSelected) 
				{
					this.emit(MagoManager.EVENT_TYPE.SELECTEDF4DOBJECT, {
						type      : MagoManager.EVENT_TYPE.SELECTEDF4DOBJECT,
						octree    : auxBuildingSelected,
						object    : this.objectSelected,
						timestamp : new Date()
					});
				}
				else if (this.octreeSelected && !auxOctreeSelected)
				{
					this.emit(MagoManager.EVENT_TYPE.DESELECTEDF4DOBJECT, {
						type: MagoManager.EVENT_TYPE.DESELECTEDF4DOBJECT
					});
				}
			}

			this.buildingSelected = auxBuildingSelected;
			this.octreeSelected = auxOctreeSelected;
			this.nodeSelected = auxNodeSelected;
			if (this.nodeSelected)
			{ this.rootNodeSelected = this.nodeSelected.getRoot(); }
			else
			{ this.rootNodeSelected = undefined; }
				
			this.arrayAuxSC.length = 0;
			if (this.buildingSelected !== undefined) 
			{
				this.displayLocationAndRotation(this.buildingSelected);
				this.selectedObjectNotice(this.buildingSelected);
			}
			if (this.objectSelected !== undefined) 
			{
				//this.displayLocationAndRotation(currentSelectedBuilding);
				//this.selectedObjectNotice(currentSelectedBuilding);
				//console.log("objectId = " + selectedObject.objectId);
			}

			if (selectionManager.currentGeneralObjectSelected) 
			{
				this.emit(MagoManager.EVENT_TYPE.SELECTEDGENERALOBJECT, {
					type          : MagoManager.EVENT_TYPE.SELECTEDGENERALOBJECT,
					generalObject : selectionManager.currentGeneralObjectSelected,
					timestamp     : new Date()
				});
			}
			else if (selectedGeneralObject && !selectionManager.currentGeneralObjectSelected)
			{
				this.emit(MagoManager.EVENT_TYPE.DESELECTEDGENERALOBJECT, {
					type: MagoManager.EVENT_TYPE.DESELECTEDGENERALOBJECT
				});
			}
	
			// Test flyTo by topology.******************************************************************************
			var selCandidatesEdges = selectionManager.getSelectionCandidatesFamily("networkEdges");
			var selCandidatesNodes = selectionManager.getSelectionCandidatesFamily("networkNodes");
			var flyed = false;
			if (selCandidatesEdges)
			{
				var edgeSelected = selCandidatesEdges.currentSelected;
				if (edgeSelected && edgeSelected.vtxSegment)
				{
					// calculate the 2 positions of the edge.***
					var camPos = this.sceneState.camera.position;
					var vtxSeg = edgeSelected.vtxSegment;
					var pos1 = new Point3D();
					var pos2 = new Point3D();
					pos1.copyFrom(vtxSeg.startVertex.point3d);
					pos2.copyFrom(vtxSeg.endVertex.point3d);
					pos1.add(0.0, 0.0, 1.7); // add person height.***
					pos2.add(0.0, 0.0, 1.7); // add person height.***
						
						
					// calculate pos1 & pos2 to worldCoordinate.***
					// Need the building tMatrix.***
					var network = edgeSelected.networkOwner;
					var node = network.nodeOwner;
					var geoLocDataManager = node.data.geoLocDataManager;
					var geoLoc = geoLocDataManager.getCurrentGeoLocationData();
					var tMat = geoLoc.tMatrix;
						
					// To positions must add "pivotPointTraslation" if exist.***
					// If building moved to bboxCenter, for example, then exist "pivotPointTraslation".***
					var pivotTranslation = geoLoc.pivotPointTraslationLC;
					if (pivotTranslation)
					{
						pos1.add(pivotTranslation.x, pivotTranslation.y, pivotTranslation.z);
						pos2.add(pivotTranslation.x, pivotTranslation.y, pivotTranslation.z);
					}

					var worldPos1 = tMat.transformPoint3D(pos1, undefined);
					var worldPos2 = tMat.transformPoint3D(pos2, undefined);

					// select the farestPoint to camera.***
					var dist1 = camPos.squareDistToPoint(worldPos1);
					var dist2 = camPos.squareDistToPoint(worldPos2);
					var pointSelected;
					if (dist1<dist2)
					{
						pointSelected = worldPos2;
					}
					else
					{ pointSelected = worldPos1; }
						
					// now flyTo pointSelected.***
					this.flyToTopology(pointSelected, 2);
					flyed = true;
				}
			}
			if (!flyed && selCandidatesNodes)
			{
				var nodeSelected = selCandidatesNodes.currentSelected;
				if (nodeSelected)
				{
					// calculate the 2 positions of the edge.***
					var camPos = this.sceneState.camera.position;
					var pos1 = new Point3D(nodeSelected.position.x, nodeSelected.position.y, nodeSelected.position.z);
					pos1.add(0.0, 0.0, 1.7); // add person height.***
						
						
					// calculate pos1 & pos2 to worldCoordinate.***
					// Need the building tMatrix.***
					var network = nodeSelected.networkOwner;
					var node = network.nodeOwner;
					var geoLocDataManager = node.data.geoLocDataManager;
					var geoLoc = geoLocDataManager.getCurrentGeoLocationData();
					var tMat = geoLoc.tMatrix;
						
					// To positions must add "pivotPointTraslation" if exist.***
					// If building moved to bboxCenter, for example, then exist "pivotPointTraslation".***
					var pivotTranslation = geoLoc.pivotPointTraslationLC;
					if (pivotTranslation)
					{
						pos1.add(pivotTranslation.x, pivotTranslation.y, pivotTranslation.z);
					}
						
					var worldPos1 = tMat.transformPoint3D(pos1, undefined);
						
					// now flyTo pointSelected.***
					this.flyToTopology(worldPos1, 2);
					flyed = true;
				}
			}
			// End Test flyTo by topology.******************************************************************************
			
		}
		
		this.selectionColor.init(); // selection colors manager.***
	}
	
	this.selectionFbo.unbind();
	gl.enable(gl.CULL_FACE);
};

/**
 * Provisional function.
 */
MagoManager.prototype.getSilhouetteDepthFbo = function() 
{
	// Provisional function.***
	// Provisional function.***
	// Provisional function.***
	var gl = this.getGl();
	
	if (this.silhouetteDepthFboNeo === undefined) { this.silhouetteDepthFboNeo = new FBO(gl, this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight); }
	if (this.sceneState.drawingBufferWidth[0] !== this.silhouetteDepthFboNeo.width[0] || this.sceneState.drawingBufferHeight[0] !== this.silhouetteDepthFboNeo.height[0])
	{
		// move this to onResize.***
		this.silhouetteDepthFboNeo.deleteObjects(gl);
		this.silhouetteDepthFboNeo = new FBO(gl, this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight);
		this.sceneState.camera.frustum.dirty = true;
	}
	
	return this.silhouetteDepthFboNeo;
};

/**
 * Main rendering function.
 */
MagoManager.prototype.doRender = function(frustumVolumenObject) 
{
	var gl = this.getGl();
	var cameraPosition = this.sceneState.camera.position;
	var currentShader = undefined;
	
	// 1) The depth render.**********************************************************************************************************************
	var renderType = 0; // 0= depth. 1= color.***
	this.renderType = 0;
	var renderTexture = false;
	
	// Take the depFrameBufferObject of the current frustumVolume.***
	/*
	if (this.depthFboNeo === undefined) { this.depthFboNeo = new FBO(gl, this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight); }
	if (this.sceneState.drawingBufferWidth[0] !== this.depthFboNeo.width[0] || this.sceneState.drawingBufferHeight[0] !== this.depthFboNeo.height[0])
	{
		// move this to onResize.***
		this.depthFboNeo.deleteObjects(gl);
		this.depthFboNeo = new FBO(gl, this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight);
		this.sceneState.camera.frustum.dirty = true;
	}
	*/
	
	
	if (frustumVolumenObject.depthFbo === undefined) { frustumVolumenObject.depthFbo = new FBO(gl, this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight); }
	if (this.sceneState.drawingBufferWidth[0] !== frustumVolumenObject.depthFbo.width[0] || this.sceneState.drawingBufferHeight[0] !== frustumVolumenObject.depthFbo.height[0])
	{
		// move this to onResize.***
		frustumVolumenObject.depthFbo.deleteObjects(gl);
		frustumVolumenObject.depthFbo = new FBO(gl, this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight);
		this.sceneState.camera.frustum.dirty = true;
	}
	
	// test silhouette depthFbo.***
	//if (frustumVolumenObject.silhouetteDepthFboNeo === undefined) { frustumVolumenObject.silhouetteDepthFboNeo = new FBO(gl, this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight); }
	//if (this.sceneState.drawingBufferWidth[0] !== frustumVolumenObject.silhouetteDepthFboNeo.width[0] || this.sceneState.drawingBufferHeight[0] !== frustumVolumenObject.silhouetteDepthFboNeo.height[0])
	//{
	//	// move this to onResize.***
	//	frustumVolumenObject.silhouetteDepthFboNeo.deleteObjects(gl);
	//	frustumVolumenObject.silhouetteDepthFboNeo = new FBO(gl, this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight);
	//	this.sceneState.camera.frustum.dirty = true;
	//}
	

	this.depthFboNeo = frustumVolumenObject.depthFbo;
	//this.silhouetteDepthFboNeo = frustumVolumenObject.silhouetteDepthFboNeo;
	//frustumVolumenObject.depthFbo = this.depthFboNeo;
	this.depthFboNeo.bind(); 
	
	//if (this.isFarestFrustum())
	{
		gl.clearColor(0, 0, 0, 1);
		gl.clearDepth(1);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		gl.clearStencil(0); // provisionally here.***
	}
	
	gl.viewport(0, 0, this.sceneState.drawingBufferWidth[0], this.sceneState.drawingBufferHeight[0]);
	this.renderer.renderGeometry(gl, renderType, this.visibleObjControlerNodes);
	// test mago geometries.***********************************************************************************************************
	//this.renderer.renderMagoGeometries(renderType); //TEST
	this.depthFboNeo.unbind();
	this.swapRenderingFase();

	// 2) color render.************************************************************************************************************
	// 2.1) Render terrain shadows.*******************************************************************************************************
	// Now render the geomatry.
	if (this.isCesiumGlobe())
	{
		var scene = this.scene;
		scene._context._currentFramebuffer._bind();

		if (this.currentFrustumIdx < 2) 
		{
			renderType = 3;
			this.renderer.renderTerrainShadow(gl, renderType, this.visibleObjControlerNodes);
		}

	}

	
	renderType = 1;
	this.renderType = 1;
	this.renderer.renderGeometry(gl, renderType, this.visibleObjControlerNodes);
	
	if (this.currentFrustumIdx === 0) 
	{
		this.renderCluster();
	}

	if (this.weatherStation)
	{
		this.weatherStation.renderWindLayerDisplayPlanes(this);
		//this.weatherStation.renderWindMultiLayers(this);
		//this.weatherStation.test_renderWindLayer(this);
		//this.weatherStation.test_renderTemperatureLayer(this);
		//this.weatherStation.test_renderCuttingPlanes(this, renderType);
		/*
		var renderType = 1;
		var currentShader;
			currentShader = this.postFxShadersManager.getShader("modelRefSsao"); 
			currentShader.useProgram();
			gl.uniform1i(currentShader.bApplySsao_loc, true); // apply ssao default.***
			gl.enable(gl.BLEND);
			
			var noiseTexture = this.texturesStore.getNoiseTexture4x4();
			var textureAux_1x1 = this.texturesStore.getTextureAux1x1();
			
			gl.uniform1i(currentShader.bApplySpecularLighting_loc, true);
			gl.enableVertexAttribArray(currentShader.texCoord2_loc);
			gl.enableVertexAttribArray(currentShader.position3_loc);
			gl.enableVertexAttribArray(currentShader.normal3_loc);
			
			gl.uniform1i(currentShader.colorType_loc, 1); // 0= oneColor, 1= attribColor, 2= texture.***
			gl.uniform1i(currentShader.bApplySsao_loc, false); // apply ssao default.***

			if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
			
			currentShader.bindUniformGenerals();
			gl.uniform1i(currentShader.textureFlipYAxis_loc, this.sceneState.textureFlipYAxis);
			
			//buildingGeoLocation.bindGeoLocationUniforms(gl, currentShader);
			gl.uniformMatrix4fv(currentShader.buildingRotMatrix_loc, false, new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]));
			gl.uniform3fv(currentShader.buildingPosHIGH_loc, new Float32Array([0,0,0]));
			gl.uniform3fv(currentShader.buildingPosLOW_loc, new Float32Array([0,0,0]));

			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, this.depthFboNeo.colorBuffer);  // original.***
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, noiseTexture);
			gl.activeTexture(gl.TEXTURE2); 
			gl.bindTexture(gl.TEXTURE_2D, textureAux_1x1);
			currentShader.last_tex_id = textureAux_1x1;
		//this.weatherStation.test_renderTemperatureMesh(this, currentShader, renderType);
		this.weatherStation.test_renderPrecipitationMesh(this, currentShader, renderType);
		gl.disable(gl.BLEND);
		
		currentShader.disableVertexAttribArrayAll();
		*/
	}
	
	gl.viewport(0, 0, this.sceneState.drawingBufferWidth[0], this.sceneState.drawingBufferHeight[0]);
		
	this.swapRenderingFase();
	
	// 3) test mago geometries.***********************************************************************************************************
	//this.renderer.renderMagoGeometries(renderType); //TEST
	
	// 4) Render filter.******************************************************************************************************************
	//this.renderFilter();
};

MagoManager.prototype.renderCluster = function() 
{
	if (this.cluster && this.cluster.quatTree) 
	{
		var qtree = this.cluster.quatTree;
		var camPosWc = this.sceneState.camera.getPosition();
		var result = qtree.getDisplayPoints();
		var trees = qtree.getQuatTreeByCamDistance(undefined, camPosWc);

		if (trees && trees.length > 0) 
		{
			this.cluster.renderFunction.call(this.cluster, trees, this);
		}
	}
};

/**
 * 
 */
MagoManager.prototype.initCounters = function() 
{
	this.processCounterManager.reset();
};

/**
 * Main loop function. This function contains all Mago3D Pipe-Line.
 * @param {Boolean} isLastFrustum Indicates if this is the last frustum in the render pipe-line.
 * @param {Number} frustumIdx Current frustum indice.
 * @param {Number} numFrustums Total frustums count in current rendering pipe-line.
 */
MagoManager.prototype.startRender = function(isLastFrustum, frustumIdx, numFrustums) 
{
	// Update the current frame's frustums count.
	this.numFrustums = numFrustums;
	this.isLastFrustum = isLastFrustum;
	
	var gl = this.getGl();
	this.upDateSceneStateMatrices(this.sceneState);
	
	if (this.isFarestFrustum())
	{
		this.dateSC = new Date();
		this.prevTime = this.currTime;
		this.currTime = this.dateSC.getTime();
		
		this.initCounters();
		
		// Before of multiFrustumCullingSmartTile, do animation check, bcos during animation some object can change smartTile-owner.***
		if (this.animationManager !== undefined)
		{ this.animationManager.checkAnimation(this); }

		if (this.myCameraSCX === undefined) 
		{ this.myCameraSCX = new Camera(); }
		
		if (!this.isCameraMoving && !this.mouseLeftDown && !this.mouseMiddleDown)
		{
			this.upDateCamera(this.myCameraSCX);
			this.doMultiFrustumCullingSmartTiles(this.myCameraSCX);
			this.smartTileManager.doPendentProcess(this);
		}
		
		gl.clearStencil(0); // provisionally here.***
		gl.clear(gl.STENCIL_BUFFER_BIT);

		// If mago camera has track node, camera look track node.
		this.sceneState.camera.doTrack(this);
		
		// reset stadistics data.
		this.sceneState.resetStadistics();
		
		// clear canvas.
		this.clearCanvas2D();
	}
	
	var cameraPosition = this.sceneState.camera.position;
	
	// Take the current frustumVolumenObject.***
	var frustumVolumenObject = this.frustumVolumeControl.getFrustumVolumeCulling(frustumIdx); 
	this.myCameraSCX.setCurrentFrustum(frustumIdx);
	this.sceneState.camera.setCurrentFrustum(frustumIdx);
	var visibleNodes = frustumVolumenObject.visibleNodes; // class: VisibleObjectsController.
	
	if (!this.isCameraMoving && !this.mouseLeftDown && !this.mouseMiddleDown)
	{
		if (this.frustumVolumeControl === undefined)
		{ return; }
	
		var frustumVolume = this.myCameraSCX.bigFrustum;
		this.tilesMultiFrustumCullingFinished(frustumVolumenObject.intersectedTilesArray, visibleNodes, cameraPosition, frustumVolume);
		this.prepareNeoBuildingsAsimetricVersion(gl, visibleNodes); 
	}

	var currentShader = undefined;
	this.visibleObjControlerNodes = visibleNodes; // set the current visible nodes.***

	// prepare data if camera is no moving.***
	//if (!this.isCameraMoving && !this.mouseLeftDown && !this.mouseMiddleDown)
	if (!this.isCameraMoving && !this.mouseMiddleDown)
	{
		this.loadAndPrepareData();
		this.managePickingProcess();
	}
	
	if (this.bPicking === true && isLastFrustum)
	{
		var posWC;
	
		/*if (this.magoPolicy.issueInsertEnable === true)
		{
			if (this.objMarkerSC === undefined)
			{ this.objMarkerSC = new ObjectMarker(); }
			
			var mouseAction = this.sceneState.mouseAction;
			var strWC = mouseAction.getStartWorldPoint();
			posWC = new Point3D(strWC.x, strWC.y, strWC.z);
			
			var options = {
				positionWC            : posWC,
				imageFilePath         : "defaultBlue",
				imageFilePathSelected : "defaultRed",
				sizeX                 : 20.0,
				sizeY                 : 20.0
			};
			var objMarker = this.objMarkerManager.newObjectMarker(options, this);
		}

		if (this.magoPolicy.objectInfoViewEnable === true)
		{
			if (this.objMarkerSC === undefined)
			{ 
				if (posWC === undefined)
				{
					var mouseAction = this.sceneState.mouseAction;
					var strWC = mouseAction.getStartWorldPoint();
					posWC = new Point3D(strWC.x, strWC.y, strWC.z);
				}
				
				var options = {
					positionWC            : posWC,
					imageFilePath         : "defaultBlue",
					imageFilePathSelected : "defaultRed"
				};
			
				this.objMarkerSC = this.objMarkerManager.newObjectMarker(options, this);
				this.objMarkerManager.objectMarkerArray.pop();
			}
		}*/
	}

	// Render process.***
	this.doRender(frustumVolumenObject);

	// test. Draw the buildingNames.***
	if (this.magoPolicy.getShowLabelInfo())
	{
		if (this.currentFrustumIdx === 0)
		{ this.clearCanvas2D(); }
		this.drawBuildingNames(this.visibleObjControlerNodes) ;
		this.canvasDirty = true;
	}
	// Do stadistics.
	var displayStadistics = false;
	if (this.currentFrustumIdx === 0 && displayStadistics)
	{
		if (this.stadisticsDisplayed === undefined)
		{ this.stadisticsDisplayed = 0; }

		if (this.stadisticsDisplayed === 0)
		{
			var timePerFrame = this.getCurrentTime() - this.prevTime;
			this.sceneState.fps = Math.floor(1000.0/timePerFrame);
			this.clearCanvas2D();
			this.drawStadistics();
		}

		this.stadisticsDisplayed+= 1;
		
		if (this.stadisticsDisplayed > 5)
		{ this.stadisticsDisplayed = 0; }
	
		this.canvasDirty = true;
	}
};

/**
 * Prepare current visibles low LOD nodes.***
 */
MagoManager.prototype.clearCanvas2D = function() 
{
	if (this.canvasDirty === undefined)
	{ this.canvasDirty = true; }
	
	if (this.canvasDirty)
	{
		var canvas = this.getObjectLabel();
		var ctx = canvas.getContext("2d");
		ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); 
		this.canvasDirty = false;
	}
};


/**
 * Prepare current visibles low LOD nodes.***
 */
MagoManager.prototype.prepareVisibleLowLodNodes = function(lowLodNodesArray) 
{
	var maxParsesCount = 300; // 5
	if (this.readerWriter.skinLegos_requested > maxParsesCount)
	{ return; }
	
	// Prepare lod3, lod4 and lod5 meshes.***
	// check "this.visibleObjControlerNodes.currentVisibles3".***
	var node;
	var neoBuilding;
	
	var lowLodNodesCount = lowLodNodesArray.length;
	for (var i=0; i<lowLodNodesCount; i++) 
	{
		node = lowLodNodesArray[i];
		
		var attributes = node.data.attributes;
		if (attributes.objectType === "basicF4d")
		{
			neoBuilding = node.data.neoBuilding;
			if (neoBuilding.metaData && neoBuilding.metaData.fileLoadState === CODE.fileLoadState.PARSE_FINISHED)
			{ neoBuilding.prepareSkin(this); }
		}
		else if (attributes.objectType === "multiBuildingsTile")
		{
			// Load data if necessary.
			var multiBuildings = node.data.multiBuildings;
			
			if (multiBuildings)
			{ multiBuildings.prepareData(this); }
		}
		
		if (this.readerWriter.skinLegos_requested > maxParsesCount)
		{ return; }
	}
};

/**
 * Draw building names on scene.
 */
MagoManager.prototype.drawStadistics = function() 
{
	var canvas = this.getObjectLabel();
	var ctx = canvas.getContext("2d");
	
	if (this.isFarestFrustum())
	{ this.clearCanvas2D(); }

	var screenCoord = new Point2D(130, 60);
	var sceneState = this.sceneState;
	
	ctx.font = "13px Arial";

	ctx.strokeText("Triangles : " + sceneState.trianglesRenderedCount, screenCoord.x, screenCoord.y);
	ctx.fillText("Triangles : " + sceneState.trianglesRenderedCount, screenCoord.x, screenCoord.y);
	
	ctx.strokeText("Points : " + sceneState.pointsRenderedCount, screenCoord.x, screenCoord.y + 30);
	ctx.fillText("Points : " + sceneState.pointsRenderedCount, screenCoord.x, screenCoord.y + 30);
	
	ctx.strokeText("FPS : " + sceneState.fps, screenCoord.x, screenCoord.y+60);
	ctx.fillText("FPS : " + sceneState.fps, screenCoord.x, screenCoord.y+60);

	ctx.restore(); 
};

/**
 * Draw building names on scene.
 */
MagoManager.prototype.drawBuildingNames = function(visibleObjControlerNodes) 
{
	var canvas = this.getObjectLabel();
	var ctx = canvas.getContext("2d");

	// lod2.
	var gl = this.getGl();
	var node;
	var nodeRoot;
	var geoLocDataManager;
	var geoLoc;
	var neoBuilding;
	var worldPosition;
	var screenCoord;
	
	// 1rst, collect rootNodes.
	var rootNodesMap = {};
	var currentVisiblesArray = visibleObjControlerNodes.currentVisibles1.concat(visibleObjControlerNodes.currentVisibles2, visibleObjControlerNodes.currentVisibles3);
	var nodesCount = currentVisiblesArray.length;
	for (var i=0; i<nodesCount; i++)
	{
		node = currentVisiblesArray[i];
		nodeRoot = node.getRoot();
		if (node.data === undefined || node.data.neoBuilding === undefined)
		{ continue; }
	
		if (node.data.distToCam > 1500.0)
		{ continue; }
		
		var key = node.data.neoBuilding.buildingId;
		///rootNodesMap.set(nodeRoot, nodeRoot);
		rootNodesMap[key] = nodeRoot;
	}
	

	for (var key in rootNodesMap)
	{
		if (Object.prototype.hasOwnProperty.call(rootNodesMap, key))
		{
			//nodeRoot = rootNodesArray[i];
			nodeRoot = rootNodesMap[key];
			geoLocDataManager = nodeRoot.data.geoLocDataManager;
			geoLoc = geoLocDataManager.getCurrentGeoLocationData();
			//neoBuilding = node.data.neoBuilding;
			worldPosition = nodeRoot.getBBoxCenterPositionWorldCoord(geoLoc);
			screenCoord = ManagerUtils.calculateWorldPositionToScreenCoord(gl, worldPosition.x, worldPosition.y, worldPosition.z, screenCoord, this);
			
			if (screenCoord.x >= 0 && screenCoord.y >= 0)
			{
				ctx.font = "13px Arial";
				//ctx.strokeText(nodeRoot.data.nodeId, screenCoord.x, screenCoord.y);
				//ctx.fillText(nodeRoot.data.nodeId, screenCoord.x, screenCoord.y);
				ctx.strokeText(nodeRoot.data.data_name, screenCoord.x, screenCoord.y);
				ctx.fillText(nodeRoot.data.data_name, screenCoord.x, screenCoord.y);
			}
		}
	}
	
	rootNodesMap = {};

	ctx.restore(); 
};

/**
 * The camera was moved.
 */
MagoManager.prototype.cameraMoved = function() 
{
	this.sceneState.camera.setDirty(true);

	if (this.selectionFbo === undefined)     
	{ 
		if (this.sceneState.gl) 
		{
			this.selectionFbo = new FBO(this.sceneState.gl, this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight); 
		}
	}
	if (this.selectionFbo)
	{
		this.selectionFbo.dirty = true;
	}
};

/**
 */
MagoManager.prototype.TEST__SelectionBuffer = function() 
{
	if (this.selectionFbo === undefined)
	{ return; }
	
	var gl = this.getGl();
	
	this.selectionFbo.bind(); // framebuffer for color selection.***
	///////////////////////////////////////////////////////////////////////
	var mouseX = 500;
	var mouseY = 500;
	var mosaicWidth = 9;
	var mosaicHeight = 9;
	var totalPixelsCount = mosaicWidth*mosaicHeight;
	var pixels = new Uint8Array(4 * mosaicWidth * mosaicHeight); // 4 x 3x3 pixel, total 9 pixels select.***
	var pixelX = mouseX - Math.floor(mosaicWidth/2);
	var pixelY = this.sceneState.drawingBufferHeight - mouseY - Math.floor(mosaicHeight/2); // origin is bottom.***
	
	if (pixelX < 0){ pixelX = 0; }
	if (pixelY < 0){ pixelY = 0; }
	
	gl.readPixels(pixelX, pixelY, mosaicWidth, mosaicHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
	gl.bindFramebuffer(gl.FRAMEBUFFER, null); // unbind framebuffer.***
	
	//this.selectionManager.clearCurrents();

	// now, select the object.***
	// The center pixel of the selection is 12, 13, 14.***
	var centerPixel = Math.floor(totalPixelsCount/2);
	var idx = this.selectionColor.decodeColor3(pixels[centerPixel*3], pixels[centerPixel*3+1], pixels[centerPixel*3+2]);
	if (idx === 0)
	{ var hola = 0; }
	//////////////////////////////////////////////////////////////////////////////
	this.selectionFbo.unbind();
};

/**
 * Selects an object of the current visible objects that's under mouse.
 * @param {GL} gl.
 * @param {int} mouseX Screen x position of the mouse.
 * @param {int} mouseY Screen y position of the mouse.
 * @param {VisibleObjectsControler} visibleObjControlerBuildings Contains the current visible objects clasified by LOD.
 * @returns {Array} resultSelectedArray 
 */
MagoManager.prototype.getSelectedObjects = function(gl, mouseX, mouseY, resultSelectedArray, bSelectObjects) 
{
	if (bSelectObjects === undefined)
	{ bSelectObjects = false; }
	
	// Read the picked pixel and find the object.*********************************************************
	var mosaicWidth = 1;
	var mosaicHeight = 1;
	var totalPixelsCount = mosaicWidth*mosaicHeight;
	var pixels = new Uint8Array(4 * mosaicWidth * mosaicHeight); // 4 x 3x3 pixel, total 9 pixels select.***
	var pixelX = mouseX - Math.floor(mosaicWidth/2);
	var pixelY = this.sceneState.drawingBufferHeight - mouseY - Math.floor(mosaicHeight/2); // origin is bottom.***
	
	if (pixelX < 0){ pixelX = 0; }
	if (pixelY < 0){ pixelY = 0; }
	
	gl.readPixels(pixelX, pixelY, mosaicWidth, mosaicHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
	gl.bindFramebuffer(gl.FRAMEBUFFER, null); // unbind framebuffer.***
	
	var selectionManager = this.selectionManager;

	// now, select the object.***
	// The center pixel of the selection is 12, 13, 14.***
	var centerPixel = Math.floor(totalPixelsCount/2);
	var idx = this.selectionColor.decodeColor3(pixels[centerPixel*3], pixels[centerPixel*3+1], pixels[centerPixel*3+2]);
	
	// Provisionally.***
	if (bSelectObjects)
	{ selectionManager.selectObjects(idx); }
	else 
	{
		selectionManager.currentReferenceSelected = selectionManager.referencesMap[idx];
		selectionManager.currentOctreeSelected = selectionManager.octreesMap[idx];
		selectionManager.currentBuildingSelected = selectionManager.buildingsMap[idx];
		selectionManager.currentNodeSelected = selectionManager.nodesMap[idx];
	}
	
	var selectedObject = selectionManager.currentReferenceSelected;

	resultSelectedArray[0] = selectionManager.currentBuildingSelected;
	resultSelectedArray[1] = selectionManager.currentOctreeSelected;
	resultSelectedArray[2] = selectionManager.currentReferenceSelected;
	resultSelectedArray[3] = selectionManager.currentNodeSelected;
	
	// Aditionally check if selected an edge of topology.***
	var selNetworkEdges = selectionManager.getSelectionCandidatesFamily("networkEdges");
	if (selNetworkEdges)
	{
		var currEdgeSelected = selNetworkEdges.currentSelected;
		var i = 0;
		while (currEdgeSelected === undefined && i< totalPixelsCount)
		{
			var idx = this.selectionColor.decodeColor3(pixels[i*3], pixels[i*3+1], pixels[i*3+2]);
			currEdgeSelected = selNetworkEdges.selectObject(idx);
			i++;
		}
	}
	
	// TEST: Check if selected a cuttingPlane.***
	var selGeneralObjects = selectionManager.getSelectionCandidatesFamily("general");
	if (selGeneralObjects)
	{
		var currObjectSelected = selGeneralObjects.currentSelected;
		var i = 0;
		while (currObjectSelected === undefined && i< totalPixelsCount)
		{
			var idx = this.selectionColor.decodeColor3(pixels[i*3], pixels[i*3+1], pixels[i*3+2]);
			currObjectSelected = selGeneralObjects.selectObject(idx);
			i++;
		}
	}
	
	// Check general objects.***
	if (selectedObject === undefined)
	{ selectedObject = selectionManager.selCandidatesMap[idx]; }
	selectionManager.currentGeneralObjectSelected = selectionManager.selCandidatesMap[idx];
	//if (selectionManager.currentGeneralObjectSelected)
	//{ var hola =0; }
	
	return selectedObject;
};

/**
 * Calculates the plane on move an object.
 * @param {GL} gl 변수
 * @param {int} pixelX Screen x position of the pixel.
 * @param {int} pixelY Screen y position of the pixel.
 * @returns {Plane} resultSelObjMovePlane Calculated plane.
 */
MagoManager.prototype.calculateSelObjMovePlaneAsimetricMode = function(gl, pixelX, pixelY, resultSelObjMovePlane) 
{
	if (this.pointSC === undefined)
	{ this.pointSC = new Point3D(); }
	
	if (this.pointSC2 === undefined)
	{ this.pointSC2 = new Point3D(); }
	
	var geoLocDataManager = this.nodeSelected.getNodeGeoLocDataManager();
	
	ManagerUtils.calculatePixelPositionWorldCoord(gl, pixelX, pixelY, this.pointSC2, undefined, undefined, undefined, this);
	var buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
	var tMatrixInv = buildingGeoLocation.getTMatrixInv();
	this.pointSC = tMatrixInv.transformPoint3D(this.pointSC2, this.pointSC); // buildingSpacePoint.***

	if (resultSelObjMovePlane === undefined)
	{ resultSelObjMovePlane = new Plane(); }
	// the plane is in world coord.***
	resultSelObjMovePlane.setPointAndNormal(this.pointSC.x, this.pointSC.y, this.pointSC.z, 0.0, 0.0, 1.0);
	return resultSelObjMovePlane;
};

/**
 * Returns true if is dragging.
 * 
 * @returns {Boolean} 드래그 여부
 */
MagoManager.prototype.isDragging = function() 
{
	if (!this.selectionFbo)
	{
		return false;
	}
	
	var bIsDragging = false;
	var gl = this.sceneState.gl;
	
	this.arrayAuxSC.length = 0;
	if (!this.selectionFbo)
	{
		return false;
	}

	this.selectionFbo.bind();
	var current_objectSelected = this.getSelectedObjects(gl, this.mouse_x, this.mouse_y, this.arrayAuxSC);

	if (this.magoPolicy.objectMoveMode === CODE.moveMode.ALL)	// Moving all
	{
		var currentBuildingSelected = this.arrayAuxSC[0];
		var currentNodeSelected = this.arrayAuxSC[3];
		var currentRootNodeSelected;
		if (currentNodeSelected)
		{
			currentRootNodeSelected = currentNodeSelected.getRoot();
		}
		this.arrayAuxSC.length = 0;

		if (currentRootNodeSelected !== undefined && currentRootNodeSelected === this.rootNodeSelected) 
		{
			bIsDragging = true;
		}
		else 
		{
			bIsDragging = false;
		}
	}
	else if (this.magoPolicy.objectMoveMode === CODE.moveMode.OBJECT) // Moving object
	{
		if (current_objectSelected === undefined)
		{ bIsDragging = false; }
		else if (current_objectSelected === this.objectSelected) 
		{
			bIsDragging = true;
		}
		else 
		{
			bIsDragging = false;
		}
	}
	/*
	else if (this.magoPolicy.objectMoveMode === CODE.moveMode.GEOGRAPHICPOINTS) 
	{
		// Compare currentSelectedObject with the nowSelectedObject.***
		var currSelected = this.selectionManager.getSelectedGeneral();

		this.getSelectedObjects(gl, this.mouse_x, this.mouse_y, this.arrayAuxSC);
		var nowSelected = this.selectionManager.getSelectedGeneral();
		if (nowSelected !== undefined && nowSelected === currSelected)
		{
			var className = nowSelected.constructor.name;
			if (className === "GeographicCoord")
			{
				bIsDragging = true;
			}
			else 
			{
				bIsDragging = false;
			}
		}
	}
	*/
	else
	{
		if (this.weatherStation)
		{
			// check if there are cuttingPlanes to move.***
			var selGeneralObjects = this.selectionManager.getSelectionCandidatesFamily("general");
			if (selGeneralObjects)
			{
				var currObjectSelected = selGeneralObjects.currentSelected;
				if (currObjectSelected)
				{
					// check if is a cuttingPlane.***
					if (currObjectSelected instanceof CuttingPlane)
					{
						bIsDragging = true;
					}
				}
				else 
				{
					bIsDragging = false;
				}
			}
			else
			{ bIsDragging = false; }
		}
		
	}
	
	// General objects.***
	if (!bIsDragging)
	{
		if (current_objectSelected instanceof MagoRenderable) 
		{
			current_objectSelected = current_objectSelected.getRootOwner();
		}
		if (current_objectSelected !== undefined && current_objectSelected === this.selectionManager.getSelectedGeneral())
		{
			bIsDragging = true;
		}
	}
	
	// Finally.***
	if (!bIsDragging)
	{
		this.selectionManager.clearCandidates();
	}
	
	this.selectionFbo.unbind();

	return bIsDragging;
};

/**
 * 카메라 motion 활성 또는 비활성
 * 
 * @param {Boolean} state 카메라 모션 활성화 여부
 */
MagoManager.prototype.setCameraMotion = function(state)
{
	if (MagoConfig.isTwoDimension()) 
	{
		return;
	}
	if (this.isCesiumGlobe())
	{
		this.scene.screenSpaceCameraController.enableRotate = state;
		this.scene.screenSpaceCameraController.enableZoom = state;
		this.scene.screenSpaceCameraController.enableLook = state;
		this.scene.screenSpaceCameraController.enableTilt = state;
		this.scene.screenSpaceCameraController.enableTranslate = state;
	}
};

/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.mouseActionLeftUp = function(mouseX, mouseY) 
{
	if (!this.magoPolicy.getMagoEnable()) { return; }
	if (this.objectMoved)
	{
		this.objectMoved = false;
		var nodeSelected = this.selectionManager.currentNodeSelected;
		if (nodeSelected === undefined)
		{ return; }
		
		this.saveHistoryObjectMovement(this.objectSelected, nodeSelected);
	}
	
	/*if (!this.isCameraMoving) 
	{
		this.getSelectedObjects(this.getGl(), this.mouse_x, this.mouse_y, this.arrayAuxSC, true);
			
		var auxBuildingSelected = this.arrayAuxSC[0];
		var auxOctreeSelected = this.arrayAuxSC[1];
		var auxReferenceSelected = this.arrayAuxSC[2];
		var auxNodeSelected = this.arrayAuxSC[3]; 

		var mode = this.magoPolicy.getObjectMoveMode();

		if (mode === CODE.moveMode.ALL) 
		{
			if (!auxBuildingSelected && !auxNodeSelected) 
			{
				this.emit(MagoManager.EVENT_TYPE.DESELECTEDF4D, {
					type: MagoManager.EVENT_TYPE.DESELECTEDF4D
				});
			}
		}
		else if (mode === CODE.moveMode.OBJECT) 
		{
			if (!auxOctreeSelected && !auxReferenceSelected) 
			{
				this.emit(MagoManager.EVENT_TYPE.DESELECTEDF4DOBJECT, {
					type: MagoManager.EVENT_TYPE.DESELECTEDF4DOBJECT
				});
			}
		}
	}*/

	this.isCameraMoving = false;
	this.mouseLeftDown = false;
	this.mouseDragging = false;
	this.selObjMovePlane = undefined;
	this.selObjMovePlaneCC = undefined;
	this.startGeoCoordDif = undefined;
	this.mustCheckIfDragging = true;
	this.thereAreStartMovePoint = false;

	//this.setBPicking(mouseX, mouseY);

	this.setCameraMotion(true);
	
	// Clear startPositions of mouseAction.***
	var mouseAction = this.sceneState.mouseAction;
	mouseAction.clearStartPositionsAux(); // provisionally only clear the aux.***
	
	if (this.sceneState.sunSystem && this.sceneState.applySunShadows && this.currentFrustumIdx === 0)
	{
		this.sceneState.sunSystem.updateSun(this);
	}
};
MagoManager.prototype.setBPicking = function(mouseX, mouseY) 
{
	this.dateSC = new Date();
	this.currentTimeSC = this.dateSC.getTime();
	var miliSecondsUsed = this.currentTimeSC - this.startTimeSC;
	if (miliSecondsUsed < 1500) 
	{
		if (this.mouse_x === mouseX && this.mouse_y === mouseY) 
		{
			this.bPicking = true;
		}
	}
};

/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.keyDown = function(key) 
{
	if (!this.magoPolicy.getMagoEnable()) { return; }
	if (this.modeler === undefined)
	{ this.modeler = new Modeler(this); }
	
	if (key === 32) // 32 = 'space'.***
	{
		var renderingSettings = this._settings.getRenderingSettings();
		var pointsCloudColorRamp = renderingSettings.getPointsCloudInColorRamp();
		renderingSettings.setPointsCloudInColorRamp(!pointsCloudColorRamp);
	}
	else if (key === 37) // 37 = 'left'.***
	{
		//this.modeler.mode = CODE.modelerMode.DRAWING_GEOGRAPHICPOINTS;
		//this.modeler.mode = CODE.modelerMode.DRAWING_PLANEGRID;
		//this.modeler.mode = CODE.modelerMode.DRAWING_EXCAVATIONPOINTS;
		//this.modeler.mode = CODE.modelerMode.DRAWING_TUNNELPOINTS;
		//this.modeler.mode = CODE.modelerMode.DRAWING_PIPE;
		//this.modeler.mode = CODE.modelerMode.DRAWING_SPHERE;
		//this.modeler.mode = CODE.modelerMode.DRAWING_BOX;
		//this.modeler.mode = CODE.modelerMode.DRAWING_CLIPPINGBOX;
		//this.modeler.mode = CODE.modelerMode.DRAWING_CONCENTRICTUBES;
		//this.modeler.mode = CODE.modelerMode.DRAWING_TUBE;
		//this.modeler.mode = CODE.modelerMode.DRAWING_BASICFACTORY;
		//this.modeler.mode = 50;
		
		if (this.counterAux === undefined)
		{ this.counterAux = -1; }
		
		if (this.counterAux === -1)
		{
			//this.modeler.mode = CODE.modelerMode.DRAWING_CLIPPINGBOX;
			//this.modeler.mode = CODE.modelerMode.DRAWING_CYLYNDER;
			this.modeler.mode = CODE.modelerMode.DRAWING_GEOGRAPHICPOINTS;
			//this.modeler.mode = CODE.modelerMode.DRAWING_EXCAVATIONPOINTS;
			this.counterAux++;
		}
		else if (this.counterAux === 0)
		{
			this.modeler.mode = CODE.modelerMode.DRAWING_BOX;
			this.counterAux++;
		}
		else if (this.counterAux === 1)
		{
			this.modeler.mode = CODE.modelerMode.DRAWING_TUBE;
			this.counterAux++;
		}
		else if (this.counterAux === 2)
		{
			this.modeler.mode = CODE.modelerMode.DRAWING_CONCENTRICTUBES;
			this.counterAux++;
		}
		else if (this.counterAux === 3)
		{
			this.modeler.mode = CODE.modelerMode.DRAWING_BASICFACTORY;
			this.counterAux++;
		}
		else if (this.counterAux === 4)
		{
			this.modeler.mode = CODE.modelerMode.DRAWING_SPHERE;
			this.counterAux++;
		}
		else if (this.counterAux === 5)
		{
			this.modeler.mode = CODE.modelerMode.DRAWING_CLIPPINGBOX;
			this.counterAux ++;
		}
		else if (this.counterAux === 6)
		{
			this.modeler.mode = CODE.modelerMode.DRAWING_FREECONTOURWALL;//
			this.counterAux = 0;
		}
		
	}
	else if (key === 38) // 38 = 'up'.***
	{
		this.modeler.mode = CODE.modelerMode.DRAWING_STATICGEOMETRY;
	}
	else if (key === 39) // 39 = 'right'.***
	{
		this.modeler.mode = CODE.modelerMode.DRAWING_BSPLINE;
		//this.modeler.mode = CODE.modelerMode.DRAWING_GEOGRAPHICPOINTS;
		//this.modeler.mode = 51;
	}
	else if (key === 40) // 40 = 'down'.***
	{
		this.modeler.mode = CODE.modelerMode.DRAWING_BASICFACTORY;
	}
	else if (key === 49) // 49 = '1'.***
	{
		if (this.pointsCloudWhite === undefined)
		{ this.pointsCloudWhite = true; }
		
		if (this.pointsCloudWhite)
		{ this.pointsCloudWhite = false; }
		else
		{ this.pointsCloudWhite = true; }
	}
	else if (key === 80) // 80 = 'p'.***
	{
		var projectId = "AutonomousBus";
		var dataKey = "AutonomousBus_0";
			
		// Do a test.***
		//var projectId = "3ds.json";
		//var dataKey = "GyeomjaeJeongSeon_del";
		
		var node = this.hierarchyManager.getNodeByDataKey(projectId, dataKey);
		node.data.isTrailRender = true; // test.***
		
		var geoLocDataManager = node.getNodeGeoLocDataManager();
		var geoLocData = geoLocDataManager.getCurrentGeoLocationData();
		var geoCoords = geoLocData.getGeographicCoords();
		var currLon = geoCoords.longitude;
		var currLat = geoCoords.latitude;
		var currAlt = geoCoords.altitude;
		
		var latitude;
		var longitude;
		var elevation;
		
		var heading = 45;
		var pitch = 45;
		var roll;
		

		// Test 2: moving by a path.***
		var bSplineCubic3d = this.modeler.bSplineCubic3d;
		var geographicCoordsArray = bSplineCubic3d.geoCoordsList.geographicCoordsArray;
		var path3d = new Path3D(geographicCoordsArray);
		if (bSplineCubic3d !== undefined)
		{
			// do animation by path.***
			var animationOption = {
				animationType                : CODE.animationType.PATH,
				path                         : path3d,
				linearVelocityInMetersSecond : 30,
				autoChangeRotation           : true
			};
			this.changeLocationAndRotation(projectId, dataKey, latitude, longitude, elevation, heading, pitch, roll, animationOption);
		}
	}
	else if (key === 83) // 83 = 's'.***
	{
		// active or deactive shadows.
		if (this.sceneState.applySunShadows)
		{ this.sceneState.setApplySunShadows(false); }
		else
		{ this.sceneState.setApplySunShadows(true); }
	}
	else if (key === 84) // 84 = 't'.***
	{

		//if (this.magoPolicy.issueInsertEnable)
		//{ this.magoPolicy.issueInsertEnable = false; }
		//else
		//{ this.magoPolicy.issueInsertEnable = true; }
		
		
		// Stencil shadow mesh making test.********************
		/*
		var nodeSelected = this.selectionManager.currentNodeSelected;
		if (nodeSelected)
		{
			var geoLocDataManager = nodeSelected.data.geoLocDataManager;
			var geoLocData = geoLocDataManager.getCurrentGeoLocationData();
			var sunSystem = this.sceneState.sunSystem;
			var sunDirWC = sunSystem.getSunDirWC();
			var sunDirLC = geoLocData.getRotatedRelativeVector(sunDirWC, sunDirLC);
			
			var neoBuilding = nodeSelected.data.neoBuilding;
			var lodBuilding = neoBuilding.lodBuildingMap.lod3;
			if (lodBuilding)
			{ lodBuilding.skinLego.makeStencilShadowMesh(sunDirLC); }
		}
		*/
		// End test----------------------------------------------------
		
		// another test.***
		if (this.modeler !== undefined)
		{
			
			var geoCoordsList = this.modeler.getGeographicCoordsList();
			if (geoCoordsList !== undefined)
			{
				// test make thickLine.
				//geoCoordsList.test__makeThickLines(this);
				if (geoCoordsList.getGeoCoordsCount() > 0)
				{
					var renderableObject = GeographicCoordsList.getRenderableObjectOfGeoCoordsArray(geoCoordsList.geographicCoordsArray, this);
					this.modeler.addObject(renderableObject, 15);
					
					geoCoordsList.geographicCoordsArray.length = 0;
				}
				var hola = 0;
			}
			
			//var excavation = this.modeler.getExcavation();
			//if (excavation !== undefined)
			//{
			//	excavation.makeExtrudeObject(this);
			//}
			/*
			if (geoCoordsList !== undefined && geoCoordsList.geographicCoordsArray.length > 0)
			{
				// test make thickLine.
				var options = {
					geoCoordsArray: geoCoordsList.geographicCoordsArray
				};
				var excavation = new Excavation(options);
				this.modeler.addObject(excavation, 12);
			}
			
			
			var tunnel = this.modeler.getTunnel();
			if (tunnel !== undefined)
			{
				tunnel.getProfileGeographicCoordsList(); // executed this only to create the profile.*** TEST.***
				tunnel.makeMesh(this);
				
			}
			*/
			/*
			// Another test: Change color by projectId & objectId.***
			var api = new API();
			api.apiName = "changeColor";
			api.setProjectId("AutonomousBus");
			api.setDataKey("AutonomousBus_0");
			api.setObjectIds("13");
			api.setColor("220,150,20");
			this.callAPI(api);
			
			// Another test: BSplineCubic3d.***
			var bSplineCubic3d = this.modeler.bSplineCubic3d;
			if (bSplineCubic3d !== undefined)
			{
				if (bSplineCubic3d.geoCoordsList === undefined)
				{ bSplineCubic3d.geoCoordsList = new GeographicCoordsList(); }
				
				var maxLengthDegree = 0.001;
				Path3D.insertPointsOnLargeSegments(bSplineCubic3d.geoCoordsList.geographicCoordsArray, maxLengthDegree, this);
				
				var coordsCount = bSplineCubic3d.geoCoordsList.geographicCoordsArray.length;
				for (var i=0; i<coordsCount; i++)
				{
					var geoCoord = bSplineCubic3d.geoCoordsList.geographicCoordsArray[i];
					var geoLocDataManager = geoCoord.getGeoLocationDataManager();
					var geoLocData = geoLocDataManager.newGeoLocationData("noName");
					geoLocData = ManagerUtils.calculateGeoLocationData(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude, undefined, undefined, undefined, geoLocData, this);
				}
				
				var geoCoordsList = bSplineCubic3d.getGeographicCoordsList();
				geoCoordsList.makeLines(this);
			
				// Make the controlPoints.***
				var controlPointArmLength = 0.2;
				bSplineCubic3d.makeControlPoints(controlPointArmLength, this);
				bSplineCubic3d.makeInterpolatedPoints();
			}
			*/
		}
		
		// Another test.***
		
		if (this.smartTile_f4d_tested === undefined)
		{
			this.smartTile_f4d_tested = 1;
			//var projectFolderName = "smartTile_f4d_Korea";
			//var projectFolderName = "SejongParkJinWoo_20191101";
			var projectFolderName = "SmartTilesF4D_WorkFolder";
			var fileName = this.readerWriter.geometryDataPath + "/" + projectFolderName + "/" + "smartTile_f4d_indexFile.sii";
			this.readerWriter.getObjectIndexFileSmartTileF4d(fileName, projectFolderName, this);

		}
		
		//else if (this.smartTile_f4d_tested === 1)
		//{
		//	this.smartTile_f4d_tested ++;
		//	var projectFolderName = "smartTile_f4d_Korea";
		//	var fileName = this.readerWriter.geometryDataPath + "/" + projectFolderName + "/" + "smartTile_f4d_indexFile.sii";
		//	this.readerWriter.getObjectIndexFileSmartTileF4d(fileName, projectFolderName, this);
		//}

		
		// Another test. make collisionCheckOctree.***
		/*
		if (this.selectionManager.currentNodeSelected !== undefined)
		{
			// make collisionCheckOctree.***
			var selNode = this.selectionManager.currentNodeSelected;
			var neoBuilding = selNode.data.neoBuilding;
			if (neoBuilding !== undefined)
			{
				var attributeKey = "isDeletable";
				var attributeValue = false;
				neoBuilding.setAttribute(attributeKey, attributeValue);
				neoBuilding.setAttribute("keepDataArrayBuffers", true);
				// make collisionCheckOctree.***
				if (neoBuilding.allModelsAndReferencesAreParsed(this))
				{
					var desiredMinOctreeSize = 0.25;
					neoBuilding.makeCollisionCheckOctree(desiredMinOctreeSize);
				}
				else 
				{
					neoBuilding.forceToLoadModelsAndReferences(this);
				}
			}
		}
		
		// Moviment restriction test.***
		if (this.modeler !== undefined)
		{
			
			var geoCoordsList = this.modeler.getGeographicCoordsList();
			var geoCoordSegment = geoCoordsList.getGeoCoordSegment(0);
			
			
			var className = "ConcentricTubes";
			var objectsArray = this.modeler.extractObjectsByClassName(className);
			if (objectsArray !== undefined && objectsArray.length > 0)
			{
				var concentricTubes = objectsArray[0];
				if (concentricTubes.attributes === undefined)
				{ concentricTubes.attributes = {}; }
				
				var attributes = concentricTubes.attributes;
				if (attributes.movementRestriction === undefined)
				{ attributes.movementRestriction = {}; }
				
				
				if (attributes.movementRestriction.element === undefined)
				{
					attributes.movementRestriction.element = geoCoordSegment;
				}
				
			}
		}
		*/
		
	}
	else if (key === 87) // 87 = 'w'.***
	{
		// do wind test.
		if (this.windTest === undefined)
		{
			if (this.weatherStation === undefined)
			{ this.weatherStation = new WeatherStation(); }
		
			var geometryDataPath = this.readerWriter.geometryDataPath;
			var windDataFilesNamesArray = ["OBS-QWM_2016062000.grib2_wind_000", "OBS-QWM_2016062001.grib2_wind_000", "OBS-QWM_2016062002.grib2_wind_000", "OBS-QWM_2016062003.grib2_wind_000",
				"OBS-QWM_2016062004.grib2_wind_000", "OBS-QWM_2016062005.grib2_wind_000", "OBS-QWM_2016062006.grib2_wind_000", "OBS-QWM_2016062007.grib2_wind_000",
				"OBS-QWM_2016062008.grib2_wind_000", "OBS-QWM_2016062009.grib2_wind_000", "OBS-QWM_2016062010.grib2_wind_000", "OBS-QWM_2016062011.grib2_wind_000",
				"OBS-QWM_2016062012.grib2_wind_000", "OBS-QWM_2016062013.grib2_wind_000", "OBS-QWM_2016062014.grib2_wind_000", "OBS-QWM_2016062015.grib2_wind_000",
				"OBS-QWM_2016062016.grib2_wind_000", "OBS-QWM_2016062017.grib2_wind_000", "OBS-QWM_2016062018.grib2_wind_000", "OBS-QWM_2016062019.grib2_wind_000",
				"OBS-QWM_2016062020.grib2_wind_000", "OBS-QWM_2016062021.grib2_wind_000", "OBS-QWM_2016062022.grib2_wind_000", "OBS-QWM_2016062023.grib2_wind_000"];
				
			//var windMapFilesFolderPath = geometryDataPath +"/JeJu_wind_Airport";
			var windMapFilesFolderPath = geometryDataPath +"/JeJu_wind_GolfPark_NineBridge1";
			
			this.weatherStation.test_loadWindData3d(this, windDataFilesNamesArray, windMapFilesFolderPath);
			this.TEST__golfPark();
			this.windTest = true;
		}
	}
	else if (key === 89) // 89 = 'y'.***
	{
		if (this.magoMode === undefined)
		{ this.magoMode = CODE.magoMode.NORMAL; }
		
		if (this.magoMode === CODE.magoMode.NORMAL)
		{ this.magoMode = CODE.magoMode.DRAWING; }
		else if (this.magoMode === CODE.magoMode.DRAWING)
		{
			this.magoMode = CODE.magoMode.NORMAL;
			this.modeler.mode = CODE.modelerMode.INACTIVE;
		}
	}
	
	
};

/**
 * 마우스 클릭 이벤트 처리
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.TEST__golfPark = function() 
{
	// create 3 golfHoleFlags.
	var geoCoord = new GeographicCoord(126.40310387701689, 33.34144078912163, 34.0);
	var geoLocDataManager = geoCoord.getGeoLocationDataManager();
	var geoLocData = geoLocDataManager.newGeoLocationData("noName");
	geoLocData = ManagerUtils.calculateGeoLocationData(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude, undefined, undefined, undefined, geoLocData, this);
	
	var options = {color: {r: 0.2, g: 0.5, b: 0.9, a: 0.5}};
	
	var golfHoleFlag = new GolfHoleFlag(0.3, 20, options);
	golfHoleFlag.geoLocDataManager = geoLocDataManager;
	if (golfHoleFlag.attributes === undefined)
	{ golfHoleFlag.attributes = {}; }
	golfHoleFlag.attributes.isMovable = true;
	
	this.modeler.addObject(golfHoleFlag, 15);
	
	// 2nd golfHoleFlag.
	var geoCoord = new GeographicCoord(126.39837002777193, 33.341987673830694, 23.8);
	var geoLocDataManager = geoCoord.getGeoLocationDataManager();
	var geoLocData = geoLocDataManager.newGeoLocationData("noName");
	geoLocData = ManagerUtils.calculateGeoLocationData(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude, undefined, undefined, undefined, geoLocData, this);
	
	var options = {color: {r: 0.2, g: 0.5, b: 0.9, a: 0.5}};
	
	var golfHoleFlag = new GolfHoleFlag(0.3, 20, options);
	golfHoleFlag.geoLocDataManager = geoLocDataManager;
	if (golfHoleFlag.attributes === undefined)
	{ golfHoleFlag.attributes = {}; }
	golfHoleFlag.attributes.isMovable = true;
	
	this.modeler.addObject(golfHoleFlag, 15);
	
	// 3rd golfHoleFlag.
	var geoCoord = new GeographicCoord(126.39794580151037, 33.341476458307255, 18.5);
	var geoLocDataManager = geoCoord.getGeoLocationDataManager();
	var geoLocData = geoLocDataManager.newGeoLocationData("noName");
	geoLocData = ManagerUtils.calculateGeoLocationData(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude, undefined, undefined, undefined, geoLocData, this);
	
	var options = {color: {r: 0.2, g: 0.5, b: 0.9, a: 0.5}};
	
	var golfHoleFlag = new GolfHoleFlag(0.3, 20, options);
	golfHoleFlag.geoLocDataManager = geoLocDataManager;
	if (golfHoleFlag.attributes === undefined)
	{ golfHoleFlag.attributes = {}; }
	golfHoleFlag.attributes.isMovable = true;
	
	this.modeler.addObject(golfHoleFlag, 15);
};

/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.mouseActionLeftClick = function(mouseX, mouseY) 
{
	if (!this.magoPolicy.getMagoEnable()) { return; }

	if (!this.isDragging()) 
	{
		var eventCoordinate = ManagerUtils.getComplexCoordinateByScreenCoord(this.getGl(), mouseX, mouseY, undefined, undefined, undefined, this);
		if (eventCoordinate) 
		{
			this.emit(MagoManager.EVENT_TYPE.CLICK, {type: MagoManager.EVENT_TYPE.CLICK, clickCoordinate: eventCoordinate, timestamp: this.getCurrentTime()});

		}
	}
};

/**
 * 마우스 더블 클릭 이벤트 처리
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.mouseActionLeftDoubleClick = function(mouseX, mouseY) 
{
	if (!this.magoPolicy.getMagoEnable()) { return; }

	if (!this.isDragging()) 
	{
		var eventCoordinate = ManagerUtils.getComplexCoordinateByScreenCoord(this.getGl(), mouseX, mouseY, undefined, undefined, undefined, this);
		if (eventCoordinate) 
		{
			this.emit(MagoManager.EVENT_TYPE.DBCLICK, {
				type            : MagoManager.EVENT_TYPE.DBCLICK, 
				clickCoordinate : eventCoordinate, 
				timestamp       : this.getCurrentTime()
			});
		}
	}
};


/**
 * 마우스 더블 클릭 이벤트 처리
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.mouseActionRightClick = function(mouseX, mouseY) 
{
	if (!this.magoPolicy.getMagoEnable()) { return; }

	if (!this.isDragging()) 
	{
		var eventCoordinate = ManagerUtils.getComplexCoordinateByScreenCoord(this.getGl(), mouseX, mouseY, undefined, undefined, undefined, this);
		if (eventCoordinate) 
		{
			this.emit(MagoManager.EVENT_TYPE.RIGHTCLICK, {type: MagoManager.EVENT_TYPE.CLICK, clickCoordinate: eventCoordinate, timestamp: this.getCurrentTime()});
		}
	}
};

MagoManager.prototype.cameraChanged = function(e) 
{
	this.emit(MagoManager.EVENT_TYPE.CAMERACHANGED, {
		type      : MagoManager.EVENT_TYPE.CAMERACHANGED,
		timestamp : new Date()
	});
};

MagoManager.prototype.cameraMoveStart = function() 
{
	this.emit(MagoManager.EVENT_TYPE.CAMERAMOVESTART, {
		type      : MagoManager.EVENT_TYPE.CAMERAMOVESTART,
		timestamp : new Date()
	});
};

MagoManager.prototype.cameraMoveEnd = function() 
{
	this.emit(MagoManager.EVENT_TYPE.CAMERAMOVEEND, {
		type      : MagoManager.EVENT_TYPE.CAMERAMOVEEND,
		timestamp : new Date()
	});
};



/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.mouseActionLeftDown = function(mouseX, mouseY) 
{
	if (!this.magoPolicy.getMagoEnable()) { return; }
	this.dateSC = new Date();
	this.startTimeSC = this.dateSC.getTime();

	this.mouse_x = mouseX;
	this.mouse_y = mouseY;
	this.mouseLeftDown = true;
	//this.isCameraMoving = true;
	MagoWorld.updateMouseStartClick(mouseX, mouseY, this);
	this.setBPicking(mouseX, mouseY);
};

/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.saveHistoryObjectMovement = function(refObject, node) 
{
	var changeHistory = new ChangeHistory();
	var refMove = changeHistory.getReferenceObjectAditionalMovement();
	var refMoveRelToBuilding = changeHistory.getReferenceObjectAditionalMovementRelToBuilding();
	
	if (refObject.moveVector === undefined)
	{ refObject.moveVector = new Point3D(); }
	
	if (refObject.moveVectorRelToBuilding === undefined)
	{ refObject.moveVectorRelToBuilding = new Point3D(); }
	
	refMove.set(refObject.moveVector.x, refObject.moveVector.y, refObject.moveVector.z);
	refMoveRelToBuilding.set(refObject.moveVectorRelToBuilding.x, refObject.moveVectorRelToBuilding.y, refObject.moveVectorRelToBuilding.z);
	if (node === undefined)
	{ return; }

	var projectId = node.data.projectId;
	var dataKey = node.data.nodeId;
	var objectIndex = refObject._id;
	
	changeHistory.setProjectId(projectId);
	changeHistory.setDataKey(dataKey);
	changeHistory.setObjectIndexOrder(objectIndex);
	MagoConfig.saveMovingHistory(projectId, dataKey, objectIndex, changeHistory);
};



/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.mouseActionMiddleDown = function(mouseX, mouseY) 
{
	if (!this.magoPolicy.getMagoEnable()) { return; }
	this.dateSC = new Date();
	this.startTimeSC = this.dateSC.getTime();

	this.mouse_x = mouseX;
	this.mouse_y = mouseY;
	this.mouseMiddleDown = true;
	this.isCameraMoving = true;
};

/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.mouseActionMiddleUp = function(mouseX, mouseY) 
{
	if (!this.magoPolicy.getMagoEnable()) { return; }
	this.isCameraMoving = false;
	this.mouseMiddleDown = false;
	this.mouseDragging = false;
	this.selObjMovePlane = undefined;
	this.mustCheckIfDragging = true;
	this.thereAreStartMovePoint = false;
	this.setCameraMotion(false);
};

/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.mouseActionRightDown = function(mouseX, mouseY) 
{
	/*
	this.dateSC = new Date();
	this.startTimeSC = this.dateSC.getTime();

	this.mouse_x = mouseX;
	this.mouse_y = mouseY;
	this.mouseRightDown = true;
	this.isCameraMoving = true;
	*/
};

/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 */
MagoManager.prototype.mouseActionRightUp = function(mouseX, mouseY) 
{
	/*
	this.isCameraMoving = false;
	this.setCameraMotion(false);
	*/
};

/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param {Point2D} newPixel
 * @param {Point2D} oldPixel
 */
MagoManager.prototype.mouseActionMove = function(newPixel, oldPixel) 
{
	if (this.mouseLeftDown) 
	{
		if (newPixel.x !== oldPixel.x || newPixel.y !== oldPixel.y) 
		{
			this.manageMouseDragging(newPixel.x, newPixel.y);
			this.cameraMoved();
		}
	}
	else
	{
		this.mouseDragging = false;
		if (this.isCesiumGlobe()) 
		{
			this.setCameraMotion(true);
			//disableCameraMotion(this.scene.screenSpaceCameraController, true);
		}
		
		if (this.mouseMiddleDown || this.mouseRightDown)
		{
			this.isCameraMoving = true;
			this.cameraMoved();
		}
	}
	var gl = this.getGl();
	
	var startEventCoordinate = ManagerUtils.getComplexCoordinateByScreenCoord(gl, oldPixel.x, oldPixel.y, undefined, undefined, undefined, this);
	var endEventCoordinate = ManagerUtils.getComplexCoordinateByScreenCoord(gl, newPixel.x, newPixel.y, undefined, undefined, undefined, this);
	if (startEventCoordinate && endEventCoordinate) 
	{
		this.emit(MagoManager.EVENT_TYPE.MOUSEMOVE, {type: MagoManager.EVENT_TYPE.MOUSEMOVE, startEvent: startEventCoordinate, endEvent: endEventCoordinate, timestamp: this.getCurrentTime() });
	}

	/*function disableCameraMotion(screenSpaceCameraController, state)
	{
		screenSpaceCameraController.enableRotate = state;
		screenSpaceCameraController.enableZoom = state;
		screenSpaceCameraController.enableLook = state;
		screenSpaceCameraController.enableTilt = state;
		screenSpaceCameraController.enableTranslate = state;
	}
	if (this.mouseLeftDown) 
	{
		this.manageMouseDragging(mouseX, mouseY);
	}
	else if (this.mouseMiddleDown) 
	{
		this.sceneState.camera.setDirty(true);
	}
	else if (this.mouseRightDown) 
	{
		this.sceneState.camera.setDirty(true);
	}
	else
	{
		this.mouseDragging = false;
		this.setCameraMotion(false);
		if (this.mouseMiddleDown)
		{
			this.isCameraMoving = true;
		}
		
	}*/
};


/**
 * 선택 객체를 asimetric mode 로 이동
 * @param gl 변수
 * @param scene 변수
 * @param renderables_neoRefLists_array 변수
 */
MagoManager.prototype.manageMouseDragging = function(mouseX, mouseY) 
{
	this.sceneState.camera.setDirty(true);
	
	this.mouse_x = mouseX;
	this.mouse_y = mouseY;
	
	// distinguish 2 modes.******************************************************
	if (this.magoPolicy.objectMoveMode === CODE.moveMode.ALL) // blocks move.***
	{
		if (this.buildingSelected !== undefined && this.selectionManager.currentNodeSelected) 
		{
			// 1rst, check if there are objects to move.***
			if (this.mustCheckIfDragging) 
			{
				if (this.isDragging()) 
				{
					this.mouseDragging = true;
					this.setCameraMotion(false);
				}
				this.mustCheckIfDragging = false;
			}
			// Display geoLocationData while moving building.***
			var nodeOwner = this.buildingSelected.nodeOwner;
			if (nodeOwner === undefined)
			{ return; }

			var geoLocDataManager = nodeOwner.data.geoLocDataManager;
			if (geoLocDataManager === undefined)
			{ return; }

			var geoLocation = geoLocDataManager.getGeoLocationData(0);
			if (geoLocation === undefined)
			{ return; }

			var geographicCoords = geoLocation.geographicCoord;
			if (geographicCoords === undefined)
			{ return; }
			
			this.emit(MagoManager.EVENT_TYPE.SELECTEDF4DMOVED, {
				type   : MagoManager.EVENT_TYPE.SELECTEDF4DMOVED,
				result : {
					projectId : nodeOwner.data.projectId,
					dataKey   : nodeOwner.data.nodeId,
					latitude  : geographicCoords.latitude,
					longitude : geographicCoords.longitude,
					altitude  : geographicCoords.altitude, 
					heading   : geoLocation.heading, 
					pitch     : geoLocation.pitch, 
					roll      : geoLocation.roll
				},
				timestamp: new Date()
			});

			/*movedDataCallback(	MagoConfig.getPolicy().geo_callback_moveddata,
				nodeOwner.data.projectId,
				nodeOwner.data.nodeId,
				null,
				geographicCoords.latitude,
				geographicCoords.longitude,
				geographicCoords.altitude,
				geoLocation.heading,
				geoLocation.pitch,
				geoLocation.roll
			);*/				
		}
		else 
		{
			this.isCameraMoving = true; // if no object is selected.***
		}
	}
	else if (this.magoPolicy.objectMoveMode === CODE.moveMode.OBJECT) // objects move.***
	{
		if (this.objectSelected !== undefined && this.selectionManager.currentOctreeSelected) 
		{
			// 1rst, check if there are objects to move.***
			if (this.mustCheckIfDragging) 
			{
				if (this.isDragging()) 
				{
					this.mouseDragging = true;
					this.setCameraMotion(false);
				}
				this.mustCheckIfDragging = false;
			}
		}
		else 
		{
			this.isCameraMoving = true; // if no object is selected.***
		}
	}
	else if (this.magoPolicy.objectMoveMode === CODE.moveMode.GEOGRAPHICPOINTS) 
	{
		var currSelected = this.selectionManager.getSelectedGeneral();
		if (currSelected)
		{
			var className = currSelected.constructor.name;
			if (className === "GeographicCoord")
			{
				// 1rst, check if there are objects to move.***
				if (this.mustCheckIfDragging) 
				{
					if (this.isDragging()) 
					{
						this.mouseDragging = true;
						this.setCameraMotion(false);
					}
					this.mustCheckIfDragging = false;
				}
			}
		}
	}

	
	// General objects.***
	if (!this.mouseDragging) 
	{
		if (this.mustCheckIfDragging) 
		{
			if (this.isDragging()) 
			{
				this.mouseDragging = true;
				this.setCameraMotion(false);
			}
			this.mustCheckIfDragging = false;
		}
	}
	
	//---------------------------------------------------------------------------------
	this.isCameraMoving = true; // test.***
	if (this.mouseDragging) 
	{
		this.moveSelectedObjectAsimetricMode(this.sceneState.gl);
	}
};
MagoManager.prototype.cameraChanged = function(e) 
{
	this.emit(MagoManager.EVENT_TYPE.CAMERACHANGED, {
		type      : MagoManager.EVENT_TYPE.CAMERACHANGED,
		timestamp : new Date()
	});
};

MagoManager.prototype.cameraMoveStart = function() 
{
	this.emit(MagoManager.EVENT_TYPE.CAMERAMOVESTART, {
		type      : MagoManager.EVENT_TYPE.CAMERAMOVESTART,
		timestamp : new Date()
	});
};

MagoManager.prototype.cameraMoveEnd = function() 
{
	this.emit(MagoManager.EVENT_TYPE.CAMERAMOVEEND, {
		type      : MagoManager.EVENT_TYPE.CAMERAMOVEEND,
		timestamp : new Date()
	});
};

/**
 * Moves an object.
 * @param {WebGLRenderingContext} gl WebGLRenderingContext.
 */
MagoManager.prototype.moveSelectedObjectGeneral = function(gl, object) 
{
	if (object === undefined)
	{ return; }

	if (object instanceof ObjectMarker)
	{ return; }

	object = object.getRootOwner();

	var attributes = object.attributes;
	if (attributes === undefined)
	{ return; }

	var isMovable = attributes.isMovable;
	if (isMovable === undefined || isMovable === false)
	{ return; }
	
	var geoLocDataManager = object.getGeoLocDataManager();
	if (geoLocDataManager === undefined)
	{ return; }
	
	var geoLocationData = geoLocDataManager.getCurrentGeoLocationData();
	
	var mouseAction = this.sceneState.mouseAction;

	
	if (this.selObjMovePlaneCC === undefined) 
	{
		this.selObjMovePlaneCC = new Plane();
		// calculate the pixelPos in camCoord.
		var geoLocMatrix = geoLocationData.geoLocMatrix;
		var mvMat = this.sceneState.modelViewMatrix;
		var mvMatRelToEye = this.sceneState.modelViewRelToEyeMatrix;
		var pixelPosCC = mvMat.transformPoint3D(mouseAction.strWorldPoint, undefined);
		
		var globeYaxisWC = new Point3D(geoLocMatrix._floatArrays[4], geoLocMatrix._floatArrays[5], geoLocMatrix._floatArrays[6]);
		var globeYaxisCC = mvMatRelToEye.transformPoint3D(globeYaxisWC, undefined);
		
		var globeZaxisWC = new Point3D(geoLocMatrix._floatArrays[8], geoLocMatrix._floatArrays[9], geoLocMatrix._floatArrays[10]);
		var globeZaxisCC = mvMatRelToEye.transformPoint3D(globeZaxisWC, undefined);
		
		if (attributes.movementInAxisZ)
		{
			this.selObjMovePlaneCC.setPointAndNormal(pixelPosCC.x, pixelPosCC.y, pixelPosCC.z,    globeYaxisCC.x, globeYaxisCC.y, globeYaxisCC.z); 
		}
		else 
		{
			// movement in plane XY.
			this.selObjMovePlaneCC.setPointAndNormal(pixelPosCC.x, pixelPosCC.y, pixelPosCC.z,    globeZaxisCC.x, globeZaxisCC.y, globeZaxisCC.z); 
		}
	}

	
	if (this.lineCC === undefined)
	{ this.lineCC = new Line(); }
	var camRay = ManagerUtils.getRayCamSpace(this.mouse_x, this.mouse_y, camRay, this);
	this.lineCC.setPointAndDir(0, 0, 0,  camRay[0], camRay[1], camRay[2]);
	
	
	// Calculate intersection cameraRay with planeCC.
	var intersectionPointCC = new Point3D();
	intersectionPointCC = this.selObjMovePlaneCC.intersectionLine(this.lineCC, intersectionPointCC);
	//------------------------------------------------------------------------------------------------

	var mvMat = this.sceneState.modelViewMatrixInv;
	var intersectionPointWC = mvMat.transformPoint3D(intersectionPointCC, intersectionPointWC);

	
	// register the movement.***
	if (!this.thereAreStartMovePoint) 
	{
		var cartographic = ManagerUtils.pointToGeographicCoord(intersectionPointWC, cartographic, this);
		this.thereAreStartMovePoint = true;
		
		var buildingGeoCoord = geoLocationData.geographicCoord;
		this.startGeoCoordDif = new GeographicCoord(cartographic.longitude-buildingGeoCoord.longitude, cartographic.latitude-buildingGeoCoord.latitude, cartographic.altitude-buildingGeoCoord.altitude);

	}
	else 
	{
		var cartographic = ManagerUtils.pointToGeographicCoord(intersectionPointWC, cartographic, this);

		var difX = cartographic.longitude - this.startGeoCoordDif.longitude;
		var difY = cartographic.latitude - this.startGeoCoordDif.latitude;
		var difZ = cartographic.altitude - this.startGeoCoordDif.altitude;
		
		var newLongitude = difX;
		var newlatitude = difY;
		var newAltitude = difZ;
		
		if (Math.abs(newAltitude) > 50)
		{ var hola = 0; }
		
		// Must check if there are restrictions.***
		var attributes = object.attributes;
		
		if (attributes.minAltitude !== undefined)
		{
			if (newAltitude < attributes.minAltitude)
			{ newAltitude = attributes.minAltitude; }
		}
		
		if (attributes.maxAltitude !== undefined)
		{
			if (newAltitude > attributes.maxAltitude)
			{ newAltitude = attributes.maxAltitude; }
		}
		
		if (attributes && attributes.movementRestriction)
		{
			var movementRestriction = attributes.movementRestriction;
			if (movementRestriction)
			{
				var movementRestrictionType = movementRestriction.restrictionType;
				var movRestrictionElem = movementRestriction.element;
				if (movRestrictionElem && movRestrictionElem.constructor.name === "GeographicCoordSegment")
				{
					// restriction.***
					var geoCoordSegment = movRestrictionElem;
					var newGeoCoord = new GeographicCoord(newLongitude, newlatitude, 0.0);
					var projectedCoord = GeographicCoordSegment.getProjectedCoordToLine(geoCoordSegment, newGeoCoord, undefined);
					
					// check if is inside.***
					if (!GeographicCoordSegment.intersectionWithGeoCoord(geoCoordSegment, projectedCoord))
					{
						var nearestGeoCoord = GeographicCoordSegment.getNearestGeoCoord(geoCoordSegment, projectedCoord);
						newLongitude = nearestGeoCoord.longitude;
						newlatitude = nearestGeoCoord.latitude;
					}
					else 
					{
						newLongitude = projectedCoord.longitude;
						newlatitude = projectedCoord.latitude;
					}
				}
			}
		}
		if (attributes && attributes.hasStaticModel)
		{
			var projectId = attributes.projectId;
			var dataKey = attributes.instanceId;
			if (!defined(projectId))
			{
				return false;
			}
			if (!defined(dataKey))
			{
				return false;
			}
			var node = this.hierarchyManager.getNodeByDataKey(projectId, dataKey);
			if (node !== undefined)
			{
				node.changeLocationAndRotation(newlatitude, newLongitude, 0, attributes.f4dHeading, 0, 0, this);
			}
		}
		
		if (attributes.movementInAxisZ)
		{
			geoLocationData = ManagerUtils.calculateGeoLocationData(undefined, undefined, newAltitude, undefined, undefined, undefined, geoLocationData, this);
		}
		else 
		{
			geoLocationData = ManagerUtils.calculateGeoLocationData(newLongitude, newlatitude, undefined, undefined, undefined, undefined, geoLocationData, this);
		}

	}
	
	object.moved();
};


/**
 * Moves an object.
 * @param {WebGLRenderingContext} gl WebGLRenderingContext.
 */
MagoManager.prototype.moveSelectedObjectAsimetricMode = function(gl) 
{
	var currSelected = this.selectionManager.getSelectedGeneral();
	var currSelectedClassName = "";
	if (currSelected)
	{ currSelectedClassName = currSelected.constructor.name; }
	
	if (this.magoPolicy.objectMoveMode === CODE.moveMode.ALL) // buildings move.***
	{
		if (this.selectionManager.currentNodeSelected === undefined)
		{ return; }
		
		var geoLocDataManager = this.selectionManager.currentNodeSelected.getNodeGeoLocDataManager();
		var geoLocationData = geoLocDataManager.getCurrentGeoLocationData();
		
		var mouseAction = this.sceneState.mouseAction;
	
		var attributes = {};
		
		if (this.selObjMovePlaneCC === undefined) 
		{
			this.selObjMovePlaneCC = new Plane();
			// calculate the pixelPos in camCoord.
			var geoLocMatrix = geoLocationData.geoLocMatrix;
			var mvMat = this.sceneState.modelViewMatrix;
			var mvMatRelToEye = this.sceneState.modelViewRelToEyeMatrix;
			var pixelPosCC = mvMat.transformPoint3D(mouseAction.strWorldPoint, undefined);
			
			var globeYaxisWC = new Point3D(geoLocMatrix._floatArrays[4], geoLocMatrix._floatArrays[5], geoLocMatrix._floatArrays[6]);
			var globeYaxisCC = mvMatRelToEye.transformPoint3D(globeYaxisWC, undefined);
			
			var globeZaxisWC = new Point3D(geoLocMatrix._floatArrays[8], geoLocMatrix._floatArrays[9], geoLocMatrix._floatArrays[10]);
			var globeZaxisCC = mvMatRelToEye.transformPoint3D(globeZaxisWC, undefined);
			
			if (attributes.movementInAxisZ)
			{
				this.selObjMovePlaneCC.setPointAndNormal(pixelPosCC.x, pixelPosCC.y, pixelPosCC.z,    globeYaxisCC.x, globeYaxisCC.y, globeYaxisCC.z); 
			}
			else 
			{
				// movement in plane XY.
				this.selObjMovePlaneCC.setPointAndNormal(pixelPosCC.x, pixelPosCC.y, pixelPosCC.z,    globeZaxisCC.x, globeZaxisCC.y, globeZaxisCC.z); 
			}
		}

		if (this.lineCC === undefined)
		{ this.lineCC = new Line(); }
		var camRay = ManagerUtils.getRayCamSpace(this.mouse_x, this.mouse_y, camRay, this);
		this.lineCC.setPointAndDir(0, 0, 0,  camRay[0], camRay[1], camRay[2]);
		
		
		// Calculate intersection cameraRay with planeCC.
		var intersectionPointCC = new Point3D();
		intersectionPointCC = this.selObjMovePlaneCC.intersectionLine(this.lineCC, intersectionPointCC);
		//------------------------------------------------------------------------------------------------

		var mvMat = this.sceneState.modelViewMatrixInv;
		var intersectionPointWC = mvMat.transformPoint3D(intersectionPointCC, intersectionPointWC);
	
		// register the movement.***
		if (!this.thereAreStartMovePoint) 
		{
			var cartographic = ManagerUtils.pointToGeographicCoord(intersectionPointWC, cartographic, this);
			this.thereAreStartMovePoint = true;
			
			var buildingGeoCoord = geoLocationData.geographicCoord;
			this.startGeoCoordDif = new GeographicCoord(cartographic.longitude-buildingGeoCoord.longitude, cartographic.latitude-buildingGeoCoord.latitude, cartographic.altitude-buildingGeoCoord.altitude);
		}
		else 
		{
			var cartographic = ManagerUtils.pointToGeographicCoord(intersectionPointWC, cartographic, this);

			var difX = cartographic.longitude - this.startGeoCoordDif.longitude;
			var difY = cartographic.latitude - this.startGeoCoordDif.latitude;
			var difZ = cartographic.altitude - this.startGeoCoordDif.altitude;
			
			var newLongitude = difX;
			var newlatitude = difY;
			var newAltitude = difZ;

			if (attributes.movementInAxisZ)
			{
				//geoLocationData = ManagerUtils.calculateGeoLocationData(undefined, undefined, newAltitude, undefined, undefined, undefined, geoLocationData, this);
				this.changeLocationAndRotationNode(this.selectionManager.currentNodeSelected, undefined, undefined, newAltitude, undefined, undefined, undefined);
			}
			else 
			{
				//geoLocationData = ManagerUtils.calculateGeoLocationData(newLongitude, newlatitude, undefined, undefined, undefined, undefined, geoLocationData, this);
				this.changeLocationAndRotationNode(this.selectionManager.currentNodeSelected, newlatitude, newLongitude, undefined, undefined, undefined, undefined);
			}
			
			this.displayLocationAndRotation(this.buildingSelected);
		}
	}
	else if (this.magoPolicy.objectMoveMode === CODE.moveMode.OBJECT) // objects move.***
	{
		if (this.objectSelected === undefined)
		{ return; }
	
		if (this.objectSelected.constructor.name !== "NeoReference")
		{ return; }

		// create a XY_plane in the selected_pixel_position.***
		if (this.selObjMovePlane === undefined) 
		{
			this.selObjMovePlane = this.calculateSelObjMovePlaneAsimetricMode(gl, this.mouse_x, this.mouse_y, this.selObjMovePlane);
		}
		
		var geoLocDataManager = this.selectionManager.currentNodeSelected.getNodeGeoLocDataManager();

		// world ray = camPos + lambda*camDir.***
		if (this.lineSC === undefined)
		{ this.lineSC = new Line(); }
		
		this.lineSC = ManagerUtils.getRayWorldSpace(gl, this.mouse_x, this.mouse_y, this.lineSC, this); // rayWorldSpace.***
		var buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
		var camPosBuilding = new Point3D();
		var camDirBuilding = new Point3D();
		var tMatrixInv = buildingGeoLocation.getTMatrixInv();
		camPosBuilding = tMatrixInv.transformPoint3D(this.lineSC.point, camPosBuilding);
		camDirBuilding = tMatrixInv.rotatePoint3D(this.lineSC.direction, camDirBuilding);
	
		// now, intersect building_ray with the selObjMovePlane.***
		var line = new Line();
		line.setPointAndDir(camPosBuilding.x, camPosBuilding.y, camPosBuilding.z,       camDirBuilding.x, camDirBuilding.y, camDirBuilding.z);// original.***

		var intersectionPoint = new Point3D();
		intersectionPoint = this.selObjMovePlane.intersectionLine(line, intersectionPoint);

		//the movement of an object must multiply by buildingRotMatrix.***
		if (this.objectSelected.moveVectorRelToBuilding === undefined)
		{ this.objectSelected.moveVectorRelToBuilding = new Point3D(); }
	
		// move vector rel to building.
		if (!this.thereAreStartMovePoint) 
		{
			this.startMovPoint = intersectionPoint;
			this.startMovPoint.add(-this.objectSelected.moveVectorRelToBuilding.x, -this.objectSelected.moveVectorRelToBuilding.y, -this.objectSelected.moveVectorRelToBuilding.z);
			this.thereAreStartMovePoint = true;
		}
		else 
		{
			var difX = intersectionPoint.x - this.startMovPoint.x;
			var difY = intersectionPoint.y - this.startMovPoint.y;
			var difZ = intersectionPoint.z - this.startMovPoint.z;

			this.objectSelected.moveVectorRelToBuilding.set(difX, difY, difZ);
			this.objectSelected.moveVector = buildingGeoLocation.tMatrix.rotatePoint3D(this.objectSelected.moveVectorRelToBuilding, this.objectSelected.moveVector); 
		}
		
		var projectId = this.selectionManager.currentNodeSelected.data.projectId;
		var data_key = this.selectionManager.currentNodeSelected.data.nodeId;
		var objectIndexOrder = this.objectSelected._id;
		
		MagoConfig.deleteMovingHistoryObject(projectId, data_key, objectIndexOrder);
		this.objectMoved = true; // this provoques that on leftMouseUp -> saveHistoryObjectMovement
		
	}
	else if (this.magoPolicy.objectMoveMode === CODE.moveMode.GEOGRAPHICPOINTS && currSelectedClassName === "GeographicCoord") 
	{
		// Move the current geographic point selected.***
		if (currSelected)
		{
			//if (currSelectedClassName === "GeographicCoord")
			{
				var geoLocDataManager = currSelected.getGeoLocationDataManager();
				var geoLocationData = geoLocDataManager.getCurrentGeoLocationData();
				
				var geoCoord;
				var strWorldPoint;
				if (this.isCesiumGlobe())
				{
					var camera = this.scene.frameState.camera;
					var scene = this.scene;
					var ray = camera.getPickRay(new Cesium.Cartesian2(this.mouse_x, this.mouse_y));
					strWorldPoint = scene.globe.pick(ray, scene);
					geoCoord = Globe.CartesianToGeographicWgs84(strWorldPoint.x, strWorldPoint.y, strWorldPoint.z, undefined, true);
				}
				else 
				{
					var mouseAction = this.sceneState.mouseAction;
					strWorldPoint = mouseAction.strWorldPoint;
					geoCoord = Globe.CartesianToGeographicWgs84(strWorldPoint.x, strWorldPoint.y, strWorldPoint.z, undefined, true);
				}
				
				currSelected.setLonLatAlt(geoCoord.longitude, geoCoord.latitude, undefined); // no set altitude.***
				
				var geoLocDataManager = currSelected.getGeoLocationDataManager();
				var geoLocData = geoLocDataManager.getCurrentGeoLocationData();
				geoLocData = ManagerUtils.calculateGeoLocationData(currSelected.longitude, currSelected.latitude, currSelected.altitude, undefined, undefined, undefined, geoLocData, this);
				
				// Now, must check the moved object's owner.***
				var owner = currSelected.owner;
				if (owner)
				{
					// 1rst, check if is a geoCoordsList.***
					if (owner.constructor.name === "GeographicCoordsList")
					{
						owner.makeLines(this);
					}
					
					var owner2 = owner.owner;
					if (owner2)
					{
						if (owner2.constructor.name === "Excavation")
						{
							owner2.remakeExtrudeObject(this);
						}
						else if (owner2.constructor.name === "Tunnel")
						{
							owner2.remakeMesh(this);
						}
					}
				}
			}
		}

	}
	else
	{
		if (this.weatherStation)
		{
			// Test. Check if there are cuttingPlanes to move.***
			var selGeneralObjects = this.selectionManager.getSelectionCandidatesFamily("general");
			if (selGeneralObjects)
			{
				var currObjectSelected = selGeneralObjects.currentSelected;
				if (currObjectSelected)
				{
					// check if is a cuttingPlane.***
					if (currObjectSelected instanceof CuttingPlane)
					{
						// Move the cuttingPlane.***
						var geoLocDataManager = currObjectSelected.geoLocDataManager;
						var geoLocationData = geoLocDataManager.getCurrentGeoLocationData();
						
						var mouseAction = this.sceneState.mouseAction;
						
						// New Test.*******************************************************
						var camRay = ManagerUtils.getRayWorldSpace(gl, this.mouse_x, this.mouse_y, undefined, this); // rayWorldSpace.***
						var strWorldPoint = mouseAction.strWorldPointAux; // original.***
						////var strWorldPoint = mouseAction.strWorldPoint;
						if (strWorldPoint)
						{
							var strEarthRadius = strWorldPoint.getModul();
							
							var curWorldPosAux;
							curWorldPosAux = this.globe.intersectionLineWgs84(camRay, curWorldPosAux, strEarthRadius);
							if (curWorldPosAux)
							{
								var curWorldPointAux = new Point3D(curWorldPosAux[0], curWorldPosAux[1], curWorldPosAux[2]);
								var curLocation = ManagerUtils.pointToGeographicCoord(curWorldPointAux, undefined, this);
								var strLocation = mouseAction.strLocationAux;
								var objectGeoLoc = geoLocationData.geographicCoord;
								
								var difLocation = new GeographicCoord();
								difLocation.setLonLatAlt(curLocation.longitude - strLocation.longitude, curLocation.latitude - strLocation.latitude, curLocation.altitude - strLocation.altitude);
								var newLongitude = objectGeoLoc.longitude + difLocation.longitude;
								var newlatitude = objectGeoLoc.latitude + difLocation.latitude;
								
								geoLocationData = ManagerUtils.calculateGeoLocationData(newLongitude, newlatitude, undefined, undefined, undefined, undefined, geoLocationData, this);
								mouseAction.strLocationAux.setLonLatAlt(curLocation.longitude, curLocation.latitude, curLocation.altitude);
							}
						}
					}
				}
			}
		}
		var selectionManager = this.selectionManager;
		var generalObjectSelected = selectionManager.getSelectedGeneral();
		if (generalObjectSelected)
		{
			// Move the object.***
			this.moveSelectedObjectGeneral(gl, generalObjectSelected);
		}
	}
};

MagoManager.prototype.test_renderDepth_objectSelected = function(currObjectSelected) 
{
	// Test function. Provisional.***
	// Test function. Provisional.***
	// Test function. Provisional.***
	// Test. Render depth only for the selected object.***************************
	var gl = this.sceneState.gl;
	
	if (this.depthFboAux === undefined)
	{
		this.depthFboAux = new FBO(gl, this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight);
	}
	if (this.sceneState.drawingBufferWidth[0] !== this.depthFboAux.width[0] || this.sceneState.drawingBufferHeight[0] !== this.depthFboAux.height[0])
	{
		// move this to onResize.***
		this.depthFboAux.deleteObjects(gl);
		this.depthFboAux = new FBO(gl, this.sceneState.drawingBufferWidth, this.sceneState.drawingBufferHeight);
	}
	this.depthFboAux.bind(); 
	
	if (this.isFarestFrustum())
	{
		gl.clearColor(0, 0, 0, 1);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	}
	gl.disable(gl.BLEND);
	
	gl.frontFace(gl.CCW);	
	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LEQUAL);
	gl.enable(gl.CULL_FACE);
	
	// Now, renderDepth the selected object. Fix the frustumFar for adequate precision on depthPacking.***
	var shader = this.postFxShadersManager.getShader("modelRefDepth"); 
	shader.useProgram();
	shader.bindUniformGenerals();
	shader.enableVertexAttribArray(shader.position3_loc);
		
	var geoLocDataManager = currObjectSelected.geoLocDataManager;
	var geoLocationData = geoLocDataManager.getCurrentGeoLocationData();
		
	// test: in depth, set frustumFar = 1000000000(100M).***
	var frustumFarLoc = shader.uniformsMapGeneral.frustumFar.uniformLocation;
	gl.uniform1f(frustumFarLoc, new Float32Array([100000000.0]));
			
	var renderType = 0;
	//this.weatherStation.test_renderCuttingPlanes(this, renderType);
			
	geoLocationData.bindGeoLocationUniforms(gl, shader);
	gl.uniform3fv(shader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***
	currObjectSelected.render(this, shader, renderType);
			
	
	this.depthFboAux.unbind(); 
	// End test.------------------------------------------------------------------
};


/**
 * Frustum 안의 VisibleOctree 를 검색하여 currentVisibleOctreesControler 를 준비
 * 
 * @param {any} gl 
 * @param {any} scene 
 * @param {any} neoBuilding 
 * @param {VisibleObjectsController} visibleObjControlerOctrees 
 * @param {any} lod 
 */
MagoManager.prototype.getRenderablesDetailedNeoBuildingAsimetricVersion = function(gl, node, globalVisibleObjControlerOctrees, lod) 
{
	var data = node.data;
	var neoBuilding = data.neoBuilding;
	var currentLod = data.currentLod;
	
	// chaek if the neoBuilding has availableLod_0.***
	if (neoBuilding === undefined || neoBuilding.octree === undefined) { return false; }
	
	// Check if for the current lod, the building is modelRefType.***
	var lodBuildingData = neoBuilding.getLodBuildingData(data.currentLod);
	if (lodBuildingData === undefined)
	{ return false; }
	
	if (!lodBuildingData.isModelRef)
	{ return true; } // return true, bcos the caller pops the building from the "visibleObjControlerNodes" if return false.***

	var rootGeoLocDataManager = node.getNodeGeoLocDataManager();
	var rootGeoLoc = rootGeoLocDataManager.getCurrentGeoLocationData();
	
	//var nodeGeoLocation = geoLocDataManager.getCurrentGeoLocationData(); // original.***
	var nodeGeoLocation = rootGeoLocDataManager.getCurrentGeoLocationData();
	if (nodeGeoLocation === undefined)
	{ return false; }

	// Create if necessary, the visibleObjectsControler of the node.***
	if (data.currentVisibleOctreesControler === undefined)
	{ data.currentVisibleOctreesControler = new VisibleObjectsController(); }	

	var distLod0 = this.magoPolicy.getLod0DistInMeters();
	var distLod1 = this.magoPolicy.getLod1DistInMeters();
	var distLod2 = this.magoPolicy.getLod2DistInMeters();
	var distLod3 = this.magoPolicy.getLod3DistInMeters();
	var distLod4 = this.magoPolicy.getLod4DistInMeters();
	var distLod5 = this.magoPolicy.getLod5DistInMeters();

	var find = false;
	if (data.myCameraRelative === undefined)
	{ data.myCameraRelative = new Camera(); }
	
	data.myCameraRelative.frustum.copyParametersFrom(this.myCameraSCX.bigFrustum);
	data.myCameraRelative = nodeGeoLocation.getTransformedRelativeCamera(this.sceneState.camera, data.myCameraRelative);
	//var isCameraInsideOfBuilding = neoBuilding.isCameraInsideOfBuilding(data.myCameraRelative.position.x, data.myCameraRelative.position.y, data.myCameraRelative.position.z); // old.***
	
	data.currentVisibleOctreesControler.clear();
	
	if (lod === 2)
	{
		// In this case is not necessary calculate the frustum planes.
		neoBuilding.octree.extractLowestOctreesByLOD(data.currentVisibleOctreesControler, globalVisibleObjControlerOctrees, this.boundingSphere_Aux,
			data.myCameraRelative.position, distLod0, distLod1, distLod5);
		find = true;
	}
	else 
	{
		// Must calculate the frustum planes.
		data.myCameraRelative.calculateFrustumsPlanes();
		
		// 1rst, check if there are octrees very close.
		var frustum0 = data.myCameraRelative.bigFrustum;
		find = neoBuilding.octree.getFrustumVisibleLowestOctreesByLOD(	frustum0, data.currentVisibleOctreesControler, globalVisibleObjControlerOctrees, this.boundingSphere_Aux,
			data.myCameraRelative.position, distLod0, distLod1, distLod2*100);
	}

	if (!find) 
	{
		// If the building is far to camera, then delete it.
		if (data.distToCam > 100) // default: 60.***
		{ this.processQueue.putNodeToDeleteModelReferences(node, 1); }
		
		// TODO: must check if some part of the building is in parseQueue.***
		return false;
	}
	else 
	{
		this.processQueue.eraseNodeToDeleteModelReferences(node);
	}
	
	return true;
};


/**
 * LOD0, LOD1 에 대한 F4D ModelData, ReferenceData 를 요청
 * 
 * @param {any} gl 
 * @param {any} scene 
 * @param {any} neoBuilding 
 */
MagoManager.prototype.manageQueue = function() 
{
	var gl = this.sceneState.gl;
	
	
	// 1rst, manage deleting queue.***************
	this.processQueue.manageDeleteQueue(this);
	
	
	
	// 2nd, parse pendent data.**********************************************************************************
	// is desirable to parse octrees references ordered by the current eye distance.
	// in the "visibleObjControlerOctrees" there are the octrees sorted by distance, so must use it.
	this.parseQueue.initCounters();
	
	// parse octrees lod0 & lod1 references.***
	this.parseQueue.parseArrayOctreesLod0References(this.visibleObjControlerOctrees.currentVisibles0, this);
	this.parseQueue.parseArrayOctreesLod0References(this.visibleObjControlerOctrees.currentVisibles1, this);


	// parse octrees lod0 & lod1 models.***
	this.parseQueue.parseArrayOctreesLod0Models(this.visibleObjControlerOctrees.currentVisibles0, this);
	this.parseQueue.parseArrayOctreesLod0Models(this.visibleObjControlerOctrees.currentVisibles1, this);
	
	
	// parse octrees lod2 (lego).***
	this.parseQueue.parseArrayOctreesLod2Legos(gl, this.visibleObjControlerOctrees.currentVisibles2, this);

	// parse PCloud octree.***
	this.parseQueue.parseArrayOctreesPCloud(gl, this.visibleObjControlerOctrees.currentVisiblesAux, this);
	this.parseQueue.parseArrayOctreesPCloudPartition(gl, this.visibleObjControlerOctrees.currentVisiblesAux, this);

	// parse skin-lego.***
	this.parseQueue.parseArraySkins(gl, this.visibleObjControlerNodes.currentVisibles0, this);
	this.parseQueue.parseArraySkins(gl, this.visibleObjControlerNodes.currentVisibles2, this);
	this.parseQueue.parseArraySkins(gl, this.visibleObjControlerNodes.currentVisibles3, this);
	
	// parse multiBuildings.
	this.parseQueue.parseMultiBuildings(gl, this.visibleObjControlerNodes.currentVisibles0, this);
	this.parseQueue.parseMultiBuildings(gl, this.visibleObjControlerNodes.currentVisibles2, this);
	this.parseQueue.parseMultiBuildings(gl, this.visibleObjControlerNodes.currentVisibles3, this);

	// parse TinTerrain.***
	var tinTerrain;
	var parsedsCount = 0;
	for (var key in this.parseQueue.tinTerrainsToParseMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.parseQueue.tinTerrainsToParseMap, key))
		{
			var tinTerrain = this.parseQueue.tinTerrainsToParseMap[key];
			if (tinTerrain !== undefined)
			{
				if (this.parseQueue.eraseTinTerrainToParse(tinTerrain)) // check if is inside of the queue to parse.***
				{
					tinTerrain.parseData(tinTerrain.dataArrayBuffer);
					parsedsCount++;
				}
			}
			
			if (parsedsCount > 1)
			{ break; }
		}
	}
	/*
	var visibleTilesArray = this.tinTerrainManager.visibleTilesArray;
	var visiblesTilesCount = visibleTilesArray.length;
	for(var i=0; i<visiblesTilesCount; i++)
	{
		tinTerrain = visibleTilesArray[i];
		if (tinTerrain !== undefined)
		{
			if (this.parseQueue.eraseTinTerrainToParse(tinTerrain)) // check if is inside of the queue to parse.***
			{
				tinTerrain.parseData(tinTerrain.dataArrayBuffer);
			}
		}
	}
	*/
	
	
};

/**
 */
MagoManager.prototype.prepareVisibleOctreesSortedByDistancePointsCloudType = function(gl, globalVisibleObjControlerOctrees, fileRequestExtraCount) 
{
	var lod2DataInQueueCount = Object.keys(this.loadQueue.lod2PCloudDataMap).length;
	if (lod2DataInQueueCount > 5)
	{ return; }
	
	var extraCount = fileRequestExtraCount;
		
	var currentVisibles = globalVisibleObjControlerOctrees.getAllVisibles();
	//var currentVisibles = globalVisibleObjControlerOctrees.currentVisiblesAux;

	if (currentVisibles === undefined)
	{ return; }

	var geometryDataPath = this.readerWriter.geometryDataPath;
	var projectFolderName;
	var neoBuilding;
	var buildingFolderName;

	// LOD2
	// Check if the lod2lowestOctrees must load and parse data
	var lowestOctree;
	for (var i=0, length = currentVisibles.length; i<length; i++) 
	{	
		if (this.fileRequestControler.isFullPlus(extraCount))	
		{ return; }
		
		lowestOctree = currentVisibles[i];
		
		if (lowestOctree.octree_number_name === undefined)
		{ continue; }
		
		if (lowestOctree.lego === undefined) 
		{
			lowestOctree.lego = new Lego();
			lowestOctree.lego.fileLoadState = CODE.fileLoadState.READY;
			lowestOctree.lego.legoKey = lowestOctree.octreeKey + "_lego";
		}
	
		neoBuilding = lowestOctree.neoBuildingOwner;
		if (neoBuilding === undefined)
		{ continue; }
	
		var projectDataType = neoBuilding.metaData.projectDataType;
		
		if (projectDataType !== undefined && projectDataType === 4) // projectDataType = 4 (pointsCloudType building).***
		{
			projectFolderName = neoBuilding.projectFolderName;
			buildingFolderName = neoBuilding.buildingFileName;

			if (lowestOctree.lego.fileLoadState === CODE.fileLoadState.READY)
			{
				var subOctreeNumberName = lowestOctree.octree_number_name.toString();
				var references_folderPath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/References";
				var filePathInServer = references_folderPath + "/" + subOctreeNumberName + "_Ref";
				this.loadQueue.putLod2PCloudData(lowestOctree, filePathInServer, undefined, undefined, 0);

			}
			
			if (Object.keys(this.loadQueue.lod2PCloudDataMap).length > 5)
			{ return; }
		}
	} 
};

/**
 * LOD0, LOD1 에 대한 F4D ModelData, ReferenceData 를 요청
 * 
 * @param {any} gl 
 * @param {any} scene 
 * @param {any} neoBuilding 
 */
MagoManager.prototype.prepareVisibleOctreesSortedByDistance = function(gl, globalVisibleObjControlerOctrees) 
{
	if (this.readerWriter.referencesList_requested > 5)
	{ return; }

	// LOD0 & LOD1
	// Check if the lod0lowestOctrees, lod1lowestOctrees must load and parse data
	var currentVisibleOctrees = [].concat(globalVisibleObjControlerOctrees.currentVisibles0, globalVisibleObjControlerOctrees.currentVisibles1);
	var lowestOctree;
	this.thereAreUrgentOctrees = false;

	// now, prepare the ocree normally.
	var maxFilesLoad = 2;
	var filesLoadCounter = 0;
	
	for (var i=0, length = currentVisibleOctrees.length; i<length; i++) 
	{
		lowestOctree = currentVisibleOctrees[i];
		var neoBuilding = lowestOctree.neoBuildingOwner;
		var version = neoBuilding.getHeaderVersion();
		
		// Check if the lod2 is modelRef type data.
		var lodBuildingData = neoBuilding.getLodBuildingData(2);
		if (lodBuildingData.isModelRef === true)
		{
			// 1rst, check if lod2 is loaded. If lod2 is no loaded yet, then load first lod2.***
			if (this.readerWriter.octreesSkinLegos_requested < 5)
			{
				if (lowestOctree.lego === undefined || !lowestOctree.lego.isReadyToRender())
				{
					lowestOctree.prepareSkinData(this);
				}
			}
		}

		if (this.readerWriter.referencesList_requested < 5)
		{
			if (lowestOctree.neoReferencesMotherAndIndices === undefined || !lowestOctree.neoReferencesMotherAndIndices.isReadyToRender())
			{
				lowestOctree.prepareModelReferencesListData(this);
			}
			else 
			{
				if (version === "0.0.2")
				{
					// This is a no used partitionsBlocksLists version. Delete it.
					var blocksList = lowestOctree.neoReferencesMotherAndIndices.blocksList; 
					if (blocksList)
					{ blocksList.prepareData(this, lowestOctree); }
				}
			}
		}
		

		if (this.readerWriter.referencesList_requested > 5)
		{ return; }
		
		if (filesLoadCounter > maxFilesLoad)
		{ return; }
	}
	
	
};

/**
 * LOD2 에 대한 F4D LegoData 를 요청
 * 
 * @param {any} gl 
 * @param {any} scene 
 * @param {any} neoBuilding 
 */
MagoManager.prototype.prepareVisibleOctreesSortedByDistanceLOD2 = function(gl, currentVisibles) 
{
	if (this.readerWriter.octreesSkinLegos_requested > 5)
	{ return; }

	if (currentVisibles === undefined)
	{ return; }

	// LOD2
	// Check if the lod2lowestOctrees must load and parse data
	var lowestOctree;
	for (var i=0, length = currentVisibles.length; i<length; i++) 
	{	
		lowestOctree = currentVisibles[i];
		
		// Check if the lod2 is modelRef type data.
		var lodBuildingData = lowestOctree.neoBuildingOwner.getLodBuildingData(2);
		if (!lodBuildingData.isModelRef)
		{ continue; }

		lowestOctree.prepareSkinData(this);

		if (this.readerWriter.octreesSkinLegos_requested > 5)
		{ return; }
	} 
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param cameraPosition 카메라 입장에서 화면에 그리기 전에 객체를 그릴 필요가 있는지 유무를 판단하는 값
 * @param scene 변수
 * @param shader 변수
 * @param renderTexture 변수
 * @param ssao_idx 변수
 * @param neoRefLists_array 변수
 */

MagoManager.prototype.checkChangesHistoryMovements = function(nodesArray) 
{
	var nodesCount = nodesArray.length;
	var node;
	var rootNode;	
	var projectId;
	var dataKey;
	var moveHistoryMap;
	var colorChangedHistoryMap;
	var objectIndexOrder;
	var neoBuilding;
	var refObject;
	var moveVector;
	var moveVectorRelToBuilding;
	var geoLocdataManager;
	var geoLoc;
	
	// check movement of objects.
	for (var i=0; i<nodesCount; i++)
	{
		node = nodesArray[i];
		rootNode = node.getRoot();
		if (rootNode === undefined)
		{ continue; }
		
		geoLocdataManager = rootNode.getNodeGeoLocDataManager();
		geoLoc = geoLocdataManager.getCurrentGeoLocationData();
		projectId = node.data.projectId;
		dataKey = node.data.nodeId;
		
		// objects movement.
		moveHistoryMap = MagoConfig.getMovingHistoryObjects(projectId, dataKey);
		if (moveHistoryMap)
		{
			node.data.moveHistoryMap = moveHistoryMap;
			/*
			neoBuilding = node.data.neoBuilding;
			///for (var changeHistory of moveHistoryMap.values()) 
			for (var key in moveHistoryMap)
			{
				if (Object.prototype.hasOwnProperty.call(moveHistoryMap, key)) 
				{
					var changeHistory = moveHistoryMap[key];
					objectIndexOrder = changeHistory.getObjectIndexOrder();
					refObject = neoBuilding.getReferenceObject(objectIndexOrder);
					if (refObject === undefined)
					{ continue; }
					
					if (refObject.moveVector === undefined)
					{ refObject.moveVector = new Point3D(); }
					
					if (refObject.moveVectorRelToBuilding === undefined)
					{ refObject.moveVectorRelToBuilding = new Point3D(); }
					
					moveVector = changeHistory.getReferenceObjectAditionalMovement();
					moveVectorRelToBuilding = changeHistory.getReferenceObjectAditionalMovementRelToBuilding();
					refObject.moveVectorRelToBuilding.set(moveVectorRelToBuilding.x, moveVectorRelToBuilding.y, moveVectorRelToBuilding.z);
					refObject.moveVector.set(moveVector.x, moveVector.y, moveVector.z);
					
					// now check if the building was rotated.
					// if was rotated then recalculate the move vector.
					refObject.moveVector = geoLoc.tMatrix.rotatePoint3D(refObject.moveVectorRelToBuilding, refObject.moveVector); 
					
					// if was no rotated, then set the moveVector of the changeHistory.
					//refObject.moveVectorRelToBuilding.set(moveVectorRelToBuilding.x, moveVectorRelToBuilding.y, moveVectorRelToBuilding.z);	
				}
			}
			*/
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */

MagoManager.prototype.checkPropertyFilters = function(nodesArray) 
{
	if (this.propertyFilterSC === undefined)
	{ return; }
	
	var nodesCount = nodesArray.length;
	var node;	
	var projectId;
	var propertyKey = this.propertyFilterSC.propertyKey;
	var propertyValue = this.propertyFilterSC.propertyValue;
	var visible = this.propertyFilterSC.visible;
	
	for (var i=0; i<nodesCount; i++)
	{
		node = nodesArray[i];
		projectId = node.data.projectId;
		if (projectId === this.propertyFilterSC.projectId)
		{
			if (node.data.attributes)
			{
				if (node.data.attributes[propertyKey] !== undefined && node.data.attributes[propertyKey].toString() === propertyValue)
				{
					if (visible === true)
					{
						// do nothing.
					}
					else
					{
						nodesArray.splice(i, 1);
						i--;
						nodesCount = nodesArray.length;
					}
				}
				else
				{
					if (visible === true)
					{
						nodesArray.splice(i, 1);
						i--;
						nodesCount = nodesArray.length;
					}
					else 
					{
						// do nothing.
					}
				}
			}
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */

MagoManager.prototype.checkChangesHistoryColors = function(nodesArray) 
{
	var nodesCount = nodesArray.length;
	var node;
	var rootNode;	
	var projectId;
	var dataKey;
	var moveHistoryMap;
	var colorChangedHistoryMap;
	var objectIndexOrder;
	var neoBuilding;
	var refObject;
	
	// check movement of objects.
	for (var i=0; i<nodesCount; i++)
	{
		node = nodesArray[i];
		rootNode = node.getRoot();
		if (rootNode === undefined)
		{ continue; }
		
		projectId = node.data.projectId;
		dataKey = node.data.nodeId;

		colorChangedHistoryMap = MagoConfig.getColorHistorys(projectId, dataKey);
		if (colorChangedHistoryMap)
		{
			var data = node.data;
			
			// Set the colorChangedHistoryMap into data of the node.***
			data.colorChangedHistoryMap = colorChangedHistoryMap;
		}
	}
	
	var allColorHistoryMap = MagoConfig.getAllColorHistory();
	if (allColorHistoryMap)
	{
		for (var key in allColorHistoryMap) 
		{
			if (Object.prototype.hasOwnProperty.call(allColorHistoryMap, key))
			{
				var colorChangedHistoryMap = allColorHistoryMap[key];
				//for (var colorChangedHistoryMap of allColorHistoryMap.values()) 
				//{
				// now check nodes that is no physical.
				for (var key2 in colorChangedHistoryMap) 
				{
					if (Object.prototype.hasOwnProperty.call(colorChangedHistoryMap, key2))
					{
						var changeHistoryMap = colorChangedHistoryMap[key2];
						//for (var changeHistoryMap of colorChangedHistoryMap.values()) 
						//{
						for (var key3 in changeHistoryMap) 
						{
							if (Object.prototype.hasOwnProperty.call(changeHistoryMap, key3))
							{
								var changeHistory = changeHistoryMap[key3];
								//for (var changeHistory of changeHistoryMap.values()) 
								//{
								var projectId = changeHistory.projectId;
								var nodesMap = this.hierarchyManager.getNodesMap(projectId);
								var aNode = nodesMap[changeHistory.dataKey];
								if (aNode && aNode.data.attributes.isPhysical !== undefined && aNode.data.attributes.isPhysical === false)
								{
									// must check if there are filters.
									if (changeHistory.property === null || changeHistory.property === undefined || changeHistory.property === "" )
									{
										// this is a no physical node, so must check children.
										var nodesArray = [];
										aNode.extractNodes(nodesArray);
										var nodesCount = nodesArray.length;
										for (var i=0; i<nodesCount; i++)
										{
											var aNode2 = nodesArray[i];
											var data = aNode2.data;
											//neoBuilding = aNode2.data.neoBuilding;
											if (data)
											{
												data.isColorChanged = true;
												if (data.aditionalColor === undefined)
												{ data.aditionalColor = new Color(); }
												
												data.aditionalColor.setRGBA(changeHistory.color[0], changeHistory.color[1], changeHistory.color[2], changeHistory.color[3]);
											}
										}
									}
									else 
									{
										var propertyKey = changeHistory.propertyKey;
										var propertyValue = changeHistory.propertyValue;
											
										// this is a no physical node, so must check children.
										var nodesArray = [];
										aNode.extractNodes(nodesArray);
										var nodesCount = nodesArray.length;
										for (var i=0; i<nodesCount; i++)
										{
											var aNode2 = nodesArray[i];
											var data = aNode2.data;
											//neoBuilding = aNode2.data.neoBuilding;
											if (data)
											{
												if (aNode2.data.attributes[propertyKey] !== undefined && aNode2.data.attributes[propertyKey].toString() === propertyValue)
												{
													data.isColorChanged = true;
													if (data.aditionalColor === undefined)
													{ data.aditionalColor = new Color(); }
													
													data.aditionalColor.setRGBA(changeHistory.color[0], changeHistory.color[1], changeHistory.color[2], changeHistory.color[3]);
												}
											}
										}
									}
								}	
							}
						}	
					}
				}	
			}
		}
	}
};


/**
 * Draw building names on scene.
 */
MagoManager.prototype.getObjectLabel = function() 
{
	if (this.canvasObjectLabel === undefined)
	{
		this.canvasObjectLabel = document.getElementById("objectLabel");
		if (this.canvasObjectLabel === undefined)
		{ return; }

		var magoDiv = document.getElementById(MagoConfig.getContainerId());
		var offsetLeft = magoDiv.offsetLeft;
		var offsetTop = magoDiv.offsetTop;
		var offsetWidth = magoDiv.offsetWidth;
		var offsetHeight = magoDiv.offsetHeight;
		
		this.canvasObjectLabel.style.opacity = 1.0;
		this.canvasObjectLabel.width = this.sceneState.drawingBufferWidth;
		this.canvasObjectLabel.height = this.sceneState.drawingBufferHeight;
		var canvasStyleLeft = offsetLeft.toString()+"px";
		var canvasStyleTop = offsetTop.toString()+"px";
		this.canvasObjectLabel.style.left = canvasStyleLeft;
		this.canvasObjectLabel.style.top = canvasStyleTop;
		this.canvasObjectLabel.style.position = "absolute";
		
		this.canvasObjectLabel.style.opacity = 1.0;
		this.canvasObjectLabel.width = this.sceneState.drawingBufferWidth;
		this.canvasObjectLabel.height = this.sceneState.drawingBufferHeight;
		var ctx = this.canvasObjectLabel.getContext("2d");
		//ctx.strokeStyle = 'SlateGrey';
		//ctx.strokeStyle = 'MidnightBlue';
		ctx.strokeStyle = 'DarkSlateGray'; 
		//ctx.fillStyle= "white";
		ctx.fillStyle= "PapayaWhip";
		ctx.lineWidth = 4;
		ctx.font = "20px Arial";
		ctx.textAlign = 'center';
		//ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
		ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
		ctx.save();
		ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

		var lineHeight = ctx.measureText("M").width * 1.1;
	}
	
	return this.canvasObjectLabel;
};

/**
 * Draw building names on scene.
 */
MagoManager.prototype.drawCCTVNames = function(cctvArray) 
{
	var canvas = this.getObjectLabel();
	var ctx = canvas.getContext("2d");
	ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

	// lod2.
	var gl = this.sceneState.gl;
	var node;
	var nodeRoot;
	var geoLocDataManager;
	var geoLoc;
	var neoBuilding;
	var worldPosition;
	var screenCoord;
	var cctv;
	
	var cctvCount = cctvArray.length;
	for (var i=0; i<cctvCount; i++)
	{
		cctv = cctvArray[i];
		geoLoc = cctv.geoLocationData;
		worldPosition = geoLoc.position;
		//screenCoord = this.calculateWorldPositionToScreenCoord(gl, worldPosition.x, worldPosition.y, worldPosition.z, screenCoord);
		screenCoord = ManagerUtils.calculateWorldPositionToScreenCoord(gl, worldPosition.x, worldPosition.y, worldPosition.z, screenCoord, this);
		//screenCoord.x += 250;
		//screenCoord.y += 150;
		
		if (screenCoord.x >= 0 && screenCoord.y >= 0)
		{
			ctx.font = "13px Arial";
			ctx.strokeText(cctv.name, screenCoord.x, screenCoord.y);
			ctx.fillText(cctv.name, screenCoord.x, screenCoord.y);
		}
		
	}

	ctx.restore();
};
/**
 * 데이터 표출 컨디션 설정
 * @param {string} projectId required.
 * @param {string} dataKey option. 키 존재 시 해당 노드만 컨디션 들어감.
 * @param {function} condition required.
 */
MagoManager.prototype.setRenderCondition = function(projectId, dataKey, condition) 
{
	if (!condition || typeof condition !== 'function') 
	{
		throw new Error('renderCondition is required.');
	}

	if (!projectId) 
	{
		throw new Error('projectId is required.');
	}
	if (!this.hierarchyManager.existProject(projectId)) 
	{
		throw new Error(projectId + ' project is not exist.');
	}

	var nodeMap = this.hierarchyManager.getNodesMap(projectId);
	if (!dataKey) 
	{
		for (var i in nodeMap) 
		{
			if (nodeMap.hasOwnProperty(i)) 
			{
				checkAndSetCondition(nodeMap[i], condition);
			}
		}
	}
	else 
	{
		checkAndSetCondition(nodeMap[dataKey], condition);
	}
	
	function checkAndSetCondition(node, cond)
	{
		if (node instanceof Node && node.data.attributes.isPhysical) 
		{
			node.setRenderCondition(cond);
		}
	}
};


/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
MagoManager.prototype.createDefaultShaders = function(gl) 
{
	// here creates the necessary shaders for mago3d.***
	// 1) ModelReferences ssaoShader.******************************************************************************
	var shaderName = "modelRefSsao";
	var ssao_vs_source = ShaderSource.ModelRefSsaoVS;
	var ssao_fs_source = ShaderSource.ModelRefSsaoFS;
	var shader = this.postFxShadersManager.createShaderProgram(gl, ssao_vs_source, ssao_fs_source, shaderName, this);

	// 1.1) ModelReferences depthShader.******************************************************************************
	var shaderName = "modelRefDepth";
	var showDepth_vs_source = ShaderSource.RenderShowDepthVS;
	var showDepth_fs_source = ShaderSource.RenderShowDepthFS;
	shader = this.postFxShadersManager.createShaderProgram(gl, showDepth_vs_source, showDepth_fs_source, shaderName, this);

	// 2) ModelReferences colorCoding shader.***********************************************************************
	var shaderName = "modelRefColorCoding";
	var showDepth_vs_source = ShaderSource.ColorSelectionSsaoVS;
	var showDepth_fs_source = ShaderSource.ColorSelectionSsaoFS;
	shader = this.postFxShadersManager.createShaderProgram(gl, showDepth_vs_source, showDepth_fs_source, shaderName, this);
	
	// 3) TinTerrain shader.****************************************************************************************
	shaderName = "tinTerrain";
	ssao_vs_source = ShaderSource.TinTerrainVS;
	ssao_fs_source = ShaderSource.TinTerrainFS;
	shader = this.postFxShadersManager.createShaderProgram(gl, ssao_vs_source, ssao_fs_source, shaderName, this);

	shader.bIsMakingDepth_loc = gl.getUniformLocation(shader.program, "bIsMakingDepth");
	
	// 4) PointsCloud shader.****************************************************************************************
	shaderName = "pointsCloud";
	ssao_vs_source = ShaderSource.PointCloudVS;
	ssao_fs_source = ShaderSource.PointCloudFS;
	shader = this.postFxShadersManager.createShaderProgram(gl, ssao_vs_source, ssao_fs_source, shaderName, this);
	// pointsCloud shader locals.***
	shader.bPositionCompressed_loc = gl.getUniformLocation(shader.program, "bPositionCompressed");
	shader.minPosition_loc = gl.getUniformLocation(shader.program, "minPosition");
	shader.bboxSize_loc = gl.getUniformLocation(shader.program, "bboxSize");
	shader.maxPointSize_loc = gl.getUniformLocation(shader.program, "maxPointSize");
	shader.minPointSize_loc = gl.getUniformLocation(shader.program, "minPointSize");
	shader.pendentPointSize_loc = gl.getUniformLocation(shader.program, "pendentPointSize");

	// 5) Test Quad shader.****************************************************************************************
	shaderName = "testQuad"; // used by temperatura layer.***
	ssao_vs_source = ShaderSource.Test_QuadVS;
	ssao_fs_source = ShaderSource.Test_QuadFS;
	shader = this.postFxShadersManager.createShaderProgram(gl, ssao_vs_source, ssao_fs_source, shaderName, this);

	// 6) Filter silhouette shader.*************************************************************************************
	shaderName = "filterSilhouette"; 
	ssao_vs_source = ShaderSource.wgs84_volumVS; // simple screen quad v-shader.***
	ssao_fs_source = ShaderSource.filterSilhouetteFS;
	shader = this.postFxShadersManager.createShaderProgram(gl, ssao_vs_source, ssao_fs_source, shaderName, this);

	// 7) PointsCloud Depth shader.****************************************************************************************
	shaderName = "pointsCloudDepth";
	ssao_vs_source = ShaderSource.PointCloudDepthVS;
	ssao_fs_source = ShaderSource.PointCloudDepthFS;
	shader = this.postFxShadersManager.createShaderProgram(gl, ssao_vs_source, ssao_fs_source, shaderName, this);
	// pointsCloud shader locals.***
	shader.bPositionCompressed_loc = gl.getUniformLocation(shader.program, "bPositionCompressed");
	shader.minPosition_loc = gl.getUniformLocation(shader.program, "minPosition");
	shader.bboxSize_loc = gl.getUniformLocation(shader.program, "bboxSize");
	shader.maxPointSize_loc = gl.getUniformLocation(shader.program, "maxPointSize");
	shader.minPointSize_loc = gl.getUniformLocation(shader.program, "minPointSize");
	shader.pendentPointSize_loc = gl.getUniformLocation(shader.program, "pendentPointSize");

	// 8) PointsCloud shader.****************************************************************************************
	shaderName = "pointsCloudSsao";
	ssao_vs_source = ShaderSource.PointCloudVS;
	ssao_fs_source = ShaderSource.PointCloudSsaoFS;
	shader = this.postFxShadersManager.createShaderProgram(gl, ssao_vs_source, ssao_fs_source, shaderName, this);

	// pointsCloud shader locals.***
	shader.bPositionCompressed_loc = gl.getUniformLocation(shader.program, "bPositionCompressed");
	shader.minPosition_loc = gl.getUniformLocation(shader.program, "minPosition");
	shader.bboxSize_loc = gl.getUniformLocation(shader.program, "bboxSize");
	shader.maxPointSize_loc = gl.getUniformLocation(shader.program, "maxPointSize");
	shader.minPointSize_loc = gl.getUniformLocation(shader.program, "minPointSize");
	shader.pendentPointSize_loc = gl.getUniformLocation(shader.program, "pendentPointSize");

	// 9) PointsCloud shader RAINBOW.****************************************************************************************
	shaderName = "pointsCloudSsao_rainbow";
	ssao_vs_source = ShaderSource.PointCloudVS_rainbow;
	ssao_fs_source = ShaderSource.PointCloudSsaoFS_rainbow;
	shader = this.postFxShadersManager.createShaderProgram(gl, ssao_vs_source, ssao_fs_source, shaderName, this);
	// pointsCloud shader locals.***
	shader.bPositionCompressed_loc = gl.getUniformLocation(shader.program, "bPositionCompressed");
	shader.minPosition_loc = gl.getUniformLocation(shader.program, "minPosition");
	shader.bboxSize_loc = gl.getUniformLocation(shader.program, "bboxSize");
	shader.bUseColorCodingByHeight_loc = gl.getUniformLocation(shader.program, "bUseColorCodingByHeight");
	shader.minHeight_rainbow_loc = gl.getUniformLocation(shader.program, "minHeight_rainbow");
	shader.maxHeight_rainbow_loc = gl.getUniformLocation(shader.program, "maxHeight_rainbow");
	shader.maxPointSize_loc = gl.getUniformLocation(shader.program, "maxPointSize");
	shader.minPointSize_loc = gl.getUniformLocation(shader.program, "minPointSize");
	shader.pendentPointSize_loc = gl.getUniformLocation(shader.program, "pendentPointSize");
	
	// 10) Atmosphere shader.****************************************************************************************
	shaderName = "atmosphere";
	ssao_vs_source = ShaderSource.atmosphereVS;
	ssao_fs_source = ShaderSource.atmosphereFS;
	shader = this.postFxShadersManager.createShaderProgram(gl, ssao_vs_source, ssao_fs_source, shaderName, this);

	shader.bIsMakingDepth_loc = gl.getUniformLocation(shader.program, "bIsMakingDepth");
	shader.equatorialRadius_loc = gl.getUniformLocation(shader.program, "equatorialRadius");
	
	// 11) ImageViewerRectangle Shader.******************************************************************************
	var shaderName = "imageViewerRectangle";
	var ssao_vs_source = ShaderSource.ImageViewerRectangleShaderVS;
	var ssao_fs_source = ShaderSource.ImageViewerRectangleShaderFS;
	shader = this.postFxShadersManager.createShaderProgram(gl, ssao_vs_source, ssao_fs_source, shaderName, this);

	// 12) OrthogonalDepth Shader.******************************************************************************
	var shaderName = "orthogonalDepth";
	var ssao_vs_source = ShaderSource.OrthogonalDepthShaderVS;
	var ssao_fs_source = ShaderSource.OrthogonalDepthShaderFS;
	shader = this.postFxShadersManager.createShaderProgram(gl, ssao_vs_source, ssao_fs_source, shaderName, this);
	// OrthogonalShader locations.***
	shader.modelViewProjectionMatrixRelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye");
	shader.modelViewMatrixRelToEye_loc = gl.getUniformLocation(shader.program, "modelViewMatrixRelToEye");
	shader.encodedCameraPositionMCHigh_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh");
	shader.encodedCameraPositionMCLow_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow");
	shader.fov_loc = gl.getUniformLocation(shader.program, "fov");
	shader.aspectRatio_loc = gl.getUniformLocation(shader.program, "aspectRatio");
	shader.screenWidth_loc = gl.getUniformLocation(shader.program, "screenWidth");
	shader.screenHeight_loc = gl.getUniformLocation(shader.program, "screenHeight");
	
	// 13) ThickLine Shader.******************************************************************************
	var shaderName = "thickLine";
	var ssao_vs_source = ShaderSource.thickLineVS;
	var ssao_fs_source = ShaderSource.thickLineFS;
	shader = this.postFxShadersManager.createShaderProgram(gl, ssao_vs_source, ssao_fs_source, shaderName, this);
	// ThickLine shader locations.***
	shader.projectionMatrix_loc = gl.getUniformLocation(shader.program, "projectionMatrix");
	shader.modelViewMatrix_loc = gl.getUniformLocation(shader.program, "modelViewMatrix");
	shader.viewport_loc = gl.getUniformLocation(shader.program, "viewport");
	shader.thickness_loc = gl.getUniformLocation(shader.program, "thickness");
	gl.bindAttribLocation(shader.program, 0, "prev");
	gl.bindAttribLocation(shader.program, 1, "current");
	gl.bindAttribLocation(shader.program, 2, "next");
	gl.bindAttribLocation(shader.program, 3, "color4");
	shader.prev_loc = 0;
	shader.current_loc = 1;
	shader.next_loc = 2;
	shader.color4_loc = 3;
	
	// 14) ScreenQuad shader.***********************************************************************************
	var shaderName = "screenQuad";
	var ssao_vs_source = ShaderSource.ScreenQuadVS;
	var ssao_fs_source = ShaderSource.ScreenQuadFS;
	var shader = this.postFxShadersManager.createShaderProgram(gl, ssao_vs_source, ssao_fs_source, shaderName, this);
	
	// 15) Pin shader.******************************************************************************************
	var shaderName = "pin";
	var ssao_vs_source = ShaderSource.PngImageVS;
	var ssao_fs_source = ShaderSource.PngImageFS;
	var shader = this.postFxShadersManager.createShaderProgram(gl, ssao_vs_source, ssao_fs_source, shaderName, this);
	shader.position4_loc = gl.getAttribLocation(shader.program, "position");
	shader.texCoord2_loc = gl.getAttribLocation(shader.program, "texCoord");
	shader.scale2d_loc = gl.getUniformLocation(shader.program, "scale2d");
	shader.size2d_loc = gl.getUniformLocation(shader.program, "size2d");
	shader.imageSize_loc = gl.getUniformLocation(shader.program, "imageSize");
	shader.bUseOriginalImageSize_loc = gl.getUniformLocation(shader.program, "bUseOriginalImageSize");
	shader.aditionalOffset_loc = gl.getUniformLocation(shader.program, "aditionalOffset");
};

/**
 * 카메라 영역에 벗어난 오브젝트의 렌더링은 비 활성화
 */
MagoManager.prototype.isFarestFrustum = function() 
{
	if (this.numFrustums - this.currentFrustumIdx - 1 === 0)
	{ return true; }
	else
	{ return false; }
};

/**
 * 카메라 영역에 벗어난 오브젝트의 렌더링은 비 활성화
 * 
 * @param frustumVolume 변수
 * @param cameraPosition 변수
 */
MagoManager.prototype.doMultiFrustumCullingSmartTiles = function(camera) 
{
	// Here uses a frustum that is the sum of all frustums.***
	var frustumVolume = this.myCameraSCX.bigFrustum;
	
	// This makes the visible buildings array.
	var smartTile1 = this.smartTileManager.tilesArray[0]; // America side tile.
	var smartTile2 = this.smartTileManager.tilesArray[1]; // Asia side tile.
	
	if (this.intersectedTilesArray === undefined)
	{ this.intersectedTilesArray = []; }
	
	if (this.lastIntersectedLowestTilesArray === undefined)
	{ this.lastIntersectedLowestTilesArray = []; }
	
	// save the last frustumCulled lowestTiles to delete if necessary.
	this.lastIntersectedLowestTilesArray = this.intersectedTilesArray;
	this.intersectedTilesArray = [];
	
	// mark all last_tiles as "no visible".
	var lastLowestTilesCount = this.lastIntersectedLowestTilesArray.length;
	var lowestTile;
	for (var i=0; i<lastLowestTilesCount; i++)
	{
		lowestTile = this.lastIntersectedLowestTilesArray[i];
		lowestTile.isVisible = false;
	}
	
	// do frustum culling for Asia_side_tile and America_side_tile.
	var maxDistToCamera = 5000;
	smartTile1.getFrustumIntersectedLowestTiles(camera, frustumVolume, this.intersectedTilesArray, maxDistToCamera);
	smartTile2.getFrustumIntersectedLowestTiles(camera, frustumVolume, this.intersectedTilesArray, maxDistToCamera);
	
	
	// Now, store the culled tiles into corresponding frustums, and mark all current_tiles as "visible".***
	this.frustumVolumeControl.initArrays(); // init.***
	var frustumsCount = this.myCameraSCX.frustumsArray.length;
	var frustum;
	var lowestTile;
	var currentLowestTilesCount = this.intersectedTilesArray.length;
	for (var i=0; i<currentLowestTilesCount; i++)
	{
		lowestTile = this.intersectedTilesArray[i];
		if (lowestTile.sphereExtent === undefined)
		{ continue; }
	
		// Now, if the "lowestOctree" is inside of deletingQueue, then erase from deletingQueue.
		this.processQueue.eraseSmartTileToDelete(lowestTile);
	
		lowestTile.isVisible = true;
		for (var j=frustumsCount-1; j>= 0 ; j--)
		{
			frustum = this.myCameraSCX.frustumsArray[j];
			if (frustum.intersectionNearFarSphere(lowestTile.sphereExtent) !== Constant.INTERSECTION_OUTSIDE)
			{
				var frustumVolumeControlObject = this.frustumVolumeControl.getFrustumVolumeCulling(j); 
				frustumVolumeControlObject.intersectedTilesArray.push(lowestTile);
				//break;
			}
		}
	}
	
	
	// Now, delete all tiles that is no visible in the all frustumVolumes.***
	// Put to deleting queue.***
	var lastLowestTilesCount = this.lastIntersectedLowestTilesArray.length;
	var lowestTile;
	for (var i=0; i<lastLowestTilesCount; i++)
	{
		lowestTile = this.lastIntersectedLowestTilesArray[i];
		if (!lowestTile.isVisible)
		{
			//if (lowestTile.distToCamera > 2000)
			{ 
				//this.processQueue.putNodesArrayToDelete(lowestTile.nodesArray); 
				this.processQueue.putSmartTileToDelete(lowestTile, 0);
				///lowestTile.clearNodesArray();
			}
			
		}
	}
	
	this.lastIntersectedLowestTilesArray.length = 0;
	
	
	// TinTerranTiles.*************************************************************************
	// Provisionally:
	if (this.tinTerrainManager !== undefined)
	{ this.tinTerrainManager.doFrustumCulling(frustumVolume, camera.position, this); }
};

/**
 * dataKey 이용해서 data 검색
 * @param dataKey
 */
MagoManager.prototype.tilesMultiFrustumCullingFinished = function(intersectedLowestTilesArray, visibleNodes, cameraPosition, frustumVolume) 
{
	var tilesCount = intersectedLowestTilesArray.length;
	
	if (tilesCount === 0)
	{ return; }
	
	var distToCamera;
	var magoPolicy = this.magoPolicy;
	
	// The max distance to render in mago.
	var lod5_minDist = magoPolicy.getLod5DistInMeters();
	
	var lowestTile;
	var buildingSeedsCount;
	var buildingSeed;
	var neoBuilding;
	var renderable;
	var node;
	var nodeRoot;
	var nodeBbox;
	var geoLoc;
	var geoLocDataManager;
	var realBuildingPos;
	var longitude, latitude, altitude, heading, pitch, roll;
	
	if (this.boundingSphere_Aux === undefined)
	{ this.boundingSphere_Aux = new Sphere(); }

	var frustumFar = magoPolicy.getFrustumFarDistance();
	
	//if (frustumFar < 30000)
	//{ frustumFar = 30000; }

	var doFrustumCullingToBuildings = false;

	for (var i=0; i<tilesCount; i++)
	{
		lowestTile = intersectedLowestTilesArray[i];
		
		if (lowestTile.sphereExtent === undefined)
		{ continue; }
	
		distToCamera = cameraPosition.distToSphere(lowestTile.sphereExtent);
		//if (distToCamera > Number(lod5_minDist))
		//{ continue; }
	
		if (lowestTile.intersectionType === Constant.INTERSECTION_INSIDE)
		{
			doFrustumCullingToBuildings = false;
		}
		else 
		{
			doFrustumCullingToBuildings = true;
		}

		// Check the smartTile state: (1- is all updated), (2- need make geometries from objectsSeeds).
		if (lowestTile.nodesArray && lowestTile.nodesArray.length > 0)
		{
			// the neoBuildings are made.
			var nodesCount = lowestTile.nodesArray.length;
			for (var j=0; j<nodesCount; j++)
			{
				// determine LOD for each building.
				node = lowestTile.nodesArray[j];
				nodeRoot = node.getRoot();
				var attributes = node.data.attributes;

				// now, create a geoLocDataManager for node if no exist.
				if (nodeRoot.data.geoLocDataManager === undefined)
				{
					geoLoc = node.calculateGeoLocData(this);
					continue;
				}
				
				var data = node.data;
					
				if (attributes.objectType === "basicF4d")
				{					
					neoBuilding = node.data.neoBuilding;
					if (neoBuilding === undefined) // attributes.isReference === true
					{
						// This node is a reference node.***
						visibleNodes.currentVisiblesToPrepare.push(node);
						continue;
					}
					
					//check if parsed header.***
					//neoBuilding.metaData.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
					if (neoBuilding.metaData !== undefined && neoBuilding.metaData.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED)
					{
						visibleNodes.currentVisiblesToPrepare.push(node);
						continue;
					}

					distToCamera = node.getDistToCamera(cameraPosition, this.boundingSphere_Aux);
					var lodByDist = magoPolicy.getLod(distToCamera);
					
					// Set the current LOD of node.
					data.distToCam = distToCamera;
					data.currentLod = magoPolicy.getLod(data.distToCam);
					
					
					if (distToCamera > frustumFar)// || distToCamera > 1500)
					{ 
						// put this node to delete into queue.***
						//this.processQueue.putNodeToDelete(node, 0);
						continue; 
					}
					
					// If necessary do frustum culling.**********************************************************
					if (doFrustumCullingToBuildings)
					{
						var frustumCull = frustumVolume.intersectionSphere(this.boundingSphere_Aux); // cesium.***
						// intersect with Frustum
						if (frustumCull === Constant.INTERSECTION_OUTSIDE) 
						{
							// put this node to delete into queue.***
							////this.processQueue.putNodeToDeleteModelReferences(node, 0);
							//this.processQueue.putNodeToDeleteLessThanLod3(node, 0);
							continue;
						}
					}
					//-------------------------------------------------------------------------------------------
					
					// provisionally fork versions.***
					var version = neoBuilding.getHeaderVersion();
					if (version === undefined)
					{ continue; }
					
					if (version[0] === 'v')
					{
						visibleNodes.putNodeByLod(node, lodByDist);
					}
					else 
					{
						// provisional test for pointsCloud data.************
						var metaData = neoBuilding.metaData;
						var projectsType = metaData.projectDataType;
						if (projectsType && (projectsType === 4 || projectsType === 5))
						{
							// Project_data_type (new in version 002).***
							// 1 = 3d model data type (normal 3d with interior & exterior data).***
							// 2 = single building skin data type (as vWorld or googleEarth data).***
							// 3 = multi building skin data type (as Shibuya & Odaiba data).***
							// 4, 5 = pointsCloud data type.***
							visibleNodes.putNodeToArraySortedByDist(visibleNodes.currentVisiblesAux, node);
						}
						// end provisional test.-----------------------------
						else
						{
							visibleNodes.putNodeByLod(node, lodByDist);
						}
					}
				
				}
				else if (attributes.objectType === "multiBuildingsTile")
				{
					// Put node into visibleNodes.
					distToCamera = node.getDistToCamera(cameraPosition, this.boundingSphere_Aux);
					var lodByDist = magoPolicy.getLod(distToCamera);
					
					// Set the current LOD of node.
					data.distToCam = distToCamera;
					data.currentLod = magoPolicy.getLod(data.distToCam);
					
					var frustumFar = magoPolicy.getFrustumFarDistance();
					if (distToCamera > frustumFar)
					{ 
						// put this node to delete into queue.***
						this.processQueue.putNodeToDelete(node, 1);
						continue; 
					}
					
					// If necessary do frustum culling.**********************************************************
					//if (doFrustumCullingToBuildings)
					//{
					//	var frustumCull = frustumVolume.intersectionSphere(this.boundingSphere_Aux); // cesium.***
					//	// intersect with Frustum
					//	if (frustumCull === Constant.INTERSECTION_OUTSIDE) 
					//	{
					//		// put this node to delete into queue.***
					//		//this.processQueue.putNodeToDeleteLessThanLod3(node, 0);
					//		continue;
					//	}
					//}
					//-------------------------------------------------------------------------------------------
					
					visibleNodes.putNodeByLod(node, lodByDist);
				}
			}
		}
		
		// Check native objects.
		var nativeObjects = lowestTile.nativeObjects;
		var currVisibleNativeObjects = visibleNodes.currentVisibleNativeObjects;
		Array.prototype.push.apply(currVisibleNativeObjects.opaquesArray, nativeObjects.opaquesArray);
		Array.prototype.push.apply(currVisibleNativeObjects.transparentsArray, nativeObjects.transparentsArray);
		Array.prototype.push.apply(currVisibleNativeObjects.excavationsArray, nativeObjects.excavationsArray);
		Array.prototype.push.apply(currVisibleNativeObjects.vectorTypeArray, nativeObjects.vectorTypeArray);

		if (lowestTile.isNeededToCreateGeometriesFromSeeds())
		{
			lowestTile.createGeometriesFromSeeds(this);
		}
	}
};

/**
 */
MagoManager.prototype.flyToTopology = function(worldPoint3d, duration) 
{
	if (this.isCesiumGlobe()) 
	{
		this.scene.camera.flyTo({
			destination : Cesium.Cartesian3.clone(worldPoint3d),
			orientation : {
				direction : new Cesium.Cartesian3(this.scene.camera.direction.x, this.scene.camera.direction.y, this.scene.camera.direction.z),
				up        : new Cesium.Cartesian3(this.scene.camera.up.x, this.scene.camera.up.y, this.scene.camera.up.z)},
			duration: parseInt(duration)
		});
	}
	/*
	else if (MagoConfig.getPolicy().basicGlobe === Constant.WORLDWIND)
	{
		this.wwd.goToAnimator.travelTime = duration * 1000;
		this.wwd.goTo(new WorldWind.Position(parseFloat(latitude), parseFloat(longitude), parseFloat(altitude) + 50));
	}
	else if (MagoConfig.getPolicy().basicGlobe === Constant.MAGOWORLD)
	{
		this.magoWorld.goto(parseFloat(longitude),
			parseFloat(latitude),
			parseFloat(altitude) + 10);
	}
	*/
};

/**
 * dataKey 이용해서 data 검색
 * @param apiName api 이름
 * @param projectId project id
 * @param dataKey
 */
MagoManager.prototype.flyTo = function(longitude, latitude, altitude, duration) 
{
	if (this.isCesiumGlobe()) 
	{
		this.scene.camera.flyTo({
			destination: Cesium.Cartesian3.fromDegrees(parseFloat(longitude),
				parseFloat(latitude),
				parseFloat(altitude)),
			duration: parseInt(duration)
		});
	}
	else/* if (MagoConfig.getPolicy().basicGlobe === Constant.MAGOWORLD)*/
	{
		this.magoWorld.goto(parseFloat(longitude),
			parseFloat(latitude),
			parseFloat(altitude));
	}

};

/**
 * dataKey 이용해서 data 검색
 * @param apiName api 이름
 * @param projectId project id
 * @param dataKey
 */
MagoManager.prototype.flyToBuilding = function(apiName, projectId, dataKey) 
{
	var node = this.hierarchyManager.getNodeByDataName(projectId, "nodeId", dataKey);
	if (node === undefined)
	{ 
		apiResultCallback( MagoConfig.getPolicy().geo_callback_apiresult, apiName, "-1");
		return; 
	}
	
	var nodeRoot = node.getRoot();
	var geoLocDataManager = nodeRoot.data.geoLocDataManager;
	var geoLoc;
	if (geoLocDataManager === undefined)
	{ 
		geoLoc = node.calculateGeoLocData(this);
		if (geoLoc === undefined)
		{
			apiResultCallback( MagoConfig.getPolicy().geo_callback_apiresult, apiName, "-1");
			return; 
		}
	}
	geoLocDataManager = nodeRoot.data.geoLocDataManager;
	geoLoc = geoLocDataManager.getCurrentGeoLocationData();
	var realBuildingPos = node.getBBoxCenterPositionWorldCoord(geoLoc);

	if (realBuildingPos === undefined)
	{ return; }

	if (!nodeRoot.data.bbox)
	{ return; }
	this.radiusAprox_aux = nodeRoot.data.bbox.getRadiusAprox();

	if (this.boundingSphere_Aux === undefined)
	{ this.boundingSphere_Aux = new Sphere(); }
	
	this.boundingSphere_Aux.radius = this.radiusAprox_aux;

	if (this.isCesiumGlobe())
	{
		this.boundingSphere_Aux.center = Cesium.Cartesian3.clone(realBuildingPos);
		var seconds = 3;
		this.scene.camera.flyToBoundingSphere(this.boundingSphere_Aux, seconds);
	}
};

MagoManager.prototype.displayLocationAndRotation = function(neoBuilding) 
{
	//var node = this.hierarchyManager.getNodeByDataName(projectId, dataName, dataNameValue); // original.***
	var node = neoBuilding.nodeOwner;
	var geoLocDatamanager = node.getNodeGeoLocDataManager();
	if (geoLocDatamanager === undefined)
	{ return; }
	var geoLocationData = geoLocDatamanager.getCurrentGeoLocationData();
	var latitude = geoLocationData.geographicCoord.latitude;
	var longitude = geoLocationData.geographicCoord.longitude;
	var altitude = geoLocationData.geographicCoord.altitude;
	var heading = geoLocationData.heading;
	var pitch = geoLocationData.pitch;
	var roll = geoLocationData.roll;
	var dividedName = neoBuilding.buildingId.split("_");
};

/**
 * 변환 행렬
 */
MagoManager.prototype.selectedObjectNotice = function(neoBuilding) 
{
	if (neoBuilding === undefined)
	{ return; }
	
	var node = neoBuilding.nodeOwner;
	var geoLocDatamanager = node.getNodeGeoLocDataManager();
	if (geoLocDatamanager === undefined)
	{ return; }
	var geoLocationData = geoLocDatamanager.getCurrentGeoLocationData();
	var dataKey = node.data.nodeId;
	var projectId = node.data.projectId;

	if (MagoConfig.getPolicy().geo_callback_enable === "true") 
	{
		//if (this.objMarkerSC === undefined) { return; }
		var objectId = null;
		if (this.objectSelected !== undefined) { objectId = this.objectSelected.objectId; }
		
		// click object 정보를 표시
		if (this.magoPolicy.getObjectInfoViewEnable()) 
		{
			selectedObjectCallback(		MagoConfig.getPolicy().geo_callback_selectedobject,
				projectId,
				dataKey,
				objectId,
				geoLocationData.geographicCoord.latitude,
				geoLocationData.geographicCoord.longitude,
				geoLocationData.geographicCoord.altitude,
				geoLocationData.heading,
				geoLocationData.pitch,
				geoLocationData.roll);
		}
			
		// 이슈 등록 창 오픈
		if (this.magoPolicy.getIssueInsertEnable()) 
		{
			//if (this.objMarkerSC === undefined) { return; }
			
			insertIssueCallback(	MagoConfig.getPolicy().geo_callback_insertissue,
				projectId,
				dataKey,
				objectId,
				geoLocationData.geographicCoord.latitude,
				geoLocationData.geographicCoord.longitude,
				(parseFloat(geoLocationData.geographicCoord.altitude)));
		}
	}
	
	
};

/**
 * 변환 행렬
 */
MagoManager.prototype.changeLocationAndRotation = function(projectId, dataKey, latitude, longitude, elevation, heading, pitch, roll, animationOption) 
{
	var node = this.hierarchyManager.getNodeByDataKey(projectId, dataKey);
	if (node === undefined)
	{ return; }
	this.changeLocationAndRotationNode(node, latitude, longitude, elevation, heading, pitch, roll, animationOption);
};

/**
 * 변환 행렬
 */
MagoManager.prototype.changeLocationAndRotationNode = function(node, latitude, longitude, elevation, heading, pitch, roll, animationOption) 
{
	if (node === undefined)
	{ return; }

	if (animationOption !== undefined)
	{
		if (this.animationManager === undefined)
		{ this.animationManager = new AnimationManager(); }
		this.animationManager.putNode(node);
		
		//For compatibility with lower versions, lower version parameter is duratiuon(number).
		node.changeLocationAndRotationAnimated(latitude, longitude, elevation, heading, pitch, roll, this, animationOption);
	}
	else 
	{
		node.changeLocationAndRotation(latitude, longitude, elevation, heading, pitch, roll, this);
	}
	
	var neoBuilding = node.data.neoBuilding;
	
	//this.selectedObjectNotice(neoBuilding);
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 * @param {string} projectId policy 사용 시 geo_data_default_projects 배열에 있는 값.
 * @param {string} projectDataFolder 해당 프로젝트의 data_key를 의미.
 */
MagoManager.prototype.getObjectIndexFile = function(projectId, projectDataFolder) 
{
	if (this.configInformation === undefined)
	{
		this.configInformation = MagoConfig.getPolicy();
	}
	
	this.buildingSeedList = new BuildingSeedList();
	var fileName;
	var geometrySubDataPath = projectDataFolder;
	fileName = this.readerWriter.geometryDataPath + "/" + geometrySubDataPath + Constant.OBJECT_INDEX_FILE + Constant.CACHE_VERSION + new Date().getTime();
	this.readerWriter.getObjectIndexFileForSmartTile(fileName, this, this.buildingSeedList, projectId);
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 * @param {string} projectId policy 사용 시 geo_data_default_projects 배열에 있는 값.
 * @param {Array<object> | object} f4dObject f4d data definition object
 */
MagoManager.prototype.getObjectIndexFileForData = function(projectId, f4dObject) 
{
	if (this.configInformation === undefined)
	{
		this.configInformation = MagoConfig.getPolicy();
	}
	
	var f4dGroupObject = MagoConfig.getData(CODE.PROJECT_ID_PREFIX + projectId);
	var groupDataFolder = this.hierarchyManager.getNodeByDataKey(projectId, projectId).data.projectFolderName;
	groupDataFolder = groupDataFolder.replace(/\/+$/, '');
	var newDataKeys = [];
	var children = f4dGroupObject.children;
	// TODO :
	if (Array.isArray(f4dObject)) 
	{
		for (var i=0, len=f4dObject.length;i<len;i++) 
		{
			var attributes = f4dObject[i].attributes || JSON.parse(f4dObject[i].metainfo);
			if (!attributes.isPhysical) 
			{
				throw new Error('f4d member must isPhysical true.'); 
			}
			f4dObject[i].groupDataFolder = groupDataFolder;
			var dataKey = f4dObject[i].data_key || f4dObject[i].dataKey;
			newDataKeys.push(dataKey);
			children.push(f4dObject[i]);
		}
	}
	else 
	{
		// TODO :
		var attributes = f4dObject.attributes || JSON.parse(f4dObject.metainfo);
		if (!attributes.isPhysical) 
		{
			throw new Error('f4d member must isPhysical true.'); 
		}
		f4dObject.groupDataFolder = groupDataFolder;
		var dataKey = f4dObject.data_key || f4dObject.dataKey;
		newDataKeys.push(dataKey);
		children.push(f4dObject);
	}
	
	var geometrySubDataPath = groupDataFolder;
	var fileName = this.readerWriter.geometryDataPath + "/" + geometrySubDataPath + Constant.OBJECT_INDEX_FILE + Constant.CACHE_VERSION + MagoConfig.getPolicy().content_cache_version;
	this.readerWriter.getObjectIndexFileForData(fileName, this, projectId, newDataKeys, f4dObject);
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 */
MagoManager.prototype.getObjectIndexFile_xxxx = function() 
{
	if (this.configInformation === undefined)
	{
		this.configInformation = MagoConfig.getPolicy();
	}

	this.buildingSeedList = new BuildingSeedList();
	this.readerWriter.getObjectIndexFileForSmartTile(
		this.readerWriter.getCurrentDataPath() + Constant.OBJECT_INDEX_FILE + Constant.CACHE_VERSION + MagoConfig.getPolicy().content_cache_version, this, this.buildingSeedList);
		
};

/**
 * smartTile 의 object index 파일을 읽음
 * @param {string} projectId 프로젝트 고유번호
 * @param {string} projectDataFolder smartTile 의 위치
 */
MagoManager.prototype.getObjectIndexFileSmartTileF4d = function(projectDataFolder) 
{
	if (this.configInformation === undefined)
	{
		this.configInformation = MagoConfig.getPolicy();
	}

	var geometrySubDataPath = projectDataFolder;
	var fileName = this.readerWriter.geometryDataPath + "/" + geometrySubDataPath + Constant.TILE_INDEX_FILE;
	this.readerWriter.getObjectIndexFileSmartTileF4d(fileName, geometrySubDataPath, this);
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 */
MagoManager.prototype.makeNode = function(jasonObject, resultPhysicalNodesArray, buildingSeedMap, projectFolderName, projectId) 
{
	var attributes = undefined;
	var children = undefined;
	var data_group_id = undefined;
	var data_group_name = undefined;
	var data_id = undefined;
	var data_key = undefined;
	var data_name = undefined;
	var heading = undefined;
	var height = undefined;
	var latitude = undefined;
	var longitude = undefined;
	var pitch = undefined;
	var roll = undefined;
	var mapping_type = undefined;

	if (jasonObject !== undefined)
	{
		if (!jasonObject.data_key) 
		{
			jasonObject.childrenCnt = jasonObject.children;
			jasonObject.attributes = jasonObject.attributes || JSON.parse(jasonObject.metainfo);
			
			jasonObject.children = jasonObject.datas;
			
			delete jasonObject.datas;
			
			
			data_group_id = jasonObject.dataGroupId;
			data_group_name = jasonObject.dataGroupName;
			data_id = jasonObject.dataId;
			data_key = jasonObject.dataKey || jasonObject.dataGroupKey;
			data_name = jasonObject.dataName || jasonObject.dataGroupName;
			heading = jasonObject.heading;
			height = jasonObject.altitude;
			latitude = jasonObject.latitude;
			longitude = jasonObject.longitude;
			pitch = jasonObject.pitch;
			roll = jasonObject.roll;
			mapping_type = jasonObject.mappingType || 'origin';
		}
		else 
		{
			data_group_id = jasonObject.data_group_id;
			data_group_name = jasonObject.data_group_name;
			data_id = jasonObject.data_id;
			data_key = jasonObject.data_key;
			data_name = jasonObject.data_name;
			heading = jasonObject.heading;
			height = jasonObject.height;
			latitude = jasonObject.latitude;
			longitude = jasonObject.longitude;
			pitch = jasonObject.pitch;
			roll = jasonObject.roll;
			mapping_type = jasonObject.mapping_type;
		}
		attributes = jasonObject.attributes;
		children = jasonObject.children;
	}

	if (heading === undefined)
	{ heading = 0; }

	if (pitch === undefined)
	{ pitch = 0; }

	if (roll === undefined)
	{ roll = 0; }

	// now make the node.
	var buildingId;
	var buildingSeed;
	var node;
	var bbox;
	var childJason;
	var childNode;
	var childrenCount;
	if (attributes !== undefined)
	{
		if (!attributes.isReference)
		{
			attributes.objectType = "basicF4d";
			buildingId = data_key;
			node = this.hierarchyManager.newNode(buildingId, projectId, attributes);
			// set main data of the node.
			var data = node.data;
			var relativePath = attributes.relativePath;
			projectFolderName = (relativePath && relativePath.length > 0) ? projectFolderName + relativePath : projectFolderName;
			data.projectFolderName = projectFolderName;
			data.projectId = projectId;
			data.data_name = data_name;
			data.attributes = attributes;
			data.mapping_type = mapping_type;
			data.dataId = data_id;
			data.dataGroupId = data_group_id;
			var tMatrix;
			
			if (attributes.isPhysical)
			{
				// find the buildingSeed.
				buildingSeed = buildingSeedMap[buildingId];
				if (buildingSeed)
				{
					data.buildingSeed = buildingSeed;
					resultPhysicalNodesArray.push(node);
				}
			}

			if (longitude && latitude)
			{
				// this is root node.
				if (height === undefined)
				{ height = 0; }
				
				data.geographicCoord = new GeographicCoord();
				data.geographicCoord.setLonLatAlt(longitude, latitude, height);
				
				if (data.rotationsDegree === undefined)
				{ data.rotationsDegree = new Point3D(); }
				data.rotationsDegree.set(pitch, roll, heading);
				
				
				if (buildingSeed !== undefined)
				{
					if (buildingSeed.geographicCoord === undefined)
					{ buildingSeed.geographicCoord = new GeographicCoord(); }
				
					if (buildingSeed.rotationsDegree === undefined)
					{ buildingSeed.rotationsDegree = new Point3D(); }
			
					buildingSeed.geographicCoord.setLonLatAlt(longitude, latitude, height);
					buildingSeed.rotationsDegree.set(pitch, roll, heading);
					
					// now calculate the geographic coord of the center of the bbox.
					if (buildingSeed.geographicCoordOfBBox === undefined) 
					{ buildingSeed.geographicCoordOfBBox = new GeographicCoord(); }
				
					// calculate the transformation matrix at (longitude, latitude, height).
					var worldCoordPosition = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, height, worldCoordPosition, this);
					tMatrix = ManagerUtils.calculateTransformMatrixAtWorldPosition(worldCoordPosition, heading, pitch, roll, undefined, tMatrix, this);
					
					// now calculate the geographicCoord of the center of the bBox.
					var bboxCenterPoint;

					bboxCenterPoint = buildingSeed.bBox.getCenterPoint(bboxCenterPoint);
					
					var bboxCenterPointWorldCoord = tMatrix.transformPoint3D(bboxCenterPoint, bboxCenterPointWorldCoord);
					buildingSeed.geographicCoordOfBBox = ManagerUtils.pointToGeographicCoord(bboxCenterPointWorldCoord, buildingSeed.geographicCoordOfBBox, this); // original.
					
					// Set the altitude as the original. This method has little error.***
					buildingSeed.geographicCoordOfBBox.altitude = buildingSeed.geographicCoord.altitude;
					
				}
			}

			// now, calculate the bbox.***
			data.bbox = new BoundingBox();
			
			if (data.buildingSeed && data.buildingSeed.bBox)
			{ data.bbox.copyFrom(buildingSeed.bBox); }
			
			// calculate the geographicCoordOfTheBBox.***
			if (tMatrix !== undefined)
			{
				if (data.mapping_type.toLowerCase() === "origin")
				{
					bboxCenterPoint = data.bbox.getCenterPoint(bboxCenterPoint);
					var bboxCenterPointWorldCoord = tMatrix.transformPoint3D(bboxCenterPoint, bboxCenterPointWorldCoord);
					data.bbox.geographicCoord = ManagerUtils.pointToGeographicCoord(bboxCenterPointWorldCoord, data.bbox.geographicCoord, this);
				}
				else if (data.mapping_type.toLowerCase() === "boundingboxcenter")
				{
					data.bbox.geographicCoord = new GeographicCoord();
					data.bbox.geographicCoord.setLonLatAlt(longitude, latitude, height);
				}
			}

			//bbox = node.data.bbox;

			if (children !== undefined)
			{
				childrenCount = children.length;
				for (var i=0; i<childrenCount; i++)
				{
					childJason = children[i];
					childNode = this.makeNode(childJason, resultPhysicalNodesArray, buildingSeedMap, projectFolderName, projectId);
					
					// if childNode has "geographicCoord" then the childNode is in reality a root.
					if (childNode.data.geographicCoord === undefined)
					{
						node.addChildren(childNode);
					}
				}
			}
		}
		else 
		{
			/* static model 사용은 API를 통해서만... 
			attributes.projectId = projectId;
			this.addStaticModel(attributes);
			if (children !== undefined)
			{
				childrenCount = children.length;
				for (var i=0; i<childrenCount; i++)
				{
					var childrenObj = children[i];
					if (!defined(childrenObj.projectId))
					{
						childrenObj.projectId = projectId;
					}
					this.instantiateStaticModel(childrenObj);
				}
			}
			*/
		}
	}
	return node;
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 */
MagoManager.prototype.calculateBoundingBoxesNodes = function(projectId) 
{
	var node;
	var nodeRoot;
	var buildingSeed;
	var longitude, latitude, height;
	var heading, pitch, roll;
	
	var nodesMap = this.hierarchyManager.getNodesMap(projectId);
	// 1rst, calculate boundingBoxes of buildingSeeds of nodes.

	for (var key in nodesMap)
	{
		if (Object.prototype.hasOwnProperty.call(nodesMap, key))
		{
			node = nodesMap[key];
			if (node.data === undefined)
			{ continue; }
			
			buildingSeed = node.data.buildingSeed;
			if (buildingSeed)
			{
				nodeRoot = node.getClosestParentWithData("geographicCoord");
			
				longitude = nodeRoot.data.geographicCoord.longitude; 
				latitude = nodeRoot.data.geographicCoord.latitude; 
				height = nodeRoot.data.geographicCoord.altitude;
			
				heading = nodeRoot.data.rotationsDegree.z;
				pitch = nodeRoot.data.rotationsDegree.x;
				roll = nodeRoot.data.rotationsDegree.y;
			
				if (buildingSeed.geographicCoord === undefined)
				{ buildingSeed.geographicCoord = new GeographicCoord(); }
		
				if (buildingSeed.rotationsDegree === undefined)
				{ buildingSeed.rotationsDegree = new Point3D(); }

				buildingSeed.geographicCoord.setLonLatAlt(longitude, latitude, height);
				buildingSeed.rotationsDegree.set(pitch, roll, heading);
			
				// now calculate the geographic coord of the center of the bbox.
				if (buildingSeed.geographicCoordOfBBox === undefined) 
				{ buildingSeed.geographicCoordOfBBox = new GeographicCoord(); }
		
				// calculate the transformation matrix at (longitude, latitude, height).
				var worldCoordPosition = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, height, worldCoordPosition, this);
				var tMatrix = ManagerUtils.calculateTransformMatrixAtWorldPosition(worldCoordPosition, heading, pitch, roll, undefined, tMatrix, this);
			
				// now calculate the geographicCoord of the center of the bBox.
				buildingSeed.geographicCoordOfBBox.setLonLatAlt(longitude, latitude, height);
			}
		}
	}
	
	
	// now, must calculate the bbox of the root nodes.
	var rootNodesArray = [];
	var nodesArray = [];
	this.hierarchyManager.getRootNodes(projectId, rootNodesArray); // original.***
	var bboxStarted = false;
	
	var rootNodesCount = rootNodesArray.length;
	for (var i=0; i<rootNodesCount; i++)
	{
		nodeRoot = rootNodesArray[i];
		
		nodesArray.length = 0; // init.***
		nodeRoot.extractNodesByDataName(nodesArray, "buildingSeed");
		// now, take nodes that is "isMain" = true.
		bboxStarted = false;
		var nodesCount =  nodesArray.length;
		for (var j=0; j<nodesCount; j++)
		{
			node = nodesArray[j];
			var nodeBBox = node.data.bbox;
			
			if (nodeBBox)
			{
				if (node.data.attributes)
				{
					if (node.data.attributes.isMain)
					{
						//buildingSeed = node.data.buildingSeed;
						if (bboxStarted === false)
						{
							nodeRoot.data.bbox.copyFrom(nodeBBox);
							bboxStarted = true;
						}
						else 
						{
							nodeRoot.data.bbox.addBox(nodeBBox);
						}
					}
					else 
					{
						if (bboxStarted === false)
						{
							nodeRoot.data.bbox.copyFrom(nodeBBox);
							bboxStarted = true;
						}
						else 
						{
							nodeRoot.data.bbox.addBox(nodeBBox);
						}
					}
				}
				else 
				{
					if (bboxStarted === false)
					{
						nodeRoot.data.bbox.copyFrom(nodeBBox);
						bboxStarted = true;
					}
					else 
					{
						nodeRoot.data.bbox.addBox(nodeBBox);
					}
				}
			}
		}
	}
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 */
MagoManager.prototype.makeSmartTile = function(buildingSeedList, projectId, f4dObjectJson, seedMap) 
{
	if (!buildingSeedList && !seedMap) 
	{
		throw new Error('buildingSeedList or seedMap is required'); 
	}
	//var realTimeLocBlocksList = MagoConfig.getData().alldata; // original.***
	// "projectId" = json file name.
	var realTimeLocBlocksList = f4dObjectJson || MagoConfig.getData(CODE.PROJECT_ID_PREFIX + projectId);
	var buildingSeed;
	var buildingId;
	var newLocation;

	// now, read all hierarchyJason and make the hierarchy tree.
	var physicalNodesArray = []; // put here the nodes that has geometry data.
	// make a buildingSeedMap.
	var buildingSeedMap = seedMap || {};
	var buildingSeedMapLength = Object.keys(buildingSeedMap).length;
	if (buildingSeedMapLength === 0) 
	{
		var buildingSeedsCount = buildingSeedList.buildingSeedArray.length;
		for (var i=0; i<buildingSeedsCount; i++)
		{
			buildingSeed = buildingSeedList.buildingSeedArray[i];
			buildingId = buildingSeed.buildingId;
			buildingSeedMap[buildingId] = buildingSeed;
		}
	}
	
	var projectFolderName = getProjectFolderName(realTimeLocBlocksList);
	if (!Array.isArray(realTimeLocBlocksList)) 
	{
		this.makeNode(realTimeLocBlocksList, physicalNodesArray, buildingSeedMap, projectFolderName, projectId);
	}
	else 
	{
		for (var i=0, len=realTimeLocBlocksList.length;i<len;i++) 
		{
			var blocks = realTimeLocBlocksList[i];
			this.makeNode(blocks, physicalNodesArray, buildingSeedMap, projectFolderName, projectId);
		}
	}
	this.calculateBoundingBoxesNodes(projectId);
	

	var auxNodesArray = JSON.parse(JSON.stringify(physicalNodesArray));
	// now, make smartTiles.
	// there are 2 general smartTiles: AsiaSide & AmericaSide.
	var targetDepth = 15;
	this.smartTileManager.makeTreeByDepth(targetDepth, physicalNodesArray, this);

	this.buildingSeedList.buildingSeedArray.length = 0; // init.

	
	this.emit(MagoManager.EVENT_TYPE.F4DLOADEND, {
		type      : MagoManager.EVENT_TYPE.F4DLOADEND,
		f4d       : auxNodesArray,
		timestamp : new Date()
	});

	function getProjectFolderName(json) 
	{
		var folderName;
		var f4d = Array.isArray(json) ? json[0] : json;
		if (f4d.data_key) 
		{
			folderName = f4d.groupDataFolder || f4d.data_key;
		}
		else 
		{
			if (f4d.dataGroupPath) 
			{
				folderName = f4d.dataGroupPath;
				folderName = folderName.replace(/\/+$/, '');
			}
			else 
			{
				folderName = f4d.groupDataFolder;
			}
		}

		return folderName;
	}
};


/**
 * instantiate static model
 * @param {instantiateOption} attributes
 */
MagoManager.prototype.instantiateStaticModel = function(attributes)
{
	if (!defined(attributes.projectId))
	{
		throw new Error('projectId is required.');
	}

	if (!this.isExistStaticModel(attributes.projectId))
	{
		throw new Error('static model is not exist.');
	}
	if (!defined(attributes.instanceId))
	{
		throw new Error('instanceId is required.');
	}

	if (!defined(attributes.longitude))
	{
		throw new Error('longitude is required.');
	}
	if (!defined(attributes.latitude))
	{
		throw new Error('latitude is required.');
	}

	if (!attributes.isReference)
	{
		attributes.isReference = true;
	}

	if (!attributes.isPhysical)
	{
		attributes.isPhysical = true;
	}

	if (!attributes.nodeType)
	{
		attributes.nodeType = "TEST";
	}
	
	attributes.objectType = "basicF4d";

	//var nodesMap = this.hierarchyManager.getNodesMap(projectId, undefined);
	//var existentNodesCount = Object.keys(nodesMap).length;
	//var instanceId = defaultValue(attributes.instanceId, projectId + "_" + existentNodesCount.toString());
	var projectId = attributes.projectId;
	var instanceId = attributes.instanceId;
	
	var longitude = attributes.longitude;
	var latitude = attributes.latitude;
	var altitude = parseFloat(defaultValueCheckLength(attributes.height, 0));
	var heading = parseFloat(defaultValueCheckLength(attributes.heading, 0));
	var pitch = parseFloat(defaultValueCheckLength(attributes.pitch, 0));
	var roll = parseFloat(defaultValueCheckLength(attributes.roll, 0));
	
	var node = this.hierarchyManager.getNodeByDataKey(projectId, instanceId);
	if (node === undefined)
	{
		node = this.hierarchyManager.newNode(instanceId, projectId, undefined);

		var geoCoord = new GeographicCoord();
		geoCoord.latitude = parseFloat(latitude);
		geoCoord.longitude = parseFloat(longitude);
		geoCoord.altitude = parseFloat(altitude);

		var geoLocDataManager = geoCoord.getGeoLocationDataManager();
		var geoLocData = geoLocDataManager.newGeoLocationData("noName");
		geoLocData = ManagerUtils.calculateGeoLocationData(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude+1, heading, pitch, roll, geoLocData, this);

		// Now, create the geoLocdataManager of node.***
		node.data.projectId = projectId;
		node.data.attributes = attributes;
		node.data.geographicCoord = geoCoord;
		node.data.rotationsDegree = new Point3D(pitch, roll, heading);
		node.data.geoLocDataManager = geoLocDataManager;

		// Now, insert node into smartTile.***
		var targetDepth = 12;
		this.smartTileManager.putNode(targetDepth, node, this);
	}
	else 
	{
		this.changeLocationAndRotation(projectId, instanceId, latitude, longitude, altitude, heading, pitch, roll);
	}
};
/**
 * add static model
 * @param {staticModelOption} attributes
 */
MagoManager.prototype.addStaticModel = function(attribute)
{
	if (!defined(attribute.projectId))
	{
		throw new Error('projectId is required.');
	}

	if (!defined(attribute.projectFolderName))
	{
		throw new Error('projectFolderName is required.');
	}

	if (!defined(attribute.buildingFolderName))
	{
		throw new Error('buildingFolderName is required.');
	}
	var projectId = attribute.projectId;
	var staticModelsManager = this.hierarchyManager.getStaticModelsManager();

	var staticModel = new StaticModel();
	staticModel.guid = projectId;
	staticModel.projectFolderName = attribute.projectFolderName;
	staticModel.buildingFolderName = attribute.buildingFolderName;
	staticModel.neoBuilding = new NeoBuilding();
	
	staticModelsManager.addStaticModel(projectId, staticModel);
};
/**
 * check static model is exist
 * @param {string} projectId
 * @returns {Boolean} isExist
 */
MagoManager.prototype.isExistStaticModel = function(projectId)
{
	var isExist = false;

	if (!this.hierarchyManager.staticModelsManager || !this.hierarchyManager.staticModelsManager.staticModelsMap)
	{
		return isExist;
	}

	if (this.hierarchyManager.staticModelsManager.staticModelsMap.hasOwnProperty(projectId))
	{
		isExist = true;
	}
	return isExist;
};
/**
 * api gateway
 */
MagoManager.prototype.callAPI = function(api) 
{
	var apiName = api.getAPIName();
	if (apiName === "changeMagoState") 
	{
		this.magoPolicy.setMagoEnable(api.getMagoEnable());
	}
	else if (apiName === "searchData") 
	{
		return this.flyToBuilding(apiName, api.getProjectId(), api.getDataKey());
	}
	else if (apiName === "changeColor") 
	{
		ColorAPI.changeColor(api, this);
	}
	else if (apiName === "show") 
	{
		this.magoPolicy.setHideBuildings.length = 0;
	}
	else if (apiName === "hide") 
	{
		this.magoPolicy.setHideBuildings(api.gethideBuilds());
	}
	else if (apiName === "changeOutFitting") 
	{
		this.magoPolicy.setShowOutFitting(api.getShowOutFitting());
	} 
	else if (apiName === "changeLabel") 
	{
		this.magoPolicy.setShowLabelInfo(api.getShowLabelInfo());
		
		// clear the text canvas.
		var canvas = document.getElementById("objectLabel");
		var ctx = canvas.getContext("2d");
		ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

	}
	else if (apiName === "changeOrigin")
	{
		this.magoPolicy.setShowOrigin(api.getShowOrigin());
	}
	else if (apiName === "changeBoundingBox") 
	{
		this.magoPolicy.setShowBoundingBox(api.getShowBoundingBox());
	}
	else if (apiName === "changeShadow") 
	{
		this.sceneState.setApplySunShadows(api.getShowShadow());
	}
	else if (apiName === "changefrustumFarDistance") 
	{
		// frustum culling 가시 거리
		this.magoPolicy.setFrustumFarSquaredDistance(api.getFrustumFarDistance() * api.getFrustumFarDistance());
	}
	else if (apiName === "changeLocationAndRotation") 
	{
		LocationAndRotationAPI.changeLocationAndRotation(api, this);
	}
	else if (apiName === "changeObjectMove") 
	{
		var objectMoveMode = api.getObjectMoveMode();
		// CODE MOVEMODE에 왜 GEOGRAPHICPOINTS가 2로 매핑되었는지....;;
		if (objectMoveMode === CODE.moveMode.GEOGRAPHICPOINTS || objectMoveMode === CODE.moveMode.NONE) 
		{
			this.emit(MagoManager.EVENT_TYPE.DESELECTEDF4D, {
				type: MagoManager.EVENT_TYPE.DESELECTEDF4D
			});
			this.emit(MagoManager.EVENT_TYPE.DESELECTEDF4DOBJECT, {
				type: MagoManager.EVENT_TYPE.DESELECTEDF4DOBJECT
			});
		}
		
		this.magoPolicy.setObjectMoveMode(objectMoveMode);
	}
	else if (apiName === "saveObjectMove") 
	{
	//		var changeHistory = new ChangeHistory();
	//		changeHistory.setObjectMoveMode(api.getObjectMoveMode());
	//		MagoConfig.saveMovingHistory(api.getProjectId(), api.getDataKey(), api.getObjectIndexOrder(), changeHistory);
	}
	else if (apiName === "deleteAllObjectMove") 
	{
		// delete "aditionalMove" of the objects.***
		var moveHistoryMap = MagoConfig.getAllMovingHistory(); // get colorHistoryMap.***
		if (moveHistoryMap === undefined)
		{
			MagoConfig.clearMovingHistory();
			return;
		}
		
		for (var key_projectId in moveHistoryMap)
		{
			if (Object.prototype.hasOwnProperty.call(moveHistoryMap, key_projectId))
			{
				var projectId = key_projectId;
				var buildingsMap = moveHistoryMap[projectId];
				if (buildingsMap === undefined)
				{ continue; }
				
				for (var key_dataKey in buildingsMap)
				{
					if (Object.prototype.hasOwnProperty.call(buildingsMap, key_dataKey))
					{
						var dataKey = key_dataKey;
						var dataValue = buildingsMap[key_dataKey];
						
						if (dataValue === undefined)
						{ continue; }
						
						for (var objectIdx in dataValue)
						{
							if (Object.prototype.hasOwnProperty.call(dataValue, objectIdx))
							{
								var node = this.hierarchyManager.getNodeByDataKey(projectId, dataKey);
								if (node === undefined || node.data === undefined)
								{ continue; }
								
								var neoBuilding = node.data.neoBuilding;
								if (neoBuilding === undefined)
								{ continue; }
								
								var refObject = neoBuilding.getReferenceObject(objectIdx);
								delete node.data.moveHistoryMap[objectIdx];
								if (refObject)
								{
									refObject.moveVector = undefined;
									refObject.moveVectorRelToBuilding = undefined;
								}	
							}
						}	
					}
				}	
			}
		}
		
		MagoConfig.clearMovingHistory();
	}
	else if (apiName === "deleteAllChangeColor") 
	{
		// 1rst, must delete the aditionalColors of objects.***
		var colorHistoryMap = MagoConfig.getAllColorHistory(); // get colorHistoryMap.***
		
		if (colorHistoryMap === undefined)
		{
			MagoConfig.clearColorHistory();
			return;
		}
		
		for (var key_projectId in colorHistoryMap)
		{
			if (Object.prototype.hasOwnProperty.call(colorHistoryMap, key_projectId))
			{
				var projectId = key_projectId;
				var buildingsMap = colorHistoryMap[projectId];
				if (buildingsMap === undefined)
				{ continue; }
				
				for (var key_dataKey in buildingsMap)
				{
					if (Object.prototype.hasOwnProperty.call(buildingsMap, key_dataKey))
					{
						var dataKey = key_dataKey;
						var dataValue = buildingsMap[key_dataKey];
						if (dataValue === undefined)
						{ continue; }
						
						for (var objectId in dataValue)
						{
							if (Object.prototype.hasOwnProperty.call(dataValue, objectId))
							{
								var node = this.hierarchyManager.getNodeByDataKey(projectId, dataKey);
								if (node === undefined || node.data === undefined)
								{ continue; }
							
								node.data.isColorChanged = false;
								node.data.colorChangedHistoryMap = undefined;
								
								var neoBuilding = node.data.neoBuilding;
								if (neoBuilding === undefined)
								{ continue; }
							
								var refObjectArray = neoBuilding.getReferenceObjectsArrayByObjectId(objectId);
								if (refObjectArray === undefined)
								{ continue; }
								
								var refObjectsCount = refObjectArray.length;
								for (var i=0; i<refObjectsCount; i++)
								{
									var refObject = refObjectArray[i];
									if (refObject)
									{
										refObject.aditionalColor = undefined;
									}
								}	
							}
						}	
					}
				}	
			}
		}
		
		MagoConfig.clearColorHistory();
	}
	else if (apiName === "changeInsertIssueMode") 
	{
		this.magoPolicy.setIssueInsertEnable(api.getIssueInsertEnable());
		//selectedObjectCallback(이걸 해 주면 될거 같음)
	}
	else if (apiName === "changeObjectInfoViewMode") 
	{
		// object info 표시
		this.magoPolicy.setObjectInfoViewEnable(api.getObjectInfoViewEnable());
	}
	else if (apiName === "changeNearGeoIssueListViewMode") 
	{
		// issue list 표시
		this.magoPolicy.setNearGeoIssueListEnable(api.getNearGeoIssueListEnable());
		if (!api.getNearGeoIssueListEnable()) 
		{
			// clear objMarkerManager objectmakersarrays 사이즈를 0 으로 하면... .됨
			this.objMarkerManager.objectMarkerArray = [];
		}
	}
	else if (apiName === "changeOcclusionCulling") 
	{
		// OcclusionCulling 적용 유무
		this.magoPolicy.setOcclusionCullingEnable(api.getOcclusionCullingEnable());
		var neoBuilding = this.selectionManager.currentBuildingSelected;
		if (neoBuilding)
		{ neoBuilding.setRenderSettingApplyOcclusionCulling(this.magoPolicy.getOcclusionCullingEnable()); }
		// dataKey 는 api.getDataKey();
	}
	else if (apiName === "drawInsertIssueImage") 
	{
		DrawAPI.drawInsertIssueImage(api, this);
	}
	else if (apiName === "changeInsertIssueState")
	{
		this.sceneState.insertIssueState = 0;
	}
	else if (apiName === "changeLod")
	{
		LodAPI.changeLod(api, this);
	}
	else if (apiName === "changeLighting")
	{
		var ambient = api.getAmbientReflectionCoef();
		var difusse = api.getDiffuseReflectionCoef();
		var specular = api.getSpecularReflectionCoef();
		var specularColor = api.getSpecularColor();
		var ambientColor = api.getAmbientColor();
		
		if (!isNaN(ambient)) 
		{
			this.sceneState.ambientReflectionCoef[0] = Number(ambient); // 0.2.
		}

		if (!isNaN(difusse)) 
		{
			this.sceneState.diffuseReflectionCoef[0] = Number(difusse); // 1.0
		}
		
		if (!isNaN(specular)) 
		{
			this.sceneState.specularReflectionCoef[0] = Number(specular); // 0.7
		}

		if (specularColor) 
		{
			var splitedSpecularColor = specularColor.split(',');
			if (splitedSpecularColor.length === 3) 
			{
				var sr = parseInt(splitedSpecularColor[0]) / 255;
				var sg = parseInt(splitedSpecularColor[1]) / 255;
				var sb = parseInt(splitedSpecularColor[2]) / 255;

				this.sceneState.specularColor[0] = sr; // 0.7
				this.sceneState.specularColor[1] = sg; // 0.7
				this.sceneState.specularColor[2] = sb; // 0.7
			}
		}

		if (ambientColor) 
		{
			var splitedAmbientColor = ambientColor.split(',');
			if (splitedAmbientColor.length === 3) 
			{
				var ar = parseInt(splitedAmbientColor[0]) / 255;
				var ag = parseInt(splitedAmbientColor[1]) / 255;
				var ab = parseInt(splitedAmbientColor[2]) / 255;

				this.sceneState.ambientColor[0] = ar;
				this.sceneState.ambientColor[1] = ag;
				this.sceneState.ambientColor[2] = ab;
			}
		}
	}
	else if (apiName === "changeSsaoRadius")
	{
		var ssaoRadius = api.getSsaoRadius();
		this.magoPolicy.setSsaoRadius(ssaoRadius);
		this.sceneState.ssaoRadius[0] = Number(ssaoRadius);
	}	
	else if (apiName === "changeFPVMode")
	{
		if (api.getFPVMode())
		{
			if (this.cameraFPV._camera !== undefined)	{ return; }

			this.cameraFPV.init();

			 if (this.isCesiumGlobe())
			{
				var scratchLookAtMatrix4 = new Cesium.Matrix4();
				var scratchFlyToBoundingSphereCart4 = new Cesium.Cartesian4();
				var camera = this.scene.camera;

				this.cameraFPV._camera = camera;
				this.cameraFPV._cameraBAK = Cesium.Camera.clone(camera, this.cameraFPV._cameraBAK);
	
				var position = new Cesium.Cartesian3();
				var direction = new Cesium.Cartesian3();
				var up = new Cesium.Cartesian3();
	
				var cameraCartographic = this.scene.globe.ellipsoid.cartesianToCartographic(camera.position);
				cameraCartographic.height = this.scene.globe.getHeight(cameraCartographic) + 1.5;
	
				this.scene.globe.ellipsoid.cartographicToCartesian(cameraCartographic, position);
				var transform = Cesium.Transforms.eastNorthUpToFixedFrame(position, Cesium.Ellipsoid.WGS84, scratchLookAtMatrix4);
				Cesium.Cartesian3.fromCartesian4(Cesium.Matrix4.getColumn(transform, 1, scratchFlyToBoundingSphereCart4), direction);
				Cesium.Cartesian3.fromCartesian4(Cesium.Matrix4.getColumn(transform, 2, scratchFlyToBoundingSphereCart4), up);
	
				camera.flyTo({
					destination : position,
					orientation : {
						direction : direction,
						up        : up
					},
					duration: 1
				});
			}
		}
		else 
		{
			if (this.cameraFPV._cameraBAK === undefined)	{ return; }
			if (this.isCesiumGlobe())
			{
				this.scene.camera = Cesium.Camera.clone(this.cameraFPV._cameraBAK, this.scene.camera);
			}
			this.cameraFPV.release();
		}
	}
	else if (apiName === "changePropertyRendering") 
	{
		var visible = api.getShowShadow();
		var projectId = api.getProjectId();
		var property = api.getProperty();
		var splittedWords = property.split("=");
		var propertyKey = splittedWords[0];
		var propertyValue = splittedWords[1];
		
		if (this.propertyFilterSC === undefined)
		{ this.propertyFilterSC = {}; }
		
		this.propertyFilterSC.visible = visible;
		this.propertyFilterSC.projectId = projectId;
		this.propertyFilterSC.propertyKey = propertyKey;
		this.propertyFilterSC.propertyValue = propertyValue;

	}	
	else if (apiName === "drawAppendData")
	{
		DrawAPI.drawAppendData(api, this);
	}
	else if (apiName === "drawDeleteData")
	{
		this.deleteAll();
	}
	else if (apiName === "clearAllData")
	{
		this.deleteAll();
	}
	else if (apiName === "getDataInfoByDataKey")
	{
		var projectId = api.getProjectId(); // for example : 3ds, collada, ifc, etc.***
		var dataKey = api.getDataKey();
		
		var node = this.hierarchyManager.getNodeByDataKey(projectId, dataKey);
		
		if (node === undefined)
		{
			apiResultCallback( MagoConfig.getPolicy().geo_callback_apiresult, apiName, "-1");
			return;
		}
		
		var dataName = node.data.data_name;
		var geoLocDataManager = node.data.geoLocDataManager;
		
		if (dataName === undefined || geoLocDataManager === undefined)
		{
			apiResultCallback( MagoConfig.getPolicy().geo_callback_apiresult, apiName, "-1");
			return;
		}
		
		var geoLocdata = geoLocDataManager.getCurrentGeoLocationData();
		
		if (geoLocdata === undefined || geoLocdata.geographicCoord === undefined)
		{
			apiResultCallback( MagoConfig.getPolicy().geo_callback_apiresult, apiName, "-1");
			return;
		}
		
		var projectId = node.data.projectId;
		var latitude = geoLocdata.geographicCoord.latitude;
		var longitude = geoLocdata.geographicCoord.longitude;
		var altitude = geoLocdata.geographicCoord.altitude;
		var heading = geoLocdata.heading;
		var pitch = geoLocdata.pitch;
		var roll = geoLocdata.roll;
		
		return {
			projectId : projectId,
			dataKey   : dataKey,
			dataName  : dataName,
			latitude  : latitude,
			longitude : longitude,
			altitude  : altitude,
			heading   : heading,
			pitch     : pitch,
			roll      : roll
		};
	}
	else if (apiName === "gotoProject")
	{
		var projectId = api.getProjectId();
		//if (!this.hierarchyManager.existProject(projectId))
		//{
		//	var projectDataFolder = api.getProjectDataFolder();
		//	this.getObjectIndexFile(projectId, projectDataFolder);
		//}
		
		var nodeMap = this.hierarchyManager.getNodesMap(projectId);
		if (Object.keys(nodeMap).length === 0)
		{
			var projectDataFolder = api.getProjectDataFolder();
			this.getObjectIndexFile(projectId, projectDataFolder);
		}
		
		
		this.flyTo(api.getLongitude(), api.getLatitude(), api.getElevation(), api.getDuration());
	}
	else if (apiName === "gotoIssue")
	{
		var projectId = api.getProjectId();
		if (!this.hierarchyManager.existProject(projectId))
		{
			var projectDataFolder = api.getProjectDataFolder();
			this.getObjectIndexFile(projectId, projectDataFolder);
		}
		
		this.flyTo(api.getLongitude(), api.getLatitude(), api.getElevation(), api.getDuration());
		
		// pin을 그림
		if (api.getIssueId() !== null && api.getIssueType() !== undefined) 
		{
			DrawAPI.drawInsertIssueImage(api, this);
		}
	}
	else if (apiName === "gotoFly")
	{
		this.flyTo(api.getLongitude(), api.getLatitude(), api.getElevation(), api.getDuration());
	}
	else if (apiName === "getCoordinateRelativeToBuilding") 
	{
		var projectId = api.getProjectId();
		var dataKey = api.getDataKey();
		var worldPoint = api.getInputPoint();
		var resultPoint = api.getResultPoint();
		
		if (projectId === undefined || dataKey === undefined || worldPoint === undefined)
		{ return undefined; }
		
		if (resultPoint === undefined)
		{ resultPoint = new Point3D(); }
		
		var node = this.hierarchyManager.getNodeByDataKey(projectId, dataKey);
		
		if (node === undefined)
		{ return undefined; }
		
		var geoLocDataManager = node.data.geoLocDataManager;
		
		if (geoLocDataManager === undefined)
		{ return undefined; }
		
		var geoLocdata = geoLocDataManager.getCurrentGeoLocationData();
		resultPoint = geoLocdata.worldCoordToLocalCoord(worldPoint, resultPoint);
		return resultPoint;
	}
	else if (apiName === "getAbsoluteCoodinateOfBuildingPoint") 
	{
		var projectId = api.getProjectId();
		var dataKey = api.getDataKey();
		var localPoint = api.getInputPoint();
		var resultPoint = api.getResultPoint();
		
		if (projectId === undefined || dataKey === undefined || localPoint === undefined)
		{ return undefined; }
		
		if (resultPoint === undefined)
		{ resultPoint = new Point3D(); }
		
		var node = this.hierarchyManager.getNodeByDataKey(projectId, dataKey);
		
		if (node === undefined)
		{ return undefined; }
		
		var geoLocDataManager = node.data.geoLocDataManager;
		
		if (geoLocDataManager === undefined)
		{ return undefined; }
		
		var geoLocdata = geoLocDataManager.getCurrentGeoLocationData();
		resultPoint = geoLocdata.localCoordToWorldCoord(localPoint, resultPoint);
		return resultPoint;
	}
	else if (apiName === "changeMagoMode") 
	{
		console.log("changeMagoMode");
	}
	else if (apiName === "getCameraCurrentPosition")
	{
		var unit = api.getUnit();
		if (this.isCesiumGlobe())
		{
			var position = this.scene.camera.position;
		
			switch (unit)
			{
			case CODE.units.METRE : return position;
			case CODE.units.RADIAN : return Cesium.Cartographic.fromCartesian(position);
			case CODE.units.DEGREE : {
				var cartographicPosition = Cesium.Cartographic.fromCartesian(position);
				return {
					lat : Cesium.Math.toDegrees(cartographicPosition.latitude),
					lon : Cesium.Math.toDegrees(cartographicPosition.longitude),
					alt : cartographicPosition.height
				};
			}
			}
		}
	}
	else if (apiName === "getCameraCurrentOrientaion")
	{
		if (this.isCesiumGlobe())
		{
			var camera = this.scene.camera;
			if (!camera)
			{
				throw new Error('Camera is broken.');
			}
			return {
				heading : Cesium.Math.toDegrees(camera.heading),
				pitch   : Cesium.Math.toDegrees(camera.pitch),
				roll    : Cesium.Math.toDegrees(camera.roll)
			};
		}
	}
	else if (apiName === "changeCameraOrientation")
	{	
		//수정필요, 카메라가 세슘카메라
		var camera = this.scene.camera;
		var heading = defaultValueCheckLength(api.getHeading(), Cesium.Math.toDegrees(camera.heading));
		var pitch = defaultValueCheckLength(api.getPitch(), Cesium.Math.toDegrees(camera.pitch));
		var roll = defaultValueCheckLength(api.getRoll(), Cesium.Math.toDegrees(camera.roll));
		var duration = defaultValueCheckLength(api.getDuration(), 0);

		if (this.isCesiumGlobe())
		{
			var camera = this.scene.camera;
			if (!camera)
			{
				throw new Error('Camera is broken.');
			}

			camera.flyTo({
				destination : camera.positionWC,
				orientation : {
					heading : Cesium.Math.toRadians(heading),
					pitch   : Cesium.Math.toRadians(pitch),
					roll    : Cesium.Math.toRadians(roll)
				},
				duration: parseInt(duration)
			});
		}
	}
	else if (apiName === "instantiateStaticModel")
	{
		var attributes = api.getInstantiateObj();
		this.instantiateStaticModel(attributes);
	}
	else if (apiName === "addStaticModel")
	{
		var attribute = api.getStaticModelAttributeObj();
		this.addStaticModel(attribute);
	}
	else if (apiName === "setTrackNode")
	{
		var node = this.hierarchyManager.getNodeByDataKey(api.getProjectId(), api.getDataKey());
		if (!defined(node))
		{
			throw new Error("This node is not exist.");
		}

		if (node.isReadyToRender())
		{
			var geoLocDataManager = node.getNodeGeoLocDataManager();
			var geoLocData = geoLocDataManager.getCurrentGeoLocationData();
			var geoCoords = geoLocData.getGeographicCoords();

			var currLon = geoCoords.longitude;
			var currLat = geoCoords.latitude;

			this.flyTo(currLon, currLat, 400, 0);
			var camera = this.sceneState.camera;
			camera.stopTrack(this);
			camera.setTrack(node, api.getTrackOption());
		}
	}
	else if (apiName === "stopTrack")
	{
		this.sceneState.camera.stopTrack(this);
	}
	else if (apiName === "isExistStaticModel")
	{
		return this.isExistStaticModel(api.getProjectId());
	}
	else if (apiName === "isExistData")
	{
		var projectId = api.getProjectId();
		var dataKey = api.getDataKey();
		if (!defined(projectId))
		{
			throw new Error("projectId is required.");
		}
		if (!defined(dataKey))
		{
			throw new Error("dataKey is required.");
		}
		var node = this.hierarchyManager.getNodeByDataKey(projectId, dataKey);
		if (node !== undefined)
		{
			return true;
		}

		return false;
		
	}
	else if (apiName === "isDataReadyToRender")
	{
		var projectId = api.getProjectId();
		var dataKey = api.getDataKey();
		if (!defined(projectId))
		{
			throw new Error("projectId is required.");
		}
		if (!defined(dataKey))
		{
			throw new Error("dataKey is required.");
		}
		var node = this.hierarchyManager.getNodeByDataKey(projectId, dataKey);

		if (node !== undefined)
		{
			if (node.isReadyToRender())
			{
				return true;
			}
		}

		return false;
	}
	else if (apiName === "setNodeAttribute")
	{
		var projectId = api.getProjectId();
		var dataKey = api.getDataKey();
		var attribute = api.getNodeAttribute();
		if (!defined(projectId))
		{
			throw new Error("projectId is required.");
		}
		if (!defined(dataKey))
		{
			throw new Error("dataKey is required.");
		}
		var node = this.hierarchyManager.getNodeByDataKey(projectId, dataKey);

		if (node !== undefined)
		{
			if (node.data) 
			{
				var nodeData = node.data;
				if (!nodeData.attributes) 
				{
					nodeData.attributes = {};
				}
				var myAttribute = nodeData.attributes;

				for (var key in attribute)
				{
					if (attribute.hasOwnProperty(key)) 
					{
						myAttribute[key] = attribute[key];
					}
				}
			}
		}

		return false;
	}
	else if (apiName === 'togglePointCloudColor') 
	{
		var renderingSettings = this._settings.getRenderingSettings();
		var pointsCloudColorRamp = renderingSettings.getPointsCloudInColorRamp();
		renderingSettings.setPointsCloudInColorRamp(!pointsCloudColorRamp);
	}
	else if (apiName === 'selectF4d')
	{
		var projectId = api.getProjectId();
		var dataKey = api.getDataKey();
		if (!defined(projectId))
		{
			throw new Error("projectId is required.");
		}
		if (!defined(dataKey))
		{
			throw new Error("dataKey is required.");
		}
		var node = this.hierarchyManager.getNodeByDataKey(projectId, dataKey);
		if (!node)
		{
			throw new Error("f4d is not exist.");
		}

		this.magoPolicy.setObjectMoveMode(CODE.moveMode.ALL);

		this.nodeSelected = node;
		this.buildingSelected = node.data.neoBuilding;
		this.rootNodeSelected = this.nodeSelected.getRoot();

		this.selectionManager.currentBuildingSelected = this.buildingSelected;
		this.selectionManager.currentNodeSelected = this.nodeSelected;

		this.emit(MagoManager.EVENT_TYPE.SELECTEDF4D, {
			type      : MagoManager.EVENT_TYPE.SELECTEDF4D, 
			f4d       : node, 
			timestamp : new Date()
		});
	}
};

MagoManager.prototype.deleteAll = function ()
{
	// deselect.
	this.selectionManager.clearCandidates();
	this.selectionManager.clearCurrents();
	this.objectSelected = undefined;
	this.octreeSelected = undefined;
	this.buildingSelected = undefined;
	this.nodeSelected = undefined;
	
	// erase from processQueue and parseQueue. 
	this.parseQueue.clearAll();
	this.processQueue.clearAll();
	
	// clear current visibles.
	if (this.visibleObjControlerBuildings)
	{ this.visibleObjControlerBuildings.clear(); }
	if (this.visibleObjControlerNodes)
	{ this.visibleObjControlerNodes.clear(); }
	if (this.visibleObjControlerOctrees)
	{ this.visibleObjControlerOctrees.clear(); }
	
	// reset tiles.
	this.smartTileManager.resetTiles();
	
	// finally delete nodes.
	this.hierarchyManager.deleteNodes(this.sceneState.gl, this.vboMemoryManager);
};

MagoManager.prototype.checkCollision = function (position, direction)
{
	var gl = this.sceneState.gl;
	if (gl === undefined)	{ return; }

	var posX = this.sceneState.drawingBufferWidth * 0.5;
	var posY = this.sceneState.drawingBufferHeight * 0.5;
	
	var objects = this.getSelectedObjects(gl, posX, posY, this.arrayAuxSC);
	if (objects === undefined)	{ return; }

	var current_building = this.buildingSelected;
	this.buildingSelected = this.arrayAuxSC[0];

	var collisionPosition = new Point3D();
	var bottomPosition = new Point3D();

	ManagerUtils.calculatePixelPositionWorldCoord(gl, posX, posY, collisionPosition, undefined, undefined, undefined, this);
	this.swapRenderingFase();
	ManagerUtils.calculatePixelPositionWorldCoord(gl, posX, this.sceneState.drawingBufferHeight, undefined, undefined, undefined, this);

	this.buildingSelected = current_building;
	var distance = collisionPosition.squareDistTo(position.x, position.y, position.z);
	this.swapRenderingFase();

	if (distance > 3.5)
	{
		var bottomPositionCartographic = this.scene.globe.ellipsoid.cartesianToCartographic(bottomPosition);
		var currentPositionCartographic = this.scene.globe.ellipsoid.cartesianToCartographic(position);
		var currentHeight = currentPositionCartographic.height;
		var bottomHeight = bottomPositionCartographic.height + 1.5;
	
		if ( bottomHeight < currentHeight )
		{
			currentHeight -= 0.2;
		}
	
		if ( bottomHeight > currentHeight || 
			(bottomHeight < currentHeight && currentHeight - bottomHeight > 1.5))
		{
			currentHeight = bottomHeight;
		}
		var tmpLat = Cesium.Math.toDegrees(currentPositionCartographic.latitude);
		var tmpLon = Cesium.Math.toDegrees(currentPositionCartographic.longitude);
		
		this.cameraFPV.camera.position = Cesium.Cartesian3.fromDegrees(tmpLon, tmpLat, currentHeight);

		return false; 
	}

	return true;
};

'use strict';

/**
 * Factory method 패턴을 사용해서 cesium, worldwind 등을 wrapping 해 주는 클래스
 * @class ManagerFactory
 *
 * @param viewer 타 시스템과의 연동의 경우 view 객체가 생성되어서 넘어 오는 경우가 있음
 * @param containerId 뷰에서 표시할 위치 id
 * @param serverPolicy policy json object
 * @param projectIdArray json object map에 저장하기 위한 key
 * @param projectDataArray data json object
 * @param projectDataFolderArray f4d data folder path
 * @param imagePath 이미지 경로
 * @param options View 생성을 위한 기타 옵션
 * @returns api
 */
var ManagerFactory = function(viewer, containerId, serverPolicy, projectIdArray, projectDataArray, projectDataFolderArray, imagePath, options) 
{
	if (!(this instanceof ManagerFactory)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	var magoManager = null;
	var scene = null;
	var magoManagerState = CODE.magoManagerState.INIT;
	var _options = options || {};
	_options.animation = _options.animation || false;
	_options.timeline = _options.timeline || false;

	// 환경 설정
	MagoConfig.init(serverPolicy, projectIdArray, projectDataArray);
	
	// 카메라 행동 설정
	function disableCameraMotion(state)
	{
		viewer.scene.screenSpaceCameraController.enableRotate = state;
		viewer.scene.screenSpaceCameraController.enableZoom = state;
		viewer.scene.screenSpaceCameraController.enableLook = state;
		viewer.scene.screenSpaceCameraController.enableTilt = state;
		viewer.scene.screenSpaceCameraController.enableTranslate = state;
	}
	
	// 이벤트 확장
	function addMouseAction() 
	{
		magoManager.handler.setInputAction(function(click) 
		{
			magoManager.mouseActionLeftDown(click.position.x, click.position.y);
		}, Cesium.ScreenSpaceEventType.LEFT_DOWN);

		magoManager.handler.setInputAction(function(click) 
		{
			magoManager.mouseActionMiddleDown(click.position.x, click.position.y);
		}, Cesium.ScreenSpaceEventType.MIDDLE_DOWN);
		
		magoManager.handler.setInputAction(function(click) 
		{
			magoManager.mouseActionRightDown(click.position.x, click.position.y);
		}, Cesium.ScreenSpaceEventType.RIGHT_DOWN);

		//var mousePosition;
		magoManager.handler.setInputAction(function(movement) 
		{
			//magoManager.mouseActionMove(movement.endPosition.x, movement.endPosition.y);
			//mousePosition = movement.endPosition;
			if (magoManager.mouseLeftDown) 
			{
				if (movement.startPosition.x !== movement.endPosition.x || movement.startPosition.y !== movement.endPosition.y) 
				{
					magoManager.manageMouseDragging(movement.startPosition.x, movement.startPosition.y);
					magoManager.cameraMoved();
				}
			}
			else
			{
				magoManager.mouseDragging = false;
				disableCameraMotion(true);
				if (magoManager.mouseMiddleDown || magoManager.mouseRightDown)
				{
					magoManager.isCameraMoving = true;
					magoManager.cameraMoved();
				}
			}
			
		}, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

		magoManager.handler.setInputAction(function(movement) 
		{
			magoManager.mouseActionLeftUp(movement.position.x, movement.position.y);
			// display current mouse position
			var pickPosition = {lat: null, lon: null, alt: null};
			var position = magoManager.scene.camera.pickEllipsoid(movement.position);
			if (position)
			{
				var cartographicPosition = Cesium.Cartographic.fromCartesian(position);
				pickPosition.lat = Cesium.Math.toDegrees(cartographicPosition.latitude);
				pickPosition.lon = Cesium.Math.toDegrees(cartographicPosition.longitude);
				pickPosition.alt = cartographicPosition.height;
			}
			if (MagoConfig.getPolicy().geo_callback_enable === "true") 
			{
				if (serverPolicy.geo_callback_clickposition !== '') 
				{
					clickPositionCallback(serverPolicy.geo_callback_clickposition, pickPosition);
				}
			}
	    }, Cesium.ScreenSpaceEventType.LEFT_UP);

		magoManager.handler.setInputAction(function(movement) 
		{
			magoManager.mouseActionMiddleUp(movement.position.x, movement.position.y);
	    }, Cesium.ScreenSpaceEventType.MIDDLE_UP);
		
		magoManager.handler.setInputAction(function(movement) 
		{
			magoManager.mouseActionRightUp(movement.position.x, movement.position.y);
	    }, Cesium.ScreenSpaceEventType.RIGHT_UP);
		
		magoManager.handler.setInputAction(function(movement) 
		{
			magoManager.mouseActionLeftClick(movement.position.x, movement.position.y);
	    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
	}

	// cesium을 구현체로서 이용
	function drawCesium() 
	{
		var gl = viewer.scene.context._gl;
		//viewer.scene.magoManager.selection.init(gl, viewer.scene.drawingBufferWidth, viewer.scene.drawingBufferHeight);
		viewer.scene.magoManager.postFxShadersManager.gl = gl;
		viewer.scene.magoManager.postFxShadersManager.createDefaultShaders(gl); // A1-OLD.***
		viewer.scene.magoManager.createDefaultShaders(gl);// A1-Use this.***
		viewer.scene.magoManager.scene = viewer.scene;

		// Start postRender version.***********************************************
		magoManager = viewer.scene.magoManager;
		scene = viewer.scene;
		//scene.copyGlobeDepth = true;
		viewer.scene.globe.depthTestAgainstTerrain = true;
		viewer.scene.logarithmicDepthBuffer = false; //do not use logarithmic buffer
		viewer.scene.highDynamicRange = false; //do not use high dynamic range
		// object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
		//viewer.scene.magoManager.getObjectIndexFile();
		if (projectIdArray !== null && projectIdArray.length > 0) 
		{
			for (var i=0; i<projectIdArray.length; i++) 
			{
				var projectDataFolder = projectDataFolderArray[i];
				var projectData = projectDataArray[i];
				if (!(projectData.data_key === projectDataFolder && projectData.attributes.isReference))
				{
					viewer.scene.magoManager.getObjectIndexFile(projectIdArray[i], projectDataFolder);
				}
			}
		}
		if (serverPolicy.geo_tile_path && serverPolicy.geo_tile_path !== "") 
		{
			viewer.scene.magoManager.getObjectIndexFileSmartTileF4d(serverPolicy.geo_tile_path);
		}

		viewer.scene.magoManager.handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);
		addMouseAction();
		viewer.clock.onTick.addEventListener(function(clock) 
		{
			magoManager.cameraFPV.update(magoManager);
		});

		viewer.camera.changed.addEventListener(function(e)
		{
			magoManager.cameraChanged(e);
		});
		viewer.camera.moveEnd.addEventListener(function(e)
		{
			magoManager.cameraMoveEnd(e);
		});
		viewer.camera.moveStart.addEventListener(function(e)
		{
			magoManager.cameraMoveStart(e);
		});
	}
	
	// magoworld을 구현체로서 이용
	function drawMagoWorld() 
	{
		var gl = viewer.magoManager.sceneState.gl;
		var manager = viewer.magoManager;
		manager.vboMemoryManager.gl = gl;
		manager.postFxShadersManager.gl = gl;
		manager.postFxShadersManager.createDefaultShaders(gl); // A1-OLD.***
		manager.createDefaultShaders(gl);// A1-Use this.***
		//viewer.renderTest();
	};

	// 실제 화면에 object를 rendering 하는 메인 메서드
	function draw() 
	{
		if (MagoConfig.getPolicy().basicGlobe === Constant.CESIUM) 
		{
			drawCesium();
		}
		else if (MagoConfig.getPolicy().basicGlobe === Constant.MAGOWORLD) 
		{
			drawMagoWorld();
		}
	}

	/**
	 * add Layers
	 */
	function addImageryLayers() 
	{
		var provider = new Cesium.WebMapServiceImageryProvider({
			url        : MagoConfig.getPolicy().geo_server_add_url,
			layers     : MagoConfig.getPolicy().geo_server_add_layers,
			parameters : {
				service     : MagoConfig.getPolicy().geo_server_add_parameters_service,
				version     : MagoConfig.getPolicy().geo_server_add_parameters_version,
				request     : MagoConfig.getPolicy().geo_server_add_parameters_request,
				transparent : MagoConfig.getPolicy().geo_server_add_parameters_transparent,
				//tiled : MagoConfig.getPolicy().backgroundProvider.parameters.tiled,
				format      : MagoConfig.getPolicy().geo_server_add_parameters_format
				//				time : MagoConfig.getPolicy().backgroundProvider.parameters.time,
				//		    	rand : MagoConfig.getPolicy().backgroundProvider.parameters.rand,
				//		    	asdf : MagoConfig.getPolicy().backgroundProvider.parameters.asdf
			}
			//,proxy: new Cesium.DefaultProxy('/proxy/')
		});

		//		if(index) viewer.imageryLayers.addImageryProvider(provider, index);
		viewer.imageryLayers.addImageryProvider(provider);
	}

	/**
	 * zoomTo 할 Entity
	 * @returns entities
	 */
	function initEntity() 
	{
		return viewer.entities.add({
			name     : "mago3D",
			position : Cesium.Cartesian3.fromDegrees(37.521168, 126.924185, 3000.0),
			box      : {
				dimensions : new Cesium.Cartesian3(300000.0*1000.0, 300000.0*1000.0, 300000.0*1000.0), // dimensions : new Cesium.Cartesian3(400000.0, 300000.0, 500000.0),
				fill       : true,
				material   : Cesium.Color.BLUE,
				outline    : false
			}
		});
	}

	// terrain 적용 유무를 설정
	function initTerrain() 
	{
		/*		if(MagoConfig.getPolicy().geoConfig.initTerrain.enable) {
			var terrainProvider = new Cesium.CesiumTerrainProvider({
				url : MagoConfig.getPolicy().geoConfig.initTerrain.url,
				requestWaterMask: MagoConfig.getPolicy().geoConfig.initTerrain.requestWaterMask,
				requestVertexNormals: MagoConfig.getPolicy().geoConfig.initTerrain.requestVertexNormals
			});
			viewer.terrainProvider = terrainProvider;
		}*/
	}

	// 최초 로딩시 이동할 카메라 위치
	function initCamera() 
	{
		viewer.camera.flyTo({
			destination: Cesium.Cartesian3.fromDegrees(parseFloat(MagoConfig.getPolicy().initLatitude),
				parseFloat(MagoConfig.getPolicy().initLongitude),
				parseFloat(MagoConfig.getPolicy().initHeight)),
			duration: parseInt(MagoConfig.getPolicy().initDuration)
		});
	}

	// deploy 타입 적용
	function initRenderMode() 
	{
		var api = new API("renderMode");
		magoManager.callAPI(api);

		// if (MagoConfig.getPolicy().geo_time_line_enable === "false") 
		// {
		// 	// visible <---> hidden
		// 	$(viewer._animation.container).css("visibility", "hidden");
		// 	$(viewer._timeline.container).css("visibility", "hidden");
		// 	viewer.forceResize();
		// }
	}
	
	var DEFALUT_IMAGE = "ESRI World Imagery";
	var DEFALUT_TERRAIN = "WGS84 Ellipsoid";
	
	// pick baseLayer
	function setDefaultDataset() 
	{
		// WGS84 Ellipsoide
		if (MagoConfig.getPolicy().initDefaultTerrain !== null && MagoConfig.getPolicy().initDefaultTerrain !== "") 
		{
			DEFALUT_TERRAIN = MagoConfig.getPolicy().initDefaultTerrain;
		}
		
		if (viewer === undefined || viewer.baseLayerPicker === undefined)  { return; }

		// search default imageryProvider from baseLayerPicker
		var imageryProvider = null;
		var imageryProviderViewModels = viewer.baseLayerPicker.viewModel.imageryProviderViewModels; 
		for (var i in imageryProviderViewModels) 
		{
			if (!imageryProviderViewModels.hasOwnProperty(i))	{ continue; }

			var provider = imageryProviderViewModels[i];
			if (provider.name === DEFALUT_IMAGE) 
			{
				imageryProvider = provider;
				break;
			}
		}
		if (imageryProvider) { viewer.baseLayerPicker.viewModel.selectedImagery = imageryProvider; }
	  
		// search default terrainProvider from baseLayerPicker
		var terrainProvider = null;
		var terrainProviderViewModels = viewer.baseLayerPicker.viewModel.terrainProviderViewModels;
		for (var i in terrainProviderViewModels) 
		{
			if (!terrainProviderViewModels.hasOwnProperty(i))	{ continue; }
			var provider = terrainProviderViewModels[i];
			if (provider.name === DEFALUT_TERRAIN) 
			{
				terrainProvider = provider;
				break;
			}
		}
		if (terrainProvider) { viewer.baseLayerPicker.viewModel.selectedTerrain = terrainProvider; }
	}


	//start
	if (serverPolicy.basicGlobe === null ||
		serverPolicy.basicGlobe === '' ||
		serverPolicy.basicGlobe === Constant.CESIUM) 
	{
		// webgl lost events.******************************************
		var canvas = document.getElementById(containerId);
		canvas.addEventListener('webglcontextlost', function(e) 
		{
			console.log(e);
		}, false);
		
		canvas.addEventListener('webglcontextrestored', function(e) 
		{
		  console.log(e); 
		}, false);
		
		
		//-------------------------------------------------------------
		
		if (serverPolicy.geo_server_enable === "true" && serverPolicy.geo_server_url !== null && serverPolicy.geo_server_url !== '') 
		{
			var imageryProvider = new Cesium.WebMapServiceImageryProvider({
				url        : serverPolicy.geo_server_url,
				layers     : serverPolicy.geo_server_layers,
				parameters : {
					service     : serverPolicy.geo_server_parameters_service,
					version     : serverPolicy.geo_server_parameters_version,
					request     : serverPolicy.geo_server_parameters_request,
					transparent : serverPolicy.geo_server_parameters_transparent,
					format      : serverPolicy.geo_server_parameters_format
				},
				enablePickFeatures: false//,
				//proxy: new Cesium.DefaultProxy('/proxy/')
			});
			// var options = {imageryProvider: imageryProvider, baseLayerPicker: false};
			_options.imageryProvider = imageryProvider;
			_options.baseLayerPicker = false;
			_options.antialias = true;
			if (viewer === null) { viewer = new Cesium.Viewer(containerId, _options); }
		}
		else 
		{
			if (serverPolicy.cesiumIonToken !== null && serverPolicy.cesiumIonToken !== "") 
			{
				Cesium.Ion.defaultAccessToken = serverPolicy.cesiumIonToken;
				DEFALUT_TERRAIN = "Cesium World Terrain";
			}
			_options.shouldAnimate = true;
			
			if (viewer === null) { viewer = new Cesium.Viewer(containerId, _options); }
			// 기본 지도 설정
			setDefaultDataset();
		}
			
		viewer.scene.magoManager = new MagoManager();
		viewer.scene.magoManager.sceneState.textureFlipYAxis = false;
		viewer.camera.frustum.fov = Cesium.Math.PI_OVER_THREE*1.8;
		if (MagoConfig.getPolicy().initDefaultFov > 0) 
		{
			viewer.camera.frustum.fov = Cesium.Math.PI_OVER_THREE * MagoConfig.getPolicy().initDefaultFov;
		}

		// Layers 추가 적용
		if (serverPolicy.geo_server_enable === "true" && serverPolicy.geo_server_add_url !== null && serverPolicy.geo_server_add_url !== '') 
		{ 
			addImageryLayers(); 
		}
			
		draw();
		// build을 rendering 할 위치
		initEntity();
		// terrain 적용 여부
		/*if() {
				initTerrain();
			}*/
		// 최초 로딩시 카메라 이동 여부
		if (serverPolicy.initCameraEnable) { initCamera(); }
		// render Mode 적용
		initRenderMode();
	}
	else if (serverPolicy.geo_view_library === Constant.MAGOWORLD) 
	{
		var canvas = document.getElementById(containerId);
		var glAttrs = {antialias          : true, 
			stencil            : true,
			premultipliedAlpha : false};
		var gl = canvas.getContext("webgl", glAttrs);
		if (!gl)
		{ gl = canvas.getContext("experimental-webgl", glAttrs); }
		
		// Problem: canvas-width initially is 300 and canvas-height = 150.***
		canvas.width = canvas.clientWidth;
		canvas.height = canvas.clientHeight;
		
		magoManager = new MagoManager();
		var sceneState = magoManager.sceneState;
		sceneState.textureFlipYAxis = false;
		sceneState.gl = gl;
		sceneState.drawingBufferWidth[0] = canvas.clientWidth;
		sceneState.drawingBufferHeight[0] = canvas.clientHeight;
		sceneState.camera.frustum.aspectRatio[0] = canvas.clientWidth/canvas.clientHeight;
		sceneState.camera.frustum.fovRad[0] = Math.PI/3*1.8;
		sceneState.camera.frustum.fovyRad[0] = sceneState.camera.frustum.fovRad[0]/sceneState.camera.frustum.aspectRatio;
		sceneState.camera.frustum.tangentOfHalfFovy[0] = Math.tan(sceneState.camera.frustum.fovyRad[0]/2);
		
		// initial camera position.***
		sceneState.camera.position.set(-7586937.743019165, 10881859.054284709, 5648264.99911627);
		sceneState.camera.direction.set(0.5307589970384617, -0.7598419113077192, -0.3754132585133587);
		sceneState.camera.up.set(0.23477224008249162, -0.29380469331271475, 0.9265855321012102);
		
		// test init camera position.***
		//sphere.r = 6378137.0;
		sceneState.encodedCamPosHigh[0] = -7536640;
		sceneState.encodedCamPosHigh[1] = 10878976;
		sceneState.encodedCamPosHigh[2] = 5636096;
		
		sceneState.encodedCamPosLow[0] = -50297.7421875;
		sceneState.encodedCamPosLow[1] = 2883.05419921875;
		sceneState.encodedCamPosLow[2] = 12168.9990234375;

		
		viewer = new MagoWorld(magoManager);
		magoManager.magoWorld = viewer;
		magoManager.globe = new Globe();
		// init matrices.***
		viewer.updateModelViewMatrixByCamera(sceneState.camera);
		//magoManager.upDateSceneStateMatrices(sceneState);
		
		// Create the tinTerrains(MagoEarth).***
		magoManager.tinTerrainManager = new TinTerrainManager();
		
		// event listener.***
		canvas.addEventListener('mousedown', function(event)
		{
			viewer.mousedown(event);			
		}, false);
		
		canvas.addEventListener('mouseup', function(event)
		{
			viewer.mouseup(event);			
		}, false);
		
		canvas.addEventListener('mousewheel', function(event)
		{
			viewer.mousewheel(event); 
		}, false);
		
		canvas.addEventListener('mousemove', function(event)
		{
			viewer.mousemove(event);
		}, false);
		
		canvas.addEventListener('click', function(event)
		{
			viewer.mouseclick(event);
		}, false);
		
		canvas.addEventListener('resize', function(event)
		{
			// TODO:
			console.log("resize");
		}, false);
		
		canvas.addEventListener('keydown', function(event) // no works.***
		{
			viewer.keydown(event); // no works.***
		}, false);

		
		draw();
	}

	// 이미지 경로
	magoManager.magoPolicy.imagePath = imagePath;
	magoManagerState = CODE.magoManagerState.READY;

	// KeyPressEvents.**************************************
	document.addEventListener('keydown', function(event) 
	{
		// get current building selected
		if (magoManager.magoPolicy.issueInsertEnable)	{ return; }
		
		magoManager.keyDown(event.keyCode);

		var selectedBuilding = magoManager.buildingSelected;	
		if (selectedBuilding === undefined) 	{ return; }

		var nodeSelected = magoManager.selectionManager.currentNodeSelected;
		if (nodeSelected === undefined)
		{ return; }
		var rootNodeSelected = nodeSelected.getRoot();
		var geoLocationData = rootNodeSelected.data.geoLocDataManager.getCurrentGeoLocationData();
		if (geoLocationData === undefined)		{ return; }

		if (magoManager.magoPolicy.objectMoveMode === CODE.moveMode.ALL)
		{
			var increDeg = 3.0;
			var currentHeading = geoLocationData.heading || 0;
			var currentPitch = geoLocationData.pitch || 0;
			var currentRoll = geoLocationData.roll || 0;
			
			var increDist = 0.2;
			var currentAlt = geoLocationData.geographicCoord.altitude || 0;
			var displayData = false;
			
			// For Heading
			if (event.keyCode === 'Q'.charCodeAt(0))
			{
				currentHeading += increDeg;
				displayData = true;
			}
			else if (event.keyCode === 'A'.charCodeAt(0))
			{
				currentHeading -= increDeg;
				displayData = true;
			}
			
			// For Pitch
			if (event.keyCode === 'W'.charCodeAt(0))
			{
				currentPitch += increDeg;
				displayData = true;
			}
			else if (event.keyCode === 'S'.charCodeAt(0))
			{
				currentPitch -= increDeg;
				displayData = true;
			}

			// For Roll
			if (event.keyCode === 'E'.charCodeAt(0))
			{
				currentRoll += increDeg;
				displayData = true;
			}
			else if (event.keyCode === 'D'.charCodeAt(0))
			{
				currentRoll -= increDeg;
				displayData = true;
			}
			
			// For Altitude
			if (event.keyCode === 'Z'.charCodeAt(0))
			{
				currentAlt += increDist;
				displayData = true;
			}
			else if (event.keyCode === 'X'.charCodeAt(0))
			{
				currentAlt -= increDist;
				displayData = true;
			}
			
			

			if (displayData)
			{
				magoManager.changeLocationAndRotationNode(nodeSelected, geoLocationData.geographicCoord.latitude, geoLocationData.geographicCoord.longitude, 
					currentAlt, currentHeading, currentPitch, currentRoll); 
			}
		}

	}, false);
	
	// TODO API 객체를 생성해서 하나의 parameter로 전달하는 방식이 좀 더 깔끔할거 같지만 성능적인 부분에서 조금은 투박할거 같아서 일단 이렇게 처리
	return {
		// api gateway 역할
		callAPI: function(api) 
		{
		    if (api.getReturnable()) 
			{
		        return magoManager.callAPI(api);
			}
			else 
			{
				magoManager.callAPI(api);
			}
		},
		// flyTo: function(issueId, issueType, longitude, latitude, height, duration)
		// {
		// 	if (MagoConfig.getPolicy().geo_view_library === Constant.CESIUM)
		// 	{
		// 		viewer.camera.flyTo({
		// 			destination: Cesium.Cartesian3.fromDegrees(parseFloat(longitude),
		// 				parseFloat(latitude),
		// 				parseFloat(height) + 10),
		// 			duration: parseInt(duration)
		// 		});
		// 	}
		// 	else
		// 	{
		// 		wwd.goToAnimator.travelTime = duration * 1000;
		// 		wwd.goTo(new WorldWind.Position(parseFloat(latitude), parseFloat(longitude), parseFloat(height) + 50));
		// 	}
		// 	// pin을 그림
		// 	if (issueId !== null && issueType !== undefined)
		// 	{
		// 		var api = new API("drawInsertIssueImage");
		// 		api.setDrawType(0);
		// 		api.setIssueId(issueId);
		// 		api.setIssueType(issueType);
		// 		api.setDataKey(null);
		// 		api.setLatitude(latitude);
		// 		api.setLongitude(longitude);
		// 		api.setElevation(height);
		// 		magoManager.callAPI(api);
		// 	}
		// },
		// magoManager 상태
		getViewer: function()
		{
			return viewer;
		},
		getMagoManagerState: function() 
		{
			return magoManagerState;
		},
		getMagoManager: function() 
		{
			return magoManager;
		}
	};
};

'use strict';


/**
 * 열우선 배열 방식의 4차원 행렬
 *
 */
var Matrix4 = function() 
{
	if (!(this instanceof Matrix4)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * @type {Float32Array}
	 */
	this._floatArrays = new Float32Array([ 1, 0, 0, 0,
										   0, 1, 0, 0,
										   0, 0, 1, 0,
										   0, 0, 0, 1]);
};

/**
 * 단위행렬로 설정한다.
 */
Matrix4.prototype.Identity = function() 
{
	this._floatArrays[0] = 1.0;		// I(1,1)
	this._floatArrays[1] = 0.0;		// I(2,1)
	this._floatArrays[2] = 0.0;		// I(3,1)
	this._floatArrays[3] = 0.0;		// I(4,1)
	
	this._floatArrays[4] = 0.0;		// I(1,2)
	this._floatArrays[5] = 1.0;		// I(2,2)
	this._floatArrays[6] = 0.0;		// I(3,2)
	this._floatArrays[7] = 0.0;		// I(4,2)
	
	this._floatArrays[8] = 0.0;		// I(1,3)
	this._floatArrays[9] = 0.0;		// I(2,3)
	this._floatArrays[10] = 1.0;	// I(3,3)
	this._floatArrays[11] = 0.0;	// I(4,3)
	
	this._floatArrays[12] = 0.0;	// I(1,4)
	this._floatArrays[13] = 0.0;	// I(2,4)
	this._floatArrays[14] = 0.0;	// I(3,4)
	this._floatArrays[15] = 1.0;	// I(4,4)
};


/**
 * 행렬 정보 삭제
 */
Matrix4.prototype.deleteObjects = function() 
{
	this._floatArrays = undefined;
};


/**
 * 행우선 배열 방식의 4차원 행렬을 제공한다.
 *
 * @returns {Float32Array} 행우선 4차원 행렬
 * 
 * @see Matrix4#get
 */
Matrix4.prototype.getRowMajorMatrix = function() 
{
	var rowMajor_matrix = new Float32Array(16);

	rowMajor_matrix[0] = this.get(0, 0);
	rowMajor_matrix[1] = this.get(1, 0);
	rowMajor_matrix[2] = this.get(2, 0);
	rowMajor_matrix[3] = this.get(3, 0);

	rowMajor_matrix[4] = this.get(0, 1);
	rowMajor_matrix[5] = this.get(1, 1);
	rowMajor_matrix[6] = this.get(2, 1);
	rowMajor_matrix[7] = this.get(3, 1);

	rowMajor_matrix[8] = this.get(0, 2);
	rowMajor_matrix[9] = this.get(1, 2);
	rowMajor_matrix[10] = this.get(2, 2);
	rowMajor_matrix[11] = this.get(3, 2);

	rowMajor_matrix[12] = this.get(0, 3);
	rowMajor_matrix[13] = this.get(1, 3);
	rowMajor_matrix[14] = this.get(2, 3);
	rowMajor_matrix[15] = this.get(3, 3);

	return rowMajor_matrix;
};

/**
 * XYZ축에 대한 회전양에 따라 회전된 4차원 행렬을 구한다.
 *
 * @param {Number} zRotDeg z축에 대한 회전양(Degree)
 * @param {Number} xRotDeg x축에 대한 회전양(Degree)
 * @param {Number} yRotDeg y축에 대한 회전양(Degree)
 * @param {Matrix4} result 회전된 4차원 행렬
 * @returns {Matrix4} 회전된 4차원 행렬
 * 
 * @see Matrix4#rotationAxisAngDeg
 * @see Matrix4#getMultipliedByMatrix
 */
Matrix4.getRotationDegZXYMatrix = function(zRotDeg, xRotDeg, yRotDeg, result) 
{
	// created as identity matrix.
	if (result === undefined)
	{
		result = new Matrix4();
	}

	var xRotMatrix = new Matrix4();  // created as identity matrix.
	var yRotMatrix = new Matrix4();  // created as identity matrix.
	var zRotMatrix = new Matrix4();  // created as identity matrix.
	
	
	if (xRotDeg !== undefined && xRotDeg !== 0)
	{ xRotMatrix.rotationAxisAngDeg(xRotDeg, 1.0, 0.0, 0.0); }
	
	if (yRotDeg !== undefined && yRotDeg !== 0)
	{ yRotMatrix.rotationAxisAngDeg(yRotDeg, 0.0, 1.0, 0.0); }
	
	if (zRotDeg !== undefined && zRotDeg !== 0)
	{ zRotMatrix.rotationAxisAngDeg(zRotDeg, 0.0, 0.0, 1.0); }

	var zRotatedTMatrix;
	var zxRotatedTMatrix;
	var zxyRotatedTMatrix;

	zRotatedTMatrix = zRotMatrix;
	zxRotatedTMatrix = xRotMatrix.getMultipliedByMatrix(zRotatedTMatrix, zxRotatedTMatrix);
	zxyRotatedTMatrix = yRotMatrix.getMultipliedByMatrix(zxRotatedTMatrix, zxyRotatedTMatrix);
	
	result = zxyRotatedTMatrix;

	return result;
};

/**
 * 좌표값과 회전양을 통해 회전된 4차원 행렬을 구한다.
 *
 * @param {Number} angDeg 회전양(Degree)
 * @param {Number} axis_x X축 좌표
 * @param {Number} axis_y Y축 좌표
 * @param {Number} axis_z Z축 좌표
 * 
 * @see Quaternion
 * @see Quaternion#rotationAngDeg
 * @see Matrix4#rotationByQuaternion
 */
Matrix4.prototype.rotationAxisAngDeg = function(angDeg, axis_x, axis_y, axis_z) 
{
	var quaternion = new Quaternion();
	quaternion.rotationAngDeg(angDeg, axis_x, axis_y, axis_z);
	this.rotationByQuaternion(quaternion);
	quaternion = undefined;
};

/**
 * 좌표값과 회전양을 통해 회전된 4차원 행렬을 구한다.
 *
 * @param {Number} angRad 회전양(Radian)
 * @param {Number} axis_x X축 좌표
 * @param {Number} axis_y Y축 좌표
 * @param {Number} axis_z Z축 좌표
 * 
 * @see Quaternion
 * @see Quaternion#rotationAngRad
 * @see Matrix4#rotationByQuaternion
 */
Matrix4.prototype.rotationAxisAngRad = function(angRad, axis_x, axis_y, axis_z) 
{
	var quaternion = new Quaternion();
	quaternion.rotationAngRad(angRad, axis_x, axis_y, axis_z);
	this.rotationByQuaternion(quaternion);
	quaternion = undefined;
};

/**
 * 쿼터니언(사원수)을 통한 회전된 4차원 행렬을 구한다.
 *
 * @param {Quaternion} quaternion 사원수
 */
Matrix4.prototype.rotationByQuaternion = function(quaternion) 
{
	var x = quaternion.x;
	var y = quaternion.y;
	var z = quaternion.z;
	var w = quaternion.w;

	this._floatArrays[this.getIndexOfArray(0, 0)] = 1 - 2*y*y - 2*z*z;
	this._floatArrays[this.getIndexOfArray(0, 1)] = 2*x*y + 2*z*w;
	this._floatArrays[this.getIndexOfArray(0, 2)] = 2*x*z - 2*y*w;
	this._floatArrays[this.getIndexOfArray(0, 3)] = 0.0;

	this._floatArrays[this.getIndexOfArray(1, 0)] = 2*x*y - 2*z*w;
	this._floatArrays[this.getIndexOfArray(1, 1)] = 1 - 2*x*x - 2*z*z;
	this._floatArrays[this.getIndexOfArray(1, 2)] = 2*y*z + 2*x*w;
	this._floatArrays[this.getIndexOfArray(1, 3)] = 0.0;

	this._floatArrays[this.getIndexOfArray(2, 0)] = 2*x*z + 2*y*w;
	this._floatArrays[this.getIndexOfArray(2, 1)] = 2*y*z - 2*x*w;
	this._floatArrays[this.getIndexOfArray(2, 2)] = 1 - 2*x*x - 2*y*y;
	this._floatArrays[this.getIndexOfArray(2, 3)] = 0.0;

	this._floatArrays[this.getIndexOfArray(3, 0)] = 0.0;
	this._floatArrays[this.getIndexOfArray(3, 1)] = 0.0;
	this._floatArrays[this.getIndexOfArray(3, 2)] = 0.0;
	this._floatArrays[this.getIndexOfArray(3, 3)] = 1.0;
};

/**
 * Float32 형식의 4차원 행렬로 행렬값을 설정한다.
 *
 * @param {Float32Array} float32array
 */
Matrix4.prototype.setByFloat32Array = function(float32array) 
{
	for (var i=0; i<16; i++) 
	{
		this._floatArrays[i] = float32array[i];
	}
};

/**
 * 열우선 방식으로 행렬의 인덱스값을 계산한다.
 * 
 * @param {Number} col 열의 위치
 * @param {Number} row 행의 위치
 * @returns {Number} 행렬의 인덱스
 */
Matrix4.prototype.getIndexOfArray = function(col, row) 
{
	var _col = col || 0;
	var _row = row || 0;

	return 4 * _col + _row;
};

/**
 * 지정된 행/열의 위치에 있는 값을 구한다.
 *
 * @param {Number} col 열의 위치
 * @param {Number} row 행의 위치
 * @returns {Number} 행렬값
 */
Matrix4.prototype.get = function(col, row) 
{
	return this._floatArrays[this.getIndexOfArray(col, row)];
};

/**
 * XYZ축으로 이동한다.
 *
 * @param {Number} x X축 이동량
 * @param {Number} y Y축 이동량
 * @param {Number} z Z축 이동량
 */
Matrix4.prototype.setTranslation = function(x, y, z) 
{
	this.set(3, 0, x);
	this.set(3, 1, y);
	this.set(3, 2, z);
};


/**
 * 4차원 행렬의 특정 위치의 값을 설정한다.
 *
 * @param {Number} col 열의 위치
 * @param {Number} row 행의 위치
 * @param {Number} value 설정값
 */
Matrix4.prototype.set = function(col, row, value) 
{
	this._floatArrays[this.getIndexOfArray(col, row)] = value;
};

/**
 * 행렬연산을 통해 주어진 포인트를 이동한다.
 *
 * @param {Point3D} point3d 입력 포인트
 * @param {Point3D} result 출력 포인트
 * @returns {Point3D} 출력 포인트
 */
Matrix4.prototype.transformPoint3D = function(point3d, result) 
{
	if (result === undefined) { result = new Point3D(); }

	var x = point3d.x;
	var y = point3d.y;
	var z = point3d.z;

	result.x = x*this.get(0, 0) + y*this.get(1, 0) + z*this.get(2, 0) + this.get(3, 0);
	result.y = x*this.get(0, 1) + y*this.get(1, 1) + z*this.get(2, 1) + this.get(3, 1);
	result.z = x*this.get(0, 2) + y*this.get(1, 2) + z*this.get(2, 2) + this.get(3, 2);

	return result;
};

/**
 * 행렬연산을 통해 주어진 포인트를 이동한다.
 *
 * @param {Point3D} point3d 입력 포인트
 * @param {Point3D} result 출력 포인트
 * @returns {Point3D} 출력 포인트
 */
Matrix4.prototype.transformPoint4D__test = function(cartesian4, result) 
{
	if (result === undefined) { result = new Point3D(); }

	var x = cartesian4[0];
	var y = cartesian4[1];
	var z = cartesian4[2];
	var w = cartesian4[3];

	result[0] = x*this.get(0, 0) + y*this.get(1, 0) + z*this.get(2, 0) + w*this.get(3, 0);
	result[1] = x*this.get(0, 1) + y*this.get(1, 1) + z*this.get(2, 1) + w*this.get(3, 1);
	result[2] = x*this.get(0, 2) + y*this.get(1, 2) + z*this.get(2, 2) + w*this.get(3, 2);
	result[3] = x*this.get(0, 3) + y*this.get(1, 3) + z*this.get(2, 3) + w*this.get(3, 3);

	return result;
};

/**
 * 행렬연산을 통해 주어진 포인트를 회전한다.
 *
 * @param {Point3D} point3d 입력 포인트
 * @param {Point3D} result 출력 포인트
 * @returns {Point3D} 출력 포인트
 */
Matrix4.prototype.rotateXYZDataArray = function(xyzDataArray, resultXYZDataArray) 
{
	if (xyzDataArray === undefined)
	{ return resultXYZDataArray; }
	
	if (resultXYZDataArray === undefined) { resultXYZDataArray = []; }
	var x, y, z;	
	var points3dCount = xyzDataArray.length/3;
	
	for (var i=0; i<points3dCount; i++)
	{
		x = xyzDataArray[i*3];
		y = xyzDataArray[i*3+1];
		z = xyzDataArray[i*3+2];

		resultXYZDataArray[i*3] = x*this.get(0, 0) + y*this.get(1, 0) + z*this.get(2, 0);
		resultXYZDataArray[i*3+1] = x*this.get(0, 1) + y*this.get(1, 1) + z*this.get(2, 1);
		resultXYZDataArray[i*3+2] = x*this.get(0, 2) + y*this.get(1, 2) + z*this.get(2, 2);
	}

	return resultXYZDataArray;
};

/**
 * 행렬연산을 통해 주어진 포인트를 회전한다.
 *
 * @param {Point3D} point3d 입력 포인트
 * @param {Point3D} result 출력 포인트
 * @returns {Point3D} 출력 포인트
 */
Matrix4.prototype.rotatePoint3D = function(point3d, result) 
{
	if (result === undefined) { result = new Point3D(); }

	var x = point3d.x;
	var y = point3d.y;
	var z = point3d.z;

	result.x = x*this.get(0, 0) + y*this.get(1, 0) + z*this.get(2, 0);
	result.y = x*this.get(0, 1) + y*this.get(1, 1) + z*this.get(2, 1);
	result.z = x*this.get(0, 2) + y*this.get(1, 2) + z*this.get(2, 2);

	return result;
};

/**
 * From gl-matrix.js
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
Matrix4.lookAt = function(out, eye, center, up) 
{
	var x0 = void 0,
		x1 = void 0,
		x2 = void 0,
		y0 = void 0,
		y1 = void 0,
		y2 = void 0,
		z0 = void 0,
		z1 = void 0,
		z2 = void 0,
		len = void 0;
	var eyex = eye[0];
	var eyey = eye[1];
	var eyez = eye[2];
	var upx = up[0];
	var upy = up[1];
	var upz = up[2];
	var centerx = center[0];
	var centery = center[1];
	var centerz = center[2];

	if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) 
	{
		return glMatrix.mat4.identity(out);
	}

	z0 = eyex - centerx;
	z1 = eyey - centery;
	z2 = eyez - centerz;

	len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
	z0 *= len;
	z1 *= len;
	z2 *= len;

	x0 = upy * z2 - upz * z1;
	x1 = upz * z0 - upx * z2;
	x2 = upx * z1 - upy * z0;
	len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
	if (!len) 
	{
		x0 = 0;
		x1 = 0;
		x2 = 0;
	}
	else 
	{
		len = 1 / len;
		x0 *= len;
		x1 *= len;
		x2 *= len;
	}

	y0 = z1 * x2 - z2 * x1;
	y1 = z2 * x0 - z0 * x2;
	y2 = z0 * x1 - z1 * x0;

	len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
	if (!len) 
	{
		y0 = 0;
		y1 = 0;
		y2 = 0;
	}
	else 
	{
		len = 1 / len;
		y0 *= len;
		y1 *= len;
		y2 *= len;
	}

	out[0] = x0;
	out[1] = y0;
	out[2] = z0;
	out[3] = 0;
	out[4] = x1;
	out[5] = y1;
	out[6] = z1;
	out[7] = 0;
	out[8] = x2;
	out[9] = y2;
	out[10] = z2;
	out[11] = 0;
	out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
	out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
	out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
	out[15] = 1;

	return out;
};

/**
 * 4차원 행렬의 곱셈을 계산한다.(Rm = AmBm)
 * Rm(j,i) = (AmBm)(j,i) = Sum( Am(j,k)*Bm(k,i) )(k=1,4)
 * 
 * @param {Matrix4} matrix 입력 행렬(Am)
 * @param {Matrix4} result 결과 행렬(Rm)
 * @returns {Matrix4} 결과 행렬(Rm)
 */
Matrix4.prototype.getMultipliedByMatrix = function(matrix, result) 
{

	if (result === undefined) { result = new Matrix4(); }

	for (var i=0; i<4; i++) 
	{
		for (var j=0; j<4; j++) 
		{
			var idx = this.getIndexOfArray(i, j);
			result._floatArrays[idx] = 0.0;
			for (var k=0; k<4; k++) 
			{
				result._floatArrays[idx] += matrix.get(k, j) * this.get(i, k);
			}
		}
	}
	return result;
};

/**
 * 원근 투영 행렬을 생성한다.
 * normalized device coordinates (NDC) uses the left-handed coordinate system
 * Always use right-handed coordinate system
 * 
 * @param {*} fovyrad Radian 단위의 시야각(Field of view)
 * @param {*} aspect 화면비율(Aspect Ratio:가로값/세로값)
 * @param {*} near 근거리
 * @param {*} far 원거리
 * 
 * @see http://ogldev.atspace.co.uk/www/tutorial12/tutorial12.html
 * @see https://www.gamedev.net/articles/programming/graphics/perspective-projections-in-lh-and-rh-systems-r3598/
 * @see http://www.songho.ca/opengl/gl_projectionmatrix.html
 */
Matrix4.prototype.setToPerspectiveProjection = function (fovyrad, aspect, near, far) 
{
	var yScale = 1.0 / Math.tan(fovyrad / 2);
	var xScale = yScale / aspect;
	var zRange = near - far;

	this.setByFloat32Array([xScale, 0, 0, 0,
		0, yScale, 0, 0,
		0, 0, (far + near) / zRange, -1,
		0, 0, 2*far*near / zRange, 0 ]);
};

/**
 * 입력된 4차원 행렬로부터 행렬값을 복사한다.
 *
 * @param {Matrix4} matrix 4차원 행렬
 */
Matrix4.prototype.copyFromMatrix4 = function(matrix) 
{
	for (var i=0; i<16; i++)
	{
		this._floatArrays[i] = matrix._floatArrays[i];
	}
};


/**
 * 입력된 배열로부터 4차원 행렬값을 복사한다.
 *
 * @param {Object[]} floatArrays 배열
 */
Matrix4.prototype.copyFromFloatArray = function(floatArrays) 
{
	for (var i=0; i<16; i++)
	{
		this._floatArrays[i] = floatArrays[i];
	}
};

/**
 * 행렬의 타입을 알려준다.
 *
 * @returns {Number} 행렬의 타입
 */
Matrix4.prototype.computeMatrixType = function() 
{
	// matrixType = 0 -> identity matrix.
	// matrixType = 1 -> translate matrix.
	// matrixType = 2 -> transform matrix.
	
	var error = 10E-8;
	if (this.isRotationIdentity())
	{
		// check if there are translation.
		if (this.aproxEqual(this._floatArrays[3], 0, error))
		{
			if (this.aproxEqual(this._floatArrays[7], 0, error))
			{
				if (this.aproxEqual(this._floatArrays[11], 0, error))
				{
					if (this.aproxEqual(this._floatArrays[12], 0, error))
					{
						if (this.aproxEqual(this._floatArrays[13], 0, error))
						{
							if (this.aproxEqual(this._floatArrays[14], 0, error))
							{
								if (this.aproxEqual(this._floatArrays[15], 1, error))
								{
									return 0;
								}
								else { return 1; }
							}
							else { return 1; }
						}
						else { return 1; }
					}
					else { return 1; }
				}
				else { return 1; }
			}
			else { return 1; }
		}
		else { return 1; }
	}
	else
	{
		return 2;
	}
};

/**
 * 오차범위내에 두 값의 동일 여부를 확인한다.
 * Returns if the value is aproximately equal to the valueToCompare with error.
 *
 * @param {Number} value 비교값
 * @param {Number} valueToCompare 비교값
 * @param {Number} error 오차율
 * @returns {Boolean} 비교값의 일치여부
 */
Matrix4.prototype.aproxEqual = function(value, valueToCompare, error) 
{
	if (error === undefined)
	{ error = 10E-8; }
	
	if (value === valueToCompare)
	{
		return true;
	}
	else
	{
		if (value > (valueToCompare - error) && value < (valueToCompare + error))
		{ return true; }
		else
		{ return false; }
	}
};

/**
 */
Matrix4.perspective = function(fieldOfViewInRadians, aspect, near, far) 
{
	var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewInRadians);
	var rangeInv = 1.0 / (near - far);
	
	return [
		f / aspect, 0, 0, 0,
		0, f, 0, 0,
		0, 0, (near + far) * rangeInv, -1,
		0, 0, near * far * rangeInv * 2, 0
	];
};

/**
 * 두 배열의 일치여부를 확인한다.
 * Returns if the arrayA equal to the arrayB.
 *
 * @param {Object[]} arrayA
 * @param {Object[]} arrayB
 * @returns {Boolean} 두 배열의 일치여부
 */
Matrix4.areEqualArrays = function(arrayA, arrayB) 
{
	var areEqual = true;
	var i=0;
	while (areEqual && i<16)
	{
		if (arrayA[i] !== arrayB[i])
		{
			areEqual = false;
		}
		i++;
	}
	
	return areEqual;
};

/**
 *
 */
Matrix4.copyArray = function(arrayOrigin, arrayDest) 
{
	for (var i=0; i<16; i++)
	{
		arrayDest[i] = arrayOrigin[i];
	}
};

/**
 * 회전/이동을 위한 단위행렬 여부를 확인한다.
 *
 * @param {Number} error
 * @returns {Boolean}
 */
Matrix4.prototype.isRotationIdentity = function(error) 
{
	if (this.aproxEqual(this._floatArrays[0], 1, error))
	{
		if (this.aproxEqual(this._floatArrays[1], 0, error))
		{
			if (this.aproxEqual(this._floatArrays[2], 0, error))
			{
				if (this.aproxEqual(this._floatArrays[4], 0, error))
				{
					if (this.aproxEqual(this._floatArrays[5], 1, error))
					{
						if (this.aproxEqual(this._floatArrays[6], 0, error))
						{
							if (this.aproxEqual(this._floatArrays[8], 0, error))
							{
								if (this.aproxEqual(this._floatArrays[9], 0, error))
								{
									if (this.aproxEqual(this._floatArrays[10], 1, error))
									{
										return true;
									}
									else { return false; }
								}
								else { return false; }
							}
							else { return false; }
						}
						else { return false; }
					}
					else { return false; }
				}
				else { return false; }
			}
			else { return false; }
		}
		else { return false; }
	}
	else { return false; }
};

'use strict';

var Messages = {};

Messages.CONSTRUCT_ERROR = "이 객체는 new를 사용하여 생성해야 합니다.";
'use strict';

/**
 * Manages & controls all mouse actions.
 * @class MouseAction
 */
var MouseAction = function() 
{
	if (!(this instanceof MouseAction)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	/**
	 * Start mouse click x position in screen coordinates.
	 * @type {Number}
	 * @default 0
	 */
	this.strX;
	
	/**
	 * Start mouse click y position in screen coordinates.
	 * @type {Number}
	 * @default 0
	 */
	this.strY;
	
	/**
	 * Linear depth value of the start click point.
	 * @type {Number}
	 * @default 0
	 */
	this.strLinealDepth;
	
	/**
	 * Start click point in camera coordinates.
	 * @type {Point3D}
	 * @default (0,0,0)
	 */
	this.strCamCoordPoint;
	
	/**
	 * Start click point in world coordinates.
	 * @type {Point3D}
	 * @default (0,0,0)
	 */
	this.strWorldPoint;
	
	/**
	 * TEST var: Start click point in world coordinates.
	 * @type {Point3D}
	 * @default (0,0,0)
	 */
	//this.strWorldPoint2;
	
	/**
	 * Transformation matrix of start click point location.
	 * @type {Matrix4}
	 * @default Identity matrix.
	 */
	this.strModelViewMatrix = new Matrix4();
	
	/**
	 * Transformation matrix inverse of start click point location.
	 * @type {Matrix4}
	 * @default Identity matrix.
	 */
	this.strModelViewMatrixInv = new Matrix4();
	
	/**
	 * Camera state on start click.
	 * @type {Camera}
	 * @default Camera.
	 */
	this.strCamera = new Camera();
	
	/**
	 * Camera target on start click.
	 * @type {Float32Array(3)}
	 * @default (0,0,0).
	 */
	this.strCameraTarget = new Float32Array([0.0, 0.0, 0.0]);
	
	/**
	 * Current mouse click x position in screen coordinates.
	 * @type {Number}
	 * @default 0
	 */
	this.curX;
	
	/**
	 * Current mouse click y position in screen coordinates.
	 * @type {Number}
	 * @default 0
	 */
	this.curY;
	
	/**
	 * Camera rotation point.
	 * @type {Point3D}
	 * @default (0,0,0).
	 */
	this.camRotPoint = new Point3D();
	
	/**
	 * Camera rotation axis.
	 * @type {Point3D}
	 * @default (0,0,0).
	 */
	this.camRotAxis = new Point3D();
	
	/**
	 * Time in the start moment.
	 * @type {Number}
	 * @default undefined.
	 */
	this.strTime;
	
	/**
	 * Aux var. Start click point in world coordinates.
	 * @type {Point3D}
	 * @default (0,0,0).
	 */
	this.strWorldPointAux;
	
	/**
	 * Aux var. Start click point location.
	 * @type {GeographicCoord}
	 * @default (0,0,0).
	 */
	this.strLocationAux;
	
};

/**
 * Deletes the auxiliary start point & location.
 */
MouseAction.prototype.clearStartPositionsAux = function()
{
	if (this.strWorldPointAux)
	{
		this.strWorldPointAux.deleteObjects();
	}
	this.strWorldPointAux = undefined;
		
	if (this.strLocationAux)
	{
		this.strLocationAux.deleteObjects();
	}
	this.strLocationAux = undefined;
};

/**
 * Calculates the camera start position in world coordinates.
 * @param {MagoManager} magoManager Main Mago3D manager.
 */
MouseAction.prototype.claculateStartPositionsAux = function(magoManager)
{
	var strLinDepth = this.strLinealDepth;
					
	// calculate the strWorldPos.
	var frustumFar = 100000000.0;
	var strRealDepth = strLinDepth*frustumFar;
	// now, find the 3d position of the pixel in camCoord.*
	magoManager.resultRaySC = magoManager.getRayCamSpace(this.strX, this.strY, magoManager.resultRaySC);
	var strCamPos = new Point3D();
	strCamPos.set(magoManager.resultRaySC[0] * strRealDepth, magoManager.resultRaySC[1] * strRealDepth, magoManager.resultRaySC[2] * strRealDepth);
	this.strWorldPointAux = magoManager.cameraCoordPositionToWorldCoord(strCamPos, this.strWorldPointAux);
	this.strLocationAux = ManagerUtils.pointToGeographicCoord(this.strWorldPointAux, undefined, magoManager);
};

/**
 * Save the current-state on start-state vars. of worldPoint and CamCoordPoint
 */
MouseAction.prototype.saveCurrentToStart = function()
{
	this.strX = this.curX;
	this.strY = this.curY;
	
	// world point.
	if (this.strWorldPoint === undefined)
	{ this.strWorldPoint = new Point3D(); }
	
	if (this.curWorldPoint)
	{
		this.strWorldPoint.copyFrom(this.curWorldPoint);
	}
	
	// camCoord point.
	if (this.strCamCoordPoint === undefined)
	{ this.strCamCoordPoint = new Point3D(); }
	
	if (this.curCamCoordPoint)
	{
		this.strCamCoordPoint.copyFrom(this.curCamCoordPoint);
	}
};

/**
 * Save the current-state on start-state vars. of worldPoint and CamCoordPoint
 */
MouseAction.prototype.getStartWorldPoint = function()
{
	return this.strWorldPoint;
};







































'use strict';

/**
 * Movement class for camera.
 * @class Movement
 */
var Movement = function(options) 
{
	if (!(this instanceof Movement)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.movementType = CODE.movementType.NO_MOVEMENT; // it can be translation, rotation or no movement.
	this.deltaTime;
	
	this.currLinearVelocity;
	this.translationDir;
	
	this.currAngularVelocity;
	this.rotationAxis;
	this.xAngVelocity;
	this.zAngVelocity;
	//this.angRad;
	//this.xRotAngRad;
	//this.zRotAngRad;
	
	this.rotationPoint;
	
	if (options)
	{
		if (options.movementType !== undefined)
		{ this.movementType = options.movementType; }
		
		if (options.linearVelocity !== undefined)
		{ this.currLinearVelocity = options.linearVelocity; }
		
		if (options.translationDir !== undefined)
		{ this.translationDir = options.translationDirection; }
		
		if (options.angularVelocity !== undefined)
		{ this.currAngularVelocity = options.angularVelocity; }
		
		if (options.rotationAxis !== undefined)
		{ this.rotationAxis = options.rotationAxis; }
	
		if (options.rotationPoint !== undefined)
		{ this.rotationPoint = options.rotationPoint; }
	}
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class ObjectMarker
 *
 */
var ObjectMarker = function() 
{
	if (!(this instanceof ObjectMarker)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.id;
	this.geoLocationData = new GeoLocationData();
	this.issue_id = null;
	this.issue_type = null;
	//this.latitude = 0;
	//this.longitude = 0;
	//this.height = 0;
	
	this.imageFilePath;
	this.size2d = new Float32Array([25.0, 25.0]);
	this.bUseOriginalImageSize = true;
};

ObjectMarker.prototype.deleteObjects = function() 
{
	if (this.geoLocationData)
	{ this.geoLocationData.deleteObjects(); }
};

ObjectMarker.prototype.setImageFilePath = function(imageFilePath) 
{
	this.imageFilePath = imageFilePath;
};

ObjectMarker.prototype.copyFrom = function(objMarker) 
{
	if (objMarker === undefined) { return; }
		
	if (objMarker.geoLocationData) 
	{
		this.geoLocationData.copyFrom(objMarker.geoLocationData);
	}
	
	this.issue_id = objMarker.issue_id;
	this.issue_type = objMarker.issue_type;
};



'use strict';


/**
 * 어떤 일을 하고 있습니까?
 * @class ObjectMarkerManager
 *
 */
var ObjectMarkerManager = function(magoManager) 
{
	if (!(this instanceof ObjectMarkerManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.magoManager = magoManager;
	this.objectMarkerArray = [];
	this.pin = new Pin();
};

/**
 * 어떤 일을 하고 있습니까?
 * @class ObjectMarkerManager
 *
 */
ObjectMarkerManager.prototype.deleteObjects = function()
{
	var objectsMarkersCount = this.objectMarkerArray.length;
	for (var i=0; i<objectsMarkersCount; i++)
	{
		this.objectMarkerArray[i].deleteObjects();
		this.objectMarkerArray[i] = undefined;
	}
	this.objectMarkerArray = [];
};
ObjectMarkerManager.prototype.setMarkerByCondition = function(condition)
{
	var that = this;
	var arr = that.objectMarkerArray.filter(function(om)
	{
		return condition.call(that, om);
	});
	that.objectMarkerArray = arr;
};
/**
 * start rendering.
 * @param scene 변수
 * @param isLastFrustum 변수
 */
 
ObjectMarkerManager.prototype.loadDefaultImages = function(magoManager) 
{
	if (this.pin.defaultImagesLoaded === false)
	{
		var gl = magoManager.getGl();
		var magoPolicy = magoManager.magoPolicy;
		var pin = this.pin;
		
		var filePath_inServer = magoPolicy.imagePath + "/defaultRed.png";
		var texture = pin.loadImage(filePath_inServer, magoManager);
		pin.imageFileMap.defaultRed = texture;
		
		filePath_inServer = magoPolicy.imagePath + "/defaultBlue.png";
		var texture = pin.loadImage(filePath_inServer, magoManager);
		pin.imageFileMap.defaultBlue = texture;
		
		filePath_inServer = magoPolicy.imagePath + "/defaultOrange.png";
		var texture = pin.loadImage(filePath_inServer, magoManager);
		pin.imageFileMap.defaultOrange = texture;
		
		filePath_inServer = magoPolicy.imagePath + "/defaultCian.png";
		var texture = pin.loadImage(filePath_inServer, magoManager);
		pin.imageFileMap.defaultCian = texture;
		
		this.pin.defaultImagesLoaded = true;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @class ObjectMarkerManager
 *
 */
ObjectMarkerManager.prototype.newObjectMarker = function(options, magoManager)
{
	var objMarker = new ObjectMarker();
	this.objectMarkerArray.push(objMarker);
	
	if (options)
	{
		if (options.positionWC)
		{
			var posWC = options.positionWC;
			if (objMarker.geoLocationData === undefined)
			{ objMarker.geoLocationData = new GeoLocationData(); }
			ManagerUtils.calculateGeoLocationDataByAbsolutePoint(posWC.x, posWC.y, posWC.z, objMarker.geoLocationData, magoManager);
		}
		
		if (options.imageFilePath)
		{
			objMarker.imageFilePath = options.imageFilePath;
		}
		
		if (options.imageFilePathSelected)
		{
			objMarker.imageFilePathSelected = options.imageFilePathSelected;
		}
		
		if (options.sizeX && options.sizeY)
		{
			if (objMarker.size2d === undefined)
			{ objMarker.size2d = new Float32Array([25.0, 25.0]); }
			objMarker.size2d[0] = options.sizeX;
			
			if (objMarker.size2d === undefined)
			{ objMarker.size2d = new Float32Array([25.0, 25.0]); }
			objMarker.size2d[1] = options.sizeY;
			
			objMarker.bUseOriginalImageSize = false;
		}
		else
		{
			objMarker.bUseOriginalImageSize = true;
		}
	}
	
	return objMarker;
};

/**
 * 어떤 일을 하고 있습니까?
 * @class ObjectMarkerManager
 *
 */
ObjectMarkerManager.prototype.render = function(magoManager, renderType)
{
	var objectsMarkersCount = this.objectMarkerArray.length;
	if (objectsMarkersCount > 0)
	{
		// Check if defaultImages are loaded.
		//this.loadDefaultImages(magoManager);
		var gl = magoManager.getGl();
		
		// now repeat the objects markers for png images.***
		// Png for pin image 128x128.********************************************************************
		if (this.pin.positionBuffer === undefined)
		{ this.pin.createPinCenterBottom(gl); }
		
		// check if pin textures is loaded.
		/*var currentTexture = this.pin.texturesArray[0];
		if (!currentTexture || !currentTexture.texId)
		{
			//magoManager.load_testTextures();
			return;
		}*/
		
		var shader = magoManager.postFxShadersManager.getShader("pin"); 
		shader.resetLastBuffersBinded();
		
		var shaderProgram = shader.program;
		
		gl.useProgram(shaderProgram);
		shader.bindUniformGenerals();
		magoManager.effectsManager.setCurrentShader(shader);
		gl.uniformMatrix4fv(shader.modelViewProjectionMatrix4RelToEye_loc, false, magoManager.sceneState.modelViewProjRelToEyeMatrix._floatArrays);
		gl.uniform3fv(shader.cameraPosHIGH_loc, magoManager.sceneState.encodedCamPosHigh);
		gl.uniform3fv(shader.cameraPosLOW_loc, magoManager.sceneState.encodedCamPosLow);
		gl.uniformMatrix4fv(shader.buildingRotMatrix_loc, false, magoManager.sceneState.modelViewRelToEyeMatrixInv._floatArrays);
		
		gl.uniform1i(shader.textureFlipYAxis_loc, magoManager.sceneState.textureFlipYAxis); 
		// Tell the shader to get the texture from texture unit 0
		gl.uniform1i(shader.texture_loc, 0);
		gl.enableVertexAttribArray(shader.texCoord2_loc);
		gl.enableVertexAttribArray(shader.position4_loc);
		gl.activeTexture(gl.TEXTURE0);
		
		gl.depthRange(0, 0.05);
		//var context = document.getElementById('canvas2').getContext("2d");
		//var canvas = document.getElementById("magoContainer");
		
		gl.bindBuffer(gl.ARRAY_BUFFER, this.pin.positionBuffer);
		gl.vertexAttribPointer(shader.position4_loc, 4, gl.FLOAT, false, 0, 0);
		gl.bindBuffer(gl.ARRAY_BUFFER, this.pin.texcoordBuffer);
		gl.vertexAttribPointer(shader.texCoord2_loc, 2, gl.FLOAT, false, 0, 0);
		
		gl.activeTexture(gl.TEXTURE0);
		
		gl.uniform1i(shader.colorType_loc, 2); // 0= oneColor, 1= attribColor, 2= texture.
		gl.uniform4fv(shader.oneColor4_loc, [0.2, 0.7, 0.9, 1.0]);
		gl.uniform2fv(shader.scale2d_loc, [1.0, 1.0]);
		gl.uniform2fv(shader.size2d_loc, [25.0, 25.0]);
		gl.uniform1i(shader.bUseOriginalImageSize_loc, true);
		gl.uniform3fv(shader.aditionalOffset_loc, [0.0, 0.0, 0.0]);
		
		gl.depthMask(false);
		gl.disable(gl.BLEND);
		var selectionManager = magoManager.selectionManager;
		var lastTexId = undefined;
		if (renderType === 1)
		{
			var executedEffects = false;
			for (var i=0; i<objectsMarkersCount; i++)
			{
				var objMarker = magoManager.objMarkerManager.objectMarkerArray[i];
				var currentTexture = this.pin.getTexture(objMarker.imageFilePath);
				
				if (!currentTexture)
				{
					this.pin.loadImage(objMarker.imageFilePath, magoManager);
					continue;
				}
				
				if (selectionManager.isObjectSelected(objMarker))
				{
					gl.uniform2fv(shader.scale2d_loc, new Float32Array([1.5, 1.5]));
					if (objMarker.imageFilePathSelected)
					{
						var selectedTexture = this.pin.getTexture(objMarker.imageFilePathSelected);
						if (selectedTexture)
						{ currentTexture = selectedTexture; }
						else 
						{
							this.pin.loadImage(objMarker.imageFilePathSelected, magoManager);
							continue;
						}
					}
				}
				else
				{
					gl.uniform2fv(shader.scale2d_loc, new Float32Array([1.0, 1.0]));
				}
				gl.uniform1i(shader.bUseOriginalImageSize_loc, objMarker.bUseOriginalImageSize);
				if (!objMarker.bUseOriginalImageSize)
				{ gl.uniform2fv(shader.size2d_loc, objMarker.size2d); }
			
				// Check if there are effects.
				if (renderType !== 2 && magoManager.currentProcess !== CODE.magoCurrentProcess.StencilSilhouetteRendering)
				{ executedEffects = magoManager.effectsManager.executeEffects(objMarker.id, magoManager.getCurrentTime()); }
			
				gl.uniform2fv(shader.imageSize_loc, [currentTexture.texId.imageWidth, currentTexture.texId.imageHeight]);
				
				var objMarkerGeoLocation = objMarker.geoLocationData;
				
				if (currentTexture.texId !== lastTexId)
				{
					gl.bindTexture(gl.TEXTURE_2D, currentTexture.texId);
					lastTexId = currentTexture.texId;
				}
					
				gl.uniform3fv(shader.buildingPosHIGH_loc, objMarkerGeoLocation.positionHIGH);
				gl.uniform3fv(shader.buildingPosLOW_loc, objMarkerGeoLocation.positionLOW);

				gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

			}
			
			if (executedEffects)
			{
				// must return all uniforms changed for effects.
				gl.uniform3fv(shader.aditionalOffset_loc, [0.0, 0.0, 0.0]); // init referencesMatrix.
			}
		}
		else if (renderType === 2)
		{
			// Selection render.***
			var selectionColor = magoManager.selectionColor;
			gl.disable(gl.BLEND);
			gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
			
			for (var i=0; i<objectsMarkersCount; i++)
			{
				var objMarker = magoManager.objMarkerManager.objectMarkerArray[i];
				var objMarkerGeoLocation = objMarker.geoLocationData;
				
				var colorAux = selectionColor.getAvailableColor(undefined);
				var idxKey = selectionColor.decodeColor3(colorAux.r, colorAux.g, colorAux.b);
				selectionManager.setCandidateGeneral(idxKey, objMarker);
			
				gl.uniform4fv(shader.oneColor4_loc, [colorAux.r/255.0, colorAux.g/255.0, colorAux.b/255.0, 1.0]);
			
				gl.uniform3fv(shader.buildingPosHIGH_loc, objMarkerGeoLocation.positionHIGH);
				gl.uniform3fv(shader.buildingPosLOW_loc, objMarkerGeoLocation.positionLOW);

				gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
			}
			gl.enable(gl.BLEND);
		}
		
		gl.enable(gl.BLEND);
		gl.depthRange(0, 1);
		gl.depthMask(true);
		gl.useProgram(null);
		gl.bindTexture(gl.TEXTURE_2D, null);
		shader.disableVertexAttribArrayAll();
		
	}
};





































'use strict';
	
/**
 * OcclusionCullingOctree
 * @class
 * 
 * @see OcclusionCullingOctreeCell
 */
var OcclusionCullingOctree = function() 
{
	if (!(this instanceof OcclusionCullingOctree)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this._ocCulling_box = new OcclusionCullingOctreeCell(null);
	this._infinite_ocCulling_box = new OcclusionCullingOctreeCell(null);
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class
 * 
 * @param occlusionCullingOctree_Cell_Owner OcclusionCullingOctreeCell 소유자
 */
var OcclusionCullingOctreeCell = function(occlusionCullingOctree_Cell_Owner) 
{
	if (!(this instanceof OcclusionCullingOctreeCell)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this._ocCulling_Cell_owner = occlusionCullingOctree_Cell_Owner;
	this.minX = 0.0;
	this.maxX = 0.0;
	this.minY = 0.0;
	this.maxY = 0.0;
	this.minZ = 0.0;
	this.maxZ = 0.0;
	this._indicesArray = []; // Visible objects indices.
	this._subBoxesArray = [];
	this.modelReferencedGroupsList; // undefined initially.
};

/**
 * 어떤 일을 하고 있습니까?
 * @param neoRefsIndices 변수
 * @param motherNeoRefsList 변수
 */
OcclusionCullingOctreeCell.prototype.createModelReferencedGroups = function(motherNeoRefsList) 
{
	var subBoxesCount = this._subBoxesArray.length;
	if (subBoxesCount === 0)
	{
		if (this._indicesArray.length === 0)
		{ return; }
		
		if (this.modelReferencedGroupsList === undefined)
		{ this.modelReferencedGroupsList = new ModelReferencedGroupsList(); }
		
		this.modelReferencedGroupsList.createModelReferencedGroups(this._indicesArray, motherNeoRefsList);
	}
	else
	{
		for (var i=0; i<subBoxesCount; i++)
		{
			this._subBoxesArray[i].createModelReferencedGroups(motherNeoRefsList);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns subBox
 */
OcclusionCullingOctreeCell.prototype.newSubBox = function() 
{
	var subBox = new OcclusionCullingOctreeCell(this);
	this._subBoxesArray.push(subBox);
	return subBox;
};

/**
 * 어떤 일을 하고 있습니까?
 */
OcclusionCullingOctreeCell.prototype.create8SubBoxes = function() 
{
	this._subBoxesArray.length = 0;	
	for (var i=0; i<8; i++) 
	{
		this.newSubBox();
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param min_x 변수
 * @param max_x 변수
 * @param min_y 변수
 * @param max_y 변수
 * @param min_z 변수
 * @param max_z 변수
 */
OcclusionCullingOctreeCell.prototype.setDimensions = function(min_x, max_x, min_y, max_y, min_z, max_z) 
{
	this.minX = min_x;
	this.maxX = max_x;
	this.minY = min_y;
	this.maxY = max_y;
	this.minZ = min_z;
	this.maxZ = max_z;
};

/**
 * 어떤 일을 하고 있습니까?
 */
OcclusionCullingOctreeCell.prototype.setSizesSubBoxes = function() 
{
	// Bottom                      Top
	// |----------|----------|     |----------|----------|
	// |          |          |     |          |          |       Y
	// |    3     |    2     |	   |    7     |    6     |       ^
	// |          |          |     |          |          |       |
	// |----------|----------|     |----------|----------|       |
	// |          |          |     |          |          |       |
	// |     0    |     1    |     |    4     |    5     |       |
	// |          |          |     |          |          |       -----------------> X
	// |----------|----------|     |----------|----------|  
	
	if (this._subBoxesArray.length > 0) 
	{
		var half_x= (this.maxX + this.minX)/2.0;
		var half_y= (this.maxY + this.minY)/2.0;
		var half_z= (this.maxZ + this.minZ)/2.0;
		
		this._subBoxesArray[0].setDimensions(this.minX, half_x,   this.minY, half_y,   this.minZ, half_z);
		this._subBoxesArray[1].setDimensions(half_x, this.maxX,   this.minY, half_y,   this.minZ, half_z);
		this._subBoxesArray[2].setDimensions(half_x, this.maxX,   half_y, this.maxY,   this.minZ, half_z);
		this._subBoxesArray[3].setDimensions(this.minX, half_x,   half_y, this.maxY,   this.minZ, half_z);

		this._subBoxesArray[4].setDimensions(this.minX, half_x,   this.minY, half_y,   half_z, this.maxZ);
		this._subBoxesArray[5].setDimensions(half_x, this.maxX,   this.minY, half_y,   half_z, this.maxZ);
		this._subBoxesArray[6].setDimensions(half_x, this.maxX,   half_y, this.maxY,   half_z, this.maxZ);
		this._subBoxesArray[7].setDimensions(this.minX, half_x,   half_y, this.maxY,   half_z, this.maxZ);
		
		for (var i=0; i<this._subBoxesArray.length; i++) 
		{
			this._subBoxesArray[i].setSizesSubBoxes();
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 * @returns intersects
 */
OcclusionCullingOctreeCell.prototype.intersectsWithPoint3D = function(x, y, z) 
{
	var intersects = false;
	if (x> this.minX && x<this.maxX) 
	{
		if (y> this.minY && y<this.maxY) 
		{
			if (z> this.minZ && z<this.maxZ) 
			{
				intersects = true;
			}
		}
	}
	
	return intersects;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 * @returns intersectedSubBox
 */
OcclusionCullingOctreeCell.prototype.getIntersectedSubBoxByPoint3D = function(x, y, z) 
{
	if (this._ocCulling_Cell_owner === undefined) 
	{
		// This is the mother_cell.
		if (!this.intersectsWithPoint3D(x, y, z)) 
		{
			return undefined;
		}
	}
	
	var intersectedSubBox = undefined;
	var subBoxes_count = this._subBoxesArray.length;
	if (subBoxes_count > 0) 
	{
		var center_x = (this.minX + this.maxX)/2.0;
		var center_y = (this.minY + this.maxY)/2.0;
		var center_z = (this.minZ + this.maxZ)/2.0;
		
		var intersectedSubBox_aux = undefined;
		var intersectedSubBox_idx;
		if (x<center_x) 
		{
			// Here are the boxes number 0, 3, 4, 7.
			if (y<center_y) 
			{
				// Here are 0, 4.
				if (z<center_z) { intersectedSubBox_idx = 0; }
				else { intersectedSubBox_idx = 4; }
			}
			else 
			{
				// Here are 3, 7.
				if (z<center_z) { intersectedSubBox_idx = 3; }
				else { intersectedSubBox_idx = 7; }
			}
		}
		else 
		{
			// Here are the boxes number 1, 2, 5, 6.
			if (y<center_y) 
			{
				// Here are 1, 5.
				if (z<center_z) { intersectedSubBox_idx = 1; }
				else { intersectedSubBox_idx = 5; }
			}
			else 
			{
				// Here are 2, 6.
				if (z<center_z) { intersectedSubBox_idx = 2; }
				else { intersectedSubBox_idx = 6; }
			}
		}
		
		intersectedSubBox_aux = this._subBoxesArray[intersectedSubBox_idx];
		intersectedSubBox = intersectedSubBox_aux.getIntersectedSubBoxByPoint3D(x, y, z);
		
	}
	else 
	{
		intersectedSubBox = this;
	}
	
	return intersectedSubBox;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param eye_x 변수
 * @param eye_y 변수
 * @param eye_z 변수
 * @param result_visibleIndicesArray 변수
 * @returns result_visibleIndicesArray
 */
OcclusionCullingOctreeCell.prototype.getIndicesVisiblesForEye = function(eye_x, eye_y, eye_z, result_visibleIndicesArray, result_modelReferencedGroup) 
{
	var intersectedSubBox = this.getIntersectedSubBoxByPoint3D(eye_x, eye_y, eye_z);
	
	if (intersectedSubBox !== undefined && intersectedSubBox._indicesArray.length > 0) 
	{
		result_visibleIndicesArray = intersectedSubBox._indicesArray;
		if (result_modelReferencedGroup)
		{
			result_modelReferencedGroup = this.modelReferencedGroupsList;
		}
	}
	
	return result_visibleIndicesArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param expansionDist 변수
 */
OcclusionCullingOctreeCell.prototype.expandBox = function(expansionDist) 
{
	this.minX -= expansionDist;
	this.maxX += expansionDist;
	this.minY -= expansionDist;
	this.maxY += expansionDist;
	this.minZ -= expansionDist;
	this.maxZ += expansionDist;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param arrayBuffer 변수
 * @param bytes_readed 변수
 * @param f4dReaderWriter 변수
 * @returns bytes_readed
 */
OcclusionCullingOctreeCell.prototype.parseArrayBuffer = function(arrayBuffer, bytes_readed, f4dReaderWriter) 
{
	// Important note: this is the version of neoGeometry.
	// Important note: this is the version of neoGeometry.
	// Important note: this is the version of neoGeometry.
	var is_mother_cell = f4dReaderWriter.readInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
	if (is_mother_cell) 
	{
		// read the mother dimensions.
		var minX = f4dReaderWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		var maxX = f4dReaderWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		var minY = f4dReaderWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		var maxY = f4dReaderWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		var minZ = f4dReaderWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		var maxZ = f4dReaderWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		
		this.setDimensions(minX, maxX, minY, maxY, minZ, maxZ);
	}
	
	var subBoxes_count = f4dReaderWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
	
	if (subBoxes_count === 0) 
	{
		var objects_count = f4dReaderWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		for (var i=0; i<objects_count; i++) 
		{
			var objects_idxInList = f4dReaderWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			this._indicesArray.push(objects_idxInList);
		}
	}
	else 
	{
		for (var i=0; i<subBoxes_count; i++) 
		{
			var subOcclusionBox = this.newSubBox();
			bytes_readed = subOcclusionBox.parseArrayBuffer(arrayBuffer, bytes_readed, f4dReaderWriter);
		}
	}
	
	return bytes_readed;
};
'use strict';

/**
 * This is the pin which is created to be placed on the map
 * @class Pin
 *
 */
var Pin = function() 
{
	if (!(this instanceof Pin)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.texture; // default.
	this.texturesArray = [];
	this.positionBuffer;
	this.texcoordBuffer;
	
	this.imageFileMap = {};
	this.defaultImagesLoaded = false;
	
};

Pin.prototype.createPin = function(gl)
{
	// Old. deprecated.
	this.positionBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);

	// Put a unit quad in the buffer
	var positionsPinQuad = [
		0, 0, 0,
		1, 0, 0,
		0, 1, 0,
		0, 1, 0,
		1, 0, 0,
		1, 1, 0
	];
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positionsPinQuad), gl.STATIC_DRAW);

	this.texcoordBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);
	var texcoordsPinQuad = [
		0, 0,
		1, 0,
		0, 1,
		0, 1,
		1, 0,
		1, 1
	];
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoordsPinQuad), gl.STATIC_DRAW);
	
};

/**
 * draw the bottom pick of the pin
 */
Pin.prototype.loadImage = function(imageFilePath, magoManager)
{
	var texture = new Texture();
	var gl = magoManager.getGl();
	texture.texId = gl.createTexture();
	magoManager.readerWriter.readNeoReferenceTexture(gl, imageFilePath, texture, undefined, magoManager);
	this.texturesArray.push(texture);
	this.imageFileMap[imageFilePath] = texture;
	
	return texture;
};

/**
 * draw the bottom pick of the pin
 */
Pin.prototype.getTexture = function(imageFilePath)
{
	return this.imageFileMap[imageFilePath];
};

/**
 * draw the bottom pick of the pin
 */
Pin.prototype.createPinCenterBottom = function(gl)
{
	this.positionBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);

	// Put a unit quad in the buffer
	var positionsPinQuad = new Float32Array(16);
	
	var i =0;
	var point3d = new Point3D(0, 0, 0);
	positionsPinQuad[i*16] = point3d.x;
	positionsPinQuad[i*16+1] = point3d.y;
	positionsPinQuad[i*16+2] = point3d.z;
	positionsPinQuad[i*16+3] = 1; // order.
	
	positionsPinQuad[i*16+4] = point3d.x;
	positionsPinQuad[i*16+5] = point3d.y;
	positionsPinQuad[i*16+6] = point3d.z;
	positionsPinQuad[i*16+7] = -1; // order.
	
	positionsPinQuad[i*16+8] = point3d.x;
	positionsPinQuad[i*16+9] = point3d.y;
	positionsPinQuad[i*16+10] = point3d.z;
	positionsPinQuad[i*16+11] = 2; // order.
	
	positionsPinQuad[i*16+12] = point3d.x;
	positionsPinQuad[i*16+13] = point3d.y;
	positionsPinQuad[i*16+14] = point3d.z;
	positionsPinQuad[i*16+15] = -2; // order.
		
	gl.bufferData(gl.ARRAY_BUFFER, positionsPinQuad, gl.STATIC_DRAW);

	this.texcoordBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);
	var texcoordsPinQuad = [
		0, 0,
		1, 0,
		0, 1,
		1, 1
	];
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoordsPinQuad), gl.STATIC_DRAW);
	
};


























'use strict';

/**
 * The plane which can be represented as linear equation
 * Plane on 3D space. Plane equation ax+by+cz+d = 0.
 * @class Plane
 */
var Plane = function() 
{
	if (!(this instanceof Plane)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	// ax+by+cz+d = 0 plane.
	// a*x + b*y + c*z + d = 0
	// where (a,b,c) is the normal, and d is negative distance to origin.
	this.a = 0.0;
	this.b = 0.0;
	this.c = 0.0;
	this.d = 0.0;
};

/**
 * set the point and the vector which determine this plane
 * @param px the x coordi of the point that determine this plane
 * @param py the y coordi of the point that determine this plane
 * @param pz the z coordi of the point that determine this plane
 * @param nx the x coordi of the normal vector
 * @param ny the y coordi of the normal vector
 * @param nz the z coordi of the normal vector
 */
Plane.prototype.setPointAndNormal = function(px, py, pz, nx, ny, nz) 
{
	this.a = nx;
	this.b = ny;
	this.c = nz;
	this.d = -this.a*px -this.b*py - this.c*pz;
};

/**
 * set the point which determine this plane
 * @param px the x coordi of the point that determine this plane
 * @param py the y coordi of the point that determine this plane
 * @param pz the z coordi of the point that determine this plane
 */
Plane.prototype.setPoint = function(px, py, pz) 
{
	this.d = -this.a*px -this.b*py - this.c*pz;
};

/**
 * determine this plane as normal vector and the distance from the point which determine normal vector
 * @param dist
 * @param nx the x coordi of the normal vector
 * @param ny the y coordi of the normal vector
 * @param nz the z coordi of the normal vector
 */
Plane.prototype.setNormalAndDistance = function(nx, ny, nz, dist) 
{
	this.a = nx;
	this.b = ny;
	this.c = nz;
	this.d = dist;
};

/**
 * get the point of normal vector
 */
Plane.prototype.getNormal = function(resultNormal) 
{
	if (resultNormal === undefined)
	{ resultNormal = new Point3D(); }
	
	resultNormal.set(this.a, this.b, this.c);
	
	return resultNormal;
};

/**
 * Calculate the matrix which can rotate this plane
 * @param resultMatrix the matrix which will hold the result
 */
Plane.prototype.getRotationMatrix = function(resultTMatrix) 
{
	// The initial normal is (0, 0, 1), & the planeNormal is the transformed normal, so, calculate the rotationMatrix.
	var initialNormal = new Point3D(0.0, 0.0, 1.0);
	var transformedNormal = this.getNormal(undefined);
	
	// Calculate rotation axis. CrossProduct between initialNormal and the transformedNormal.
	// Check if the "initialNormal & the transformedNormal are parallels.
	var radError = 10E-10;
	var relativeOrientation = initialNormal.getRelativeOrientationToVector(transformedNormal, radError);
	// relativeOrientation = 0 -> // there are parallels & the same sense.
	// relativeOrientation = 1 -> // there are parallels & opposite sense.
	// relativeOrientation = 2 -> // there are NO parallels.
	var matrixAux = glMatrix.mat4.create(); // creates as identityMatrix.
	if (relativeOrientation === 0)
	{
		// there are parallels & the same sense.
		// In this case, the resultMatrix is a identityMatrix, so do nothing.
	}
	else if (relativeOrientation === 1)
	{
		// there are parallels & opposite sense.
		// Rotate 180 degree in xAxis.
		var identityMat = glMatrix.mat4.create();
		matrixAux = glMatrix.mat4.rotateX(matrixAux, identityMat, Math.PI);
	}
	else if (relativeOrientation === 2)
	{
		// there are NO parallels.
		// Calculate rotation axis. CrossProduct between initialNormal and the transformedNormal.
		var rotAxis = initialNormal.crossProduct(transformedNormal, undefined);
		rotAxis.unitary();
		var angRad = initialNormal.angleRadToVector(transformedNormal);
		var axis = glMatrix.vec3.fromValues(rotAxis.x, rotAxis.y, rotAxis.z);
		var quaternion = quat.create();
		quaternion = quat.setAxisAngle(quaternion, axis, angRad);
		
		// Now, make matrix4 from quaternion.
		var identityMat = glMatrix.mat4.create();
		matrixAux = glMatrix.mat4.fromQuat(identityMat, quaternion);
	}
	
	if (resultTMatrix === undefined)
	{ resultTMatrix = new Matrix4(); }
	
	resultTMatrix._floatArrays = matrixAux;
	
	return resultTMatrix;
};

/**
 * Get the point of the intersecting point of line and this plane
 * @param line 변수
 * @param intersectionPoint 변수
 */
Plane.prototype.getProjectedPoint = function(point, resultProjectedPoint) 
{
	if (point === undefined)
	{ return; }
	
	if (resultProjectedPoint === undefined)
	{ resultProjectedPoint = new Point3D(); }
	
	var normal = this.getNormal();
	var line = new Line();
	line.setPointAndDir(point.x, point.y, point.z, normal.x, normal.y, normal.z);
	
	resultProjectedPoint = this.intersectionLine(line, resultProjectedPoint);
	
	return resultProjectedPoint;
};

/**
 * Get the point of the intersecting point of line and this plane
 * @param line 변수
 * @param intersectionPoint 변수
 */
Plane.prototype.intersectionLine = function(line, intersectionPoint) 
{
	var r = line.point.x;
	var s = line.point.y;
	var t = line.point.z;
	
	var u = line.direction.x;
	var v = line.direction.y;
	var w = line.direction.z;
	
	var den = this.a*u + this.b*v + this.c*w;
	
	if (Math.abs(den) > 10E-8) 
	{
		var alfa = -((this.a*r + this.b*s + this.c*t + this.d)/(den));
		
		if (intersectionPoint === undefined) { intersectionPoint = new Point3D(); }
		
		intersectionPoint.set(r+alfa*u, s+alfa*v, t+alfa*w);
		return intersectionPoint;
	}
	else { return undefined; }
};

/**
 * Check whether the given sphere is intersected with this plane or not
 * @param sphere sphere
 */
Plane.prototype.intersectionSphere = function(sphere) 
{
	if (sphere === undefined || sphere.centerPoint === undefined)
	{ return Constant.INTERSECTION_OUTSIDE; }
	
	var sphereCenter = sphere.centerPoint;
	
	// calculate the distance by dotProduct.
	// sphere centerPoint = (x1, y1, z1), distance = |ax1 + by1 + cz1 + d|/sqrt(a*a +b*b + c*c*).
	// note: the module sqrt(a*a +b*b + c*c*) = 1, so no necessary divide distance by module.
	var distance = sphereCenter.x * this.a + sphereCenter.y * this.b + sphereCenter.z * this.c + this.d;

	if (distance < -sphere.r)
	{
		return Constant.INTERSECTION_OUTSIDE;
	}
	else if (distance < sphere.r)
	{
		return Constant.INTERSECTION_INTERSECT;
	}
	return Constant.INTERSECTION_INSIDE;
};






'use strict';

/**
 * 쿼터니언
 * 
 * @class
 */
var Quaternion = function() 
{
	if (!(this instanceof Quaternion)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * x 속성값
	 * @type {Number}
	 */
	this.x = 0.0;

	/**
	 * y 속성값
	 * @type {Number}
	 */
	this.y = 0.0;

	/**
	 * z 속성값
	 * @type {Number}
	 */
	this.z = 0.0;

	/**
	 * w 속성값
	 * @type {Number}
	 */
	this.w = 1.0;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z + this.w*this.w )
 */
Quaternion.prototype.Modul = function() 
{
	return Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z + this.w*this.w );
};

/**
 * 어떤 일을 하고 있습니까?
 */
Quaternion.prototype.Unitary = function() 
{
	var modul = this.Modul();
	this.x /= modul;
	this.y /= modul;
	this.z /= modul;
	this.w /= modul;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param angDeg 변수
 * @param axis_x 변수
 * @param axis_y 변수
 * @param axis_z 변수
 */
Quaternion.prototype.rotationAngDeg = function(angDeg, axis_x, axis_y, axis_z) 
{
	var angRad = angDeg*Math.PI/180.0;
	this.rotationAngRad(angRad, axis_x, axis_y, axis_z);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param angRad 변수
 * @param axis_x 변수
 * @param axis_y 변수
 * @param axis_z 변수
 */
Quaternion.prototype.rotationAngRad = function(angRad, axis_x, axis_y, axis_z) 
{
	var s = Math.sqrt(axis_x*axis_x + axis_y*axis_y + axis_z*axis_z);
	var error = 10E-13;
	if (!s < error) 
	{
		var c = 1.0/s;
		var omega = 0.5 * angRad;
		s = Math.sin(omega);
		this.x = axis_x * c * s;
		this.y = axis_y * c * s;
		this.z = axis_z * c * s;
		this.w = Math.cos(omega);
		this.Unitary();
	}
	else 
	{
		this.x = 0.0;
		this.y = 0.0;
		this.z = 0.0;
		this.w = 1.0;
	}
};

'use strict';

/**
 * This class is used for color code of GL
 * @class SelectionColor
 */
var SelectionColor = function() 
{
	if (!(this instanceof SelectionColor)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	/**
	 * Color
	 * @type {Color}
	 */
	this.color = new Color();
};

/**
 * Initiate the color value of this feature
 */
SelectionColor.prototype.init = function() 
{
	this.color.r = 0;
	this.color.g = 0;
	this.color.b = 0;
	this.cycle = 0;
};

/**
 * get the color code of given RGB color
 * @param {Color} resultColor target color instance
 */
SelectionColor.prototype.getAvailableColor = function(resultColor) 
{
	if (resultColor === undefined)
	{ resultColor = new Color(); }
	
	resultColor.setRGB(this.color.r, this.color.g, this.color.b);
	
	this.color.b += 1;
	if (this.color.b >= 254)
	{
		this.color.b = 0;
		this.color.g += 1;
		if (this.color.g >= 254)
		{
			this.color.g = 0;
			this.color.r += 1;
			if (this.color.r >= 254)
			{
				this.color.r = 0;
				this.cycle += 1;
			}
		}
	}
	
	return resultColor;
};

/**
 * Change the RGB code to color code.
 * (255,255,255) is used to white color so 254 number is used
 * @param {Number} r
 * @param {Number} g
 * @param {Number} b
 * @returns Color code
 */
SelectionColor.prototype.decodeColor3 = function(r, g, b) 
{
	return 64516*r + 254*g + b;
};

'use strict';

/**
 * This class contains settings.
 * @class Settings
 */
var Settings = function() 
{
	if (!(this instanceof Settings)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	/**
	 * This class contains rendering settings.
	 * @type {RenderingSettings}
	 */
	this._renderingSettings = new RenderingSettings();
	
	this.keepVboPositionDataArrayBuffers = true;
};

/**
 * Returns the Rendering Settings.
 * @return {RenderingSettings} this._renderingSettings
 */
Settings.prototype.getRenderingSettings = function()
{
	return this._renderingSettings;
};
'use strict';

/**
 * 4분할 타일링 수행 시 타일 객체.
 * Quadtree based tile with thickness.
 * @class SmartTile
 * 
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * @param {String} smartTileName tile name;
 */
var SmartTile = function(smartTileName) 
{
	//       +-----+-----+
	//       |  3  |  2  |
	//       +-----+-----+
	//       |  0  |  1  |
	//       +-----+-----+
	
	if (!(this instanceof SmartTile)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.name;
	if (smartTileName)
	{ this.name = smartTileName; }
	this.depth; // mother tile depth = 0.
	this.X;
	this.Y;
	this.minGeographicCoord; // longitude, latitude, altitude.
	this.maxGeographicCoord; // longitude, latitude, altitude.
	this.sphereExtent; // Cartesian position sphere in worldCoord.
	this.subTiles; // array.
	
	this.nodeSeedsArray;
	this.smartTileF4dSeedArray;
	this.nodesFromSmartTileF4dArray; 
	this.nodesArray; 
	this.objectsArray; // parametric objects.
	this.vectorTypeObjectsArray;
	
	this.nativeObjects = {
		opaquesArray      : [],
		transparentsArray : [],
		excavationsArray  : [],
		vectorTypeArray   : []
	};
	
	this.isVisible; // var to manage the frustumCulling and delete buildings if necessary.
	this.distToCamera;
};

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTile.prototype.deleteObjects = function() 
{
	this.name = undefined;
	this.depth = undefined;
	if (this.minGeographicCoord)
	{ this.minGeographicCoord.deleteObjects(); } 
		
	if (this.maxGeographicCoord)
	{ this.maxGeographicCoord.deleteObjects(); } 
	
	this.minGeographicCoord = undefined; 
	this.maxGeographicCoord = undefined; 
	if (this.sphereExtent)
	{ this.sphereExtent.deleteObjects(); }
	
	this.sphereExtent = undefined;
	
	// now, erase nodeSeeds.
	if (this.nodeSeedsArray)
	{
		var nodeSeedsCount = this.nodeSeedsArray.length;
		for (var i=0; i<nodeSeedsCount; i++)
		{
			// no delete the nodeObjects. nodeObjects must be deleted by hierarchyManager.
			this.nodeSeedsArray[i] = undefined;
		}
		this.nodeSeedsArray = undefined;
	}
	
	// now, erase nodes.
	if (this.nodesArray)
	{
		var nodesCount = this.nodesArray.length;
		for (var i=0; i<nodesCount; i++)
		{
			// no delete the nodeObjects. nodeObjects must be deleted by hierarchyManager.
			this.nodesArray[i] = undefined;
		}
		this.nodesArray = undefined;
	}
	
	this.isVisible = undefined;
	
	// delete children.
	if (this.subTiles)
	{
		var subTilesCount = this.subTiles.length;
		for (var i=0; i<subTilesCount; i++)
		{
			this.subTiles[i].deleteObjects();
			this.subTiles[i] = undefined;
		}
		this.subTiles = undefined;
	}
};

/**
 * 타일에 자식 타일 생성 및 반환.
 * @param {SmartTile} parentTile 부모타일
 * @return {SmartTile} subTile 생성된 자식타일 반환
 */
SmartTile.prototype.newSubTile = function(parentTile) 
{
	if (!(parentTile instanceof SmartTile))
	{
		return;
	}
	if (this.subTiles === undefined)
	{ this.subTiles = []; }
	
	var subTile = new SmartTile();
	subTile.depth = parentTile.depth + 1;
	subTile.targetDepth = parentTile.targetDepth;
	this.subTiles.push(subTile);
	return subTile;
};

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTile.prototype.clearNodesArray = function() 
{
	if (this.nodesArray === undefined)
	{ return; }
	
	for (var i=0; i<this.nodesArray.length; i++)
	{
		this.nodesArray[i] = undefined;
	}
	this.nodesArray = undefined;
};


/**
 * 어떤 일을 하고 있습니까?
 */
/*
SmartTile.prototype.getNodeByBuildingId = function(buildingType, buildingId) 
{
	var resultNode;
	var neoBuilding;
	var node;
	var hasSubTiles = true;
	if (this.subTiles === undefined)
	{ hasSubTiles = false; }
	
	if (this.subTiles && this.subTiles.length === 0)
	{ hasSubTiles = false; }
		
	if (!hasSubTiles)
	{
		if (this.nodesArray)
		{
			var nodesCount = this.nodesArray.length;
			var find = false;
			var i=0;
			while (!find && i<nodesCount) 
			{
				node = this.nodesArray[i];
				neoBuilding = node.data.neoBuilding;
				if (buildingType)
				{
					if (neoBuilding.buildingId === buildingId && neoBuilding.buildingType === buildingType) 
					{
						find = true;
						resultNode = node;
						return resultNode;
					}
				}
				else 
				{
					if (neoBuilding.buildingId === buildingId) 
					{
						find = true;
						resultNode = node;
						return resultNode;
					}
				}
				i++;
			}
		}	
	}
	else 
	{
		for (var i=0; i<this.subTiles.length; i++)
		{
			resultNode = this.subTiles[i].getNodeByBuildingId(buildingType, buildingId);
			if (resultNode)
			{ return resultNode; }
		}
	}
	
	return resultNode;
};
*/

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTile.prototype.getNeoBuildingById = function(buildingType, buildingId) 
{
	var resultNeoBuilding;
	var node = this.getNodeByBuildingId(buildingType, buildingId);
	if (node !== undefined)
	{ resultNeoBuilding = node.data.neoBuilding; }

	return resultNeoBuilding;
};

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTile.prototype.getBuildingSeedById = function(buildingType, buildingId) 
{
	var resultNeoBuildingSeed;
	var hasSubTiles = true;
	if (this.subTiles === undefined)
	{ hasSubTiles = false; }
	
	if (this.subTiles && this.subTiles.length === 0)
	{ hasSubTiles = false; }
		
	if (!hasSubTiles)
	{
		if (this.nodeSeedsArray)
		{
			var buildingCount = this.nodeSeedsArray.length;
			var find = false;
			var i=0;
			var buildingSeed, node;
			while (!find && i<buildingCount) 
			{
				node = this.nodeSeedsArray[i];
				buildingSeed = node.data.buildingSeed;
				if (buildingType)
				{
					if (buildingSeed.buildingId === buildingId && buildingSeed.buildingType === buildingType) 
					{
						find = true;
						resultNeoBuildingSeed = buildingSeed;
						return resultNeoBuildingSeed;
					}
				}
				else 
				{
					if (buildingSeed.buildingId === buildingId) 
					{
						find = true;
						resultNeoBuildingSeed = buildingSeed;
						return resultNeoBuildingSeed;
					}
				}
				i++;
			}
		}	
	}
	else 
	{
		for (var i=0; i<this.subTiles.length; i++)
		{
			resultNeoBuildingSeed = this.subTiles[i].getBuildingSeedById(buildingType, buildingId);
			if (resultNeoBuildingSeed)
			{ return resultNeoBuildingSeed; }
		}
	}
	
	return resultNeoBuildingSeed;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
SmartTile.prototype.TEST__hasLowestTiles_nodesArray = function() 
{
	
	var lowestTilesArray = [];
	this.extractLowestTiles(lowestTilesArray);
	var subTilesCount = lowestTilesArray.length;
	var find = false;
	var i=0;
	while (!find && i<subTilesCount)
	{
		if (lowestTilesArray[i].nodesArray && lowestTilesArray[i].nodesArray.length > 0)
		{
			return true;
		}
		i++;
	}
	
	return find;
	
};


/**
 * 타일의 min max coord를 이용하여 타원체를 생성 후 this.sphereExtent에 할당
 * @param {MagoManager} magoManager
 * 
 * @see SmartTile#computeSphereExtent
 */
SmartTile.prototype.makeSphereExtent = function(magoManager) 
{
	this.sphereExtent = SmartTile.computeSphereExtent(magoManager, this.minGeographicCoord, this.maxGeographicCoord, this.sphereExtent);
};

/**
 * Sphere에 반지름과 중심점을 담아서 반환.
 * @static
 * @param {MagoManager} magoManager
 * @param {GeographicCoord} minGeographicCoord
 * @param {GeographicCoord} maxGeographicCoord
 * @param {Sphere} resultSphereExtent
 * 
 * @returns {Sphere} resultSphereExtent
 */
SmartTile.computeSphereExtent = function(magoManager, minGeographicCoord, maxGeographicCoord, resultSphereExtent) 
{
	if (minGeographicCoord === undefined || maxGeographicCoord === undefined)
	{ return undefined; }
	
	if (resultSphereExtent === undefined)
	{ resultSphereExtent = new Sphere(); }
	
	// calculate worldCoord center position.
	var midLongitude = (maxGeographicCoord.longitude + minGeographicCoord.longitude)/2;
	var midLatitude = (maxGeographicCoord.latitude + minGeographicCoord.latitude)/2;
	var midAltitude = (maxGeographicCoord.altitude + minGeographicCoord.altitude)/2;
	
	resultSphereExtent.centerPoint = ManagerUtils.geographicCoordToWorldPoint(midLongitude, midLatitude, midAltitude, resultSphereExtent.centerPoint, magoManager);
	
	// calculate an aproximate radius.
	var cornerPoint;
	cornerPoint = ManagerUtils.geographicCoordToWorldPoint(minGeographicCoord.longitude, minGeographicCoord.latitude, minGeographicCoord.altitude, cornerPoint, magoManager);

	resultSphereExtent.r = resultSphereExtent.centerPoint.distTo(cornerPoint.x, cornerPoint.y, cornerPoint.z) * 1.1;
	return resultSphereExtent;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
SmartTile.prototype.putSmartTileF4dSeed = function(targetDepth, smartTileF4dSeed, magoManager) 
{
	if (this.sphereExtent === undefined)
	{ this.makeSphereExtent(magoManager); }
	
	// now, if the current depth < targetDepth, then descend.
	if (this.depth < targetDepth)
	{
		// create 4 child smartTiles.
		if (this.subTiles === undefined || this.subTiles.length === 0)
		{
			for (var i=0; i<4; i++)
			{ this.newSubTile(this); }
		}
		
		// set the sizes to subTiles (The minLongitude, MaxLongitude, etc. is constant, but the minAlt & maxAlt can will be modified every time that insert new buildingSeeds).
		this.setSizesToSubTiles();

		// intercept buildingSeeds for each subTiles.
		var geoCoord = smartTileF4dSeed.geographicCoord;
		var subSmartTile;
		var finish = false;
		var i=0;
		while (!finish && i<4)
		{
			subSmartTile = this.subTiles[i];
			if (subSmartTile.intersectPoint(geoCoord.longitude, geoCoord.latitude) )
			{
				subSmartTile.putSmartTileF4dSeed(targetDepth, smartTileF4dSeed, magoManager);
				finish = true;
			}
			
			i++;
		}
	}
	else if (this.depth === targetDepth)
	{
		if (this.smartTileF4dSeedArray === undefined)
		{ this.smartTileF4dSeedArray = []; }

		this.smartTileF4dSeedArray.push(smartTileF4dSeed);
		
		// test inserting dataPackage(lod4 & lod3).***
		var smTileName = smartTileF4dSeed.tileName;
		var splitted = smTileName.split('.');
		var smTileRawName = splitted[0];
		
		// copy all attributtes, except tileName.
		var smartTileF4dSeed_lod4 = {};
		smartTileF4dSeed_lod4.L = smartTileF4dSeed.L;
		smartTileF4dSeed_lod4.X = smartTileF4dSeed.X;
		smartTileF4dSeed_lod4.Y = smartTileF4dSeed.Y;
		smartTileF4dSeed_lod4.geographicCoord = smartTileF4dSeed.geographicCoord;
		smartTileF4dSeed_lod4.objectType = smartTileF4dSeed.objectType;
		smartTileF4dSeed_lod4.id = smartTileF4dSeed.id;
		smartTileF4dSeed_lod4.smartTileType = smartTileF4dSeed.smartTileType;
		smartTileF4dSeed_lod4.tileName = smTileRawName + "_4.sti";
		smartTileF4dSeed_lod4.projectFolderName = smartTileF4dSeed.projectFolderName;
		smartTileF4dSeed_lod4.fileLoadState = CODE.fileLoadState.READY;
		this.smartTileF4dSeedArray.push(smartTileF4dSeed_lod4);
		
		var smartTileF4dSeed_lod3 = {};
		smartTileF4dSeed_lod3.L = smartTileF4dSeed.L;
		smartTileF4dSeed_lod3.X = smartTileF4dSeed.X;
		smartTileF4dSeed_lod3.Y = smartTileF4dSeed.Y;
		smartTileF4dSeed_lod3.geographicCoord = smartTileF4dSeed.geographicCoord;
		smartTileF4dSeed_lod3.objectType = smartTileF4dSeed.objectType;
		smartTileF4dSeed_lod3.id = smartTileF4dSeed.id;
		smartTileF4dSeed_lod3.smartTileType = smartTileF4dSeed.smartTileType;
		smartTileF4dSeed_lod3.tileName = smTileRawName + "_3.sti";
		smartTileF4dSeed_lod3.projectFolderName = smartTileF4dSeed.projectFolderName;
		smartTileF4dSeed_lod3.fileLoadState = CODE.fileLoadState.READY;
		this.smartTileF4dSeedArray.push(smartTileF4dSeed_lod3);
		
		return true;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
SmartTile.prototype.putNode = function(targetDepth, node, magoManager) 
{
	if (this.sphereExtent === undefined)
	{ this.makeSphereExtent(magoManager); }
	
	// now, if the current depth < targetDepth, then descend.
	if (this.depth < targetDepth)
	{
		// create 4 child smartTiles.
		if (this.subTiles === undefined || this.subTiles.length === 0)
		{
			for (var i=0; i<4; i++)
			{ this.newSubTile(this); }
		}
		
		// set the sizes to subTiles (The minLongitude, MaxLongitude, etc. is constant, but the minAlt & maxAlt can will be modified every time that insert new buildingSeeds).
		this.setSizesToSubTiles();

		// intercept buildingSeeds for each subTiles.
		var subSmartTile;
		var finish = false;
		var i=0;
		while (!finish && i<4)
		{
			subSmartTile = this.subTiles[i];
			if (subSmartTile.intersectsNode(node))
			{
				subSmartTile.putNode(targetDepth, node, magoManager);
				finish = true;
			}
			
			i++;
		}
	}
	else if (this.depth === targetDepth)
	{
		if (this.nodeSeedsArray === undefined)
		{ this.nodeSeedsArray = []; }
		
		if (this.nodesArray === undefined)
		{ this.nodesArray = []; }
		
		node.data.smartTileOwner = this;
		
		this.nodeSeedsArray.push(node);
		this.nodesArray.push(node);
		
		// todo: Must recalculate the smartTile sphereExtent.
		//this.makeSphereExtent(magoManager);
		
		
		return true;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
SmartTile.prototype.putObject = function(targetDepth, object, magoManager) 
{
	if (this.sphereExtent === undefined)
	{ this.makeSphereExtent(magoManager); }
	
	// now, if the current depth < targetDepth, then descend.
	if (this.depth < targetDepth)
	{
		// create 4 child smartTiles.
		if (this.subTiles === undefined || this.subTiles.length === 0)
		{
			for (var i=0; i<4; i++)
			{ this.newSubTile(this); }
		}
		
		// set the sizes to subTiles (The minLongitude, MaxLongitude, etc. is constant, but the minAlt & maxAlt can will be modified every time that insert new buildingSeeds).
		this.setSizesToSubTiles();

		// intercept buildingSeeds for each subTiles.
		var geoLocData = object.geoLocDataManager.getCurrentGeoLocationData();
		var geoCoord = geoLocData.getGeographicCoords();
		
		var subSmartTile;
		var finish = false;
		var i=0;
		while (!finish && i<4)
		{
			subSmartTile = this.subTiles[i];
			if (subSmartTile.intersectPoint(geoCoord.longitude, geoCoord.latitude))
			{
				subSmartTile.putObject(targetDepth, object, magoManager);
				finish = true;
			}
			
			i++;
		}
	}
	else if (this.depth === targetDepth)
	{
		object.smartTileOwner = this;
		if (object instanceof MagoRenderable) 
		{
			if (object.objectType === MagoRenderable.OBJECT_TYPE.MESH)
			{
				if (object.isOpaque())
				{
					this.nativeObjects.opaquesArray.push(object);
				}
				else 
				{
					this.nativeObjects.transparentsArray.push(object);
				}
			}
			else if (object.objectType === MagoRenderable.OBJECT_TYPE.VECTORMESH)
			{
				this.nativeObjects.vectorTypeArray.push(object);
			}
		}
		else if (object instanceof Excavation) 
		{
			this.nativeObjects.excavationsArray.push(object);
		}
		// todo: Must recalculate the smartTile sphereExtent.
		return true;
	}
};


/**
 * 목표레벨까지 각 타일의 SUB타일 생성 및 노드의 위치와 교점이 있는지 파악 후 노드를 보관.
 * @param {Number} targetDepth
 * @param {MagoManager} magoManager
 */
SmartTile.prototype.makeTreeByDepth = function(targetDepth, magoManager) 
{
	if (this.nodeSeedsArray === undefined || this.nodeSeedsArray.length === 0)
	{ return; }

	this.targetDepth = targetDepth;
	
	// if this has "nodeSeedsArray" then make sphereExtent.
	this.makeSphereExtent(magoManager);
	
	// now, if the current depth < targetDepth, then descend.
	if (this.depth < targetDepth)
	{
		// create 4 child smartTiles.
		if (this.subTiles === undefined || this.subTiles.length === 0)
		{
			for (var i=0; i<4; i++)
			{ this.newSubTile(this); }
		}
		
		// set the sizes to subTiles (The minLongitude, MaxLongitude, etc. is constant, but the minAlt & maxAlt can will be modified every time that insert new buildingSeeds).
		this.setSizesToSubTiles();

		// intercept buildingSeeds for each subTiles.
		for (var i=0; i<4; i++)
		{
			this.subTiles[i].takeIntersectedBuildingSeeds(this.nodeSeedsArray);
		}
		
		// for each subTile that has intercepted buildingSeeds -> makeTree.
		for (var i=0; i<4; i++)
		{
			this.subTiles[i].makeTreeByDepth(targetDepth, magoManager);
		}
		
	}
	else 
	{
		var hola = 0;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
/*
SmartTile.prototype.getLowestTileWithNodeInside = function(node) 
{
	// this function returns the lowestTile with "node" if exist.
	if (this.subTiles === undefined)
	{
		var nodesCount = this.nodesArray.length;
		var i=0;
		while (i<nodesCount)
		{
			if (node == this.nodesArray[i])
			{
				return this;
			}
			i++;
		}
		return undefined;
	}
	else 
	{	
		var subTilesCount = this.subTiles.length;
		var lowestTile;
		for (var i=0; i<subTilesCount; i++)
		{
			lowestTile = this.subTiles[i].getLowestTileWithNodeInside(node);
			if (lowestTile)
			{ return lowestTile; }
		}
		
		return undefined;
	}
};
*/

/**
 * 타일과 노드의 포함유무 체크
 * @param {Node} node 포함유무를 체크할 
 * @return {Boolean}
 * 
 * @see this#intersectPoint
 */
SmartTile.prototype.intersectsNode = function(node) 
{
	var intersects = false;
	var buildingSeed = node.data.buildingSeed;
	var rootNode = node.getRoot();
	
	// Find geographicCoords as is possible.
	var longitude, latitude;
	
	if (rootNode.data.bbox !== undefined && rootNode.data.bbox.geographicCoord !== undefined)
	{
		longitude = rootNode.data.bbox.geographicCoord.longitude;
		latitude = rootNode.data.bbox.geographicCoord.latitude;
	}
	else if (buildingSeed !== undefined)
	{
		// in this case take the data from buildingSeed.
		longitude = buildingSeed.geographicCoordOfBBox.longitude;
		latitude = buildingSeed.geographicCoordOfBBox.latitude;
	}
	else
	{
		longitude = node.data.geographicCoord.longitude;
		latitude = node.data.geographicCoord.latitude;
	}
	
	if (this.intersectPoint(longitude, latitude))
	{
		intersects = true;
	}
	
	return intersects;
};

/**
 * 해당 타일에 속하는 Node를 찾아서 nodeseedsArray에 추가.
 * Node의 smartTileOwner에 해당 SmartTile 인스턴스를 할당.
 * @param {Array.<Node>} nodeSeedsArray Node Array
 * 
 * @see this#intersectsNode
 */
SmartTile.prototype.takeIntersectedBuildingSeeds = function(nodeSeedsArray) 
{
	// this function intersects the buildingSeeds with this tile.
	// this function is used only one time when load a initial buildings distributions on the globe.
	var buildingSeed;
	var node, rootNode;
	var buildingSeedsCount = nodeSeedsArray.length;
	for (var i=0; i<buildingSeedsCount; i++)
	{
		node = nodeSeedsArray[i];
		if (this.intersectsNode(node))
		{
			nodeSeedsArray.splice(i, 1);
			i--;
			buildingSeedsCount = nodeSeedsArray.length;
			
			if (this.nodeSeedsArray === undefined)
			{ this.nodeSeedsArray = []; }
		
			// Set the smartTileOwner, for fast move of the node between smartTiles.
			node.data.smartTileOwner = this;
			
			this.nodeSeedsArray.push(node);
			
			// now, redefine the altitude limits of this tile.
			var buildingSeed = node.data.buildingSeed;
			if (buildingSeed !== undefined)
			{
				var altitude = buildingSeed.geographicCoordOfBBox.altitude;
				var bboxRadius = buildingSeed.bBox.getRadiusAprox();
				if (altitude-bboxRadius < this.minGeographicCoord.altitude)
				{
					this.minGeographicCoord.altitude = altitude-bboxRadius;
				}
				if (altitude+bboxRadius > this.maxGeographicCoord.altitude)
				{
					this.maxGeographicCoord.altitude = altitude+bboxRadius;
				}
			}
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
/*
SmartTile.prototype.calculateAltitudeLimits = function() 
{
	// this function calculates the minAltitude and maxAltitude of the tile.
	// init the altitudes.
	this.minGeographicCoord.altitude = 0;
	this.maxGeographicCoord.altitude = 0;
	
	var buildingSeed;
	var buildingSeedsCount = this.buildingSeedsArray.length;
	for (var i=0; i<buildingSeedsCount; i++)
	{
		buildingSeed = this.buildingSeedsArray[i];

		var altitude = buildingSeed.geographicCoordOfBBox.altitude;
		var bboxRadius = buildingSeed.bBox.getRadiusAprox();
		if (altitude-bboxRadius < this.minGeographicCoord.altitude)
		{
			this.minGeographicCoord.altitude = altitude-bboxRadius;
		}
		if (altitude+bboxRadius > this.maxGeographicCoord.altitude)
		{
			this.maxGeographicCoord.altitude = altitude+bboxRadius;
		}
	}
};
*/

/**
 * 위경도를 받아서 현재 타일인스턴스와의 포함유무 반환.
 * @param {Number} longitude
 * @param {Number} latitude
 * 
 * @return {boolean}
 */
SmartTile.prototype.intersectPoint = function(longitude, latitude) 
{
	if (longitude < this.minGeographicCoord.longitude || longitude > this.maxGeographicCoord.longitude)
	{ return false; }
	
	if (latitude < this.minGeographicCoord.latitude || latitude > this.maxGeographicCoord.latitude)
	{ return false; }
	
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
SmartTile.prototype.eraseNode = function(node) 
{
	//this.nodeSeedsArray;
	//this.nodesArray;
	
	// Erase from this.nodeSeedsArray & this.nodesArray.
	if (this.nodeSeedsArray !== undefined)
	{
		var nodeSeedsCount = this.nodeSeedsArray.length;
		var finished = false;
		var i = 0;
		while (!finished && i<nodeSeedsCount)
		{
			if (this.nodeSeedsArray[i] === node)
			{
				this.nodeSeedsArray.splice(i, 1);
				finished = true;
			}
			i++;
		}
	}
	
	if (this.nodesArray !== undefined)
	{
		var nodesCount = this.nodesArray.length;
		finished = false;
		i = 0;
		while (!finished && i<nodesCount)
		{
			if (this.nodesArray[i] === node)
			{
				this.nodesArray.splice(i, 1);
				finished = true;
			}
			i++;
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
SmartTile.prototype.calculateDistToCamera = function(camera) 
{
	var sphereExtent = this.getSphereExtent();
	this.distToCamera = sphereExtent.distToPoint3D(camera.position);
	return this.distToCamera;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
SmartTile.prototype.extractLowestTiles = function(camera, resultLowestTilesArray, maxDistToCamera) 
{
	if (this.hasRenderables())
	{
		// Calculate distToCamera to sort by distance.
		var distToCam = this.calculateDistToCamera(camera);
		if (distToCam < SmartTileManager.maxDistToCameraByDepth(this.depth))
		{ 
			this.intersectionType = Constant.INTERSECTION_INSIDE;
			this.putSmartTileInEyeDistanceSortedArray(resultLowestTilesArray, this); 
		}
	}
		
	if (this.subTiles === undefined || this.subTiles.length === 0)
	{
		return;
	}
		
	var subTilesCount = this.subTiles.length;
	for (var i=0; i<subTilesCount; i++)
	{
		this.subTiles[i].extractLowestTiles(camera, resultLowestTilesArray, maxDistToCamera);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
SmartTile.prototype.getFrustumIntersectedLowestTiles = function(camera, frustum, resultFullyIntersectedTilesArray, maxDistToCamera) 
{
	var fullyIntersectedTiles = [];
	var partiallyIntersectedTilesArray = [];
	this.getFrustumIntersectedTiles(camera, frustum, fullyIntersectedTiles, partiallyIntersectedTilesArray, maxDistToCamera);
	resultFullyIntersectedTilesArray.push.apply(resultFullyIntersectedTilesArray, partiallyIntersectedTilesArray);
	
	var intersectedTilesCount = fullyIntersectedTiles.length;
	for (var i=0; i<intersectedTilesCount; i++)
	{
		fullyIntersectedTiles[i].extractLowestTiles(camera, resultFullyIntersectedTilesArray, maxDistToCamera);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
SmartTile.prototype.getFrustumIntersectedTiles = function(camera, frustum, resultFullyIntersectedTilesArray, resultPartiallyIntersectedTilesArray, maxDistToCamera) 
{
	if (this.sphereExtent === undefined)
	{ return Constant.INTERSECTION_OUTSIDE; }
	
	this.intersectionType = frustum.intersectionSphere(this.sphereExtent);
	
	if (this.intersectionType === Constant.INTERSECTION_OUTSIDE)
	{ return; }
	else if (this.intersectionType === Constant.INTERSECTION_INSIDE)
	{
		resultFullyIntersectedTilesArray.push(this);
		return;
	}
	else if (this.intersectionType === Constant.INTERSECTION_INTERSECT)
	{
		if (this.hasRenderables())
		{ 
			// Calculate the distToCamera.
			var distToCam = this.calculateDistToCamera(camera);
			if (distToCam < SmartTileManager.maxDistToCameraByDepth(this.depth))
			{ this.putSmartTileInEyeDistanceSortedArray(resultPartiallyIntersectedTilesArray, this); }
		} 
			
		if (this.subTiles && this.subTiles.length > 0)
		{
			for (var i=0; i<this.subTiles.length; i++)
			{
				if (this.subTiles[i].sphereExtent)
				{ this.subTiles[i].getFrustumIntersectedTiles(camera, frustum, resultFullyIntersectedTilesArray, resultPartiallyIntersectedTilesArray, maxDistToCamera); }
			}
		}
	}
};
/*
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
SmartTile.prototype.getSphereIntersectedTiles = function(sphere, resultIntersectedTilesArray, maxDepth) 
{
	if (this.depth > maxDepth)
	{ return Constant.INTERSECTION_OUTSIDE; }
	
	if (this.sphereExtent === undefined)
	{ return Constant.INTERSECTION_OUTSIDE; }
	
	var intersectionType = sphere.intersectionSphere(this.sphereExtent);
	
	if (intersectionType === Constant.INTERSECTION_OUTSIDE)
	{ return Constant.INTERSECTION_OUTSIDE; }
	else
	{
		if (this.hasRenderables())
		{ 
			resultIntersectedTilesArray.push(this);
		} 
			
		if (this.subTiles && this.subTiles.length > 0)
		{
			for (var i=0; i<this.subTiles.length; i++)
			{
				if (this.subTiles[i].sphereExtent)
				{ this.subTiles[i].getSphereIntersectedTiles(sphere, resultIntersectedTilesArray, maxDepth); }
			}
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param result_smartTilesArray 변수
 * @param smartTile 변수
 */
SmartTile.prototype.putSmartTileInEyeDistanceSortedArray = function(result_smartTilesArray, smartTile) 
{
	// sorting is from minDist to maxDist.
	if (result_smartTilesArray.length > 0)
	{
		var startIdx = 0;
		var endIdx = result_smartTilesArray.length - 1;
		var insert_idx= ManagerUtils.getIndexToInsertBySquaredDistToEye(result_smartTilesArray, smartTile, startIdx, endIdx);

		result_smartTilesArray.splice(insert_idx, 0, smartTile);
	}
	else 
	{
		result_smartTilesArray.push(smartTile);
	}
};

/**
 * This function returns true if this smartTile has renderables objects.
 */
SmartTile.prototype.hasRenderables = function() 
{
	var hasObjects = false;
	
	if (this.nodeSeedsArray !== undefined &&  this.nodeSeedsArray.length > 0)
	{ return true; }

	if (this.nodesArray !== undefined &&  this.nodesArray.length > 0)
	{ return true; }

	// check if has smartTileF4dSeeds.***
	if (this.smartTileF4dSeedArray !== undefined && this.smartTileF4dSeedArray.length > 0)
	{ return true; }

	// check native objects.
	var nativeObjects = this.nativeObjects;
	if (nativeObjects.opaquesArray.length > 0 || nativeObjects.transparentsArray.length > 0 || nativeObjects.excavationsArray.length > 0 || nativeObjects.vectorTypeArray.length > 0)
	{ return true; }
	
	//if (this.objectsArray !== undefined && this.objectsArray.length > 0)
	//{ return true; }
	
	return hasObjects;
};

/**
 * This function returns true if this smartTile needs create geometries from sedds.
 */
SmartTile.prototype.isNeededToCreateGeometriesFromSeeds = function() 
{
	var isNeeded = false;
	
	if (this.nodeSeedsArray !== undefined)
	{
		if (this.nodesArray === undefined)
		{ return true; }
		
		if (this.nodesArray.length !== this.nodeSeedsArray.length)
		{ return true; }
	}
	
	if (this.smartTileF4dSeedArray !== undefined && this.smartTileF4dSeedArray.length > 0)
	{ 
		var smartTilesF4dCount = this.smartTileF4dSeedArray.length;
		for (var i=0; i<smartTilesF4dCount; i++)
		{
			if (this.smartTileF4dSeedArray[i].fileLoadState !== CODE.fileLoadState.PARSE_FINISHED)
			{ return true; }
		} 
	}
	
	return isNeeded;
};

/**
 */
SmartTile.prototype.setNodesAttribute = function(nodesArray, attributeName, attributeValue) 
{
	if (nodesArray !== undefined)
	{
		var nodesCount = nodesArray.length;
		for (var i=0; i<nodesCount; i++)
		{
			var node = nodesArray[i];
			if (node.data.attributes === undefined)
			{ node.data.attributes = {}; }
			
			node.data.attributes[attributeName] = attributeValue;
		}
	}
};

/**
 */
SmartTile.prototype.createGeometriesFromSeeds = function(magoManager) 
{
	// create the buildings by buildingSeeds.
	var node;
	var neoBuilding;
	var nodeBbox;
	var buildingSeed;
	var startIndex = 0;
	
	var geometriesCreated = false;
	
	// if exist nodesArray (there are buildings) and add a nodeSeed, we must make nodes of the added nodeSeeds.***
	if (this.nodeSeedsArray !== undefined)
	{
		//if (this.nodesArray)
		//{ startIndex = this.nodesArray.length; }

		if (this.nodesArray === undefined)
		{ this.nodesArray = []; }

		var nodeSeedsCount = this.nodeSeedsArray.length;
		var nodesCount = this.nodesArray.length;
		
		if (nodeSeedsCount !== nodesCount)
		{
			this.setNodesAttribute(this.nodeSeedsArray, "needCreated", 1);
			this.setNodesAttribute(this.nodesArray, "needCreated", 0);
			
			for (var j=0; j<nodeSeedsCount; j++)
			{
				node = this.nodeSeedsArray[j];
				
				if (node.data.attributes.needCreated === 1)
				{
					var attributes = node.data.attributes;
					if (attributes.objectType === "basicF4d" && !attributes.fromSmartTile)
					{
						if (attributes.projectId !== undefined && attributes.isReference !== undefined && attributes.isReference === true)
						{
							StaticModelsManager.manageStaticModel(node, magoManager);
						}
					
						if (node.data.neoBuilding !== undefined)
						{
							this.nodesArray.push(node);
							continue;
						}
						
						neoBuilding = new NeoBuilding();
						
						// Test.
						neoBuilding.setAttribute("keepDataArrayBuffers", true);
						// End test.
						
						neoBuilding.nodeOwner = node;
						node.data.neoBuilding = neoBuilding;
						if (node.data.bbox === undefined)
						{ node.data.bbox = new BoundingBox(); }
						nodeBbox = node.data.bbox;
						buildingSeed = node.data.buildingSeed;
						
						this.nodesArray.push(node);
						
						if (neoBuilding.metaData === undefined) 
						{ neoBuilding.metaData = new MetaData(); }

						if (neoBuilding.metaData.geographicCoord === undefined)
						{ neoBuilding.metaData.geographicCoord = new GeographicCoord(); }

						if (neoBuilding.metaData.bbox === undefined) 
						{ neoBuilding.metaData.bbox = new BoundingBox(); }

						// create a building and set the location.***
						neoBuilding.name = buildingSeed.name;
						neoBuilding.buildingId = buildingSeed.buildingId;
					
						neoBuilding.buildingType = "basicBuilding";
						neoBuilding.buildingFileName = buildingSeed.buildingFileName;
						neoBuilding.metaData.geographicCoord.setLonLatAlt(buildingSeed.geographicCoord.longitude, buildingSeed.geographicCoord.latitude, buildingSeed.geographicCoord.altitude);
						neoBuilding.metaData.bbox.copyFrom(buildingSeed.bBox);
						nodeBbox.copyFrom(buildingSeed.bBox); // initially copy from building.
						if (neoBuilding.bbox === undefined)
						{ neoBuilding.bbox = new BoundingBox(); }
						neoBuilding.bbox.copyFrom(buildingSeed.bBox);
						neoBuilding.metaData.heading = buildingSeed.rotationsDegree.z;
						neoBuilding.metaData.pitch = buildingSeed.rotationsDegree.x;
						neoBuilding.metaData.roll = buildingSeed.rotationsDegree.y;
						neoBuilding.projectFolderName = node.data.projectFolderName;
						
						geometriesCreated = true;

						magoManager.emit(MagoManager.EVENT_TYPE.F4DRENDERREADY, {
							type      : MagoManager.EVENT_TYPE.F4DRENDERREADY,
							f4d       : node,
							timestamp : new Date()
						});
					}
				}
				//else if (attributes.objectType === "multiBuildingsTile")
				//{
				//	if (node.data.multiBuildings !== undefined)
				//	{
				//		this.nodesArray.push(node);
				//		continue;
				//	}
				//	
				//	var multiBuildings = new MultiBuildings();
				//	multiBuildings.nodeOwner = node;
				//	multiBuildings.attributes = attributes;
				//	node.data.multiBuildings = multiBuildings;
				//	
				//	geometriesCreated = true;
				//}
			}
		}
	}
	
	// Now, check if exist smartTileF4dSeeds.***
	var distToCam = this.distToCamera; // use distToCam to decide load & parse smartTiles.
	
	if (this.smartTileF4dSeedArray !== undefined)
	{
		var smartTileF4dSeedsCount = this.smartTileF4dSeedArray.length;
		for (var i=0; i<smartTileF4dSeedsCount; i++)
		{
			var smartTileF4dSeed = this.smartTileF4dSeedArray[i];
			if (smartTileF4dSeed.fileLoadState === undefined)
			{ smartTileF4dSeed.fileLoadState = CODE.fileLoadState.READY; }
			
			if (i > 0)
			{
				// check if the previous level is parsedFinished.
				if (this.smartTileF4dSeedArray[i-1].fileLoadState !== CODE.fileLoadState.PARSE_FINISHED)
				{ break; }
			
				if (distToCam > magoManager.magoPolicy.getLod4DistInMeters())
				{ break; }
			}
			
			if (smartTileF4dSeed.fileLoadState === CODE.fileLoadState.READY)
			{
				//this.smartTileF4dSeedMap[name] = {
				//"L"                 : L,
				//"X"                 : X,
				//"Y"                 : Y,
				//"geographicCoord"   : centerGeoCoord,
				//"objectType"        : "F4dTile",
				//"id"                : f4dTileId,
				//"tileName"          : name,
				//"projectFolderName" : projectFolderName};
				if (magoManager.readerWriter.smartTileF4d_requested < 3)
				{
					var readerWriter = magoManager.readerWriter;
					var projectFolderName = smartTileF4dSeed.projectFolderName;
					var L = smartTileF4dSeed.L.toString();
					var X = smartTileF4dSeed.X.toString();
					var tilename = smartTileF4dSeed.tileName;
					var smartTileOwner = this;
					var geometryDataPath = readerWriter.geometryDataPath; // default geometryDataPath = "/f4d".***
					var fileName = geometryDataPath + "/" + projectFolderName + "/" + L + "/" + X + "/" + tilename;
					
					readerWriter.getSmartTileF4d(fileName, smartTileF4dSeed, smartTileOwner, magoManager);
				}
				break;
			}
			else if (smartTileF4dSeed.fileLoadState === CODE.fileLoadState.LOADING_FINISHED )
			{
				// parse the dataArrayBuffer.***
				var maxParses = 30;
				if (i > 0)
				{ maxParses = 5; }
				var parseQueue = magoManager.parseQueue;
				if (parseQueue.smartTileF4dParsesCount < maxParses)
				{
					// proceed to parse the dataArrayBuffer.***
					this.parseSmartTileF4d(smartTileF4dSeed.dataArrayBuffer, magoManager);
					parseQueue.smartTileF4dParsesCount++; // increment counter.
					smartTileF4dSeed.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
				
					geometriesCreated = true;
					break;
				}
			}
		}
	}

	return geometriesCreated;
};

/**
 */
SmartTile.prototype.parseSmartTileF4d = function(dataArrayBuffer, magoManager) 
{
	var hierarchyManager = magoManager.hierarchyManager;
	var readWriter = magoManager.readerWriter;
	var smartTileManager = magoManager.smartTileManager;
	var targetDepth = 17;
	
	if (targetDepth > this.depth)
	{ targetDepth = this.depth; }

	if (this.nodesArray === undefined)
	{ this.nodesArray = []; }

	if (this.sphereExtent === undefined)
	{ this.makeSphereExtent(magoManager); }

	var enc = new TextDecoder("utf-8");
	
	// parse smartTileF4d.***
	var bytesReaded = 0;
	var smartTileType = (new Int32Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	var buildingsCount = (new Int32Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	magoManager.emit(MagoManager.EVENT_TYPE.SMARTTILELOADSTART, {tile: this, timestamp: new Date()});

  var smartTilePathInfo = magoManager.f4dController.smartTilePathInfo;
  var hardcodeList = ['F4D_mapo_health_center_del','F4D_NorthSeoulArt_del',
  'F4D_Sadang_del','F4D_Sangdo3dong_del','F4D_Seodaemun_del',
  'F4D_Seobu_del','F4D_Seobingo_del','F4D_Sesomoon1_3_del',
  'F4D_Sesomoon2dong_del','F4D_seoul_museum_del',
  'F4D_SEOULHISTORICA_del','F4D_Simincheong_del',
  'F4D_Edumuseum_del_150417_02','F4D_SEOULSTATION_del',
  'F4D_GyeomjaeJeongSeon_del','F4D_Gwangjin_center_del',
  'F4D_Gangsu_office_del','F4D_gangil_del',
  'F4D_GasanDigital_del','F4D_SD_COUNCIL_del',
  'F4D_Seongdong_del','F4D_Seongbuk_del','F4D_SeongBuck_del',
  'F4D_Main_del','F4D_Sinnae_del','F4D_Yongsan_del',
  'F4D_imun_del','F4D_Leejina_del','F4D_junggok_del',
  'F4D_GARAK_del','F4D_Jungnanggu-public-library_del',
  'F4D_gangnamgu_office_del','F4D_gangdongguoffice_del_1222_02'];
  
	for (var i=0; i<buildingsCount; i++)
	{
		// read projectId.
		var projectId = "";
		var wordLength = (new Uint16Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+2)))[0]; bytesReaded += 2;
		projectId = enc.decode(new Int8Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+ wordLength))) ;bytesReaded += wordLength;
		
		// read buildingId.
		var buildingId = "";
		wordLength = (new Uint16Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+2)))[0]; bytesReaded += 2;
		buildingId = enc.decode(new Int8Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+ wordLength))) ;bytesReaded += wordLength;

		var projectFolderName = smartTilePathInfo[projectId].projectFolderPath;
		var savedProjectId = smartTilePathInfo[projectId].projectId;
		
		// Create a node for each building.
		var attributes = {
			"isPhysical" : true,
			"objectType" : "basicF4d"
    };
    if(hardcodeList.indexOf(buildingId) > -1) attributes.flipYTexCoords = true;
		if (projectFolderName.indexOf('-tree') > 0) 
		{
			attributes.isReference = true;
			
			if (!magoManager.isExistStaticModel(savedProjectId)) 
			{
				magoManager.addStaticModel({
					projectId          : savedProjectId,
					projectFolderName  : projectFolderName,
					buildingFolderName : buildingId
				});
			}
		}

		var commonAttr = magoManager.hierarchyManager.getNodeByDataKey(savedProjectId, 'attributes');
		if (commonAttr) 
		{
			attributes.isVisible = commonAttr.isVisible;
		}

		// Now, must check if the node exists.
		var node = hierarchyManager.getNodeByDataKey(savedProjectId, buildingId);
		var neoBuilding;
		var data;
		var metadataByteSize = (new Int32Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
		var startBuff = bytesReaded;
		var endBuff = bytesReaded + metadataByteSize;
		var neoBuildingHeaderData = dataArrayBuffer.slice(startBuff, endBuff);
		bytesReaded = bytesReaded + metadataByteSize; // updating data.

		var prefix = 'F4D_';
		var data_name = buildingId.startsWith(prefix) ? buildingId.replace(prefix, '') : buildingId;
		if (!node)
		{ 
			if (!attributes.isReference) 
			{
				node = hierarchyManager.newNode(buildingId, savedProjectId, attributes); 
				// Create a neoBuilding.
				data = node.data;
				data.projectFolderName = projectFolderName;
				data.projectId = savedProjectId;// + ".json";
				data.data_name = data_name;
				data.attributes = attributes;
				data.attributes.fromSmartTile = true;
				data.mapping_type = "origin";
			
				neoBuilding = new NeoBuilding();
				data.neoBuilding = neoBuilding;
				neoBuilding.buildingFileName = buildingId;
				neoBuilding.buildingId = buildingId;
				neoBuilding.projectFolderName = projectFolderName;
				neoBuilding.nodeOwner = node;
				
				neoBuilding.headerDataArrayBuffer = neoBuildingHeaderData;
				if (neoBuilding.metaData === undefined) 
				{ neoBuilding.metaData = new MetaData(); }
				neoBuilding.metaData.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
			}
		}
		else 
		{
			if (!attributes.isReference) 
			{
				data = node.data;
				neoBuilding = data.neoBuilding;
				
				if (neoBuilding === undefined)
				{
					neoBuilding = new NeoBuilding();
					data.neoBuilding = neoBuilding;
					neoBuilding.buildingFileName = buildingId;
					neoBuilding.buildingId = buildingId;
					neoBuilding.projectFolderName = projectFolderName;
					neoBuilding.nodeOwner = node;
				}
	
				var headerDataArrayBuffer = neoBuildingHeaderData; // Step over "dataArrayBuffer".
				if (neoBuilding.metaData === undefined) 
				{ 
					neoBuilding.metaData = new MetaData(); 
					neoBuilding.headerDataArrayBuffer = headerDataArrayBuffer;
					neoBuilding.metaData.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
				}
			}
		}
		var lodString = "lod5"; // default.
		if (smartTileType === 2)
		{
			// NEW. Read "LOD".*** NEW. Read "LOD".*** NEW. Read "LOD".*** NEW. Read "LOD".*** NEW. Read "LOD".***
			var lod = (new Int8Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+1)))[0]; bytesReaded += 1;
			lodString = "lod" + lod.toString();
		}
		var lodNameLength = (new Uint16Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+2)))[0]; bytesReaded += 2;
		var lodName = enc.decode(new Int8Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+ lodNameLength))) ;bytesReaded += lodNameLength;
		
		// read lod5 mesh data.
		var lod5meshSize = (new Int32Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
		var startBuff = bytesReaded;
		var endBuff = bytesReaded + lod5meshSize;
		var lowLodMeshDataArray = dataArrayBuffer.slice(startBuff, endBuff);
		bytesReaded = bytesReaded + lod5meshSize; // updating data.

		// read lod5 image.
		var lod5ImageSize = (new Int32Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
		var byteSize = 1;
		var startBuff = bytesReaded;
		var endBuff = bytesReaded + byteSize * lod5ImageSize;
		var lodBuildingTextureData = dataArrayBuffer.slice(startBuff, endBuff);
		bytesReaded = bytesReaded + byteSize * lod5ImageSize; // updating data.

		// read geographicCoord.
		var geoCoord = new GeographicCoord();
		bytesReaded = geoCoord.readDataFromBuffer(dataArrayBuffer, bytesReaded);
		// read euler angles degree.
		var eulerAngDeg = new Point3D();
		bytesReaded = eulerAngDeg.readDataFromBuffer(dataArrayBuffer, bytesReaded);
		var dataId = (new Int32Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
		var dataGroupId = (new Int32Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
		var endMark = (new Int8Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+1)))[0]; bytesReaded += 1;

		var externInfo = {};
		while (endMark > 0)
		{
			// There are more data.
			if (endMark === 5) // the next data is string type data.***
			{
				// read the stringKey.
				var dataKeyLength = (new Uint16Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+2)))[0]; bytesReaded += 2;
				var dataKey = enc.decode(new Int8Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+ dataKeyLength))) ;bytesReaded += dataKeyLength;
				
				// read the string value.
				var dataValueLength = (new Uint16Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+2)))[0]; bytesReaded += 2;
				var charArray = new Uint8Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+ dataValueLength)); bytesReaded += dataValueLength;
				//var dataValue = enc.decode(new Int8Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+ dataValueLength))) ;bytesReaded += dataValueLength;
				var decoder = new TextDecoder('utf-8');
				var dataValueUtf8 = decoder.decode(charArray);
				
				// Put the readed data into externInfo.***
				externInfo[dataKey] = dataValueUtf8;
			}
			
			endMark = (new Int8Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+1)))[0]; bytesReaded += 1;
		}

		if (!attributes.isReference) 
		{
			var lodBuilding = neoBuilding.getOrNewLodBuilding(lodString);
			var lowLodMesh = neoBuilding.getOrNewLodMesh(lodName);
			
			lowLodMesh.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
			lowLodMesh.dataArrayBuffer = lowLodMeshDataArray;

			if (lodBuilding.texture === undefined)
			{ lodBuilding.texture = new Texture(); }
		
			lodBuilding.texture.imageBinaryData = lodBuildingTextureData;
			lodBuilding.texture.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;

			node.data.geographicCoord = geoCoord;
			node.data.rotationsDegree = eulerAngDeg; 
			node.data.dataId = dataId;
			node.data.dataGroupId = savedProjectId;

			node.data.smartTileOwner = this;
			for (var j in externInfo) 
			{
				if (externInfo.hasOwnProperty(j)) 
				{
					node.data[j] = externInfo[j];
				}
			}

			this.nodesArray.push(node);
		}
		else 
		{
			var lon = geoCoord.longitude;
			var lat = geoCoord.latitude;
			var alt = geoCoord.altitude;
			magoManager.instantiateStaticModel({
				projectId  : savedProjectId,
				instanceId : buildingId,
				longitude  : lon,
				latitude   : lat,
				height     : alt,
				heading    : eulerAngDeg.z,
				pitch      : eulerAngDeg.x,
				roll       : eulerAngDeg.y
			});

			var intantiatedNode = hierarchyManager.getNodeByDataKey(savedProjectId, buildingId);

			intantiatedNode.data.dataId = dataId;
			intantiatedNode.data.dataGroupId = savedProjectId;
			intantiatedNode.data.projectFolderName = projectFolderName;
			for (var j in externInfo) 
			{
				if (externInfo.hasOwnProperty(j)) 
				{
					intantiatedNode.data[j] = externInfo[j];
				}
			}
			this.nodesArray.push(intantiatedNode);
		}
	}
	magoManager.emit(MagoManager.EVENT_TYPE.SMARTTILELOADEND, {
		tile      : this,  
		timestamp : new Date()
	});
	//this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
SmartTile.selectTileAngleRangeByDepth = function(depth) 
{
	if (depth === undefined || depth < 0 || depth > 21)
	{ return undefined; }
	
	if (depth === 0)
	{ return 180; }
	if (depth === 1)
	{ return 90; }
	if (depth === 2)
	{ return 45; }
	if (depth === 3)
	{ return 22.5; }
	if (depth === 4)
	{ return 11.25; }
	if (depth === 5)
	{ return 5.625; }
	if (depth === 6)
	{ return 2.8125; }
	if (depth === 7)
	{ return 1.40625; }
	if (depth === 8)
	{ return 0.703125; }
	if (depth === 9)
	{ return 0.3515625; }
	if (depth === 10)
	{ return 0.17578125; }
	if (depth === 11)
	{ return 0.087890625; }
	if (depth === 12)
	{ return 0.043945313; }
	if (depth === 13)
	{ return 0.021972656; }
	if (depth === 14)
	{ return 0.010986328; }
	if (depth === 15)
	{ return 0.010986328/2.0; }
	if (depth === 16)
	{ return 0.010986328 / 4.0; }
	if (depth === 17)
	{ return 0.010986328 / 8.0; }
	if (depth === 18)
	{ return 0.010986328 / 16.0; }
	if (depth === 19)
	{ return 0.010986328 / 32.0; }
	if (depth === 20)
	{ return 0.010986328 / 64.0; }
	if (depth === 21)
	{ return 0.010986328 / 128.0; }
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
SmartTile.selectTileName = function(depth, longitude, latitude, resultTileName) 
{
	var xMin = -180.0;
	var yMin = 90.0;
	var angRange = SmartTile.selectTileAngleRangeByDepth(depth);
	
	var xIndex = Math.floor((longitude - xMin)/angRange);
	// with yMin = -90.0;
	//var yIndex = Math.floor((latitude - yMin)/angRange);
	var yIndex = Math.floor((yMin - latitude)/angRange);
	resultTileName = depth.toString() + "\\" + xIndex.toString() + "\\" + yIndex.toString();
	return resultTileName;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
SmartTile.getGeographicExtentOfTileLXY = function(L, X, Y, resultGeoExtend) 
{
	var angRange = SmartTile.selectTileAngleRangeByDepth(L);
	var minLon = angRange*X - 180.0;
	var maxLon = angRange*(X+1) - 180.0;
	var minLat = 90.0 - angRange*(Y+1);
	var maxLat = 90.0 - angRange*(Y);
	
	if (resultGeoExtend === undefined)
	{ resultGeoExtend = new GeographicExtent(); }
	
	resultGeoExtend.setExtent(minLon, minLat, 0, maxLon, maxLat, 0);
	return resultGeoExtend;
};


/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
 
SmartTile.getFrustumIntersectedTilesNames = function(frustum, maxDepth, camPos, magoManager, resultIntersectedTilesNamesMap) 
{
	var currMinGeographicCoords = new GeographicCoord();
	var currMaxGeographicCoords = new GeographicCoord();
	var currDepth = 0;
	
	if (resultIntersectedTilesNamesMap === undefined)
	{ resultIntersectedTilesNamesMap = []; }
	
	// America side.
	currMinGeographicCoords.setLonLatAlt(-180, -90, 0);
	currMaxGeographicCoords.setLonLatAlt(0, 90, 0);
	currDepth = 0;
	SmartTile.getFrustumIntersectedTilesNamesForGeographicExtent(frustum, maxDepth, currDepth, camPos, currMinGeographicCoords, currMaxGeographicCoords, magoManager, magoManager.boundingSphere_Aux, 
		resultIntersectedTilesNamesMap);
	
	// Asia side.
	currMinGeographicCoords.setLonLatAlt(0, -90, 0);
	currMaxGeographicCoords.setLonLatAlt(180, 90, 0);
	currDepth = 0;
	SmartTile.getFrustumIntersectedTilesNamesForGeographicExtent(frustum, maxDepth, currDepth, camPos, currMinGeographicCoords, currMaxGeographicCoords, magoManager, magoManager.boundingSphere_Aux, 
		resultIntersectedTilesNamesMap);
		
	return resultIntersectedTilesNamesMap;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
 
SmartTile.getFrustumIntersectedTilesNamesForGeographicExtent = function(frustum, maxDepth, currDepth, camPos, currMinGeographicCoords, currMaxGeographicCoords, magoManager, sphereExtentAux, resultFullyIntersectedTilesNamesMap) 
{
	// STATIC FUNCTION.
	// 1rst, make a sphereExtent.
	
	sphereExtentAux = SmartTile.computeSphereExtent(magoManager, currMinGeographicCoords, currMaxGeographicCoords, sphereExtentAux);

	var intersectionType = frustum.intersectionSphere(sphereExtentAux);
	
	if (intersectionType === Constant.INTERSECTION_OUTSIDE)
	{ return; }
	else if (intersectionType === Constant.INTERSECTION_INSIDE)
	{
		var midLon = (currMinGeographicCoords.longitude + currMaxGeographicCoords.longitude)/2;
		var midLat = (currMinGeographicCoords.latitude + currMaxGeographicCoords.latitude)/2;
		var tileName = SmartTile.selectTileName(currDepth, midLon, midLat, undefined);
		var geographicExtent = new GeographicExtent();
		geographicExtent.minGeographicCoord = new GeographicCoord(currMinGeographicCoords.longitude, currMinGeographicCoords.latitude, currMinGeographicCoords.altitude);
		geographicExtent.maxGeographicCoord = new GeographicCoord(currMaxGeographicCoords.longitude, currMaxGeographicCoords.latitude, currMaxGeographicCoords.altitude);
		resultFullyIntersectedTilesNamesMap[tileName] = geographicExtent;
		return;
	}
	else if (intersectionType === Constant.INTERSECTION_INTERSECT)
	{
		// check distance to camera.
		var distToCam = camPos.distToSphere(sphereExtentAux);
		if (distToCam > 2000)
		{
			var midLon = (currMinGeographicCoords.longitude + currMaxGeographicCoords.longitude)/2;
			var midLat = (currMinGeographicCoords.latitude + currMaxGeographicCoords.latitude)/2;
			var tileName = SmartTile.selectTileName(currDepth, midLon, midLat, undefined);
			var geographicExtent = new GeographicExtent();
			geographicExtent.minGeographicCoord = new GeographicCoord(currMinGeographicCoords.longitude, currMinGeographicCoords.latitude, currMinGeographicCoords.altitude);
			geographicExtent.maxGeographicCoord = new GeographicCoord(currMaxGeographicCoords.longitude, currMaxGeographicCoords.latitude, currMaxGeographicCoords.altitude);
			resultFullyIntersectedTilesNamesMap[tileName] = geographicExtent;
			return;
		}
		
		if (currDepth < maxDepth)
		{
			// must descend.
			currDepth += 1;
			var minLon = currMinGeographicCoords.longitude;
			var minLat = currMinGeographicCoords.latitude;
			var minAlt = currMinGeographicCoords.altitude;
			var maxLon = currMaxGeographicCoords.longitude;
			var maxLat = currMaxGeographicCoords.latitude;
			var maxAlt = currMaxGeographicCoords.altitude;
			var midLon = (minLon + maxLon)/ 2;
			var midLat = (minLat + maxLat)/ 2;
			
			// subTile 1.
			currMaxGeographicCoords.setLonLatAlt(midLon, midLat, maxAlt);
			this.getFrustumIntersectedTilesNamesForGeographicExtent(frustum, maxDepth, currDepth, camPos, currMinGeographicCoords, currMaxGeographicCoords, magoManager, sphereExtentAux, resultFullyIntersectedTilesNamesMap);
			
			// subTile 2.
			currMinGeographicCoords.setLonLatAlt(midLon, minLat, minAlt);
			currMaxGeographicCoords.setLonLatAlt(maxLon, midLat, maxAlt);
			this.getFrustumIntersectedTilesNamesForGeographicExtent(frustum, maxDepth, currDepth, camPos, currMinGeographicCoords, currMaxGeographicCoords, magoManager, sphereExtentAux, resultFullyIntersectedTilesNamesMap);
			
			// subTile 3.
			currMinGeographicCoords.setLonLatAlt(midLon, midLat, minAlt);
			currMaxGeographicCoords.setLonLatAlt(maxLon, maxLat, maxAlt);
			this.getFrustumIntersectedTilesNamesForGeographicExtent(frustum, maxDepth, currDepth, camPos, currMinGeographicCoords, currMaxGeographicCoords, magoManager, sphereExtentAux, resultFullyIntersectedTilesNamesMap);
			
			// subTile 4.
			currMinGeographicCoords.setLonLatAlt(minLon, midLat, minAlt);
			currMaxGeographicCoords.setLonLatAlt(midLon, maxLat, maxAlt);
			this.getFrustumIntersectedTilesNamesForGeographicExtent(frustum, maxDepth, currDepth, camPos, currMinGeographicCoords, currMaxGeographicCoords, magoManager, sphereExtentAux, resultFullyIntersectedTilesNamesMap);
			
		}
		else 
		{
			var midLon = (currMinGeographicCoords.longitude + currMaxGeographicCoords.longitude)/2;
			var midLat = (currMinGeographicCoords.latitude + currMaxGeographicCoords.latitude)/2;
			var tileName = SmartTile.selectTileName(currDepth, midLon, midLat, undefined);
			var geographicExtent = new GeographicExtent();
			geographicExtent.minGeographicCoord = new GeographicCoord(currMinGeographicCoords.longitude, currMinGeographicCoords.latitude, currMinGeographicCoords.altitude);
			geographicExtent.maxGeographicCoord = new GeographicCoord(currMaxGeographicCoords.longitude, currMaxGeographicCoords.latitude, currMaxGeographicCoords.altitude);
			resultFullyIntersectedTilesNamesMap[tileName] = geographicExtent;
			return;
		}
	}
	
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustum 변수
 */
 
SmartTile.getTilesNamesByTargetDepth = function(targetDepth, currDepth, currMinGeographicCoords, currMaxGeographicCoords, resultTilesNamesMap) 
{
	if (currDepth < targetDepth)
	{
		// must descend.
		currDepth += 1;
		var minLon = currMinGeographicCoords.longitude;
		var minLat = currMinGeographicCoords.latitude;
		var minAlt = currMinGeographicCoords.altitude;
		var maxLon = currMaxGeographicCoords.longitude;
		var maxLat = currMaxGeographicCoords.latitude;
		var maxAlt = currMaxGeographicCoords.altitude;
		var midLon = (minLon + maxLon)/ 2;
		var midLat = (minLat + maxLat)/ 2;
		
		// subTile 1.
		currMaxGeographicCoords.setLonLatAlt(midLon, midLat, maxAlt);
		this.getTilesNamesByTargetDepth(targetDepth, currDepth, currMinGeographicCoords, currMaxGeographicCoords, resultTilesNamesMap);
		
		// subTile 2.
		currMinGeographicCoords.setLonLatAlt(midLon, minLat, minAlt);
		currMaxGeographicCoords.setLonLatAlt(maxLon, midLat, maxAlt);
		this.getTilesNamesByTargetDepth(targetDepth, currDepth, currMinGeographicCoords, currMaxGeographicCoords, resultTilesNamesMap);
		
		// subTile 3.
		currMinGeographicCoords.setLonLatAlt(midLon, midLat, minAlt);
		currMaxGeographicCoords.setLonLatAlt(maxLon, maxLat, maxAlt);
		this.getTilesNamesByTargetDepth(targetDepth, currDepth, currMinGeographicCoords, currMaxGeographicCoords, resultTilesNamesMap);
		
		// subTile 4.
		currMinGeographicCoords.setLonLatAlt(minLon, midLat, minAlt);
		currMaxGeographicCoords.setLonLatAlt(midLon, maxLat, maxAlt);
		this.getTilesNamesByTargetDepth(targetDepth, currDepth, currMinGeographicCoords, currMaxGeographicCoords, resultTilesNamesMap);
		
	}
	else 
	{
		var midLon = (currMinGeographicCoords.longitude + currMaxGeographicCoords.longitude)/2;
		var midLat = (currMinGeographicCoords.latitude + currMaxGeographicCoords.latitude)/2;
		var tileName = SmartTile.selectTileName(currDepth, midLon, midLat, undefined);
		var geographicExtent = new GeographicExtent();
		geographicExtent.minGeographicCoord = new GeographicCoord(currMinGeographicCoords.longitude, currMinGeographicCoords.latitude, currMinGeographicCoords.altitude);
		geographicExtent.maxGeographicCoord = new GeographicCoord(currMaxGeographicCoords.longitude, currMaxGeographicCoords.latitude, currMaxGeographicCoords.altitude);
		resultTilesNamesMap[tileName] = geographicExtent;
		return;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * Extent(범위)
 * @param frustum 변수
 */
SmartTile.prototype.getSphereExtent = function() 
{
	return this.sphereExtent;
};

/**
 * 각각 민맥스 좌표들로 타일의 사이즈 세팅.
 * @param {number} minLon
 * @param {number} minLat
 * @param {number} minAlt
 * @param {number} maxLon
 * @param {number} maxLat
 * @param {number} maxAlt
 */
SmartTile.prototype.setSize = function(minLon, minLat, minAlt, maxLon, maxLat, maxAlt) 
{
	if (this.minGeographicCoord === undefined)
	{ this.minGeographicCoord = new GeographicCoord(); }
	if (this.maxGeographicCoord === undefined)	
	{ this.maxGeographicCoord = new GeographicCoord(); }
		
	this.minGeographicCoord.setLonLatAlt(minLon, minLat, minAlt);	
	this.maxGeographicCoord.setLonLatAlt(maxLon, maxLat, maxAlt);	
};

/**
 * 생성된 4개의 subtile에 각각의 좌표를 할당
 */
SmartTile.prototype.setSizesToSubTiles = function() 
{
	//       +-----+-----+
	//       |  3  |  2  |
	//       +-----+-----+
	//       |  0  |  1  |
	//       +-----+-----+
	if (this.subTiles.length < 4)
	{
		throw new Error('When subTiles length is 4, setSizesToSubTiles is ok.'); 
	}
	var minLon = this.minGeographicCoord.longitude;
	var maxLon = this.maxGeographicCoord.longitude;
	var minLat = this.minGeographicCoord.latitude;
	var maxLat = this.maxGeographicCoord.latitude;
	var minAlt = this.minGeographicCoord.altitude;
	var maxAlt = this.maxGeographicCoord.altitude;
	
	var midLon = (maxLon + minLon)/2;
	var midLat = (maxLat + minLat)/2;
	
	var subTile = this.subTiles[0];
	subTile.setSize(minLon, minLat, minAlt,     midLon, midLat, maxAlt);
	subTile.X = this.X*2;
	subTile.Y = this.Y*2 + 1;
	
	subTile = this.subTiles[1];
	subTile.setSize(midLon, minLat, minAlt,     maxLon, midLat, maxAlt);
	subTile.X = this.X*2 + 1;
	subTile.Y = this.Y*2 + 1;
	
	subTile = this.subTiles[2];
	subTile.setSize(midLon, midLat, minAlt,     maxLon, maxLat, maxAlt);
	subTile.X = this.X*2 + 1;
	subTile.Y = this.Y*2;
	
	subTile = this.subTiles[3];
	subTile.setSize(minLon, midLat, minAlt,     midLon, maxLat, maxAlt);
	subTile.X = this.X*2;
	subTile.Y = this.Y*2;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
SmartTile.prototype.getId = function() 
{
	if (this.id === undefined)
	{
		this.id = this.depth.toString()+ "_" + this.X.toString() + "_" + this.Y.toString();
	}
	return this.id;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
SmartTile.prototype.getLongitudeRangeDegree = function() 
{
	return this.maxGeographicCoord.longitude - this.minGeographicCoord.longitude;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param geoLocData 변수
 */
SmartTile.prototype.getLatitudeRangeDegree = function() 
{
	return this.maxGeographicCoord.latitude - this.minGeographicCoord.latitude;
};

/**
 * 스마트 타일 내에 object 제거
 * @param {object} object mago3d model object
 * @param {string} comparision comparision key name
 */
SmartTile.prototype.eraseObjectByComparision = function(object, comparision) 
{
	if (!object[comparision]) { return false; }
	
	var comparisionValue = object[comparision];
	var idx = null;
	if (this.objectsArray && Array.isArray(this.objectsArray)) 
	{
		for (var i=0, len=this.objectsArray.length; i<len;++i) 
		{
			if (!this.objectsArray[i][comparision]) { continue; }
			
			if (this.objectsArray[i][comparision] === comparisionValue)
			{
				this.objectsArray.splice(i, 1);
				break;
			}
		}
	}
};
'use strict';

/**
 * 4분할 타일링 수행 및 타일 객체 보관 객체
 * 인스턴스 생성 시 mother tile 생성
 * @class SmartTileManager
 * 
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * @see SmartTile
 */
var SmartTileManager = function() 
{
	if (!(this instanceof SmartTileManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
    
	/**
     * 타일 배열
     * has 2 tiles (Asia side and America side).
     * @type {Array.<SmartTile>}
     */
	this.tilesArray = []; 
    
	/**
     * mother 타일 생성
     */
	this.createMainTiles();
	
	// objectSeedsMap created to process multiBuildings.
	this.objectSeedsMap;
	
	this.maxDepth = 17;
};

/**
 * Returns the depth of smartTile that corresponds by bbox size.
 */
SmartTileManager.getDepthByBoundingBoxMaxSize = function(bboxMaxSize) 
{
	if (bboxMaxSize === undefined)
	{ return undefined; }
	
	var smartTileDepth;
	
	if (bboxMaxSize < 30.0)
	{
		smartTileDepth = 16;
	}
	else if (bboxMaxSize >= 30.0 && bboxMaxSize < 50.0)
	{
		smartTileDepth = 15;
	}
	else if (bboxMaxSize >= 50.0 && bboxMaxSize < 100.0)
	{
		smartTileDepth = 14;
	}
	else if (bboxMaxSize >=100.0)
	{
		smartTileDepth = 13;
	}
	
	return smartTileDepth;
};

/**
 * Returns the max distance that is visible a smartTile by his depth.
 */
SmartTileManager.maxDistToCameraByDepth = function(depth) 
{
	if (depth < 13)
	{
		return 10000;
	}
	else if (depth === 13)
	{
		return 9000;
	}
	else if (depth === 14)
	{
		return 4000;
	}
	else if (depth === 15)
	{
		return 2000;
	}
	else if (depth === 16)
	{
		return 1500;
	}
	else if (depth === 17)
	{
		return 1000;
	}
	else if (depth === 18)
	{
		return 250;
	}
	else if (depth > 18)
	{
		return 150;
	}
	
	
	return 10;
};

/**
 * 아메리카쪽 아시아쪽으로 구분하여 두개의 mother 타일 생성
 */
SmartTileManager.prototype.createMainTiles = function() 
{
	// tile 1 : longitude {-180, 0}, latitude {-90, 90}
	// tile 2 : longitude {0, 180},  latitude {-90, 90}
	
	// America side.
	var tile1 = this.newSmartTile("AmericaSide");
	if (tile1.minGeographicCoord === undefined)
	{ tile1.minGeographicCoord = new GeographicCoord(); }
	if (tile1.maxGeographicCoord === undefined)
	{ tile1.maxGeographicCoord = new GeographicCoord(); }
	
	tile1.depth = 0; // mother tile.
	tile1.X = 0; 
	tile1.Y = 0; 
	tile1.minGeographicCoord.setLonLatAlt(-180, -90, 0);
	tile1.maxGeographicCoord.setLonLatAlt(0, 90, 0);
	
	// Asia side.
	var tile2 = this.newSmartTile("AsiaSide");
	if (tile2.minGeographicCoord === undefined)
	{ tile2.minGeographicCoord = new GeographicCoord(); }
	if (tile2.maxGeographicCoord === undefined)
	{ tile2.maxGeographicCoord = new GeographicCoord(); }
	
	tile2.depth = 0; // mother tile.
	tile2.X = 1; // Asia side tile X coord = 1.***
	tile2.Y = 0; 
	tile2.minGeographicCoord.setLonLatAlt(0, -90, 0);
	tile2.maxGeographicCoord.setLonLatAlt(180, 90, 0);
};

/**
 */
SmartTileManager.prototype.doPendentProcess = function(magoManager) 
{
	// This function does pendent process.
	if (this.objectSeedsMap !== undefined)
	{
		var hierarchyManager = magoManager.hierarchyManager;
		var tilesCount = this.tilesArray.length; // allways tilesCount = 2. (Asia & America sides).
		for (var key in this.objectSeedsMap)
		{
			if (Object.prototype.hasOwnProperty.call(this.objectSeedsMap, key))
			{
				var objectSeed = this.objectSeedsMap[key];
				var targetDepth = objectSeed.L;
				var projectId = objectSeed.objectType;
				var nodesMap = hierarchyManager.getNodesMap(projectId, undefined);
				
				var multiBuildingId = objectSeed.id;
				if (multiBuildingId === "")
				{
					// Assign a default id.
					var existNodesCount = Object.keys(nodesMap).length; 
					multiBuildingId = objectSeed.objectType + "_" + existNodesCount;
				}
				
				var node = magoManager.hierarchyManager.newNode(multiBuildingId, projectId, undefined);
				
				// Now, create the basic node data.
				node.data.attributes = {objectType: "multiBuildingsTile"};
				node.data.geographicCoord = objectSeed.geographicCoord;
				node.data.bbox = objectSeed.boundingBox;
				node.data.projectFolderName = objectSeed.projectFolderName;
				node.data.multiBuildingsFolderName = objectSeed.multiBuildingsFolderName;
				
				for (var i=0; i<tilesCount; i++)
				{
					//this.tilesArray[i].putObjectSeed(targetDepth, objectSeed, magoManager);
					this.tilesArray[i].putNode(targetDepth, node, magoManager);
				}
			}
		}
		
		// finally clear the this.objectSeedsMap.
		this.objectSeedsMap = undefined;
	}
	
	if (this.smartTileF4dSeedMap !== undefined)
	{
		var tilesCount = this.tilesArray.length; // allways tilesCount = 2. (Asia & America sides).
		
		// insert into smartTiles the smartTileF4d.***
		for (var key in this.smartTileF4dSeedMap)
		{
			if (Object.prototype.hasOwnProperty.call(this.smartTileF4dSeedMap, key))
			{
				var smartTileF4dSeed = this.smartTileF4dSeedMap[key];
				var targetDepth = smartTileF4dSeed.L;
				for (var i=0; i<tilesCount; i++)
				{
					this.tilesArray[i].putSmartTileF4dSeed(targetDepth, smartTileF4dSeed, magoManager);
				}
			}
		}
		
		this.smartTileF4dSeedMap = undefined;
	}
};

/**
 */
SmartTileManager.prototype.parseSmartTilesMultiBuildingsIndexFile = function(dataBuffer, projectFolderName, magoManager) 
{
	var bytes_readed = 0;
	var readWriter = magoManager.readerWriter;
	
	if (this.objectSeedsMap === undefined)
	{ this.objectSeedsMap = {}; }

	var smartTilesMBCount = readWriter.readInt32(dataBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
	for (var i=0; i<smartTilesMBCount; i++)
	{
		var nameLength = readWriter.readInt32(dataBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		var name = "";
		for (var j=0; j<nameLength; j++)
		{
			name += String.fromCharCode(new Int8Array(dataBuffer.slice(bytes_readed, bytes_readed+ 1))[0]);bytes_readed += 1;
		}
		
		var L = readWriter.readInt32(dataBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		var X = readWriter.readInt32(dataBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		var Y = readWriter.readInt32(dataBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		
		// Now read bbox.
		var bbox = new BoundingBox();
		bytes_readed = bbox.readData(dataBuffer, bytes_readed);
		
		var geoExtent = SmartTile.getGeographicExtentOfTileLXY(L, X, Y, undefined);
		var centerGeoCoord = geoExtent.getMidPoint();
		//centerGeoCoord.altitude += 20.0;// test. delete!!!
		var multiBuildingId = "";
		this.objectSeedsMap[name] = {
			"L"                        : L,
			"X"                        : X,
			"Y"                        : Y,
			"geographicCoord"          : centerGeoCoord,
			"objectType"               : "MultiBuildingsTile",
			"id"                       : multiBuildingId,
			"boundingBox"              : bbox,
			"multiBuildingsFolderName" : name,
			"projectFolderName"        : projectFolderName};

	}
	
	return this.objectSeedsMap;
};

/**
 */
SmartTileManager.prototype.parseSmartTilesF4dIndexFile = function(dataBuffer, projectFolderName, magoManager) 
{
	var bytes_readed = 0;
	var readWriter = magoManager.readerWriter;
	
	if (this.smartTileF4dSeedMap === undefined)
	{ this.smartTileF4dSeedMap = {}; }

	var smartTilesMBCount = readWriter.readInt32(dataBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
	for (var i=0; i<smartTilesMBCount; i++)
	{
		var nameLength = readWriter.readInt16(dataBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
		var name = "";
		for (var j=0; j<nameLength; j++)
		{
			name += String.fromCharCode(new Int8Array(dataBuffer.slice(bytes_readed, bytes_readed+ 1))[0]);bytes_readed += 1;
		}
		
		var L = readWriter.readUInt8(dataBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
		var X = readWriter.readInt32(dataBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		var Y = readWriter.readInt32(dataBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		var smartTileType = readWriter.readUInt8(dataBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
		
		// Now read bbox.
		//var bbox = new BoundingBox();
		//bytes_readed = bbox.readData(dataBuffer, bytes_readed);
		
		var geoExtent = SmartTile.getGeographicExtentOfTileLXY(L, X, Y, undefined);
		var centerGeoCoord = geoExtent.getMidPoint();
		//centerGeoCoord.altitude += 20.0;// test. delete!!!
		var f4dTileId = "";
		//var smartTileLodsCount = 3;
		this.smartTileF4dSeedMap[name] = {
			"L"                 : L,
			"X"                 : X,
			"Y"                 : Y,
			"geographicCoord"   : centerGeoCoord,
			"objectType"        : "F4dTile",
			"id"                : f4dTileId,
			"smartTileType"     : smartTileType,
			"tileName"          : name,
			"projectFolderName" : projectFolderName,
			"fileLoadState"     : CODE.fileLoadState.READY};

	}
	
	return this.smartTileF4dSeedMap;
};

/**
 * f4d들의 object index 파일을 읽고 생성한 물리적인 노드들을 타일에 배치.
 * @param {Number} targetDepth 없을 시 17, 일반적으로 17레벨까지 생성.
 * @param {Array.<Node>} physicalNodesArray geometry정보가 있는 화면에 표출할 수 있는 Node 배열
 * @param {MagoManager} magoManager 마고매니저.
 * 
 * @see Node
 */
SmartTileManager.prototype.makeTreeByDepth = function(targetDepth, physicalNodesArray, magoManager) 
{
	if (targetDepth === undefined)
	{ targetDepth = 17; }
	
	this.targetDepth = targetDepth;
	
	var smartTilesCount = this.tilesArray.length; // In this point, "smartTilesCount" = 2 always.
	for (var a=0; a<smartTilesCount; a++)
	{
		var smartTile = this.tilesArray[a];
		if (smartTile.nodeSeedsArray === undefined)
		{ smartTile.nodeSeedsArray = []; }
		
		smartTile.nodeSeedsArray = physicalNodesArray;
		smartTile.makeTreeByDepth(targetDepth, magoManager); // default depth = 17.
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTileManager.prototype.putNode = function(targetDepth, node, magoManager) 
{
	targetDepth = defaultValue(targetDepth, this.maxDepth);
	if (this.tilesArray !== undefined)
	{
		var tilesCount = this.tilesArray.length; // allways tilesCount = 2. (Asia & America sides).
		for (var i=0; i<tilesCount; i++)
		{
			this.tilesArray[i].putNode(targetDepth, node, magoManager);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTileManager.prototype.putObject = function(targetDepth, object, magoManager) 
{
	targetDepth = defaultValue(targetDepth, this.maxDepth);
	if (this.tilesArray !== undefined)
	{
		var tilesCount = this.tilesArray.length; // allways tilesCount = 2. (Asia & America sides).
		for (var i=0; i<tilesCount; i++)
		{
			this.tilesArray[i].putObject(targetDepth, object, magoManager);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTileManager.prototype.getSphereIntersectedTiles = function(sphere, resultIntersectedTilesArray, maxDepth) 
{
	if (maxDepth === undefined)
	{ maxDepth = this.maxDepth; }
	
	if (this.tilesArray !== undefined)
	{
		var tilesCount = this.tilesArray.length; // allways tilesCount = 2. (Asia & America sides).
		for (var i=0; i<tilesCount; i++)
		{
			this.tilesArray[i].getSphereIntersectedTiles(sphere, resultIntersectedTilesArray, maxDepth);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param geoLocData 변수
 */
SmartTileManager.prototype.deleteTiles = function() 
{
	// this function deletes all children tiles.
	if (this.tilesArray)
	{
		var tilesCount = this.tilesArray.length; // allways tilesCount = 2. (Asia & America sides).
		for (var i=0; i<tilesCount; i++)
		{
			this.tilesArray[i].deleteObjects();
			this.tilesArray[i] = undefined;
		}
		this.tilesArray.length = 0;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @class GeoLocationData
 * @param geoLocData 변수
 */
SmartTileManager.prototype.resetTiles = function() 
{
	this.deleteTiles();
	
	// now create the main tiles.
	this.createMainTiles();
};

/**
 * 새로운 스마트타일을 생성하여 tilesArray에 넣고 반환.
 * @param {String} smartTileName tile name\
 * @returns {SmartTile}
 */
SmartTileManager.prototype.newSmartTile = function(smartTileName) 
{
	if (this.tilesArray === undefined)
	{ this.tilesArray = []; }
	
	var smartTile = new SmartTile(smartTileName);
	this.tilesArray.push(smartTile);
	return smartTile;
};

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTileManager.prototype.getNeoBuildingById = function(buildingType, buildingId) 
{
	var resultNeoBuilding;
	var i = 0;
	var smartTilesCount = this.tilesArray.length;
	while (resultNeoBuilding === undefined && i<smartTilesCount)
	{
		resultNeoBuilding = this.tilesArray[i].getNeoBuildingById(buildingType, buildingId); 
		i++;
	}
	
	return resultNeoBuilding;
};

/**
 * 어떤 일을 하고 있습니까?
 */
SmartTileManager.prototype.getBuildingSeedById = function(buildingType, buildingId) 
{
	var resultNeoBuilding;
	var i = 0;
	var smartTilesCount = this.tilesArray.length;
	while (resultNeoBuilding === undefined && i<smartTilesCount)
	{
		resultNeoBuilding = this.tilesArray[i].getBuildingSeedById(buildingType, buildingId);
		i++;
	}
	
	return resultNeoBuilding;
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Sphere
 */
var Sphere = function(options) 
{
	MagoRenderable.call(this);
	if (!(this instanceof Sphere)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.r = 0.0;
	this.centerPoint = new Point3D();
	
	this.geoLocDataManager;
	this.color4;
	
	this.vboKeyContainer; // class: VBOVertexIdxCacheKeyContainer.
	this.dirty = true;
	
	if (options !== undefined)
	{
		var color = options.color;
		if (color)
		{
			this.color4 = new DynamicColor();
			this.color4.setRGBA(color.r, color.g, color.b, color.a);

			var event = new MagoEvent('RENDER_END', function(thisArgs, magoManager)
			{
				thisArgs.color4.updateColorAlarm(magoManager.getCurrentTime());
			});
			this.addEventListener(event);
		}
	}
	
};
Sphere.prototype = Object.create(MagoRenderable.prototype);
Sphere.prototype.constructor = Sphere;

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Sphere.prototype.setCenterPoint = function(x, y, z) 
{
	this.centerPoint.set(x, y, z);
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Sphere.prototype.setRadius = function(radius) 
{
	this.r = radius;
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Sphere.prototype.deleteObjects = function() 
{
	this.r = undefined;
	this.centerPoint.deleteObjects();
	this.centerPoint = undefined;
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Sphere.prototype.distToPoint3D = function(point3d) 
{
	return this.centerPoint.distToPoint(point3d) - this.r;
};

/**
 */
Sphere.prototype.getVbo = function(resultVboContainer, bTexCoords)
{
	if (resultVboContainer === undefined)
	{ resultVboContainer = new VBOVertexIdxCacheKeysContainer(); }

	var pMesh;

	// make vbo.
	pMesh = this.makePMesh(pMesh);
	var bIncludeBottomCap = false;
	var bIncludeTopCap = false;
	
	var surfIndepMesh = pMesh.getSurfaceIndependentMesh(undefined, bIncludeBottomCap, bIncludeTopCap);
	
	// now rotate in X axis.
	var rotMatAux = new Matrix4();
	rotMatAux.rotationAxisAngDeg(90.0, 1.0, 0.0, 0.0);
	surfIndepMesh.transformByMatrix4(rotMatAux);
	
	surfIndepMesh.setColor(0.0, 0.5, 0.9, 0.3);
	surfIndepMesh.calculateVerticesNormals();
	if (bTexCoords !== undefined && bTexCoords === true)
	{
		// calculate spherical texCoords.
		surfIndepMesh.calculateTexCoordsSpherical();
	}
	surfIndepMesh.getVbo(resultVboContainer);

	return resultVboContainer;
};

/**
 * Makes the geometry mesh.
 */
Sphere.prototype.makeMesh = function()
{
	var profile2dAux = new Profile2D();
	
	// Outer ring.**
	var outerRing = profile2dAux.newOuterRing();
	
	var startAngDeg = 91.00;
	var endAngDeg = 270.00;
	var arc = outerRing.newElement("ARC");
	this.sweepSense = 1;
	arc.setCenterPosition(0.0, 0.0);
	arc.setRadius(this.r);
	arc.setStartAngleDegree(startAngDeg);
	arc.setSweepAngleDegree(endAngDeg - startAngDeg);
	arc.numPointsFor360Deg = 8;
	
	var revolveAngDeg = 360;
	var revolveSegmentsCount = 8;
	var revolveSegment2d = new Segment2D();
	var strPoint2d = new Point2D(0, -1);
	var endPoint2d = new Point2D(0, 1);
	revolveSegment2d.setPoints(strPoint2d, endPoint2d);
	var bIncludeBottomCap = false;
	var bIncludeTopCap = false;
	var mesh = Modeler.getRevolvedSolidMesh(profile2dAux, revolveAngDeg, revolveSegmentsCount, revolveSegment2d, bIncludeBottomCap, bIncludeTopCap, undefined);
	this.objectsArray.push(mesh);
	this.dirty = false;
};

/**
 * 포인트값 삭제
 * 어떤 일을 하고 있습니까?
 */
Sphere.prototype.makePMesh = function(resultPMesh) 
{
	// Old. delete.
	if (resultPMesh === undefined)
	{ resultPMesh = new ParametricMesh(); }

	resultPMesh.profile = new Profile(); 
	var profileAux = resultPMesh.profile; 
	
	// Outer ring.**
	var outerRing = profileAux.newOuterRing();
	var polyLine, point3d, arc;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(-this.r*0.01, -this.r); // 0
	point3d = polyLine.newPoint2d(-this.r*0.01, this.r); // 1
	
	var startAngDeg = 95.00;
	var endAngDeg = 265.00;
	arc = outerRing.newElement("ARC");
	this.sweepSense = 1;
	arc.setCenterPosition(0.0, 0.0);
	arc.setRadius(this.r);
	arc.setStartAngleDegree(startAngDeg);
	arc.setSweepAngleDegree(endAngDeg - startAngDeg);
	arc.numPointsFor360Deg = 48;
	
	// now revolve.
	var revolveAngDeg, revolveSegmentsCount, revolveSegment2d;
	revolveAngDeg = 360;
	revolveSegment2d = new Segment2D();
	var strPoint2d = new Point2D(0, -1);
	var endPoint2d = new Point2D(0, 1);
	revolveSegment2d.setPoints(strPoint2d, endPoint2d);
	revolveSegmentsCount = 48;
	resultPMesh.revolve(profileAux, revolveAngDeg, revolveSegmentsCount, revolveSegment2d);
	/*
	var extrusionVector
	var extrudeSegmentsCount = 2;
	var extrusionDist = 15.0;
		resultPMesh.extrude(profileAux, extrusionDist, extrudeSegmentsCount, extrusionVector);
	*/
	
	return resultPMesh;
};

Sphere.prototype.intersectionSphere = function(sphere) 
{
	if (sphere === undefined)
	{ return Constant.INTERSECTION_OUTSIDE; }
	
	var dist = this.centerPoint.distToPoint(sphere.centerPoint);
	if (dist < this.r)
	{
		return Constant.INTERSECTION_INSIDE;
	}
	else if (dist < sphere.r)
	{
		return Constant.INTERSECTION_INSIDE;
	}
	else if (dist < (this.r + sphere.r))
	{
		return Constant.INTERSECTION_INTERSECT;
	}
	
	return Constant.INTERSECTION_OUTSIDE;
};











































'use strict';

/**
 * ??
 * @class SceneState
 */

var SplitValue = function()
{
	this.high = undefined;
	this.low = undefined;
};

'use strict';

/**
 * SunSystem.
 * 
 * @class SunSystem
 * @constructor 
 */
var SunSystem = function(options) 
{
	if (!(this instanceof SunSystem)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.sunGeoLocDataManager = new GeoLocationDataManager();
	this.lightSourcesArray;
	this.date; // month, day, hour, min, sec.
	this.sunDirWC;
	this.bAnimation = false;
	this.updated = false;
	
	if (options !== undefined)
	{
		// todo:
	}
	
	// create the initial position of the sun.
	var geoLocData = this.sunGeoLocDataManager.newGeoLocationData("sunPosition");
	var lon = 115.31586919332165;
	var lat = 10.0;
	var alt = 0.0;
	geoLocData = ManagerUtils.calculateGeoLocationData(lon, lat, alt, undefined, undefined, undefined, geoLocData);
	
	var sunRotMat = geoLocData.rotMatrix;
	this.sunDirWC = new Float32Array([-sunRotMat._floatArrays[8], -sunRotMat._floatArrays[9], -sunRotMat._floatArrays[10]]);
	this.init();
};

SunSystem.prototype.init = function() 
{
	if (this.lightSourcesArray === undefined)
	{ this.lightSourcesArray = []; }
	
	// provisionally create 3 lightSources.
	// 1rst light.
	var lightType = 2; // omni = 0, spot = 1, directional = 2, area = 3, volume = 4.
	var light = new LightSource(lightType);
	light.directionalBoxWidth = 400.0;
	light.geoCoord = new GeographicCoord(126.61255088096084, 37.58071053758259, 50);
	this.lightSourcesArray.push(light);
	
	// 2nd light.
	lightType = 2; // omni = 0, spot = 1, directional = 2, area = 3, volume = 4.
	light = new LightSource(lightType);
	light.directionalBoxWidth = 400.0;
	light.geoCoord = new GeographicCoord(126.61255088096084, 37.58071053758259, 50);
	this.lightSourcesArray.push(light);
};

SunSystem.prototype.getSunDirWC = function() 
{
	return this.sunDirWC;
};

SunSystem.prototype.getLight = function(idx) 
{
	if (this.lightSourcesArray === undefined)
	{ return undefined; }
	
	return this.lightSourcesArray[idx];
};

SunSystem.prototype.getLightsMatrixFloat32Array = function() 
{
	var lightsCount = this.lightSourcesArray.length;
	
	if (this.lightMatrixFloat32Array === undefined)
	{ this.lightMatrixFloat32Array = new Float32Array(16*lightsCount); }
	
	for (var i=0; i<lightsCount; i++)
	{
		var light = this.getLight(i);
		var lightMat = light.tMatrix;
		if (lightMat === undefined)
		{ continue; }
		
		for (var j=0; j<16; j++)
		{
			this.lightMatrixFloat32Array[j + 16*i] = lightMat._floatArrays[j];
		}
	}
	
	return this.lightMatrixFloat32Array;
};

SunSystem.prototype.getLightsPosLOWFloat32Array = function() 
{
	var lightsCount = this.lightSourcesArray.length;
	
	if (this.lightPosLOWFloat32Array === undefined)
	{ this.lightPosLOWFloat32Array = new Float32Array(3*lightsCount); }
	
	for (var i=0; i<lightsCount; i++)
	{
		var light = this.getLight(i);
		var lightPosLOW = light.positionLOW;
		if (lightPosLOW === undefined)
		{ continue; }
		for (var j=0; j<3; j++)
		{
			this.lightPosLOWFloat32Array[j + 3*i] = lightPosLOW[j];
		}
	}
	
	return this.lightPosLOWFloat32Array;
};

SunSystem.prototype.getLightsPosHIGHFloat32Array = function() 
{
	var lightsCount = this.lightSourcesArray.length;
	
	if (this.lightPosHIGHFloat32Array === undefined)
	{ this.lightPosHIGHFloat32Array = new Float32Array(3*lightsCount); }
	
	for (var i=0; i<lightsCount; i++)
	{
		var light = this.getLight(i);
		var lightPosHIGH = light.positionHIGH;
		if (lightPosHIGH === undefined)
		{ continue; }
		for (var j=0; j<3; j++)
		{
			this.lightPosHIGHFloat32Array[j + 3*i] = lightPosHIGH[j];
		}
	}
	
	return this.lightPosHIGHFloat32Array;
};

SunSystem.prototype.setDate = function(date) 
{
	this.date = date;
	this.calculateSunGeographicCoords();
};

SunSystem.prototype.setAnimation = function(options) 
{
	if (options === undefined)
	{ return; }
	
	this.bAnimation = true;
	var timeSpeed = options.timeSpeed; // seconds/seconds.
	var startHour = options.startHour;
	var startMin = options.startMin;
	
	var endHour = options.endHour;
	var endMin = options.endMin;
	
	
};

SunSystem.prototype.calculateSunGeographicCoords = function() 
{
	//https://in-the-sky.org/twilightmap.php // web page. sun in current time.
	//----------------------------------------------
	//https://en.wikipedia.org/wiki/Position_of_the_Sun
	//https://www.nrel.gov/docs/fy08osti/34302.pdf
	//https://forum.logicmachine.net/showthread.php?tid=161
	
	//https://astronomy.stackexchange.com/questions/20560/how-to-calculate-the-position-of-the-sun-in-long-lat
	// The boilerplate: fiddling with dates
	var radToDeg = 180/Math.PI;
	if (this.date === undefined)
	{
		this.date = new Date();
		this.date.setMonth(2);
		this.date.setHours(15);
		this.date.setMinutes(30);
	}
	
	var date = this.date;
	
	var fullYear = date.getFullYear();
	var soy = (new Date(date.getFullYear(), 0, 0)).getTime();
	var eoy = (new Date(date.getFullYear() + 1, 0, 0)).getTime();
	var nows = date.getTime();
	var poy = (nows - soy) / (eoy - soy);

	var secs = date.getUTCMilliseconds() / 1e3
                + date.getUTCSeconds()
                + 60 * (date.getUTCMinutes() + 60 * date.getUTCHours());
	var pod = secs / 86400; // leap secs? nah.

	// The actual magic
	var lon = (-pod + 0.5) * Math.PI * 2;
	lon = lon*radToDeg;
	var lat = Math.sin((poy - .22) * Math.PI * 2) * .41;
	lat = lat*radToDeg;
	var alt = 0.0;
	
	// Now, calculate the sun geoLocationData & sun direction world coord.
	var geoLocData = this.sunGeoLocDataManager.getCurrentGeoLocationData();
	geoLocData = ManagerUtils.calculateGeoLocationData(lon, lat, alt, undefined, undefined, undefined, geoLocData);
	
	var sunRotMat = geoLocData.rotMatrix;
	this.sunDirWC = new Float32Array([-sunRotMat._floatArrays[8], -sunRotMat._floatArrays[9], -sunRotMat._floatArrays[10]]);
};


SunSystem.prototype.updateSun = function(magoManager, options) 
{
	this.calculateSunGeographicCoords(); // test.***
	
	if (this.lightSourcesArray === undefined)
	{ return; }

	if (magoManager.frustumVolumeControl === undefined)
	{ return; }

	//var date = new Date();
	
	if (options)
	{
		if (options.date)
		{
			// earthAxis inclination = 23.439281 degree.
			// December solstice -> March equinox (Friday, 20 March 2020, 03:49 UTC) -> June solstice -> September equinox.
			
		}
	}
	
	var camera = magoManager.sceneState.getCamera();
	var camPos = camera.position;
	var camDir = camera.getDirection();
	
	
	// calculate the parameters of the light.
	var frustumVolumeControl = magoManager.frustumVolumeControl;
	var totalBoundingFrustum = frustumVolumeControl.getTotalBoundingFrustum(undefined);
	
	if (totalBoundingFrustum.bFrustumNear === undefined || totalBoundingFrustum.bFrustumFar === undefined)
	{ return; }
	
	var bFrustumNear = totalBoundingFrustum.bFrustumNear;
	var bFrustumFar = totalBoundingFrustum.bFrustumFar;
	
	var frustum = camera.getFrustum(0);
	var tangentOfHalfFovy = frustum.tangentOfHalfFovy;
	
	var minDist = bFrustumNear;
	if (minDist < 0.0)
	{ minDist = 0.0; }
	var maxDist = bFrustumFar;
	var distRange = maxDist - minDist;

	
	// light 0 (nearest).
	//var dist0 = minDist + distRange * 0.20;
	var dist0 = minDist + distRange * 0.30;
	if (dist0 < 1.0){ dist0 = 1.0; }
	
	var light = this.lightSourcesArray[0];
	
	var newRadius = Math.abs(tangentOfHalfFovy*dist0)*4.0;
	var newPoint = new Point3D(camPos.x + camDir.x * dist0, camPos.y + camDir.y * dist0, camPos.z + camDir.z * dist0);
	if (light.bSphere === undefined)
	{ light.bSphere = new BoundingSphere(newPoint.x, newPoint.y, newPoint.z, newRadius); }
	else 
	{
		light.bSphere.setCenterPoint(newPoint.x, newPoint.y, newPoint.z);
		light.bSphere.setRadius(newRadius);
	}
	light.lightPosWC = light.bSphere.centerPoint;
	light.directionalBoxWidth = light.bSphere.r;
	light.minDistToCam = dist0 - light.bSphere.r; // use only in directional lights.
	light.maxDistToCam = dist0 + light.bSphere.r; // use only in directional lights.
	this.updateLight(light);
	
	// light 1 (farest).
	//var dist1 = minDist + distRange * 0.70;
	var dist1 = minDist + distRange * 0.60;
	if (dist1 < 10.0){ dist1 = 10.0; }
	var light = this.lightSourcesArray[1];
	var newRadius = Math.abs(tangentOfHalfFovy*dist1)*4.0;
	var newPoint = new Point3D(camPos.x + camDir.x * dist1, camPos.y + camDir.y * dist1, camPos.z + camDir.z * dist1);
	if (light.bSphere === undefined)
	{ light.bSphere = new BoundingSphere(newPoint.x, newPoint.y, newPoint.z, newRadius); }
	else 
	{
		light.bSphere.setCenterPoint(newPoint.x, newPoint.y, newPoint.z);
		light.bSphere.setRadius(newRadius);
	}
	light.lightPosWC = light.bSphere.centerPoint;
	light.directionalBoxWidth = light.bSphere.r*2;
	light.minDistToCam = dist1 - light.bSphere.r; // use only in directional lights.
	light.maxDistToCam = dist1 + light.bSphere.r; // use only in directional lights.
	this.updateLight(light);
		
	this.updated = true;
};

/**
 * This function renders the sunPointOfView depth.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {VisibleObjectsController} visibleObjControlerNodes This object contains visible objects for the camera frustum.
 */
SunSystem.prototype.updateLight = function(light) 
{
	var sunGeoLocData = this.sunGeoLocDataManager.getCurrentGeoLocationData();
	//var sunTMatrix = sunGeoLocData.rotMatrix;
	var sunTMatrix = sunGeoLocData.getRotMatrixInv();
	if (light.tMatrix === undefined)
	{ light.tMatrix = new Matrix4(); }

	// calculate sunTransformMatrix for this light.***
	var lightPosWC = light.lightPosWC;
	var depthFactor = 10.0;
	var ortho = new Matrix4();
	var nRange = light.directionalBoxWidth/2;
	var left = -nRange, right = nRange, bottom = -nRange, top = nRange, near = -depthFactor*nRange, far = depthFactor*nRange;
	ortho._floatArrays = glMatrix.mat4.ortho(ortho._floatArrays, left, right, bottom, top, near, far);
	
	light.tMatrix = sunTMatrix.getMultipliedByMatrix(ortho, light.tMatrix);

	if (light.positionHIGH === undefined)
	{ light.positionHIGH = new Float32Array([0.0, 0.0, 0.0]); } 
	
	if (light.positionLOW === undefined)
	{ light.positionLOW = new Float32Array([0.0, 0.0, 0.0]); } 
	
	ManagerUtils.calculateSplited3fv([lightPosWC.x, lightPosWC.y, lightPosWC.z], light.positionHIGH, light.positionLOW);
};




















'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class TerranTile
 */
var TerranTile = function() 
{
	if (!(this instanceof TerranTile)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	//           +-----+-----+
	//           |  3  |  2  |
	//           +-----+-----+
	//           |  0  |  1  |
	//           +-----+-----+

	this._depth = 0; // qudtree depth. 0 => mother_quadtree.
	this._numberName = 1; // mother quadtree.
	this._terranTile_owner;
	//------------------------------------------------------------
	this.projectsArray = [];
	
	this._BR_buildingsArray = []; // Old.
	this._boundingBox; // dont use this.
	this._pCloudMesh_array = []; // 1rst aproximation to the pointCloud data. Test.

	this.position; // absolute position, for do frustum culling.
	this.radius; // aprox radius for this tile.

	this.leftDown_position;
	this.rightDown_position;
	this.rightUp_position;
	this.leftUp_position;
	this.visibilityType;

	this.subTiles_array = [];
	this.terranIndexFile_readed = false;
	this.empty_tile = false;

	// File.
	this.fileReading_started = false;
	this.fileReading_finished = false;
	this.fileArrayBuffer;
	this.fileBytesReaded = 0;
	this.fileParsingFinished = false;
	this.projectsParsed_count = 0;

	this.current_BRProject_parsing;
	this.current_BRProject_parsing_state = 0;

	this.readWriter;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns br_buildingProject
 */
TerranTile.prototype.newBRProject = function() 
{
	// Old. Old. Old. Old. Old. Old. Old. Old.
	// dont use this. delete this.
	var br_buildingProject = new BRBuildingProject();
	this._BR_buildingsArray.push(br_buildingProject);
	return br_buildingProject;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns subTile
 */
TerranTile.prototype.newSubTerranTile = function() 
{
	var subTiles_count = this.subTiles_array.length;
	var subTile = new TerranTile();
	subTile._depth = this._depth + 1;
	subTile._numberName = this._numberName*10 + subTiles_count + 1;
	this.subTiles_array.push(subTile);
	return subTile;
};

/**
 * 어떤 일을 하고 있습니까?
 */
TerranTile.prototype.make4subTiles = function() 
{
	for (var i = 0; i < 4; i++) 
	{
		this.newSubTerranTile();
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param lonMin 변수
 * @param lonMax 변수
 * @param latMin 변수
 * @param latMax 변수
 */
TerranTile.prototype.setDimensions = function(lonMin, lonMax, latMin, latMax) 
{
	this.longitudeMin = lonMin;
	this.longitudeMax = lonMax;
	this.latitudeMin = latMin;
	this.latitudeMax = latMax;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param maxDepth 변수
 */
TerranTile.prototype.makeTree = function(maxDepth) 
{
	if (this._depth < maxDepth)
	{
		var subTileAux;
		for (var i = 0; i < 4; i++)
		{
			subTileAux = this.newSubTerranTile();
			subTileAux.makeTree(maxDepth);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
TerranTile.prototype.calculatePositionByLonLat = function() 
{
	var lon_mid = (this.longitudeMax + this.longitudeMin)/2.0;
	var lat_mid = (this.latitudeMax + this.latitudeMin)/2.0;

	this.position = Cesium.Cartesian3.fromDegrees(lon_mid, lat_mid, 0.0);

	this.leftDown_position = Cesium.Cartesian3.fromDegrees(this.longitudeMin, this.latitudeMin, 0.0);
	this.rightDown_position = Cesium.Cartesian3.fromDegrees(this.longitudeMax, this.latitudeMin, 0.0);
	this.rightUp_position = Cesium.Cartesian3.fromDegrees(this.longitudeMax, this.latitudeMax, 0.0);
	this.leftUp_position = Cesium.Cartesian3.fromDegrees(this.longitudeMin, this.latitudeMax, 0.0);

	this.radius = Cesium.Cartesian3.distance(this.leftDown_position, this.rightUp_position)/2.0 * 0.9;
};

/**
 * 어떤 일을 하고 있습니까?
 */
TerranTile.prototype.calculatePositionByLonLatSubTiles = function() 
{
	this.calculatePositionByLonLat();

	var subTile;
	var subTiles_count = this.subTiles_array.length; // subTiles_count must be 4.

	for (var i=0; i<subTiles_count; i++)
	{
		this.subTiles_array[i].calculatePositionByLonLatSubTiles();
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param BR_Project 변수
 */
TerranTile.prototype.parseFileHeader = function(BR_Project) 
{
	var fileLegth = this.fileArrayBuffer.byteLength;
	if (this.fileBytesReaded >= fileLegth)
	{ return; }

	var version_string_length = 5;
	var intAux_scratch = 0;
	//var auxScratch;
	var header = BR_Project._header;
	var arrayBuffer = this.fileArrayBuffer;
	var bytes_readed = this.fileBytesReaded;

	if (this.readWriter === undefined)
	{ this.readWriter = new ReaderWriter(); }

	// 1) Version(5 chars).**
	for (var j=0; j<version_string_length; j++)
	{
		header._version += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+ 1)));bytes_readed += 1;
	}

	header._f4d_version = 2;

	// 3) Global unique ID.
	intAux_scratch = this.readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
	for (var j=0; j<intAux_scratch; j++)
	{
		header._global_unique_id += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+ 1)));bytes_readed += 1;
	}

	// 4) Location.*
	header._longitude = (new Float64Array(arrayBuffer.slice(bytes_readed, bytes_readed+8)))[0]; bytes_readed += 8;
	header._latitude = (new Float64Array(arrayBuffer.slice(bytes_readed, bytes_readed+8)))[0]; bytes_readed += 8;
	header._elevation = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;

	//header._elevation += 70.0; // delete this. TEST.!!!

	// 6) BoundingBox.
	header._boundingBox.minX = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	header._boundingBox.minY = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	header._boundingBox.minZ = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	header._boundingBox.maxX = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	header._boundingBox.maxY = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;
	header._boundingBox.maxZ = (new Float32Array(arrayBuffer.slice(bytes_readed, bytes_readed+4)))[0]; bytes_readed += 4;

	var semiHeight = (header._boundingBox.maxZ - header._boundingBox.minZ )/2.0;
	header._elevation = 45.0 + semiHeight-0.5;

	var isLarge = false;
	if (header._boundingBox.maxX - header._boundingBox.minX > 40.0 || header._boundingBox.maxY - header._boundingBox.minY > 40.0)
	{
		isLarge = true;
	}

	if (!isLarge && header._boundingBox.maxZ - header._boundingBox.minZ < 30.0)
	{
		header.isSmall = true;
	}

	var imageLODs_count = this.readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

	// Now, must calculate some params of the project.*
	// 0) PositionMatrix.
	// Determine the elevation of the position.**
	var position = Cesium.Cartesian3.fromDegrees(header._longitude, header._latitude, header._elevation);
	var cartographic = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
	var height = cartographic.height;
	// End Determine the elevation of the position.-------------------------------------------------------

	//var position = Cesium.Cartesian3.fromDegrees(header._longitude, header._latitude, header._elevation);  // Original.
	position = Cesium.Cartesian3.fromDegrees(header._longitude, header._latitude, height);

	BR_Project.buildingPosition = position;

	// High and Low values of the position.*
	var splitValue = Cesium.EncodedCartesian3.encode(position);
	var splitVelue_X  = Cesium.EncodedCartesian3.encode(position.x);
	var splitVelue_Y  = Cesium.EncodedCartesian3.encode(position.y);
	var splitVelue_Z  = Cesium.EncodedCartesian3.encode(position.z);

	BR_Project.buildingPositionHIGH = new Float32Array(3);
	BR_Project.buildingPositionHIGH[0] = splitVelue_X.high;
	BR_Project.buildingPositionHIGH[1] = splitVelue_Y.high;
	BR_Project.buildingPositionHIGH[2] = splitVelue_Z.high;

	BR_Project.buildingPositionLOW = new Float32Array(3);
	BR_Project.buildingPositionLOW[0] = splitVelue_X.low;
	BR_Project.buildingPositionLOW[1] = splitVelue_Y.low;
	BR_Project.buildingPositionLOW[2] = splitVelue_Z.low;

	this.fileBytesReaded = bytes_readed;
};


/**
 * 어떤 일을 하고 있습니까?
 * @param BR_Project 변수
 */
TerranTile.prototype.parseFileSimpleBuilding = function(BR_Project) 
{
	var fileLegth = this.fileArrayBuffer.byteLength;
	if (this.fileBytesReaded >= fileLegth)
	{ return; }

	if (this.readWriter === undefined)
	{ this.readWriter = new ReaderWriter(); }

	var bytes_readed = this.fileBytesReaded;
	var startBuff;
	var endBuff;
	var arrayBuffer = this.fileArrayBuffer;

	if (BR_Project._simpleBuilding_v1 === undefined)
	{ BR_Project._simpleBuilding_v1 = new SimpleBuildingV1(); }

	var simpBuildingV1 = BR_Project._simpleBuilding_v1;
	var vbo_objects_count = this.readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4; // Almost allways is 1.

	// single interleaved buffer mode.
	for (var i=0; i<vbo_objects_count; i++) // Almost allways is 1.
	{
		var simpObj = simpBuildingV1.newSimpleObject();
		var vt_cacheKey = simpObj._vtCacheKeys_container.newVertexTexcoordsArraysCacheKey();

		var iDatas_count = this.readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		startBuff = bytes_readed;
		endBuff = bytes_readed + (4*3+2*2+1*4)*iDatas_count; // fPos_usTex_bNor.*
		vt_cacheKey.verticesArrayBuffer = arrayBuffer.slice(startBuff, endBuff);

		bytes_readed = bytes_readed + (4*3+2*2+1*4)*iDatas_count; // updating data.

		vt_cacheKey._vertices_count = iDatas_count;

	}

	// Finally read the 4byte color.
	var color_4byte_temp = this.readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

	//var b = color_4byte_temp & 0xFF;
	//var g = (color_4byte_temp & 0xFF00) >>> 8;
	//var r = (color_4byte_temp & 0xFF0000) >>> 16;
	//var a = ( (color_4byte_temp & 0xFF000000) >>> 24 ) / 255 ;

	this.fileBytesReaded = bytes_readed;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param BR_Project 변수
 * @param magoManager 변수
 */
TerranTile.prototype.parseFileNailImage = function(BR_Project, magoManager) 
{
	//BR_Project._f4d_nailImage_readed = true;

	if (BR_Project._simpleBuilding_v1 === undefined)
	{ BR_Project._simpleBuilding_v1 = new SimpleBuildingV1(); }

	if (this.readWriter === undefined)
	{ this.readWriter = new ReaderWriter(); }

	var simpBuildingV1 = BR_Project._simpleBuilding_v1;

	// Read the image.*
	var bytes_readed = this.fileBytesReaded;
	var arrayBuffer = this.fileArrayBuffer;

	var nailImageSize = this.readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
	var startBuff = bytes_readed;
	var endBuff = bytes_readed + nailImageSize;
	simpBuildingV1.textureArrayBuffer = new Uint8Array(arrayBuffer.slice(startBuff, endBuff));

	bytes_readed += nailImageSize;

	this.fileBytesReaded = bytes_readed;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param magoManager 변수
 */
TerranTile.prototype.parseFileAllBuildings = function(magoManager) 
{
	var fileLegth = this.fileArrayBuffer.byteLength;
	if (this.fileBytesReaded >= fileLegth)
	{
		this.fileParsingFinished = true;
		return;
	}

	if (this.readWriter === undefined)
	{ this.readWriter = new ReaderWriter(); }

	var arrayBuffer = this.fileArrayBuffer;
	var projects_count = this.readWriter.readInt32(arrayBuffer, 0, 4); this.fileBytesReaded += 4;

	if (projects_count === 0)
	{ this.empty_tile = true; }

	for (var i=0; i<projects_count; i++)
	{
		/*
		// 1rst, read the relative rawFile_path.
		var rawFileNamePath_length = this.readWriter.readInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;// only debug test.
		var rawFileNamePath = "";

		for(var j=0; j<rawFileNamePath_length; j++){
			rawFileNamePath += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+ 1)));bytes_readed += 1;
		}
		*/
		var bytes_readed = this.fileBytesReaded;
		this.fileBytesReaded = bytes_readed;

		this.current_BRProject_parsing = this.newBRProject();
		//this.current_BRProject_parsing._f4d_rawPathName = rawFileNamePath;

		this.parseFileHeader(this.current_BRProject_parsing);
		this.parseFileSimpleBuilding(this.current_BRProject_parsing);
		this.parseFileNailImage(this.current_BRProject_parsing, magoManager);
	}
	this.fileParsingFinished = true;
	this.fileArrayBuffer = null;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param magoManager 변수
 */
TerranTile.prototype.parseFileOneBuilding = function(gl, magoManager) 
{
	var fileLegth = this.fileArrayBuffer.byteLength;
	if (this.fileBytesReaded >= fileLegth)
	{
		this.fileParsingFinished = true;
		return;
	}

	if (this.readWriter === undefined)
	{ this.readWriter = new ReaderWriter(); }

	var projects_count = this.readWriter.readInt32(this.fileArrayBuffer, 0, 4); // only debug test.

	if (this.projectsParsed_count >= projects_count)
	{
		this.fileParsingFinished = true;
		this.fileBytesReaded = null;
		return;
	}

	if (this.current_BRProject_parsing_state === 0)
	{
		if (this.projectsParsed_count === 0)
		{ this.fileBytesReaded = 4; }

		this.current_BRProject_parsing = this.newBRProject();
	}

	var BR_Project = this.current_BRProject_parsing;

	// Read header, simpleBuilding, and the nailImage.
	if (this.current_BRProject_parsing_state === 0) 
	{
		this.parseFileHeader(BR_Project);
		this.current_BRProject_parsing_state=1;
	}
	else if (this.current_BRProject_parsing_state === 1) 
	{
		if (magoManager.backGround_imageReadings_count < 1) 
		{
			this.parseFile_simpleBuilding_old(gl, BR_Project);
			this.current_BRProject_parsing_state=2;
		}
	}
	else if (this.current_BRProject_parsing_state === 2) 
	{
		if (magoManager.backGround_imageReadings_count < 1) 
		{
			this.parseFile_nailImage_old(gl, BR_Project, magoManager);
			this.current_BRProject_parsing_state=0;
			this.projectsParsed_count++;
			magoManager.backGround_imageReadings_count ++;
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
TerranTile.prototype.setDimensionsSubTiles = function() 
{
	var subTile;
	var subTiles_count = this.subTiles_array.length; // subTiles_count must be 4.
	if (subTiles_count === 4) 
	{
		var lon_mid = (this.longitudeMax + this.longitudeMin)/2.0;
		var lat_mid = (this.latitudeMax + this.latitudeMin)/2.0;

		subTile = this.subTiles_array[0];
		subTile.setDimensions(this.longitudeMin, lon_mid, this.latitudeMin, lat_mid);

		subTile = this.subTiles_array[1];
		subTile.setDimensions(lon_mid, this.longitudeMax, this.latitudeMin, lat_mid);

		subTile = this.subTiles_array[2];
		subTile.setDimensions(lon_mid, this.longitudeMax, lat_mid, this.latitudeMax);

		subTile = this.subTiles_array[3];
		subTile.setDimensions(this.longitudeMin, lon_mid, lat_mid, this.latitudeMax);

		for (var i=0; i<subTiles_count; i++) 
		{
			this.subTiles_array[i].setDimensionsSubTiles();
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param smallefstTiles_array 변수
 */
TerranTile.prototype.getSmallestTiles = function(smallestTiles_array) 
{
	// this returns smallestTiles, if the smallestTile has buildingd inside.
	if (this.subTiles_array.length > 0) 
	{
		for (var i=0; i<this.subTiles_array.length; i++) 
		{
			this.subTiles_array[i].visibilityType = this.visibilityType;
			this.subTiles_array[i].getSmallestTiles(smallestTiles_array);
		}
	}
	else 
	{
		if (!this.empty_tile.length) { smallestTiles_array.push(this); }
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustumVolume 변수
 * @param intersectedSmallestTiles_array 변수
 * @param boundingSphere_Aux 변수
 */
TerranTile.prototype.getIntersectedSmallestTiles = function(frustumVolume, intersectedSmallestTiles_array, boundingSphere_Aux) 
{
	var intersectedTiles_array = [];
	this.getIntersectedTiles(frustumVolume, intersectedTiles_array, boundingSphere_Aux);

	var intersectedTiles_count = intersectedTiles_array.length;
	for (var i=0; i<intersectedTiles_count; i++) 
	{
		intersectedTiles_array[i].getSmallestTiles(intersectedSmallestTiles_array);
	}
	intersectedTiles_array.length = 0;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustumVolume 변수
 * @param intersectedTiles_array 변수
 * @param boundingSphere_Aux 변수
 */
TerranTile.prototype.getIntersectedTiles = function(frustumVolume, intersectedTiles_array, boundingSphere_Aux) 
{
	// Cesium dependency.
	if (this.position === undefined) { return; }

	if (boundingSphere_Aux === undefined) { boundingSphere_Aux = new Cesium.BoundingSphere(); }

	//var intersectedPoints_count = 0;
	boundingSphere_Aux.radius = this.radius;
	boundingSphere_Aux.center.x = this.position.x;
	boundingSphere_Aux.center.y = this.position.y;
	boundingSphere_Aux.center.z = this.position.z;
	this.visibilityType = frustumVolume.computeVisibility(boundingSphere_Aux); // old. change for intersectionSphere.
	/*
	boundingSphere_Aux.center = this.leftDown_position;
	if(frustumVolume.computeVisibility(boundingSphere_Aux) !== Cesium.Intersect.OUTSIDE)
		intersectedPoints_count++;

	boundingSphere_Aux.center = this.rightDown_position;
	if(frustumVolume.computeVisibility(boundingSphere_Aux) !== Cesium.Intersect.OUTSIDE)
		intersectedPoints_count++;

	boundingSphere_Aux.center = this.rightUp_position;
	if(frustumVolume.computeVisibility(boundingSphere_Aux) !== Cesium.Intersect.OUTSIDE)
		intersectedPoints_count++;

	boundingSphere_Aux.center = this.leftUp_position;
	if(frustumVolume.computeVisibility(boundingSphere_Aux) !== Cesium.Intersect.OUTSIDE)
		intersectedPoints_count++;
	*/

	if (this.visibilityType === Cesium.Intersect.OUTSIDE) 
	{
		// OUTSIDE.
		// do nothing.
	}
	else if (this.visibilityType === Cesium.Intersect.INSIDE) 
	{
		// INSIDE.
		intersectedTiles_array.push(this);
	}
	else 
	{
		// INTERSECTED.
		if (this.subTiles_array.length > 0) 
		{
			for (var i=0; i<this.subTiles_array.length; i++) 
			{
				this.subTiles_array[i].getIntersectedTiles(frustumVolume, intersectedTiles_array);
			}
		}
		else 
		{
			intersectedTiles_array.push(this);
		}
	}
};

'use strict';


/**
 * 맵 이미지. 머티리얼에는 텍스처에 대한 참조가 포함될 수 있으므로 머티리얼의 셰이더는 객체의 표면색을 계산하는 동안 텍스처를 사용할 수 있습니다.
 * 오브제의 표면의 기본 색상 (알베도) 외에도 텍스쳐는 반사율이나 거칠기와 같은 재질 표면의 많은 다른면을 나타낼 수 있습니다.
 * This class deals the image of the map which will express the texture
 * @class Texture
 */
var Texture = function() 
{
	if (!(this instanceof Texture)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.textureTypeName = "";
	this.textureImageFileName = "";
	this.texId; // webGlTexture.
	this.fileLoadState = CODE.fileLoadState.READY;
	this.imageBinaryData;
	this.imageWidth = 32;
	this.imageHeight = 32;
};

/**
 * Delete the texture Id and clear the data of this instance
 * @param gl
 */
Texture.prototype.deleteObjects = function(gl)
{
	this.textureTypeName = undefined;
	this.textureImageFileName = undefined;
	if (this.texId !== undefined)
	{
		gl.deleteTexture(this.texId);
	}
	this.texId = undefined;
	this.fileLoadState = undefined;
	this.imageBinaryData = undefined;
};

/**
 * Create the instance of texture
 * @param gl
 * @param filter the filter of this texture
 * @param data the data of image source
 * @param width the width of the texture image
 * @param height the height of the texture image
 */
Texture.createTexture = function(gl, filter, data, width, height) 
{
	// static function.
	// example of filter: gl.NEAREST
	var texture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
	if (data instanceof Uint8Array) 
	{
		//Reference : https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
	}
	else 
	{
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, data);
	}
	gl.bindTexture(gl.TEXTURE_2D, null);
	return texture;
};

'use strict';

/**
 * Manages textures of the Mago3D.
 * @class TexturesManager
 */
var TexturesManager = function(magoManager) 
{
	// class used by "neoBuilding" class.
	if (!(this instanceof TexturesManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	/**
	 * Textures loaded array.
	 * @type {Array}
	 */
	this._texturesLoaded = []; 
	this.texturesMap = {};// map<textureName, Texture>
};


/**
 * Handles the loaded image.
 * 
 * @param {WebGLRenderingContext} gl WebGL rendering context.
 * @param {image} image 
 * @param {WebGLTexture} texture 
 * @param {Boolean} flip_y_texCoords //if need vertical mirror of the image
 */
TexturesManager.handleTextureLoaded = function(gl, image, flip_y_texCoords) 
{
	if (flip_y_texCoords === undefined)
	{ flip_y_texCoords = true; }

	if (image === undefined)
	{ return undefined; }
	
	var texture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flip_y_texCoords); // if need vertical mirror of the image.
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image); // Original.
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
	gl.generateMipmap(gl.TEXTURE_2D);
	gl.bindTexture(gl.TEXTURE_2D, null);
	return texture;
};

TexturesManager.prototype.getTexture = function(textureIdx)
{
	if (textureIdx === undefined)
	{ return undefined; }
	
	if (textureIdx < 0)
	{ return undefined; }

	if (this._texturesLoaded[textureIdx] === undefined)
	{ return undefined; }

	return this._texturesLoaded[textureIdx];
};

TexturesManager.prototype.getOrNewTexture = function(textureIdx)
{
	if (textureIdx === undefined)
	{ return undefined; }
	
	if (textureIdx < 0)
	{ return undefined; }

	if (this._texturesLoaded[textureIdx] === undefined)
	{
		var texture = new Texture();
		this._texturesLoaded[textureIdx] = texture;
	}

	return this._texturesLoaded[textureIdx];
};

TexturesManager.prototype.getTextureByName = function(textureName)
{
	return texturesMap[textureName];
};

TexturesManager.loadTexture = function(imagePath, texture, magoManager, flip_y_texCoord)
{
	var imageToLoad = new Image();
	texture.fileLoadState = CODE.fileLoadState.LOADING_STARTED;

	imageToLoad.onload = function() 
	{
		var gl = magoManager.getGl();
		
		if (texture.texId === undefined) 
		{ texture.texId = gl.createTexture(); }
		
		if (flip_y_texCoord === undefined)
		{ flip_y_texCoord = false; }
		
		handleTextureLoaded(gl, imageToLoad, texture.texId, flip_y_texCoord);
		texture.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
	};

	imageToLoad.onerror = function() 
	{
		texture.fileLoadState = CODE.fileLoadState.LOAD_FAILED;
	};

	imageToLoad.src = imagePath;
};

TexturesManager.newWebGlTextureByEmbeddedImage = function(gl, embeddedImage, texture)
{
	var blob = new Blob([embeddedImage], {type: 'application/octet-binary'});
	var url = URL.createObjectURL(blob);
	texture.fileLoadState = CODE.fileLoadState.BINDING_STARTED;
	
	var img = new Image();
	img.onload = function() 
	{
		URL.revokeObjectURL(url);
		texture.texId = TexturesManager.handleTextureLoaded(gl, img);
		texture.fileLoadState = CODE.fileLoadState.BINDING_FINISHED; // file load finished.***
	};
	img.src = url;
};





































'use strict';

/**
 * Manages textures of the Mago3D.
 * @class TexturesStore
 */
var TexturesStore = function(magoManager) 
{
	if (!(this instanceof TexturesStore)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	/**
	 * Main Mago3D manager.
	 * @type {MagoManager}
	 * @default undefined.
	 */
	this._magoManager = magoManager;
	
	/**
	 * WebGL rendering context.
	 * @type {WebGLRenderingContext}
	 * @default undefined.
	 */
	this._gl = this._magoManager.getGl();

	/**
	 * Auxiliar texture 1x1 pixel.
	 * @type {WebGLTexture}
	 * @default undefined.
	 */
	this._textureAux_1x1;
	
	/**
	 * Noise texture 4x4 pixels used for ssao.
	 * @type {WebGLTexture}
	 * @default undefined.
	 */
	this._noiseTexture_4x4;
	
	this.texturesManager;
};

/**
 * Returns WebGL Rendering Context.
 */
TexturesStore.prototype.getGl = function()
{
	if (this._gl === undefined)
	{
		this._gl = this._magoManager.getGl();
	}
	
	return this._gl;
};

function isPowerOf2(number) 
{
	// Returns if the number is powerOf2.***
	return (Math.log(number)/Math.log(2)) % 1 === 0;
};

/**
 * Handles the loaded image.
 * 
 * @param {WebGLRenderingContext} gl WebGL rendering context.
 * @param {image} image 
 * @param {WebGLTexture} texture 
 * @param {Boolean} flip_y_texCoords //if need vertical mirror of the image
 */
function handleTextureLoaded(gl, image, texture, flip_y_texCoords) 
{
	if (flip_y_texCoords === undefined)
	{ flip_y_texCoords = true; }

	texture.imageWidth = image.width;
	texture.imageHeight = image.height;
	
	if (isPowerOf2(texture.imageWidth) && isPowerOf2(texture.imageHeight))
	{
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flip_y_texCoords); // if need vertical mirror of the image.
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image); // Original.
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
		gl.generateMipmap(gl.TEXTURE_2D);
		gl.bindTexture(gl.TEXTURE_2D, null);
	}
	else 
	{
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flip_y_texCoords); // if need vertical mirror of the image.
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image); // Original.
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.bindTexture(gl.TEXTURE_2D, null);
	}
};


/**
 * Returns the auxiliar texture 1x1 pixel. If is undefined, then creates it.
 */
TexturesStore.prototype.getTextureAux1x1 = function() 
{
	if (this._textureAux_1x1 === undefined)
	{
		var gl = this.getGl();
		this._textureAux_1x1 = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, this._textureAux_1x1);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([150, 150, 150, 255])); // clear grey
		gl.bindTexture(gl.TEXTURE_2D, null);
	}
	
	return this._textureAux_1x1;
};




/**
 * Generates a noise texture.
 * It detects the coner or the area which need to be shaded by the distance to camera
 * @param {WebGLRenderingContext} gl WebGL rendering context.
 * @param {Number} w The width of the texture.
 * @param {Number} h The height of the texture.
 * @param {Uint8Array} pixels Optional.
 * @returns {WebGLTexture} texture Returns WebGLTexture.
 */
function genNoiseTextureRGBA(gl, w, h, pixels) 
{
	var texture = gl.createTexture();
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, texture);

	if (pixels === undefined)
	{ pixels = new Uint8Array(4*4*4); }
	
	if (w === 4 && h === 4) 
	{
		var i = 0;
		pixels[i] = 50; i++;
		pixels[i] = 58; i++;
		pixels[i] = 229; i++;
		pixels[i] = 120; i++;
		pixels[i] = 212; i++;
		pixels[i] = 236; i++;
		pixels[i] = 251; i++;
		pixels[i] = 148; i++;
		pixels[i] = 75; i++;
		pixels[i] = 92; i++;
		pixels[i] = 246; i++;
		pixels[i] = 59; i++;
		pixels[i] = 197; i++;
		pixels[i] = 95; i++;
		pixels[i] = 235; i++;
		pixels[i] = 216; i++;
		pixels[i] = 130; i++;
		pixels[i] = 124; i++;
		pixels[i] = 215; i++;
		pixels[i] = 154; i++;
		pixels[i] = 25; i++;
		pixels[i] = 41; i++;
		pixels[i] = 221; i++;
		pixels[i] = 146; i++;
		pixels[i] = 187; i++;
		pixels[i] = 217; i++;
		pixels[i] = 130; i++;
		pixels[i] = 199; i++;
		pixels[i] = 142; i++;
		pixels[i] = 112; i++;
		pixels[i] = 61; i++;
		pixels[i] = 135; i++;
		pixels[i] = 67; i++;
		pixels[i] = 125; i++;
		pixels[i] = 159; i++;
		pixels[i] = 153; i++;
		pixels[i] = 215; i++;
		pixels[i] = 49; i++;
		pixels[i] = 49; i++;
		pixels[i] = 69; i++;
		pixels[i] = 126; i++;
		pixels[i] = 168; i++;
		pixels[i] = 61; i++;
		pixels[i] = 215; i++;
		pixels[i] = 21; i++;
		pixels[i] = 93; i++;
		pixels[i] = 183; i++;
		pixels[i] = 1; i++;
		pixels[i] = 125; i++;
		pixels[i] = 44; i++;
		pixels[i] = 22; i++;
		pixels[i] = 130; i++;
		pixels[i] = 197; i++;
		pixels[i] = 118; i++;
		pixels[i] = 109; i++;
		pixels[i] = 23; i++;
		pixels[i] = 195; i++;
		pixels[i] = 4; i++;
		pixels[i] = 148; i++;
		pixels[i] = 245; i++;
		pixels[i] = 124; i++;
		pixels[i] = 125; i++;
		pixels[i] = 185; i++;
		pixels[i] = 28; i++;
	}
	else 
	{
		for (var y=0; y<h; y++) 
		{
			for (var x=0; x<w; x++) 
			{
				pixels[(y*w + x)*4+0] = Math.floor(255 * Math.random());
				pixels[(y*w + x)*4+1] = Math.floor(255 * Math.random());
				pixels[(y*w + x)*4+2] = Math.floor(255 * Math.random());
				pixels[(y*w + x)*4+3] = Math.floor(255 * Math.random());
			}
		}
	}

	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
	gl.bindTexture(gl.TEXTURE_2D, null);

	texture.width = w;
	texture.height = h;
	return texture;
};

/**
 * Returns the noise texture 4x4 pixels. If is undefined, then creates it. This texture is used when ssao.
 */
TexturesStore.prototype.getNoiseTexture4x4 = function() 
{
	if (this._noiseTexture_4x4 === undefined)
	{
		var gl = this.getGl();
		this._noiseTexture_4x4 = genNoiseTextureRGBA(gl, 4, 4, undefined);
	}
	
	return this._noiseTexture_4x4;
};






































'use strict';

/**
 * Triangular mesh
 * @class TriPolyhedron
 */
var TriPolyhedron = function() 
{
	if (!(this instanceof TriPolyhedron)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.vertexMatrix = new VertexMatrix();
	this.vertexList = this.vertexMatrix.newVertexList(); //the list of the vertexs which consist of this feature
	this.triSurfacesArray = []; //triSurfaceArray is a list of TriSurfaces which consist of this feature
};

TriPolyhedron.prototype.newTriSurface = function() 
{
	var triSurface = new TriSurface();
	this.triSurfacesArray.push(triSurface);
	return triSurface;
};

/**
 * Inverse the direction sense of the triangle meshes
 */
TriPolyhedron.prototype.invertTrianglesSenses = function() 
{
	var triSurfacesCount = this.triSurfacesArray.length;
	for (var i=0; i<triSurfacesCount; i++)
	{
		this.triSurfacesArray[i].invertTrianglesSenses();
	}
};

/**
 * Get the information of the VBO key of the triangles which consist of the TriPolyhedron
 * @param {VBOVertexIdxCacheKey} resultVBOVertexIdxCacheKey the array which will hold the VBO key of the triangular meshes
 * @param {VBOMemoryManager} vboMemManager 
 * @returns {VBOVertexIdxCacheKey}
 */
TriPolyhedron.prototype.getVBOArrayModePosNorCol = function(resultVBOVertexIdxCacheKey, vboMemManager) 
{
	// there are "arrayMode" and the "elementMode". "elementMode" uses indices.
	if (resultVBOVertexIdxCacheKey === undefined)
	{ resultVBOVertexIdxCacheKey = new VBOVertexIdxCacheKey(); }

	if (resultVBOVertexIdxCacheKey.posVboDataArray === undefined)
	{ resultVBOVertexIdxCacheKey.posVboDataArray = []; }

	if (resultVBOVertexIdxCacheKey.norVboDataArray === undefined)
	{ resultVBOVertexIdxCacheKey.norVboDataArray = []; }

	if (resultVBOVertexIdxCacheKey.colVboDataArray === undefined)
	{ resultVBOVertexIdxCacheKey.colVboDataArray = []; }

	var positionArray = [];
	var normalsArray = [];
	var colorsArray = [];


	resultVBOVertexIdxCacheKey.vertexCount = 0;

	var vertex0, vertex1, vertex2;
	var triangle;
	var trianglesCount;
	var triSurface;
	var triSurfacesCount = this.triSurfacesArray.length;
	for (var i = 0; i < triSurfacesCount; i++) 
	{
		triSurface = this.triSurfacesArray[i];
		trianglesCount = triSurface.trianglesArray.length;
		for (var j = 0; j < trianglesCount; j++) 
		{
			triangle = triSurface.trianglesArray[j];
			if (triangle.normal === undefined)
			{ triangle.calculatePlaneNormal(); }

			// position.
			vertex0 = triangle.vertex0;
			vertex1 = triangle.vertex1;
			vertex2 = triangle.vertex2;

			positionArray.push(vertex0.point3d.x);
			positionArray.push(vertex0.point3d.y);
			positionArray.push(vertex0.point3d.z);

			positionArray.push(vertex1.point3d.x);
			positionArray.push(vertex1.point3d.y);
			positionArray.push(vertex1.point3d.z);

			positionArray.push(vertex2.point3d.x);
			positionArray.push(vertex2.point3d.y);
			positionArray.push(vertex2.point3d.z);

			// normal (use planeNormal).
			normalsArray.push(triangle.normal.x);
			normalsArray.push(triangle.normal.y);
			normalsArray.push(triangle.normal.z);

			normalsArray.push(triangle.normal.x);
			normalsArray.push(triangle.normal.y);
			normalsArray.push(triangle.normal.z);

			normalsArray.push(triangle.normal.x);
			normalsArray.push(triangle.normal.y);
			normalsArray.push(triangle.normal.z);

			// colors.
			if (vertex0.color4 === undefined) 
			{
				colorsArray.push(200);
				colorsArray.push(200);
				colorsArray.push(200);
				colorsArray.push(200);

				colorsArray.push(200);
				colorsArray.push(200);
				colorsArray.push(200);
				colorsArray.push(200);

				colorsArray.push(200);
				colorsArray.push(200);
				colorsArray.push(200);
				colorsArray.push(200);
			}
			else 
			{
				colorsArray.push(vertex0.color4.r);
				colorsArray.push(vertex0.color4.g);
				colorsArray.push(vertex0.color4.b);
				colorsArray.push(vertex0.color4.a);

				colorsArray.push(vertex1.color4.r);
				colorsArray.push(vertex1.color4.g);
				colorsArray.push(vertex1.color4.b);
				colorsArray.push(vertex1.color4.a);

				colorsArray.push(vertex2.color4.r);
				colorsArray.push(vertex2.color4.g);
				colorsArray.push(vertex2.color4.b);
				colorsArray.push(vertex2.color4.a);
			}

			resultVBOVertexIdxCacheKey.vertexCount += 3;
		}
	}

	var vertexCount = resultVBOVertexIdxCacheKey.vertexCount;
	
	var float32PosArray = new Float32Array(vertexCount*3);
	float32PosArray.set(positionArray);
	
	var int8NorArray = new Int8Array(vertexCount*3);
	int8NorArray.set(normalsArray);
	
	var uint8ColArray = new Uint8Array(vertexCount*4);
	uint8ColArray.set(colorsArray);
	
	////////////////////////////////////////////////////////////////////////////////
	// Positions
	resultVBOVertexIdxCacheKey.setDataArrayPos(float32PosArray, vboMemManager);
	
	// Normals.
	resultVBOVertexIdxCacheKey.setDataArrayNor(int8NorArray, vboMemManager);
	
	// Colors.
	resultVBOVertexIdxCacheKey.setDataArrayCol(uint8ColArray, vboMemManager);
	////////////////////////////////////////////////////////////////////////////////

	return resultVBOVertexIdxCacheKey;
};
















'use strict';

/**
 * This feature consists of TriPolyhedron
 * Using this feature, we can save the lid, bottom, and side surface.
 * @class TriSurface
 */
var TriSurface = function() 
{
	if (!(this instanceof TriSurface)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.vertexList;
	this.trianglesArray; //The array of triangles which consist of the surface
	this.trianglesList; 
};

TriSurface.prototype.newTriangle = function() 
{
	if (this.trianglesArray === undefined)
	{ this.trianglesArray = []; }
	
	var triangle = new Triangle();
	this.trianglesArray.push(triangle);
	return triangle;
};

TriSurface.prototype.invertTrianglesSenses = function() 
{
	var trianglesCount = this.trianglesArray.length;
	for (var i=0; i<trianglesCount; i++)
	{
		this.trianglesArray[i].invertSense();
	}
};



'use strict';

/**
 * VBO.
 * 
 * @class VboBuffer
 * @constructor 
 */
var VboBuffer = function(dataTarget, options) 
{
	if (!(this instanceof VboBuffer)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * VBO data array.
	 * @type {TypedArray}
	 * @default undefined
	 */
	this.dataArray;
	
	/**
	 * VBO data array length.
	 * @type {Number}
	 * @default undefined
	 */
	this.dataLength; 
	
	/**
	 * VBO data array type. (5120 : signed byte), (5121 : unsigned byte), (5122 : signed short), (5123 : unsigned short), (5126 : float).
	 * @type {Number}
	 * @default undefined
	 */
	this.dataGlType; 
	
	/**
	 * Webgl vbo identifier.
	 * @type {WebGLBuffer}
	 * @default undefined
	 */
	this.key; 
	
	/**
	 * Webgl data target. It can be gl.ARRAY_BUFFER or gl.ELEMENT_ARRAY_BUFFER. In WebGl2 added(gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, gl.TRANSFORM_FEEDBACK_BUFFER, gl.UNIFORM_BUFFER, gl.PIXEL_PACK_BUFFER, gl.PIXEL_UNPACK_BUFFER).
	 * @type {Number}
	 * @default 34962 gl.ARRAY_BUFFER
	 */
	this.dataTarget; 

	if (dataTarget !== undefined)
	{ this.dataTarget = dataTarget; }
	else 
	{ this.dataTarget = 34962; } // 34962 = gl.ARRAY_BUFFER. Default value.

	this.dataDimensions;
	this.dataStride = 0;
	this.dataOffSet = 0;
	this.normalized = false;
	this.id;
	this.bKeepDataArray = false;
	
	if (options)
	{
		if (options.bKeepDataArray !== undefined)
		{ this.bKeepDataArray = options.bKeepDataArray; }
	}
	
	this.attribLocation;
};

/**
 * Deletes all objects.
 * @param {VboMemoryManager} vboMemManager.
 */
VboBuffer.prototype.deleteGlObjects = function(vboMemManager) 
{
	if (this.key !== undefined)
	{
		var gl = vboMemManager.gl;
		
		if (this.dataTarget === gl.ARRAY_BUFFER)
		{ vboMemManager.storeClassifiedBufferKey(gl, this.key, this.dataLength); }
		else if (this.dataTarget === gl.ELEMENT_ARRAY_BUFFER)
		{ vboMemManager.storeClassifiedElementKey(gl, this.key, this.dataLength); }
	}
	
	this.dataArray = undefined;
	this.dataLength = undefined; 
	this.dataGlType = undefined; 
	this.key = undefined;
	this.dataTarget = undefined;
};

/**
 * Sets the data array.
 * @param {TypedArray} dataArray The heading value in degrees.
 * @param {VboMemoryManager} vboMemManager.
 */
VboBuffer.prototype.setDataArray = function(dataArray, dimensions, normalized, vboMemManager, attribLocation) 
{
	if (dataArray === undefined)
	{ return; }
	
	this.dataGlType = VboBuffer.getGlTypeOfArray(dataArray);
	
	var arrayElemsCount = dataArray.length;
	var classifiedPosByteSize = arrayElemsCount; // Init value.
	if (vboMemManager.enableMemoryManagement)
	{
		classifiedPosByteSize = vboMemManager.getClassifiedBufferSize(arrayElemsCount);
		this.dataArray = VboBuffer.newTypedArray(classifiedPosByteSize, this.dataGlType);
		this.dataArray.set(dataArray);
	}
	else 
	{
		this.dataArray = dataArray;
	}
	this.dataLength = arrayElemsCount;
	this.dataDimensions = dimensions;
	this.normalized = normalized;
	this.attribLocation = attribLocation;
};

/**
 * 어떤 일을 하고 있습니까?
 */

VboBuffer.prototype.bindData = function(shader, vertexAttribIndex, vboMemManager) 
{
	if (shader === undefined)
	{ return false; }
	
	var gl = shader.gl;
	if (!this.isReady(gl, vboMemManager))
	{ return false; }
	
	if (shader.enableVertexAttribArray(vertexAttribIndex))
	{
		if (this.key !== shader.lastVboKeyBindedMap[vertexAttribIndex])
		{
			gl.bindBuffer(this.dataTarget, this.key);
			gl.vertexAttribPointer(vertexAttribIndex, this.dataDimensions, this.dataGlType, this.normalized, this.dataStride, this.dataOffSet);
			shader.lastVboKeyBindedMap[vertexAttribIndex] = this.key;
		}

		return true;
	}
	else { shader.disableVertexAttribArray(vertexAttribIndex); }
	return false;
};

/**
 * 어떤 일을 하고 있습니까?
 */
 
VboBuffer.prototype.isReady = function(gl, vboMemManager) 
{
	if (this.key === undefined) 
	{
		if (this.dataArray === undefined) { return false; }
		if (this.dataLength === undefined)
		{
			this.dataLength = this.dataArray.length;
		}
		this.key = vboMemManager.getClassifiedBufferKey(gl, this.dataLength);
		if (this.key === undefined)
		{ return false; }
		gl.bindBuffer(this.dataTarget, this.key);
		gl.bufferData(this.dataTarget, this.dataArray, gl.STATIC_DRAW);
		if (!this.bKeepDataArray)
		{ this.dataArray = undefined; }
		return true;
	}
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 */
VboBuffer.getGlTypeOfArray = function(dataArray) 
{
	var glType = -1;
	if (dataArray.constructor === Float32Array)
	{ glType = 5126; } // gl.FLOAT.
	else if (dataArray.constructor === Int16Array)
	{ glType = 5122; } // gl.SHORT.
	else if (dataArray.constructor === Uint16Array)
	{ glType = 5123; } // gl.UNSIGNED_SHORT.
	else if (dataArray.constructor === Int8Array)
	{ glType = 5120; } // gl.BYTE.
	else if (dataArray.constructor === Uint8Array)
	{ glType = 5121; } // gl.UNSIGNED_BYTE.
	
	return glType;
};

/**
 * 어떤 일을 하고 있습니까?
 */
VboBuffer.newTypedArray = function(arrayLength, glType) 
{
	var typedArray;
	if (glType === 5126)// gl.FLOAT.
	{ typedArray = new Float32Array(arrayLength); }
	else if (glType === 5122)// gl.SHORT.
	{ typedArray = new Int16Array(arrayLength); }
	else if (glType === 5123)// gl.UNSIGNED_SHORT.
	{ typedArray = new Uint16Array(arrayLength); }
	else if (glType === 5120)// gl.BYTE.
	{ typedArray = new Int8Array(arrayLength); }
	else if (glType === 5121)// gl.UNSIGNED_BYTE.
	{ typedArray = new Uint8Array(arrayLength); }
		
	return typedArray;
};

/**
 * 어떤 일을 하고 있습니까?
 */
VboBuffer.getByteSizeByGlType = function(glType) 
{
	if (glType === 5126)// gl.FLOAT.
	{ return 4; }
	else if (glType === 5122)// gl.SHORT.
	{ return 2; }
	else if (glType === 5123)// gl.UNSIGNED_SHORT.
	{ return 2; }
	else if (glType === 5120)// gl.BYTE.
	{ return 1; }
	else if (glType === 5121)// gl.UNSIGNED_BYTE.
	{ return 1; }
		
	return undefined;
};




















'use strict';
/**
 * 어떤 일을 하고 있습니까?
 * @class VBOKeysNation
 */
var VBOKeysNation = function(bufferSizes, minSize) 
{
	if (!(this instanceof VBOKeysNation)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	// buffer sizes are in bytes.
	this.vboKeysStoreMap = {};
	this.bufferSizes = bufferSizes;
	this.minSize = minSize;
	this.maxSize = bufferSizes[bufferSizes.length-1];
	this.totalBytesUsed = 0;
	
	var vboKeysStore;
	var sizesCount = bufferSizes.length;
	for (var i=0; i<sizesCount; i++)
	{
		vboKeysStore = new VBOKeysStore(bufferSizes[i]);
		this.vboKeysStoreMap[bufferSizes[i]] = vboKeysStore;

		if (bufferSizes[i] > this.maxSize) { this.maxSize = bufferSizes[i]; }
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferKey. 
 */
VBOKeysNation.prototype.getClassifiedBufferKey = function(gl, bufferSize, keyWorld, onlyReuse) 
{
	// 1rst find the vboKeyStore for this bufferSize.
	var closestBufferSize = this.getClosestBufferSize(bufferSize);
	var vboKeyStore = this.vboKeysStoreMap[closestBufferSize];
	
	if (vboKeyStore)
	{
		return vboKeyStore.getBufferKey(gl, this, keyWorld, onlyReuse);
	}
	else { return -1; }
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferKey. 
 */
VBOKeysNation.prototype.storeClassifiedBufferKey = function(bufferKey, bufferSize) 
{
	// 1rst find the vboKeyStore for this bufferSize.
	var vboKeyStore = this.vboKeysStoreMap[bufferSize];
	if (vboKeyStore)
	{
		vboKeyStore.storeBufferKey(bufferKey);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns boolean. true if the currentBufferSize is in the range of this nation.
 */
VBOKeysNation.prototype.getClosestBufferSize = function(currentBufferSize) 
{
	if (!this.isInsideRange(currentBufferSize))
	{ return -1; }
	
	var sizesCount = this.bufferSizes.length;
	for (var i=0; i<sizesCount; i++)
	{
		if (currentBufferSize <= this.bufferSizes[i])
		{
			return this.bufferSizes[i];
		}
	}
	return -1;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns boolean. true if the currentBufferSize is in the range of this nation.
 */
VBOKeysNation.prototype.isInsideRange = function(bufferSize) 
{
	if (bufferSize > this.maxSize || bufferSize < this.minSize)
	{ return false; }

	return true;
};

'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class VBOKeysStore
 */
var VBOKeysStore = function(bufferSize) 
{
	if (!(this instanceof VBOKeysStore)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.classifiedSize = bufferSize;
	this.vboKeysArray = [];
	this.keysCreated = 0; // total keys created for this size.
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns boolean. 
 */
VBOKeysStore.prototype.getBufferKey = function(gl, keyNation, keyWorld, onlyReuse) 
{
	if (this.vboKeysArray.length > 0)
	{
		var vboKey = this.vboKeysArray.pop();
		return vboKey;
	}
	else 
	{
		if (!onlyReuse)
		{
			// there are no free key, so create one.
			var vboKey = gl.createBuffer();
			this.keysCreated += 1; // increment key created counter.
			keyNation.totalBytesUsed += this.classifiedSize;
			keyWorld.totalBytesUsed += this.classifiedSize;
			return vboKey;
		}
		return undefined;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns boolean. 
 */
VBOKeysStore.prototype.storeBufferKey = function(bufferKey) 
{
	this.vboKeysArray.push(bufferKey);
};

'use strict';
/**
 * 어떤 일을 하고 있습니까?
 */
var VBOKeysWorld = function() 
{
	if (!(this instanceof VBOKeysWorld)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.totalBytesUsed = 0;
	this.bytesLimit = 1000;
	
	this.vboKeysNationsArray = [];
	this.vboKeyNation12to128 = new VBOKeysNation(new Uint32Array([12, 16, 32, 48, 64, 76, 92, 128]), 0);
	this.vboKeysNationsArray.push(this.vboKeyNation12to128);
	this.vboKeyNation200to1000 = new VBOKeysNation(new Uint32Array([200, 300, 400, 500, 600, 700, 800, 900, 1000]), 129);
	this.vboKeysNationsArray.push(this.vboKeyNation200to1000);
	this.vboKeyNation1500to6000 = new VBOKeysNation(new Uint32Array([1500, 2000, 2500, 3000, 3500, 4000, 4500, 5000, 5500, 6000]), 1001);
	this.vboKeysNationsArray.push(this.vboKeyNation1500to6000);
	this.vboKeyNation7000to16000 = new VBOKeysNation(new Uint32Array([7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000]), 6001);
	this.vboKeysNationsArray.push(this.vboKeyNation7000to16000);
	this.vboKeyNation20000to56000 = new VBOKeysNation(new Uint32Array([20000, 24000, 28000, 32000, 36000, 40000, 44000, 48000, 52000, 56000]), 16001);
	this.vboKeysNationsArray.push(this.vboKeyNation20000to56000);
	this.vboKeyNation60000to150000 = new VBOKeysNation(new Uint32Array([60000, 70000, 80000, 90000, 100000, 110000, 120000, 130000, 140000, 150000]), 56001);
	this.vboKeysNationsArray.push(this.vboKeyNation60000to150000);
	this.vboKeyNation200000to1100000 = new VBOKeysNation(new Uint32Array([200000, 300000, 400000, 500000, 600000, 700000, 800000, 900000, 1000000, 1100000]), 150001);
	this.vboKeysNationsArray.push(this.vboKeyNation200000to1100000);
	this.vboKeyNation1500000to3000000 = new VBOKeysNation(new Uint32Array([1500000, 2000000, 2500000, 3000000, 6000000, 12000000, 24000000, 36000000, 60000000]), 1100001);
	this.vboKeysNationsArray.push(this.vboKeyNation1500000to3000000);
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferCacheKey
 */
VBOKeysWorld.prototype.getClassifiedBufferKey = function(gl, bufferSize) 
{
	// check gpuMemory limit.
	// If current totalBytesUsed is greater than bytesLimit, then enters in mode "onlyReuse".
	// "onlyReuse" = no allocate GPU memory, only use the existent
	var onlyReuse = false;
	if (this.totalBytesUsed > this.bytesLimit)
	{
		onlyReuse = true;
	}
	
	// 1rst, find the Nation for this bufferSize.
	var keyNation = this.getKeyNationBySize(bufferSize);
	var vboBufferKey = undefined;
	if (keyNation)
	{
		vboBufferKey = keyNation.getClassifiedBufferKey(gl, bufferSize, this, onlyReuse);
	}
	return vboBufferKey;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferCacheKey
 */
VBOKeysWorld.prototype.storeClassifiedBufferKey = function(bufferKey, bufferSize) 
{
	// 1rst, find the Nation for this bufferSize.
	var keyNation = this.getKeyNationBySize(bufferSize);
	if (keyNation)
	{ keyNation.storeClassifiedBufferKey(bufferKey, bufferSize); }
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferCacheKey
 */
VBOKeysWorld.prototype.getKeyNationBySize = function(bufferSize) 
{
	// 1rst, find the Nation for this bufferSize.
	var nationsCount = this.vboKeysNationsArray.length;
	var i=0;
	var vboBufferKey = -1;
	while (i<nationsCount)
	{
		if (this.vboKeysNationsArray[i].isInsideRange(bufferSize))
		{
			return this.vboKeysNationsArray[i];
		}
		i++;
	}
	return vboBufferKey;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferStandardSize
 */
VBOKeysWorld.prototype.getClassifiedBufferSize = function(currentBufferSize) 
{
	// 1rst, find the Nation for this bufferSize.
	var keyNation = this.getKeyNationBySize(currentBufferSize);
	var classifiedSize = -1;

	if (keyNation !== -1)
	{ classifiedSize = keyNation.getClosestBufferSize(currentBufferSize); }
	return classifiedSize;
};

'use strict';
/**
 * 어떤 일을 하고 있습니까?
 * @class VBOMemoryManager
 */
var VBOMemoryManager = function() 
{
	if (!(this instanceof VBOMemoryManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl;
	
	// if "enableMemoryManagement" == false -> no management of the gpu memory.
	this.enableMemoryManagement = defaultValue(MagoConfig.getPolicy().enableMemoryManagement, false);
	
	this.buffersKeyWorld = new VBOKeysWorld();
	this.elementKeyWorld = new VBOKeysWorld();
	
	this.buffersKeyWorld.bytesLimit = 800000000;
	this.elementKeyWorld.bytesLimit = 300000000;
	
	this.currentMemoryUsage = 0.0;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferCacheKey
 */
VBOMemoryManager.prototype.isGpuMemFull = function() 
{
	if (this.buffersKeyWorld.totalBytesUsed > this.buffersKeyWorld.bytesLimit || this.elementKeyWorld.totalBytesUsed > this.elementKeyWorld.bytesLimit)
	{ return true; }
	else { return false; }
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferCacheKey
 */
VBOMemoryManager.prototype.getClassifiedBufferKey = function(gl, bufferSize) 
{
	if (this.enableMemoryManagement)
	{ 
		var bufferKey = this.buffersKeyWorld.getClassifiedBufferKey(gl, bufferSize);
		if (bufferKey !== undefined)
		{ this.currentMemoryUsage += bufferSize; }
		return bufferKey; 
	}
	else
	{ 
		this.currentMemoryUsage += bufferSize;
		return gl.createBuffer(); 
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferCacheKey
 */
VBOMemoryManager.prototype.storeClassifiedBufferKey = function(gl, bufferKey, bufferSize) 
{
	if (this.enableMemoryManagement)
	{ this.buffersKeyWorld.storeClassifiedBufferKey(bufferKey, bufferSize); }
	else
	{ gl.deleteBuffer(bufferKey); }

	this.currentMemoryUsage -= bufferSize;
	if (this.currentMemoryUsage < 0.0)
	{ this.currentMemoryUsage = 0.0; }
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferCacheKey
 */
VBOMemoryManager.prototype.getClassifiedElementKey = function(gl, bufferSize) 
{
	if (this.enableMemoryManagement)
	{ return this.elementKeyWorld.getClassifiedBufferKey(gl, bufferSize); }
	else
	{ return gl.createBuffer(); }
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferCacheKey
 */
VBOMemoryManager.prototype.storeClassifiedElementKey = function(gl, bufferKey, bufferSize) 
{
	if (this.enableMemoryManagement)
	{ this.elementKeyWorld.storeClassifiedBufferKey(bufferKey, bufferSize); }
	else
	{ gl.deleteBuffer(bufferKey); }
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vboBufferStandardSize
 */
VBOMemoryManager.prototype.getClassifiedBufferSize = function(currentBufferSize) 
{
	if (this.enableMemoryManagement)
	{ return this.buffersKeyWorld.getClassifiedBufferSize(currentBufferSize); } 
	else
	{ return currentBufferSize; }
};
'use strict';
/**
 * 어떤 일을 하고 있습니까?
 * @class VBOVertexIdxCacheKey
 */
var VBOVertexIdxCacheKey = function() 
{
	if (!(this instanceof VBOVertexIdxCacheKey)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.indicesCount = -1;
	this.vertexCount = -1;
	this.bigTrianglesIndicesCount = -1;
	
	this.vboBufferPos;
	this.vboBufferNor;
	this.vboBufferIdx;
	this.vboBufferCol;
	this.vboBufferTCoord;
	
	this.vboBufferCustomMap;
	
	this.keepDataArrayBuffers;
	this.keepedColDataArray;
	this.keepedIdxDataArray;
	this.keepedNorDataArray;
	this.keepedPosDataArray;
	this.keepedTexCoordDataArray;
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.setKeepDataArray = function(bKeepDataArray) 
{
	this.keepDataArrayBuffers = bKeepDataArray;
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.stepOverPosNorIdx = function(arrayBuffer, readWriter, vboMemManager, bytesReaded) 
{
	var startBuff, endBuff;
	
	// 1) Positions array.
	var vertexCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4);
	bytesReaded += 4;
	var verticesFloatValuesCount = vertexCount * 3;
	startBuff = bytesReaded;
	endBuff = bytesReaded + 4 * verticesFloatValuesCount;
	bytesReaded = bytesReaded + 4 * verticesFloatValuesCount; // updating data.
	
	// 2) Normals.
	vertexCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4);
	bytesReaded += 4;
	var normalByteValuesCount = vertexCount * 3;
	startBuff = bytesReaded;
	endBuff = bytesReaded + 1 * normalByteValuesCount;
	bytesReaded = bytesReaded + 1 * normalByteValuesCount; // updating data.
	
	// 3) Indices.
	var shortIndicesValuesCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4);

	bytesReaded += 4;
	var sizeLevels = readWriter.readUInt8(arrayBuffer, bytesReaded, bytesReaded+1);
	bytesReaded +=1;
	//var sizeThresholds = [];
	for ( var k = 0; k < sizeLevels; k++ )
	{
		//sizeThresholds.push(new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)));
		bytesReaded += 4;
	}
	//var indexMarkers = [];
	for ( var k = 0; k < sizeLevels; k++ )
	{
		//indexMarkers.push(readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4));
		bytesReaded += 4;
	}
	//var bigTrianglesShortIndicesValues_count = indexMarkers[sizeLevels-1];
	//this.bigTrianglesIndicesCount = bigTrianglesShortIndicesValues_count;
	startBuff = bytesReaded;
	endBuff = bytesReaded + 2 * shortIndicesValuesCount;
	//var idxDataArray = new Uint16Array(arrayBuffer.slice(startBuff, endBuff));
	//this.setDataArrayIdx(idxDataArray, vboMemManager);

	bytesReaded = bytesReaded + 2 * shortIndicesValuesCount; // updating data.
	return bytesReaded;
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.readPositions = function(arrayBuffer, vboMemManager, bytesReaded) 
{
	// glType: (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
	// 1) read glType.
	var glType = (new Uint16Array(arrayBuffer.slice(bytesReaded, bytesReaded+2)))[0]; bytesReaded += 2;
	
	// 2) read dimensions.
	var dimensions = (new Uint8Array(arrayBuffer.slice(bytesReaded, bytesReaded+1)))[0]; bytesReaded += 1;
	
	// 3) read vertex count.
	var vertexCount = (new Uint32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	
	// 4) finally read data buffer.
	var verticesFloatValuesCount = vertexCount * dimensions;
	var startBuff = bytesReaded;
	var byteSize = VboBuffer.getByteSizeByGlType(glType);
	var endBuff = bytesReaded + byteSize * verticesFloatValuesCount;
	var dataBuffer = new Float32Array(arrayBuffer.slice(startBuff, endBuff));
	bytesReaded = bytesReaded + byteSize * verticesFloatValuesCount; // updating data.
	
	this.setDataArrayPos(dataBuffer, vboMemManager);
	
	return bytesReaded;
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.readNormals = function(arrayBuffer, vboMemManager, bytesReaded) 
{
	// glType: (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
	// 1) read glType.
	var glType = (new Uint16Array(arrayBuffer.slice(bytesReaded, bytesReaded+2)))[0]; bytesReaded += 2;
	
	// 2) read dimensions.
	var dimensions = (new Uint8Array(arrayBuffer.slice(bytesReaded, bytesReaded+1)))[0]; bytesReaded += 1;
	
	// 3) read vertex count.
	var vertexCount = (new Uint32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	
	// 4) finally read data buffer.
	var verticesFloatValuesCount = vertexCount * dimensions;
	var startBuff = bytesReaded;
	var byteSize = VboBuffer.getByteSizeByGlType(glType);
	var endBuff = bytesReaded + byteSize * verticesFloatValuesCount;
	var dataBuffer = new Int8Array(arrayBuffer.slice(startBuff, endBuff));
	bytesReaded = bytesReaded + byteSize * verticesFloatValuesCount; // updating data.
	
	this.setDataArrayNor(dataBuffer, vboMemManager);
	
	return bytesReaded;
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.readTexCoords = function(arrayBuffer, vboMemManager, bytesReaded) 
{
	// glType: (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
	// 1) read glType.
	var glType = (new Uint16Array(arrayBuffer.slice(bytesReaded, bytesReaded+2)))[0]; bytesReaded += 2;
	
	// 2) read dimensions.
	var dimensions = (new Uint8Array(arrayBuffer.slice(bytesReaded, bytesReaded+1)))[0]; bytesReaded += 1;
	
	// 3) read vertex count.
	var vertexCount = (new Uint32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	
	// 4) finally read data buffer.
	var verticesFloatValuesCount = vertexCount * dimensions;
	var startBuff = bytesReaded;
	var byteSize = VboBuffer.getByteSizeByGlType(glType);
	var endBuff = bytesReaded + byteSize * verticesFloatValuesCount;
	var dataBuffer = new Float32Array(arrayBuffer.slice(startBuff, endBuff));
	bytesReaded = bytesReaded + byteSize * verticesFloatValuesCount; // updating data.
	
	this.setDataArrayTexCoord(dataBuffer, vboMemManager);
	
	return bytesReaded;
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.readColors = function(arrayBuffer, vboMemManager, bytesReaded) 
{
	// glType: (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
	// 1) read glType.
	var glType = (new Uint16Array(arrayBuffer.slice(bytesReaded, bytesReaded+2)))[0]; bytesReaded += 2;
	
	// 2) read dimensions.
	var dimensions = (new Uint8Array(arrayBuffer.slice(bytesReaded, bytesReaded+1)))[0]; bytesReaded += 1;
	
	// 3) read vertex count.
	var vertexCount = (new Uint32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	
	// 4) finally read data buffer.
	var verticesFloatValuesCount = vertexCount * dimensions;
	var startBuff = bytesReaded;
	var byteSize = VboBuffer.getByteSizeByGlType(glType);
	var endBuff = bytesReaded + byteSize * verticesFloatValuesCount;
	var dataBuffer = new Int8Array(arrayBuffer.slice(startBuff, endBuff));
	bytesReaded = bytesReaded + byteSize * verticesFloatValuesCount; // updating data.
	
	this.setDataArrayCol(dataBuffer, vboMemManager);
	
	return bytesReaded;
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.readPosNorIdx = function(arrayBuffer, vboMemManager, bytesReaded) 
{
	// Function used by blocksList.
	var startBuff, endBuff;
	
	// 1) Positions array.
	var vertexCount = (new Uint32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	this.vertexCount = vertexCount;
	var verticesFloatValuesCount = vertexCount * 3;
	
	startBuff = bytesReaded;
	endBuff = bytesReaded + 4 * verticesFloatValuesCount;
	var posDataArray = new Float32Array(arrayBuffer.slice(startBuff, endBuff));
	this.setDataArrayPos(posDataArray, vboMemManager);

	bytesReaded = bytesReaded + 4 * verticesFloatValuesCount; // updating data.
	
	// 2) Normals.
	vertexCount = (new Uint32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	var normalByteValuesCount = vertexCount * 3;
	startBuff = bytesReaded;
	endBuff = bytesReaded + 1 * normalByteValuesCount;
	var norDataArray = new Int8Array(arrayBuffer.slice(startBuff, endBuff));
	this.setDataArrayNor(norDataArray, vboMemManager);
	
	bytesReaded = bytesReaded + 1 * normalByteValuesCount; // updating data.
	
	// 3) Indices.
	var shortIndicesValuesCount = (new Uint32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;

	var sizeLevels = (new Uint8Array(arrayBuffer.slice(bytesReaded, bytesReaded+1)))[0]; bytesReaded += 1;
	var sizeThresholds = [];
	for ( var k = 0; k < sizeLevels; k++ )
	{
		sizeThresholds.push(new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)));
		bytesReaded += 4;
	}
	var indexMarkers = [];
	for ( var k = 0; k < sizeLevels; k++ )
	{
		indexMarkers.push(new Uint32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)));
		bytesReaded += 4;
	}
	var bigTrianglesShortIndicesValues_count = indexMarkers[sizeLevels-1];
	this.bigTrianglesIndicesCount = bigTrianglesShortIndicesValues_count;
	startBuff = bytesReaded;
	endBuff = bytesReaded + 2 * shortIndicesValuesCount;
	var idxDataArray = new Uint16Array(arrayBuffer.slice(startBuff, endBuff));
	this.setDataArrayIdx(idxDataArray, vboMemManager);

	bytesReaded = bytesReaded + 2 * shortIndicesValuesCount; // updating data.
	return bytesReaded;
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.bindDataCustom = function(shader, vboMemManager, name) 
{
	if (shader === undefined)
	{ return false; }

	var vboBufferCustom = this.vboBufferCustomMap[name];
	return vboBufferCustom.bindData(shader, vboBufferCustom.attribLoc, vboMemManager);
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.bindDataPosition = function(shader, vboMemManager) 
{
	if (shader === undefined)
	{ return false; }

	return this.vboBufferPos.bindData(shader, shader.position3_loc, vboMemManager);
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.bindDataNormal = function(shader, vboMemManager) 
{
	if (shader === undefined)
	{ return false; }
	
	var vboBufferNor = this.vboBufferNor;
	if (vboBufferNor === undefined)
	{
		shader.disableVertexAttribArray(shader.normal3_loc);
		return true; // Return "true" bcos there are no "normal" data, that is different that having "normal" data and not prepared yet.
	}
	
	return vboBufferNor.bindData(shader, shader.normal3_loc, vboMemManager);
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.bindDataTexCoord = function(shader, vboMemManager) 
{
	if (shader === undefined)
	{ return false; }
	
	var vboBufferTCoord = this.vboBufferTCoord;
	if (vboBufferTCoord === undefined)
	{
		shader.disableVertexAttribArray(shader.texCoord2_loc);
		return true; // Return "true" bcos there are no "tCoord" data, that is different that having "tCoord" data and not prepared yet.
	}
	
	return vboBufferTCoord.bindData(shader, shader.texCoord2_loc, vboMemManager);
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.bindDataColor = function(shader, vboMemManager) 
{
	if (shader === undefined)
	{ return false; }
	
	var vboBufferCol = this.vboBufferCol;
	if (vboBufferCol === undefined)
	{
		shader.disableVertexAttribArray(shader.color4_loc);
		return true; // Return "true" bcos there are no "color" data, that is different that having "color" data and not prepared yet.
	}
	
	return vboBufferCol.bindData(shader, shader.color4_loc, vboMemManager);
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.bindDataIndice = function(shader, vboMemManager) 
{
	if (shader === undefined)
	{ return false; }
	
	var gl = shader.gl;
	
	var vboBufferIdx = this.vboBufferIdx;
	if (!vboBufferIdx.isReady(gl, vboMemManager))
	{ return false; }
	
	if (vboBufferIdx.key !== shader.lastVboKeyBindedMap.elemIdx)
	{
		gl.bindBuffer(vboBufferIdx.dataTarget, vboBufferIdx.key);
		shader.lastVboKeyBindedMap.elemIdx = vboBufferIdx.key;
	}
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.getVboCustom = function(name) 
{
	if (this.vboBufferCustomMap === undefined)
	{ return undefined; }
	
	return this.vboBufferCustomMap[name];
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.setDataArrayCustom = function(customDataArray, vboMemManager, dimensions, name, attribLoc) 
{
	if (customDataArray === undefined)
	{ return; }

	if (dimensions === undefined)
	{ return; }

	if (name === undefined)
	{ return; }

	if (attribLoc === undefined)
	{ return; }

	if (this.vboBufferCustomMap === undefined)
	{ this.vboBufferCustomMap = {}; }
	
	var gl = vboMemManager.gl;
	var vboBufferCustom = new VboBuffer(gl.ARRAY_BUFFER); 
	var normalized = false;
	vboBufferCustom.setDataArray(customDataArray, dimensions, normalized, vboMemManager, attribLoc);
	this.vboBufferCustomMap[name] = vboBufferCustom;
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.setDataArrayPos = function(posDataArray, vboMemManager, dimensions) 
{
	if (posDataArray === undefined)
	{ return; }
	
	var gl = vboMemManager.gl;
	if (this.vboBufferPos === undefined)
	{ this.vboBufferPos = new VboBuffer(gl.ARRAY_BUFFER); }
	if (dimensions === undefined)
	{ dimensions = 3; }
	var normalized = false;
	this.vboBufferPos.setDataArray(posDataArray, dimensions, normalized, vboMemManager);
	this.vertexCount = this.vboBufferPos.dataLength/dimensions;
	
	if (this.keepDataArrayBuffers)
	{ this.keepedPosDataArray = posDataArray; }
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.setDataArrayNor = function(norDataArray, vboMemManager) 
{
	if (norDataArray === undefined)
	{ return; }

	var gl = vboMemManager.gl;
	if (this.vboBufferNor === undefined)
	{ this.vboBufferNor = new VboBuffer(gl.ARRAY_BUFFER); }
	
	var dimensions = 3;
	var normalized = true;
	this.vboBufferNor.setDataArray(norDataArray, dimensions, normalized, vboMemManager);
	
	if (this.keepDataArrayBuffers)
	{ this.keepedNorDataArray = norDataArray; }
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.setDataArrayIdx = function(idxDataArray, vboMemManager) 
{
	if (idxDataArray === undefined)
	{ return; }

	var gl = vboMemManager.gl;
	if (this.vboBufferIdx === undefined)
	{ this.vboBufferIdx = new VboBuffer(gl.ELEMENT_ARRAY_BUFFER); }
	
	var dimensions = 1;
	var normalized = false;
	this.vboBufferIdx.setDataArray(idxDataArray, dimensions, normalized, vboMemManager);
	this.indicesCount = this.vboBufferIdx.dataLength;
	
	if (this.keepDataArrayBuffers)
	{ this.keepedIdxDataArray = idxDataArray; }
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.setDataArrayCol = function(colDataArray, vboMemManager) 
{
	if (colDataArray === undefined)
	{ return; }

	var gl = vboMemManager.gl;
	if (this.vboBufferCol === undefined)
	{ this.vboBufferCol = new VboBuffer(gl.ARRAY_BUFFER); }
	
	var dimensions = 4;
	var normalized = true;
	this.vboBufferCol.setDataArray(colDataArray, dimensions, normalized, vboMemManager);
	
	if (this.keepDataArrayBuffers)
	{ this.keepedColDataArray = colDataArray; }
};

/**
 * 어떤 일을 하고 있습니까?
 */
VBOVertexIdxCacheKey.prototype.setDataArrayTexCoord = function(texCoordDataArray, vboMemManager) 
{
	if (texCoordDataArray === undefined)
	{ return; }

	var gl = vboMemManager.gl;
	
	if (this.vboBufferTCoord === undefined)
	{ this.vboBufferTCoord = new VboBuffer(gl.ARRAY_BUFFER); }
	
	var dimensions = 2;
	var normalized = false;
	this.vboBufferTCoord.setDataArray(texCoordDataArray, dimensions, normalized, vboMemManager);
	
	if (this.keepDataArrayBuffers)
	{ this.keepedTexCoordDataArray = texCoordDataArray; }
};


/**
 * 어떤 일을 하고 있습니까?
 * @returns vboViCacheKey
 */
VBOVertexIdxCacheKey.prototype.deleteGlObjects = function(gl, vboMemManager) 
{
	if (this.vboBufferPos !== undefined)
	{
		this.vboBufferPos.deleteGlObjects(vboMemManager);	
		this.vboBufferPos = undefined;
	}
	if (this.vboBufferNor !== undefined)
	{
		this.vboBufferNor.deleteGlObjects(vboMemManager);	
		this.vboBufferNor = undefined;
	}
	if (this.vboBufferIdx !== undefined)
	{
		this.vboBufferIdx.deleteGlObjects(vboMemManager);	
		this.vboBufferIdx = undefined;
	}
	if (this.vboBufferCol !== undefined)
	{
		this.vboBufferCol.deleteGlObjects(vboMemManager);	
		this.vboBufferCol = undefined;
	}
	if (this.vboBufferTCoord !== undefined)
	{
		this.vboBufferTCoord.deleteGlObjects(vboMemManager);	
		this.vboBufferTCoord = undefined;
	}
	
	// If exist:
	this.keepedColDataArray = undefined;
	this.keepedIdxDataArray = undefined;
	this.keepedNorDataArray = undefined;
	this.keepedPosDataArray = undefined;
	this.keepedTexCoordDataArray = undefined;
};

'use strict';


/**
 * This class is the container which holds the VBO Cache Keys
 * @class VBOVertexIdxCacheKeysContainer
 */
var VBOVertexIdxCacheKeysContainer = function() 
{
	if (!(this instanceof VBOVertexIdxCacheKeysContainer)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.vboCacheKeysArray = []; //the container of vbo keys
};

/**
 * Create the default VBO instance
 * @returns {VBOVertexIdxCacheKey} vboVertexIdxCacheKey
 */
VBOVertexIdxCacheKeysContainer.prototype.newVBOVertexIdxCacheKey = function() 
{
	if (this.vboCacheKeysArray === undefined)
	{ this.vboCacheKeysArray = []; }
	
	var vboVertexIdxCacheKey = new VBOVertexIdxCacheKey();
	this.vboCacheKeysArray.push(vboVertexIdxCacheKey);
	return vboVertexIdxCacheKey;
};

/**
 * Clear the data of this instance
 * @param gl
 * @param {VBOMemoryManager} vboMemManager
 */
VBOVertexIdxCacheKeysContainer.prototype.deleteGlObjects = function(gl, vboMemManager) 
{
	if (this.vboCacheKeysArray === undefined)
	{ return; }
	
	var vboDatasCount = this.vboCacheKeysArray.length;
	for (var j = 0; j < vboDatasCount; j++) 
	{
		this.vboCacheKeysArray[j].deleteGlObjects(gl, vboMemManager);
		this.vboCacheKeysArray[j] = undefined;
	}
	this.vboCacheKeysArray.length = 0;
	this.vboCacheKeysArray = undefined;
};

/**
 * 
 * @returns {Number} the number of the key that this instance holds
 */
VBOVertexIdxCacheKeysContainer.prototype.getVbosCount = function() 
{
	if (this.vboCacheKeysArray === undefined) { return 0; }
	
	return this.vboCacheKeysArray.length;
};

/**
 * Get the VBO key by the index
 * @param {Number} idx
 * @returns {VBOVertexIdxCacheKey}
 */
VBOVertexIdxCacheKeysContainer.prototype.getVboKey = function(idx) 
{
	if (this.vboCacheKeysArray === undefined)
	{ return undefined; }
	
	var vbo = this.vboCacheKeysArray[idx];
	return vbo;
};

'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class VisibleObjectsController
 */
var VisibleObjectsController = function() 
{
	if (!(this instanceof VisibleObjectsController)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	// This object works with FrustumVolumeControl.
	this.currentVisibles0 = []; 
	this.currentVisibles1 = []; 
	this.currentVisibles2 = []; 
	this.currentVisibles3 = []; 
	this.currentVisiblesAux = [];
	this.currentVisibleNativeObjects = {
		opaquesArray      : [],
		transparentsArray : [],
		excavationsArray  : [],
		vectorTypeArray   : []
	};
	this.currentVisiblesToPrepare = [];
	
	this.bSphere;
	this.bFrustumNear;
	this.bFrustumFar;
};
VisibleObjectsController.prototype.initArrays = function() 
{
	this.currentVisibles0 = [];
	this.currentVisibles1 = [];
	this.currentVisibles2 = [];
	this.currentVisibles3 = [];
	this.currentVisiblesAux = [];
	this.currentVisibleNativeObjects = {
		opaquesArray      : [],
		transparentsArray : [],
		excavationsArray  : [],
		vectorTypeArray   : []
	};
	this.currentVisiblesToPrepare = [];
	
	this.bSphere = undefined;
	this.bFrustumNear = undefined;
	this.bFrustumFar = undefined;
};
/**Clear all of the volumn's data */

VisibleObjectsController.prototype.clear = function() 
{
	this.currentVisibles0.length = 0;
	this.currentVisibles1.length = 0;
	this.currentVisibles2.length = 0;
	this.currentVisibles3.length = 0;
	this.currentVisiblesAux.length = 0;
	this.currentVisibleNativeObjects.opaquesArray.length = 0;
	this.currentVisibleNativeObjects.transparentsArray.length = 0;
	this.currentVisibleNativeObjects.excavationsArray.length = 0;
	this.currentVisibleNativeObjects.vectorTypeArray.length = 0;
	this.currentVisiblesToPrepare.length = 0;
	
	
	this.bSphere = undefined;
	this.bFrustumNear = undefined;
	this.bFrustumFar = undefined;
};

/**
 * Make all volumns visible
 */
VisibleObjectsController.prototype.getAllVisibles = function() 
{
	var resultVisiblesArray = [].concat(this.currentVisibles0, this.currentVisibles1, this.currentVisibles2, this.currentVisibles3);
	return resultVisiblesArray;
};

/**
 * Make two volumns : 0, 1
 */
VisibleObjectsController.prototype.get01Visibles = function() 
{
	var resultVisiblesArray = [].concat(this.currentVisibles0, this.currentVisibles1);
	return resultVisiblesArray;
};

/**
 * Make two volumns : 0, 1
 */
VisibleObjectsController.prototype.hasRenderables = function() 
{

	if (this.currentVisibles0.length > 0 || 
		this.currentVisibles1.length > 0 || 
		this.currentVisibles2.length > 0 || 
		this.currentVisibles3.length > 0 || 
		this.currentVisiblesAux.length > 0 || 
		this.currentVisibleNativeObjects.opaquesArray.length > 0 ||
		this.currentVisibleNativeObjects.transparentsArray.length > 0 ||
		this.currentVisibleNativeObjects.excavationsArray.length > 0 ||
		this.currentVisibleNativeObjects.vectorTypeArray.length > 0)
	{ return true; }
	else
	{ return false; }

};

/**
 * Put the node to given node array
 * @param nodesArray
 * @param node
 */
VisibleObjectsController.prototype.putNativeObject = function(object) 
{
	// check if the object if opaque or transparent.
	if (object instanceof MagoRenderable) 
	{
		var isOpaque = object.isOpaque();
		//var isOpaque = true;
		if (isOpaque)
		{
		  this.currentVisibleNativeObjects.opaquesArray.push(object);
		}
		else 
		{
		  this.currentVisibleNativeObjects.transparentsArray.push(object);
		}
	}
	else if (object instanceof Excavation) 
	{
		this.currentVisibleNativeObjects.excavationsArray.push(object);
	}
	else 
	{
		this.currentVisibleNativeObjects.opaquesArray.push(object);
	}
};

/**
 * 
 */
VisibleObjectsController.prototype.getObjectIdxSortedByDist = function(objectsArray, startIdx, endIdx, object) 
{
	// this do a dicotomic search of idx in a ordered table.
	// 1rst, check the range.
	var range = endIdx - startIdx;
	if (range < 6)
	{
		// in this case do a lineal search.
		var finished = false;
		var i = startIdx;
		var idx;

		while (!finished && i<=endIdx)
		{
			var anObject = objectsArray[i];
			if (object.distToCamera < anObject.distToCamera)
			{
				idx = i;
				finished = true;
			}
			i++;
		}
		
		if (finished)
		{ return idx; }
		else 
		{ return endIdx+1; }
	}
	else 
	{
		// in this case do the dicotomic search.
		var middleIdx = startIdx + Math.floor(range/2);
		var newStartIdx;
		var newEndIdx;
		var middleObject = objectsArray[middleIdx];
		if (middleObject.distToCamera > object.distToCamera)
		{
			newStartIdx = startIdx;
			newEndIdx = middleIdx;
		}
		else 
		{
			newStartIdx = middleIdx;
			newEndIdx = endIdx;
		}
		return this.getObjectIdxSortedByDist(objectsArray, newStartIdx, newEndIdx, object);
	}
};

/**
 * Put the object by distance from camera
 * @param {VisibleObjectsController}objectsArray
 * @param {Octree}object 
 */
VisibleObjectsController.prototype.putObjectToArraySortedByDist = function(objectsArray, object) 
{
	if (objectsArray.length > 0)
	{
		var startIdx = 0;
		var endIdx = objectsArray.length - 1;
		var idx = this.getObjectIdxSortedByDist(objectsArray, startIdx, endIdx, object);
		               
		
		objectsArray.splice(idx, 0, object);
	}
	else 
	{
		objectsArray.push(object);
	}
};

/**
 * Get the index of the node which is in nodesArray
 * @param nodesArray
 * @param {Number} startIdx
 * @param {Number} endIdx
 * @param node
 */
VisibleObjectsController.prototype.getNodeIdxSortedByDist = function(nodesArray, startIdx, endIdx, node) 
{
	// Note: Function exclusive to use with Node class objects.
	// this do a dicotomic search of idx in a ordered table.
	// 1rst, check the range.
	var neoBuilding = node.data.neoBuilding;
	var range = endIdx - startIdx;
	if (range < 6)
	{
		// in this case do a lineal search.
		var finished = false;
		var i = startIdx;
		var idx;

		while (!finished && i<=endIdx)
		{
			var aNode = nodesArray[i];
			if (node.data.distToCam < aNode.data.distToCam)
			{
				idx = i;
				finished = true;
			}
			i++;
		}
		
		if (finished)
		{ return idx; }
		else 
		{ return endIdx+1; }
	}
	else 
	{
		// in this case do the dicotomic search.
		var middleIdx = startIdx + Math.floor(range/2);
		var newStartIdx;
		var newEndIdx;
		var middleNode = nodesArray[middleIdx];
		if (middleNode.data.distToCam > node.data.distToCam)
		{
			newStartIdx = startIdx;
			newEndIdx = middleIdx;
		}
		else 
		{
			newStartIdx = middleIdx;
			newEndIdx = endIdx;
		}
		return this.getNodeIdxSortedByDist(nodesArray, newStartIdx, newEndIdx, node);
	}
};

/**
 * Calculates a boundingSphere for visibleArray.
 */
VisibleObjectsController.calculateBoundingSphereForArray = function(visiblesArray, resultBoundingSphere) 
{
	if (resultBoundingSphere === undefined)
	{ resultBoundingSphere = new BoundingSphere(); }
	
	var visiblesCount = visiblesArray.length;
	var bSphere;
	for (var i=0; i<visiblesCount; i++)
	{
		var visible = visiblesArray[i];
		if (visible === undefined)
		{ continue; }
		
		bSphere = visible.getBoundingSphereWC(bSphere);
		if (i === 0)
		{
			resultBoundingSphere.copyFrom(bSphere);
		}
		else 
		{
			resultBoundingSphere.addBSphere(bSphere);
		}
		
	}
	
	return resultBoundingSphere;
};

/**
 * Given a nodes array, this returns the nodes in the boundary of the nodes group.
 */
VisibleObjectsController.getBoundaryNodes = function(visiblesArray, resultBoundaryNodesArray) 
{
	if (resultBoundaryNodesArray === undefined)
	{ resultBoundaryNodesArray = []; }

	var minLonCandidate;
	var minLatCandidate;
	var maxLonCandidate;
	var maxLatCandidate;
	
	var minLonVisible;
	var maxLonVisible;
	var minLatVisible;
	var maxLatVisible;
	
	var visiblesCount = visiblesArray.length;
	for (var i=0; i<visiblesCount; i++)
	{
		var visible = visiblesArray[i];
		var geoCoord = visible.data.geographicCoord;
		if (i===0)
		{
			minLonCandidate = geoCoord.longitude;
			minLatCandidate = geoCoord.latitude;
			maxLonCandidate = geoCoord.longitude;
			maxLatCandidate = geoCoord.latitudes;
			minLonVisible = visible;
			maxLonVisible = visible;
			minLatVisible = visible;
			maxLatVisible = visible;
		}
		else
		{
			if (geoCoord.longitude < minLonCandidate)
			{ 
				minLonCandidate = geoCoord.longitude; 
				minLonVisible = visible;
			}
			else if (geoCoord.longitude > maxLonCandidate)
			{ 
				maxLonCandidate = geoCoord.longitude; 
				maxLonVisible = visible;
			}
			
			if (geoCoord.latitude < minLatCandidate)
			{ 
				minLatCandidate = geoCoord.latitude; 
				minLatVisible = visible;
			}
			else if (geoCoord.latitude > maxLatCandidate)
			{ 
				maxLatCandidate = geoCoord.latitude; 
				maxLatVisible = visible;
			}
		}
	}
	
	resultBoundaryNodesArray.push.apply(resultBoundaryNodesArray, [minLonVisible, maxLonVisible, minLatVisible, maxLatVisible]);
	return resultBoundaryNodesArray;
};

/**
 * Calculates a boundingFrustum for all visibles array, in other words, calculates the nearDist & farDist of the visibleNodes.
 */
VisibleObjectsController.prototype.calculateBoundingFrustum = function(camera) 
{
	var visiblesArray = this.currentVisibles0.concat(this.currentVisibles1, this.currentVisibles2, this.currentVisibles3);
	
	if (visiblesArray.length === 0)
	{ return; }

	var camPos = camera.getPosition();
	var camDir = camera.getDirection();
	var camPosCopy = new Point3D(camPos.x, camPos.y, camPos.z);
	var camDirCopy = new Point3D(camDir.x, camDir.y, camDir.z);
	var camDirLine = new Line(camPosCopy, camDirCopy);

	var filteredVisiblesArray = [];
	filteredVisiblesArray = VisibleObjectsController.getBoundaryNodes(visiblesArray, filteredVisiblesArray);
	
	var nearSquareDistCandidate = 10E10;
	var farSquareDistCandidate = 0.0;
	var vecAux = new Point3D();
	
	var nodesCount = filteredVisiblesArray.length;
	for (var i=0; i<nodesCount; i++)
	{
		var visible = filteredVisiblesArray[i];
		var bSphere = visible.getBoundingSphereWC(bSphere);
		if (!bSphere)
		{ continue; }
		
		var centerPoint = bSphere.getCenterPoint();
		var radius = bSphere.getRadius();
		var projectedPoint = camDirLine.getProjectedPoint(centerPoint, undefined);
		var nearPoint = new Point3D(projectedPoint.x - camDir.x * radius, projectedPoint.y - camDir.y * radius, projectedPoint.z - camDir.z * radius);
		var farPoint = new Point3D(projectedPoint.x + camDir.x * radius, projectedPoint.y + camDir.y * radius, projectedPoint.z + camDir.z * radius);
		
		var currNearSquareDist = camPos.squareDistTo(nearPoint.x, nearPoint.y, nearPoint.z);
		var currFarSquareDist = camPos.squareDistTo(farPoint.x, farPoint.y, farPoint.z);
		
		// must check if the nearPoint is rear of the camera.
		if (nearSquareDistCandidate > 0.0)
		{
			vecAux.set(nearPoint.x - camPos.x, nearPoint.y - camPos.y, nearPoint.z - camPos.z);
			var dotProd = camDir.scalarProduct(vecAux);
			if (dotProd < 0.0)
			{
				// the nearPoint is rear of the camera.
				currNearSquareDist = 0.0;
			}
		}
		else
		{ currNearSquareDist = 0.0; }
		
		
		if (i === 0)
		{
			nearSquareDistCandidate = currNearSquareDist;
			farSquareDistCandidate = currFarSquareDist;
		}
		else
		{
			if (currNearSquareDist < nearSquareDistCandidate)
			{ nearSquareDistCandidate = currNearSquareDist; }
			
			if (currFarSquareDist > farSquareDistCandidate)
			{ farSquareDistCandidate = currFarSquareDist; }
		}
	}
	
	this.bFrustumNear = Math.sqrt(nearSquareDistCandidate);
	this.bFrustumFar = Math.sqrt(farSquareDistCandidate);
};

/**
 * Calculates a boundingSphere for all visibles array.
 */
VisibleObjectsController.prototype.calculateBoundingSpheres = function() 
{
	//this.currentVisibles0; 
	//this.currentVisibles1; 
	//this.currentVisibles2; 
	//this.currentVisibles3; 
	//this.currentVisiblesAux; // todo:
	//this.currentVisibleNativeObjects;  // todo:
	
	// check currentVisibles & make a boundingSphere for each visibles array.
	if (this.bSphere === undefined)
	{ this.bSphere = new BoundingSphere(); }

	var visiblesArray = this.currentVisibles0.concat(this.currentVisibles1, this.currentVisibles2, this.currentVisibles3);
	
	if (visiblesArray.length === 0)
	{ return; }

	var filteredVisiblesArray = [];
	filteredVisiblesArray = VisibleObjectsController.getBoundaryNodes(visiblesArray, filteredVisiblesArray);
	this.bSphere = VisibleObjectsController.calculateBoundingSphereForArray(filteredVisiblesArray, this.bSphere);
};

/**
 * Put the node to given node array
 * @param nodesArray
 * @param node
 */
VisibleObjectsController.prototype.putNodeToArraySortedByDist = function(nodesArray, node) 
{
	// Note: Function exclusive to use with Node class objects.
	if (nodesArray.length > 0)
	{
		var startIdx = 0;
		var endIdx = nodesArray.length - 1;
		var idx = this.getNodeIdxSortedByDist(nodesArray, startIdx, endIdx, node);
		
		nodesArray.splice(idx, 0, node);
	}
	else 
	{
		nodesArray.push(node);
	}
};

/**
 * Put the node to given node array
 * @param nodesArray
 * @param node
 */
VisibleObjectsController.prototype.putNodeByLod = function(node, lod) 
{
	if (lod === 0 || lod === 1) 
	{
		this.putNodeToArraySortedByDist(this.currentVisibles0, node);
	}
	else if (lod === 2) 
	{
		this.putNodeToArraySortedByDist(this.currentVisibles2, node);
	}
	else if (lod > 2) 
	{
		this.putNodeToArraySortedByDist(this.currentVisibles3, node);
	}
};
















'use strict';

/**
 * mago3djs API
 * 
 * @alias API
 * @class API
 * 
 * @param {any} apiName api이름
 */
function API(apiName)
{
	if (!(this instanceof API)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	// mago3d 활성화/비활성화 여부
	this.magoEnable = true;
	// return
	this.returnable = false;

	// api 이름
	this.apiName = apiName;
	
	// project id
	this.projectId = null;
	this.projectDataFolder = null;
	// objectIds
	this.objectIds = null;
	// data_key
	this.dataKey = null;
	// issueId
	this.issueId = null;
	// issueType
	this.issueType = null;
	// drawType 이미지를 그리는 유형 0 : DB, 1 : 이슈등록
	this.drawType = 0;

	// 위도
	this.latitude = 0;
	// 경도
	this.longitude = 0;
	// 높이
	this.elevation = 0;
	// heading
	this.heading = 0;
	// pitch
	this.pitch = 0;
	// roll
	this.roll = 0;
	// duration
	this.duration = 0;

	// 속성
	this.property = null;
	// 색깔
	this.color = 0;
	// structs = MSP, outfitting = MOP
	this.blockType = null;
	// outfitting 표시/비표시
	this.showOutFitting = false;
	// label 표시/비표시
	this.showLabelInfo = true;
	// origin 표시/비표시
	this.showOrigin = false;
	// boundingBox 표시/비표시
	this.showBoundingBox = false;
	// 그림자 표시/비표시
	this.showShadow = false;
	// frustum culling 가시 거리(M단위)
	this.frustumFarDistance = 0;
	// move mode 
	this.objectMoveMode = CODE.moveMode.NONE;
	// 이슈 등록 표시
	this.issueInsertEnable = false;
	// object 정보 표시
	this.objectInfoViewEnable = false;
	// 이슈 목록 표시
	this.nearGeoIssueListEnable = false;
	// occlusion culling
	this.occlusionCullingEnable = false;
	//
	this.insertIssueState = 0;
	
	// LOD1
	this.lod0DistInMeters = null;
	this.lod1DistInMeters = null;
	this.lod2DistInMeters = null;
	this.lod3DistInMeters = null;
	this.lod4DistInMeters = null;
	this.lod5DistInMeters = null;
	
	// Lighting
	this.ambientReflectionCoef = null;
	this.diffuseReflectionCoef = null;
	this.specularReflectionCoef = null;
	this.ambientColor = null;
	this.specularColor = null;
	
	this.ssaoRadius = null;
	//
	this.FPVMode = false;

	// input x, y, z
	this.inputPoint = null;
	// result x, y, z
	this.resultPoint = null;
	
	// General magoMode.
	this.magoMode = CODE.magoMode.NORMAL;

	//position unit
	this.unit = CODE.units.DEGREE;

	//for staticModel instantiate
	this.instantiateObj = null;

	//for staticModel add
	this.staticModelAttributeObj = null;

	//animation option. 
	this.animationOption = null;

	/**
	 * @type {trackOption}
	 */
	this.trackOption = null;

	/**
	 * @type {nodeAttribute}
	 */
	this.nodeAttribute = null;
};

API.prototype.getMagoEnable = function() 
{
	return this.magoEnable;
};
API.prototype.setMagoEnable = function(magoEnable) 
{
	this.magoEnable = magoEnable;
};

API.prototype.getReturnable = function()
{
	return this.returnable;
};
API.prototype.setReturnable = function(returnable)
{
	this.returnable = returnable;
};

API.prototype.getAPIName = function() 
{
	return this.apiName;
};

API.prototype.getProjectId = function() 
{
	return this.projectId;
};
API.prototype.setProjectId = function(projectId) 
{
	this.projectId = projectId;
};

API.prototype.getProjectDataFolder = function() 
{
	return this.projectDataFolder;
};
API.prototype.setProjectDataFolder = function(projectDataFolder) 
{
	this.projectDataFolder = projectDataFolder;
};

API.prototype.getObjectIds = function() 
{
	return this.objectIds;
};
API.prototype.setObjectIds = function(objectIds) 
{
	this.objectIds = objectIds;
};

API.prototype.getIssueId = function() 
{
	return this.issueId;
};
API.prototype.setIssueId = function(issueId) 
{
	this.issueId = issueId;
};
API.prototype.getIssueType = function() 
{
	return this.issueType;
};
API.prototype.setIssueType = function(issueType) 
{
	this.issueId = issueType;
};

API.prototype.getDataKey = function() 
{
	return this.dataKey;
};
API.prototype.setDataKey = function(dataKey) 
{
	this.dataKey = dataKey;
};

API.prototype.getLatitude = function() 
{
	return this.latitude;
};
API.prototype.setLatitude = function(latitude) 
{
	this.latitude = latitude;
};

API.prototype.getLongitude = function() 
{
	return this.longitude;
};
API.prototype.setLongitude = function(longitude) 
{
	this.longitude = longitude;
};

API.prototype.getElevation = function() 
{
	return this.elevation;
};
API.prototype.setElevation = function(elevation) 
{
	this.elevation = elevation;
};

API.prototype.getHeading = function() 
{
	return this.heading;
};
API.prototype.setHeading = function(heading) 
{
	this.heading = heading;
};

API.prototype.getPitch = function() 
{
	return this.pitch;
};
API.prototype.setPitch = function(pitch) 
{
	this.pitch = pitch;
};

API.prototype.getRoll = function() 
{
	return this.roll;
};
API.prototype.setRoll = function(roll) 
{
	this.roll = roll;
};

API.prototype.getProperty = function() 
{
	return this.property;
};
API.prototype.setProperty = function(property) 
{
	this.property = property;
};

API.prototype.getColor = function() 
{
	return this.color;
};
API.prototype.setColor = function(color) 
{
	this.color = color;
};

API.prototype.getBlockType = function() 
{
	return this.blockType;
};
API.prototype.setBlockType = function(blockType) 
{
	this.blockType = blockType;
};

API.prototype.getShowOutFitting = function() 
{
	return this.showOutFitting;
};
API.prototype.setShowOutFitting = function(showOutFitting) 
{
	this.showOutFitting = showOutFitting;
};


API.prototype.getShowLabelInfo = function() 
{
	return this.showLabelInfo;
};
API.prototype.setShowLabelInfo = function(showLabelInfo) 
{
	this.showLabelInfo = showLabelInfo;
};

API.prototype.getShowOrigin = function()
{
	return this.showOrigin;
};
API.prototype.setShowOrigin = function(showOrigin)
{
	this.showOrigin = showOrigin;
};

API.prototype.getShowBoundingBox = function() 
{
	return this.showBoundingBox;
};
API.prototype.setShowBoundingBox = function(showBoundingBox) 
{
	this.showBoundingBox = showBoundingBox;
};

API.prototype.getShowShadow = function() 
{
	return this.showShadow;
};
API.prototype.setShowShadow = function(showShadow) 
{
	this.showShadow = showShadow;
};

API.prototype.getFrustumFarDistance = function() 
{
	return this.frustumFarDistance;
};
API.prototype.setFrustumFarDistance = function(frustumFarDistance) 
{
	this.frustumFarDistance = frustumFarDistance;
};

API.prototype.getObjectMoveMode = function() 
{
	return this.objectMoveMode;
};
API.prototype.setObjectMoveMode = function(objectMoveMode) 
{
	this.objectMoveMode = objectMoveMode;
};

API.prototype.getIssueInsertEnable = function() 
{
	return this.issueInsertEnable;
};
API.prototype.setIssueInsertEnable = function(issueInsertEnable) 
{
	this.issueInsertEnable = issueInsertEnable;
};
API.prototype.getObjectInfoViewEnable = function() 
{
	return this.objectInfoViewEnable;
};
API.prototype.setObjectInfoViewEnable = function(objectInfoViewEnable) 
{
	this.objectInfoViewEnable = objectInfoViewEnable;
};
API.prototype.getOcclusionCullingEnable = function() 
{
	return this.occlusionCullingEnable;
};
API.prototype.setOcclusionCullingEnable = function(occlusionCullingEnable) 
{
	this.occlusionCullingEnable = occlusionCullingEnable;
};
API.prototype.getNearGeoIssueListEnable = function() 
{
	return this.nearGeoIssueListEnable;
};
API.prototype.setNearGeoIssueListEnable = function(nearGeoIssueListEnable) 
{
	this.nearGeoIssueListEnable = nearGeoIssueListEnable;
};

API.prototype.getInsertIssueState = function() 
{
	return this.insertIssueState;
};
API.prototype.setInsertIssueState = function(insertIssueState) 
{
	this.insertIssueState = insertIssueState;
};

API.prototype.getDrawType = function() 
{
	return this.drawType;
};
API.prototype.setDrawType = function(drawType) 
{
	this.drawType = drawType;
};

API.prototype.getLod0DistInMeters = function() 
{
	return this.lod0DistInMeters;
};
API.prototype.setLod0DistInMeters = function(lod0DistInMeters) 
{
	this.lod0DistInMeters = lod0DistInMeters;
};
API.prototype.getLod1DistInMeters = function() 
{
	return this.lod1DistInMeters;
};
API.prototype.setLod1DistInMeters = function(lod1DistInMeters) 
{
	this.lod1DistInMeters = lod1DistInMeters;
};
API.prototype.getLod2DistInMeters = function() 
{
	return this.lod2DistInMeters;
};
API.prototype.setLod2DistInMeters = function(lod2DistInMeters) 
{
	this.lod2DistInMeters = lod2DistInMeters;
};
API.prototype.getLod3DistInMeters = function() 
{
	return this.lod3DistInMeters;
};
API.prototype.setLod3DistInMeters = function(lod3DistInMeters) 
{
	this.lod3DistInMeters = lod3DistInMeters;
};
API.prototype.getLod4DistInMeters = function() 
{
	return this.lod4DistInMeters;
};
API.prototype.setLod4DistInMeters = function(lod4DistInMeters) 
{
	this.lod4DistInMeters = lod4DistInMeters;
};
API.prototype.getLod5DistInMeters = function() 
{
	return this.lod5DistInMeters;
};
API.prototype.setLod5DistInMeters = function(lod5DistInMeters) 
{
	this.lod5DistInMeters = lod5DistInMeters;
};

API.prototype.getAmbientReflectionCoef = function() 
{
	return this.ambientReflectionCoef;
};
API.prototype.setAmbientReflectionCoef = function(ambientReflectionCoef) 
{
	this.ambientReflectionCoef = ambientReflectionCoef;
};
API.prototype.getDiffuseReflectionCoef = function() 
{
	return this.diffuseReflectionCoef;
};
API.prototype.setDiffuseReflectionCoef = function(diffuseReflectionCoef) 
{
	this.diffuseReflectionCoef = diffuseReflectionCoef;
};
API.prototype.getSpecularReflectionCoef = function() 
{
	return this.specularReflectionCoef;
};
API.prototype.setSpecularReflectionCoef = function(specularReflectionCoef) 
{
	this.specularReflectionCoef = specularReflectionCoef;
};
API.prototype.getAmbientColor = function() 
{
	return this.ambientColor;
};
API.prototype.setAmbientColor = function(ambientColor) 
{
	this.ambientColor = ambientColor;
};
API.prototype.getSpecularColor = function() 
{
	return this.specularColor;
};
API.prototype.setSpecularColor = function(specularColor) 
{
	this.specularColor = specularColor;
};
API.prototype.getSsaoRadius = function() 
{
	return this.ssaoRadius;
};
API.prototype.setSsaoRadius = function(ssaoRadius) 
{
	this.ssaoRadius = ssaoRadius;
};
API.prototype.getFPVMode = function()
{
	return this.FPVMode;
};
API.prototype.setFPVMode = function(value)
{
	this.FPVMode = value;
};
API.prototype.getMagoMode = function()
{
	return this.magoMode;
};
API.prototype.setMagoMode = function(value)
{
	this.magoMode = value;
};
API.prototype.getDuration = function()
{
	return this.duration;
};
API.prototype.setDuration = function(duration)
{
	this.duration = duration;
};

API.prototype.getInputPoint = function()
{
	return this.inputPoint;
};
API.prototype.setInputPoint = function(inputPoint)
{
	this.inputPoint = inputPoint;
};

API.prototype.getResultPoint = function()
{
	return this.resultPoint;
};
API.prototype.setResultPoint = function(resultPoint)
{
	this.resultPoint = resultPoint;
};

API.prototype.getUnit = function()
{
	return this.unit;
};
API.prototype.setUnit = function(unit)
{
	if (unit !== undefined)
	{
		if (isNaN(unit) || unit > CODE.units.RADIAN)
		{
			throw new Error('unit parameter needs CODE.units');
		}
		this.unit = unit;
	}
};

API.prototype.getInstantiateObj = function()
{
	return this.instantiateObj;
};
API.prototype.setInstantiateObj = function(instantiateObj)
{
	this.instantiateObj = instantiateObj;
};

API.prototype.getStaticModelAttributeObj = function()
{
	return this.staticModelAttributeObj;
};
API.prototype.setStaticModelAttributeObj = function(staticModelAttributeObj)
{
	this.staticModelAttributeObj = staticModelAttributeObj;
};

API.prototype.getAnimationOption = function()
{
	return this.animationOption;
};
API.prototype.setAnimationOption = function(animationOption)
{
	this.animationOption = animationOption;
};

API.prototype.getTrackOption = function()
{
	return this.trackOption;
};
API.prototype.setTrackOption = function(trackOption)
{
	this.trackOption = trackOption;
};

API.prototype.getNodeAttribute = function()
{
	return this.nodeAttribute;
};
API.prototype.setNodeAttribute = function(nodeAttribute)
{
	this.nodeAttribute = nodeAttribute;
};

'use strict';

/**
 * 사용자가 변경한 moving, color, rotation 등 이력 정보를 위한 domain
 * @class Policy
 */
var ChangeHistory = function() 
{
	if (!(this instanceof ChangeHistory)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.moveHistory = false;
	this.colorHistory = false;
	this.rotationHistory = false;
	
	// move mode. ALL : 0 , OBJECT : 1, NONE : 2
	this.objectMoveMode = null;
	
	// project id
	this.projectId = null;
	// project data folder
	this.projectDataFolder = null;
	// data_key
	this.dataKey = null;	
	// objectId
	this.objectId = null;
	// objectIndexOrder
	this.objectIndexOrder = 0;
	
	// referenceObject aditional movement.
	this.refObjectAditionalMove;
	this.refObjectAditionalMoveRelToBuilding;
	
	// 위도
	this.latitude = 0.0;
	// 경도
	this.longitude = 0.0;
	// 높이
	this.elevation = 0.0;
	// heading
	this.heading = 0.0;
	// pitch
	this.pitch = 0.0;
	// roll
	this.roll = 0.0;
	// duration
	this.duration = 0;
	// 색깔
	this.color = 0;
	// color rgb
	this.rgbColor = [];
	// 속성
	this.property = null;
	this.propertyKey = null;
	this.propertyValue = null;
};

ChangeHistory.prototype.getReferenceObjectAditionalMovement = function() 
{
	if (this.refObjectAditionalMove === undefined)
	{ this.refObjectAditionalMove = new Point3D(); }
	
	return this.refObjectAditionalMove;
};

ChangeHistory.prototype.getReferenceObjectAditionalMovementRelToBuilding = function() 
{
	if (this.refObjectAditionalMoveRelToBuilding === undefined)
	{ this.refObjectAditionalMoveRelToBuilding = new Point3D(); }
	
	return this.refObjectAditionalMoveRelToBuilding;
};

ChangeHistory.prototype.getProjectId = function() 
{
	return this.projectId;
};
ChangeHistory.prototype.setProjectId = function(projectId) 
{
	this.projectId = projectId;
};

ChangeHistory.prototype.getProjectDataFolder = function() 
{
	return this.projectDataFolder;
};
ChangeHistory.prototype.setProjectDataFolder = function(projectDataFolder) 
{
	this.projectDataFolder = projectDataFolder;
};

ChangeHistory.prototype.getDataKey = function() 
{
	return this.dataKey;
};
ChangeHistory.prototype.setDataKey = function(dataKey) 
{
	this.dataKey = dataKey;
};

ChangeHistory.prototype.getObjectId = function() 
{
	return this.objectId;
};
ChangeHistory.prototype.setObjectId = function(objectId) 
{
	this.objectId = objectId;
};

ChangeHistory.prototype.getObjectIndexOrder = function() 
{
	return this.objectIndexOrder;
};
ChangeHistory.prototype.setObjectIndexOrder = function(objectIndexOrder) 
{
	this.objectIndexOrder = objectIndexOrder;
};

ChangeHistory.prototype.getLatitude = function() 
{
	return this.latitude;
};
ChangeHistory.prototype.setLatitude = function(latitude) 
{
	this.latitude = latitude;
};

ChangeHistory.prototype.getLongitude = function() 
{
	return this.longitude;
};
ChangeHistory.prototype.setLongitude = function(longitude) 
{
	this.longitude = longitude;
};

ChangeHistory.prototype.getElevation = function() 
{
	return this.elevation;
};
ChangeHistory.prototype.setElevation = function(elevation) 
{
	this.elevation = elevation;
};

ChangeHistory.prototype.getHeading = function() 
{
	return this.heading;
};
ChangeHistory.prototype.setHeading = function(heading) 
{
	this.heading = heading;
};

ChangeHistory.prototype.getPitch = function() 
{
	return this.pitch;
};
ChangeHistory.prototype.setPitch = function(pitch) 
{
	this.pitch = pitch;
};

ChangeHistory.prototype.getRoll = function() 
{
	return this.roll;
};
ChangeHistory.prototype.setRoll = function(roll) 
{
	this.roll = roll;
};

ChangeHistory.prototype.getColor = function() 
{
	return this.color;
};
ChangeHistory.prototype.setColor = function(color) 
{
	this.color = color;
};
ChangeHistory.prototype.getRgbColor = function() 
{
	return this.rgbColor;
};
ChangeHistory.prototype.setRgbColor = function(rgbColor) 
{
	this.rgbColor = rgbColor;
};

ChangeHistory.prototype.getProperty = function() 
{
	return this.property;
};
ChangeHistory.prototype.setProperty = function(property) 
{
	this.property = property;
};
ChangeHistory.prototype.getPropertyKey = function() 
{
	return this.propertyKey;
};
ChangeHistory.prototype.setPropertyKey = function(propertyKey) 
{
	this.propertyKey = propertyKey;
};
ChangeHistory.prototype.getPropertyValue = function() 
{
	return this.propertyValue;
};
ChangeHistory.prototype.setPropertyValue = function(propertyValue) 
{
	this.propertyValue = propertyValue;
};

ChangeHistory.prototype.getDuration = function()
{
	return this.duration;
};
ChangeHistory.prototype.setDuration = function(duration)
{
	this.duration = duration;
};

ChangeHistory.prototype.getObjectMoveMode = function() 
{
	return this.objectMoveMode;
};
ChangeHistory.prototype.setObjectMoveMode = function(objectMoveMode) 
{
	this.objectMoveMode = objectMoveMode;
};
"use strict";

var CODE = {};

// magoManager가 다 로딩 되지 않은 상태에서 화면으로 부터 호출 되는 것을 막기 위해
CODE.magoManagerState = {
	"INIT"   	: 0,
	"STARTED"	: 1,
	"READY"   : 2
};

//0 = no started to load. 1 = started loading. 2 = finished loading. 3 = parse started. 4 = parse finished.
CODE.fileLoadState = {
	"READY"            : 0,
	"LOADING_STARTED"  : 1,
	"LOADING_FINISHED" : 2,
	"PARSE_STARTED"    : 3,
	"PARSE_FINISHED"   : 4,
	"IN_QUEUE"         : 5,
	"IN_PARSE_QUEUE"   : 6,
	"BINDING_STARTED"  : 7,
	"BINDING_FINISHED" : 8,
	"LOAD_FAILED"      : 9
};

CODE.moveMode = {
	"ALL"              : "0",
	"OBJECT"           : "1",
	"GEOGRAPHICPOINTS" : "2",
	"NONE"             : "3"
};

CODE.magoMode = {
	"NORMAL"  : 0,
	"DRAWING" : 1
};

CODE.magoCurrentProcess = {
	"Unknown"                    : 0,
	"DepthRendering"             : 1,
	"ColorRendering"             : 2,
	"ColorCodeRendering"         : 3,
	"DepthShadowRendering"       : 4,
	"SilhouetteDepthRendering"   : 5,
	"StencilSilhouetteRendering" : 6
};

CODE.modelerMode = {
	"INACTIVE"                 : 0,
	"DRAWING_POLYLINE"         : 1,
	"DRAWING_PLANEGRID"        : 2,
	"DRAWING_GEOGRAPHICPOINTS" : 3,
	"DRAWING_EXCAVATIONPOINTS" : 4,
	"DRAWING_TUNNELPOINTS"     : 5,
	"DRAWING_BSPLINE"          : 6,
	"DRAWING_BASICFACTORY"     : 7,
	"DRAWING_STATICGEOMETRY"   : 8,
	"DRAWING_PIPE"             : 9,
	"DRAWING_SPHERE"           : 10,
	"DRAWING_BOX"              : 11,
	"DRAWING_CUTTINGPLANE"     : 12,
	"DRAWING_CLIPPINGBOX"      : 13,
	"DRAWING_CONCENTRICTUBES"  : 14,
	"DRAWING_TUBE"             : 15,
	"DRAWING_FREECONTOURWALL"  : 16,
	"DRAWING_CYLYNDER"         : 17
};

CODE.boxFace = {
	"UNKNOWN" : 0,
	"LEFT"    : 1,
	"RIGHT"   : 2,
	"FRONT"   : 3,
	"REAR"    : 4,
	"TOP"     : 5,
	"BOTTOM"  : 6
};

CODE.modelerDrawingState = {
	"NO_STARTED" : 0,
	"STARTED"    : 1
};

CODE.modelerDrawingElement = {
	"NOTHING"          : 0,
	"POINTS"           : 1,
	"LINES"            : 2,
	"POLYLINES"        : 3,
	"GEOGRAPHICPOINTS" : 4,
};

CODE.units = {
	"METRE"  : 0,
	"DEGREE" : 1,
	"RADIAN" : 2
};


CODE.trackMode = {
	"TRACKING" : 0,
	"DRIVER"   : 1
};

CODE.movementType = {
	"NO_MOVEMENT" : 0,
	"TRANSLATION" : 1,
	"ROTATION"    : 2,
	"ROTATION_ZX" : 3
};

CODE.imageryType = {
	"UNKNOWN"      : 0,
	"CRS84"        : 1,
	"WEB_MERCATOR" : 2
};

CODE.animationType = {
	"UNKNOWN"         : 0,
	"REALTIME_POINTS" : 1,
	"PATH"            : 2
};

CODE.relativePosition2D = {
	"UNKNOWN"    : 0,
	"LEFT"       : 1,
	"RIGHT"      : 2,
	"COINCIDENT" : 3
};

CODE.PROJECT_ID_PREFIX = "projectId_";
CODE.PROJECT_DATA_FOLDER_PREFIX = "projectDataFolder_";

'use strict';

/**
 * 상수 설정
 * @class Constant
 */
var Constant = {};

Constant.CESIUM = "cesium";
Constant.WORLDWIND = "worldwind";
Constant.MAGOWORLD = "magoworld";
Constant.OBJECT_INDEX_FILE = "/objectIndexFile.ihe";
Constant.TILE_INDEX_FILE = "/smartTile_f4d_indexFile.sii";
Constant.CACHE_VERSION = "?cache_version=";
Constant.SIMPLE_BUILDING_TEXTURE3x3_BMP = "/SimpleBuildingTexture3x3.bmp";
Constant.RESULT_XDO2F4D = "/Result_xdo2f4d/Images/";
Constant.RESULT_XDO2F4D_TERRAINTILES = "/Result_xdo2f4d/F4D_TerrainTiles/";
Constant.RESULT_XDO2F4D_TERRAINTILEFILE_TXT = "/Result_xdo2f4d/f4dTerranTileFile.txt";

Constant.INTERSECTION_OUTSIDE = 0;
Constant.INTERSECTION_INTERSECT= 1;
Constant.INTERSECTION_INSIDE = 2;
Constant.INTERSECTION_POINT_A = 3;
Constant.INTERSECTION_POINT_B = 4;

'use strict';

/**
 * mago3D 전체 환경 설정을 관리
 * @class MagoConfig
 */
var MagoConfig = {};

MagoConfig.setContainerId = function(containerId) 
{
	this.containerId = containerId;
};

MagoConfig.getContainerId = function() 
{
	return this.containerId;
};

MagoConfig.getPolicy = function() 
{
	return this.serverPolicy;
};

MagoConfig.getGeoserver = function() 
{
	return this.geoserver;
};

MagoConfig.getData = function(key) 
{
	return this.dataObject[key];
};

MagoConfig.isDataExist = function(key) 
{
	return this.dataObject.hasOwnProperty(key);
};

MagoConfig.deleteData = function(key) 
{
	return delete this.dataObject[key];
};

/**
 * data 를 map에 저장
 * @param key map에 저장될 key
 * @param value map에 저장될 value
 */
MagoConfig.setData = function(key, value) 
{
	if (!this.isDataExist(key)) 
	{
		this.dataObject[key] = value;
	}
};

/**
 * F4D Converter 실행 결과물이 저장된 project data folder 명을 획득
 * @param projectDataFolder data folder
 */
MagoConfig.getProjectDataFolder = function(projectDataFolder) 
{
	var key = CODE.PROJECT_DATA_FOLDER_PREFIX + projectDataFolder;
	return this.dataObject[key];
};

/**
 * project map에 data folder명의 존재 유무를 검사
 * @param projectDataFolder
 */
MagoConfig.isProjectDataFolderExist = function(projectDataFolder) 
{
	var key = CODE.PROJECT_DATA_FOLDER_PREFIX + projectDataFolder;
	return this.dataObject.hasOwnProperty(key);
};

/**
 * project data folder명을 map에서 삭제
 * @param projectDataFolder
 */
MagoConfig.deleteProjectDataFolder = function(projectDataFolder) 
{
	var key = CODE.PROJECT_DATA_FOLDER_PREFIX + projectDataFolder;
	return delete this.dataObject[key];
};

/**
 * project data folder명을 Object에서 삭제
 * @param projectDataFolder Object에 저장될 key
 * @param value Object에 저장될 value
 */
MagoConfig.setProjectDataFolder = function(projectDataFolder, value) 
{
	var key = CODE.PROJECT_DATA_FOLDER_PREFIX + projectDataFolder;
	if (!this.isProjectDataFolderExist(key))
	{
		this.dataObject[key] = value;
	}
};

/**
 * 환경설정 초기화
 * @param serverPolicy mago3d policy(json)
 * @param projectIdArray data 정보를 map 저장할 key name
 * @param projectDataArray data 정보(json)
 */
MagoConfig.init = function(serverPolicy, projectIdArray, projectDataArray) 
{
	if (!serverPolicy || !serverPolicy instanceof Object) 
	{
		throw new Error('geopolicy is required object.');
	}
	this.dataObject = {};
	
	this.selectHistoryObject = {};
	this.movingHistoryObject = {};
	this.colorHistoryObject = {};
	this.locationAndRotationHistoryObject = {};

	this.serverPolicy = serverPolicy;
	this.twoDimension = false;
	if (!this.serverPolicy.basicGlobe) { this.serverPolicy.basicGlobe = Constant.CESIUM; }

	this.serverPolicy.online = true;

	if (this.serverPolicy.geoserverEnable) 
	{
		this.geoserver = new GeoServer();

		var info = {
			"wmsVersion"    : this.serverPolicy.geoserverWmsVersion,
			"dataUrl"       : this.serverPolicy.geoserverDataUrl,
			"dataWorkspace" : this.serverPolicy.geoserverDataWorkspace,
			"dataStore"     : this.serverPolicy.geoserverDataStore,
			"user"          : this.serverPolicy.geoserverUser,
			"password"      : this.serverPolicy.geoserverPassword
		};
		this.geoserver.setServerInfo(info);
	}


	if (projectIdArray && projectIdArray.length > 0) 
	{
		for (var i=0; i<projectIdArray.length; i++) 
		{
			if (!this.isDataExist(CODE.PROJECT_ID_PREFIX + projectIdArray[i])) 
			{
				this.setData(CODE.PROJECT_ID_PREFIX + projectIdArray[i], projectDataArray[i]);
				this.setProjectDataFolder(CODE.PROJECT_DATA_FOLDER_PREFIX + projectDataArray[i].data_key, projectDataArray[i].data_key);
			}
		}
	}
};

/**
 * 모든 데이터를 삭제함
 */
MagoConfig.clearAllData = function() 
{
	this.dataObject = {};
};

/**
 * 모든 선택 히스토리 삭제
 */
MagoConfig.clearSelectHistory = function() 
{
	this.selectHistoryObject = {};
};

/**
 * 모든 object 선택 내용 이력을 취득
 */
MagoConfig.getAllSelectHistory = function()
{
	return this.selectHistoryObject;
};

/**
 * project 별 해당 키에 해당하는 모든 object 선택 내용 이력을 취득
 */
MagoConfig.getSelectHistoryObjects = function(projectId, dataKey)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.selectHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	return dataKeyObject;
};

/**
 * object 선택 내용 이력을 취득
 */
MagoConfig.getSelectHistoryObject = function(projectId, dataKey, objectIndexOrder)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.selectHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined) { return undefined; }
	// objectIndexOrder 를 저장
	return dataKeyObject[objectIndexOrder];
};

/**
 * object 선택 내용을 저장
 */
MagoConfig.saveSelectHistory = function(projectId, dataKey, objectIndexOrder, changeHistory) 
{
	// projectId 별 Object을 검사
	var projectIdObject = this.selectHistoryObject.get(projectId);
	if (projectIdObject === undefined)
	{
		projectIdObject = {};
		this.selectHistoryObject[projectId] = projectIdObject;
	}
	
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined)
	{
		dataKeyObject = {};
		projectIdObject[dataKey] = dataKeyObject;
	}
	
	// objectIndexOrder 를 저장
	dataKeyObject[objectIndexOrder] = changeHistory;
};

/**
 * object 선택 내용을 삭제
 */
MagoConfig.deleteSelectHistoryObject = function(projectId, dataKey, objectIndexOrder)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.selectHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined) { return undefined; }
	// objectIndexOrder 를 저장
	return delete dataKeyObject[objectIndexOrder];
};

/**
 * 모든 이동 히스토리 삭제
 */
MagoConfig.clearMovingHistory = function() 
{
	this.movingHistoryObject = {};
};

/**
 * 모든 object 선택 내용 이력을 취득
 */
MagoConfig.getAllMovingHistory = function()
{
	return this.movingHistoryObject;
};

/**
 * project별 입력키 값과 일치하는 object 이동 내용 이력을 취득
 */
MagoConfig.getMovingHistoryObjects = function(projectId, dataKey)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.movingHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	return dataKeyObject;
};

/**
 * object 이동 내용 이력을 취득
 */
MagoConfig.getMovingHistoryObject = function(projectId, dataKey, objectIndexOrder)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.movingHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined) { return undefined; }
	// objectIndexOrder 를 저장
	return dataKeyObject[objectIndexOrder];
};

/**
 * object 이동 내용을 저장
 */
MagoConfig.saveMovingHistory = function(projectId, dataKey, objectIndexOrder, changeHistory) 
{
	// projectId 별 Object을 검사
	var projectIdObject = this.movingHistoryObject[projectId];
	if (projectIdObject === undefined)
	{
		projectIdObject = {};
		this.movingHistoryObject[projectId] = projectIdObject;
	}
	
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined)
	{
		dataKeyObject = {};
		projectIdObject[dataKey] = dataKeyObject;
	}
	
	// objectIndexOrder 를 저장
	dataKeyObject[objectIndexOrder] = changeHistory;
};

/**
 * object 이동 내용을 삭제
 */
MagoConfig.deleteMovingHistoryObject = function(projectId, dataKey, objectIndexOrder)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.movingHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined) { return undefined; }
	// objectIndexOrder 를 저장
	return delete dataKeyObject[objectIndexOrder];
};

/**
 * 모든 색깔 변경 이력을 획득
 */
MagoConfig.getAllColorHistory = function() 
{
	return this.colorHistoryObject;
};

/**
 * 모든 색깔변경 히스토리 삭제
 */
MagoConfig.clearColorHistory = function() 
{
	this.colorHistoryObject = {};
};

/**
 * project별 키에 해당하는 모든 색깔 변경 이력을 획득
 */
MagoConfig.getColorHistorys = function(projectId, dataKey)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.colorHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	return dataKeyObject;
};

/**
 * 색깝 변경 이력을 획득
 */
MagoConfig.getColorHistory = function(projectId, dataKey, objectId)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.colorHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined) { return undefined; }
	// objectId 를 저장
	return dataKeyObject[objectId];
};

/**
 * 색깝 변경 내용을 저장
 */
MagoConfig.saveColorHistory = function(projectId, dataKey, objectId, changeHistory) 
{
	// projectId 별 Object을 검사
	var projectIdObject = this.colorHistoryObject[projectId];
	if (projectIdObject === undefined)
	{
		projectIdObject = {};
		this.colorHistoryObject[projectId] = projectIdObject;
	}
	
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined)
	{
		dataKeyObject = {};
		projectIdObject[dataKey] = dataKeyObject;
	}

	if (objectId === null || objectId === "") 
	{
		dataKeyObject[dataKey] = changeHistory;
	}
	else 
	{
		dataKeyObject[objectId] = changeHistory;
	}
};

/**
 * 색깔 변경 이력을 삭제
 */
MagoConfig.deleteColorHistory = function(projectId, dataKey, objectId)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.colorHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined) { return undefined; }
	// objectIndexOrder 를 저장
	return delete dataKeyObject[objectId];
};

/**
 * 모든 색깔변경 히스토리 삭제
 */
MagoConfig.clearColorHistory = function() 
{
	this.colorHistoryObject = {};
};

/**
 * 모든 location and rotation 변경 이력을 획득
 */
MagoConfig.getAllLocationAndRotationHistory = function() 
{
	return this.locationAndRotationHistoryObject;
};

/**
 * 프로젝트별 해당 키 값을 갖는 모든 location and rotation 이력을 획득
 */
MagoConfig.getLocationAndRotationHistorys = function(projectId, dataKey)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.locationAndRotationHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	return dataKeyObject;
};

/**
 * location and rotation 이력을 획득
 */
MagoConfig.getLocationAndRotationHistory = function(projectId, dataKey)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.locationAndRotationHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	
	return dataKeyObject;
};

/**
 * location and rotation 내용을 저장
 */
MagoConfig.saveLocationAndRotationHistory = function(projectId, dataKey, changeHistory) 
{
	// projectId 별 Object을 검사
	var projectIdObject = this.locationAndRotationHistoryObject[projectId];
	if (projectIdObject === undefined)
	{
		projectIdObject = {};
		this.locationAndRotationHistoryObject[projectId] = projectIdObject;
	}
	
	// dataKey 별 Object을 검사
	var dataKeyObject = projectIdObject[dataKey];
	if (dataKeyObject === undefined)
	{
		dataKeyObject = {};
	}

	dataKeyObject[dataKey] = changeHistory;
};

/**
 * location and rotation 이력을 삭제
 */
MagoConfig.deleteLocationAndRotationHistory = function(projectId, dataKey)
{
	// projectId 별 Object을 검사
	var projectIdObject = this.locationAndRotationHistoryObject[projectId];
	if (projectIdObject === undefined) { return undefined; }
	// dataKey 별 Object을 검사
	var dataKeyObject = delete projectIdObject[dataKey];
};

/**
 * 모든 location and rotation 히스토리 삭제
 */
MagoConfig.clearLocationAndRotationHistory = function() 
{
	this.locationAndRotationHistoryObject = {};
};
	
/**
 * TODO 이건 나중에 활요. 사용하지 않음
 * check 되지 않은 데이터들을 삭제함
 * @param keyObject 비교할 맵
 */
/*MagoConfig.clearUnSelectedData = function(keyObject)
{
	for (var key of this.dataObject.keys())
	{
		if (!keyObject.hasxxxxx(key))
		{
			// data folder path가 존재하면....
			if (key.indexOf(CODE.PROJECT_DATA_FOLDER_PREFIX) >= 0) 
			{
				// 지우는 처리가 있어야 함
			}
			this.dataObject.delete(key);
		}
	}
};*/

MagoConfig.setTwoDimension = function(twoDimension) 
{
	this.twoDimension = twoDimension;
};
MagoConfig.isTwoDimension = function()
{
	return this.twoDimension;
};
'use strict';

/**
 * Policy
 * @class Policy
 */
var Policy = function() 
{
	if (!(this instanceof Policy)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	// mago3d 활성화/비활성화 여부
	this.magoEnable = true;

	// outfitting 표시 여부
	this.showOutFitting = false;
	// label 표시/비표시
	this.showLabelInfo = false;
	// boundingBox 표시/비표시
	this.showBoundingBox = false;
	// 그림자 표시/비표시
	this.showShadow = false;
	// squared far frustum 거리
	this.frustumFarSquaredDistance = 5000000;
	// far frustum
	this.frustumFarDistance = 20000;

	// highlighting
	this.highLightedBuildings = [];
	// color
	this.colorBuildings = [];
	// color
	this.color = [];
	// show/hide
	this.hideBuildings = [];
	// move mode
	this.objectMoveMode = CODE.moveMode.NONE;
	// 이슈 등록 표시
	this.issueInsertEnable = false;
	// object 정보 표시
	this.objectInfoViewEnable = false;
	// 이슈 목록 표시
	this.nearGeoIssueListEnable = false;
	// occlusion culling
	this.occlusionCullingEnable = false;
	// origin axis XYZ
	this.showOrigin = false;
	// mago generalMode
	this.magoMode = CODE.magoMode.NORMAL;
	
	// 이미지 경로
	this.imagePath = "";
	
	// provisional.
	this.colorChangedObjectId;
	
	// LOD1
	this.lod0DistInMeters = 15;
	this.lod1DistInMeters = 50;
	this.lod2DistInMeters = 90;
	this.lod3DistInMeters = 200;
	this.lod4DistInMeters = 1000;
	this.lod5DistInMeters = 50000;
	
	// Lighting
	this.ambientReflectionCoef = 0.45; // 0.2.
	this.diffuseReflectionCoef = 0.75; // 1.0
	this.specularReflectionCoef = 0.6; // 0.7
	this.ambientColor = null;
	this.specularColor = new Float32Array([0.6, 0.6, 0.6]);
	
	this.ssaoRadius = 0.15;
	
	var policy = MagoConfig.getPolicy();
	// PointsCloud.
	this.pointsCloudSettings = {};
	if (defined(policy)) 
	{
		this.pointsCloudSettings.maxPartitionsLod0 = defaultValueCheckLength(policy.maxPartitionsLod0, 4);
		this.pointsCloudSettings.maxPartitionsLod1 = defaultValueCheckLength(policy.maxPartitionsLod1, 2);
		this.pointsCloudSettings.maxPartitionsLod2orLess = defaultValueCheckLength(policy.maxPartitionsLod2OrLess, 1);
		this.pointsCloudSettings.MaxPerUnitPointsRenderDistToCam0m = 1.0/defaultValueCheckLength(policy.maxRatioPointsDist0m, 10.0);
		this.pointsCloudSettings.MaxPerUnitPointsRenderDistToCam100m = 1.0/defaultValueCheckLength(policy.maxRatioPointsDist100m, 120.0);
		this.pointsCloudSettings.MaxPerUnitPointsRenderDistToCam200m = 1.0/defaultValueCheckLength(policy.maxRatioPointsDist200m, 240.0);
		this.pointsCloudSettings.MaxPerUnitPointsRenderDistToCam400m = 1.0/defaultValueCheckLength(policy.maxRatioPointsDist400m, 480.0);
		this.pointsCloudSettings.MaxPerUnitPointsRenderDistToCam800m = 1.0/defaultValueCheckLength(policy.maxRatioPointsDist800m, 960.0);
		this.pointsCloudSettings.MaxPerUnitPointsRenderDistToCam1600m = 1.0/defaultValueCheckLength(policy.maxRatioPointsDist1600m, 1920.0);
		this.pointsCloudSettings.MaxPerUnitPointsRenderDistToCamMoreThan1600m = 1.0/defaultValueCheckLength(policy.maxRatioPointsDistOver1600m, 3840.0);
		this.pointsCloudSettings.maxPointSize = defaultValueCheckLength(policy.maxPointSizeForPc, 40.0);
		this.pointsCloudSettings.minPointSize = defaultValueCheckLength(policy.minPointSizeForPc, 3.0);
		this.pointsCloudSettings.pendentPointSize = defaultValueCheckLength(policy.pendentPointSizeForPc, 60.0);
		this.pointsCloudSettings.minHeightRainbow = defaultValueCheckLength(policy.minHeight_rainbow_loc, 0.0);
		this.pointsCloudSettings.maxHeightRainbow = defaultValueCheckLength(policy.maxHeight_rainbow_loc, 100.0);
	}
	else 
	{
		this.pointsCloudSettings.maxPartitionsLod0 = 4;
		this.pointsCloudSettings.maxPartitionsLod1 = 2;
		this.pointsCloudSettings.maxPartitionsLod2orLess = 1;
		this.pointsCloudSettings.MaxPerUnitPointsRenderDistToCam0m = 1.0/10.0;
		this.pointsCloudSettings.MaxPerUnitPointsRenderDistToCam100m = 1.0/120.0;
		this.pointsCloudSettings.MaxPerUnitPointsRenderDistToCam200m = 1.0/240.0;
		this.pointsCloudSettings.MaxPerUnitPointsRenderDistToCam400m = 1.0/480.0;
		this.pointsCloudSettings.MaxPerUnitPointsRenderDistToCam800m = 1.0/960.0;
		this.pointsCloudSettings.MaxPerUnitPointsRenderDistToCam1600m = 1.0/1920.0;
		this.pointsCloudSettings.MaxPerUnitPointsRenderDistToCamMoreThan1600m = 1.0/3840.0;
		this.pointsCloudSettings.maxPointSize = 40.0;
		this.pointsCloudSettings.minPointSize = 3.0;
		this.pointsCloudSettings.pendentPointSize = 60.0;
		this.pointsCloudSettings.minHeightRainbow = 0.0;
		this.pointsCloudSettings.maxHeightRainbow = 100.0;
	}
};

Policy.prototype.getPointsCloudSettings = function() 
{
	return this.pointsCloudSettings;
};

Policy.prototype.getShowOrigin = function() 
{
	return this.showOrigin;
};
Policy.prototype.setShowOrigin = function(showOrigin) 
{
	this.showOrigin = showOrigin;
};

Policy.prototype.getMagoEnable = function() 
{
	return this.magoEnable;
};
Policy.prototype.setMagoEnable = function(magoEnable) 
{
	this.magoEnable = magoEnable;
};

Policy.prototype.getShowOutFitting = function() 
{
	return this.showOutFitting;
};
Policy.prototype.setShowOutFitting = function(showOutFitting) 
{
	this.showOutFitting = showOutFitting;
};
Policy.prototype.getShowLabelInfo = function() 
{
	return this.showLabelInfo;
};
Policy.prototype.setShowLabelInfo = function(showLabelInfo) 
{
	this.showLabelInfo = showLabelInfo;
};
Policy.prototype.getShowBoundingBox = function() 
{
	return this.showBoundingBox;
};
Policy.prototype.setShowBoundingBox = function(showBoundingBox) 
{
	this.showBoundingBox = showBoundingBox;
};

Policy.prototype.getShowShadow = function() 
{
	return this.showShadow;
};
Policy.prototype.setShowShadow = function(showShadow) 
{
	this.showShadow = showShadow;
};

Policy.prototype.getFrustumFarSquaredDistance = function() 
{
	return this.frustumFarSquaredDistance;
};
Policy.prototype.setFrustumFarSquaredDistance = function(frustumFarSquaredDistance) 
{
	this.frustumFarSquaredDistance = frustumFarSquaredDistance;
};

Policy.prototype.getFrustumFarDistance = function() 
{
	return this.frustumFarDistance;
};
Policy.prototype.setFrustumFarDistance = function(frustumFarDistance) 
{
	this.frustumFarDistance = frustumFarDistance;
};

Policy.prototype.getHighLightedBuildings = function() 
{
	return this.highLightedBuildings;
};
Policy.prototype.setHighLightedBuildings = function(highLightedBuildings) 
{
	this.highLightedBuildings = highLightedBuildings;
};

Policy.prototype.getColorBuildings = function() 
{
	return this.colorBuildings;
};
Policy.prototype.setColorBuildings = function(colorBuildings) 
{
	this.colorBuildings = colorBuildings;
};

Policy.prototype.getColor = function() 
{
	return this.color;
};
Policy.prototype.setColor = function(color) 
{
	this.color = color;
};

Policy.prototype.getHideBuildings = function() 
{
	return this.hideBuildings;
};
Policy.prototype.setHideBuildings = function(hideBuildings) 
{
	this.hideBuildings = hideBuildings;
};

Policy.prototype.getObjectMoveMode = function() 
{
	return this.objectMoveMode;
};
Policy.prototype.setObjectMoveMode = function(objectMoveMode) 
{
	this.objectMoveMode = objectMoveMode;
};

Policy.prototype.getMagoMode = function() 
{
	return this.magoMode;
};
Policy.prototype.setMagoMode = function(magoMode) 
{
	this.magoMode = magoMode;
};

Policy.prototype.getIssueInsertEnable = function() 
{
	return this.issueInsertEnable;
};
Policy.prototype.setIssueInsertEnable = function(issueInsertEnable) 
{
	this.issueInsertEnable = issueInsertEnable;
};
Policy.prototype.getObjectInfoViewEnable = function() 
{
	return this.objectInfoViewEnable;
};
Policy.prototype.setObjectInfoViewEnable = function(objectInfoViewEnable) 
{
	this.objectInfoViewEnable = objectInfoViewEnable;
};
Policy.prototype.getOcclusionCullingEnable = function() 
{
	return this.occlusionCullingEnable;
};
Policy.prototype.setOcclusionCullingEnable = function(occlusionCullingEnable) 
{
	this.occlusionCullingEnable = occlusionCullingEnable;
};
Policy.prototype.getNearGeoIssueListEnable = function() 
{
	return this.nearGeoIssueListEnable;
};
Policy.prototype.setNearGeoIssueListEnable = function(nearGeoIssueListEnable) 
{
	this.nearGeoIssueListEnable = nearGeoIssueListEnable;
};

Policy.prototype.getImagePath = function() 
{
	return this.imagePath;
};
Policy.prototype.setImagePath = function(imagePath) 
{
	this.imagePath = imagePath;
};

Policy.prototype.getLod = function(distInMeters) 
{
	var lod = -1;
	if (distInMeters < this.lod0DistInMeters)
	{ lod = 0; }
	else if (distInMeters < this.lod1DistInMeters)
	{ lod = 1; }
	else if (distInMeters < this.lod2DistInMeters)
	{ lod = 2; }
	else if (distInMeters < this.lod3DistInMeters)
	{ lod = 3; }
	else if (distInMeters < this.lod4DistInMeters)
	{ lod = 4; }
	else 
	{ lod = 5; }
	
	return lod;	
};
Policy.prototype.getLod0DistInMeters = function() 
{
	return this.lod0DistInMeters;
};
Policy.prototype.setLod0DistInMeters = function(lod0DistInMeters) 
{
	this.lod0DistInMeters = lod0DistInMeters;
};
Policy.prototype.getLod1DistInMeters = function() 
{
	return this.lod1DistInMeters;
};
Policy.prototype.setLod1DistInMeters = function(lod1DistInMeters) 
{
	this.lod1DistInMeters = lod1DistInMeters;
};
Policy.prototype.getLod2DistInMeters = function() 
{
	return this.lod2DistInMeters;
};
Policy.prototype.setLod2DistInMeters = function(lod2DistInMeters) 
{
	this.lod2DistInMeters = lod2DistInMeters;
};
Policy.prototype.getLod3DistInMeters = function() 
{
	return this.lod3DistInMeters;
};
Policy.prototype.setLod3DistInMeters = function(lod3DistInMeters) 
{
	this.lod3DistInMeters = lod3DistInMeters;
};
Policy.prototype.getLod4DistInMeters = function() 
{
	return this.lod4DistInMeters;
};
Policy.prototype.setLod4DistInMeters = function(lod4DistInMeters) 
{
	this.lod4DistInMeters = lod4DistInMeters;
};
Policy.prototype.getLod5DistInMeters = function() 
{
	return this.lod5DistInMeters;
};
Policy.prototype.setLod5DistInMeters = function(lod5DistInMeters) 
{
	this.lod5DistInMeters = lod5DistInMeters;
};
Policy.prototype.getAmbientReflectionCoef = function() 
{
	return this.ambientReflectionCoef;
};
Policy.prototype.setAmbientReflectionCoef = function(ambientReflectionCoef) 
{
	this.ambientReflectionCoef = ambientReflectionCoef;
};
Policy.prototype.getDiffuseReflectionCoef = function() 
{
	return this.diffuseReflectionCoef;
};
Policy.prototype.setDiffuseReflectionCoef = function(diffuseReflectionCoef) 
{
	this.diffuseReflectionCoef = diffuseReflectionCoef;
};
Policy.prototype.getSpecularReflectionCoef = function() 
{
	return this.specularReflectionCoef;
};
Policy.prototype.setSpecularReflectionCoef = function(specularReflectionCoef) 
{
	this.specularReflectionCoef = specularReflectionCoef;
};
Policy.prototype.getAmbientColor = function() 
{
	return this.ambientColor;
};
Policy.prototype.setAmbientColor = function(ambientColor) 
{
	this.ambientColor = ambientColor;
};
Policy.prototype.getSpecularColor = function() 
{
	return this.specularColor;
};
Policy.prototype.setSpecularColor = function(specularColor) 
{
	this.specularColor = specularColor;
};
Policy.prototype.getSsaoRadius = function() 
{
	return this.ssaoRadius;
};
Policy.prototype.setSsaoRadius = function(ssaoRadius) 
{
	this.ssaoRadius = ssaoRadius;
};

'use strict';

/**
 * @alias Effect
 * @class Effect
 */
var Effect = function(options) 
{
	if (!(this instanceof Effect)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	// Test class to do effects.
	this.effectsManager;
	this.birthData;
	this.durationSeconds;
	this.effectType = "unknown";
	
	if (options)
	{
		if (options.effectType)
		{ this.effectType = options.effectType; }
		
		if (options.durationSeconds)
		{ this.durationSeconds = options.durationSeconds; }
	
		if (options.zVelocity)
		{ this.zVelocity = options.zVelocity; }
	
		if (options.zMax)
		{ this.zMax = options.zMax; }
		
		if (options.zMin)
		{ this.zMin = options.zMin; }
	
	}
	
	// available effectType:
	// 1: zBounceLinear
	// 2: zBounceSpring
	// 3: borningLight
	// 4: zMovement
};

/**
 *
 */
Effect.prototype.execute = function(currTimeSec)
{
	var effectFinished = false;
	if (this.birthData === undefined)
	{
		this.birthData = currTimeSec;
		return effectFinished;
	}
	
	var timeDiffSeconds = (currTimeSec - this.birthData);
	var gl = this.effectsManager.gl;
	
	if (this.effectType === "zBounceSpring")
	{
		var zScale = 1.0;
		if (timeDiffSeconds >= this.durationSeconds)
		{
			zScale = 1.0;
			effectFinished = true; // if return true, then this effect is finished, so this effect will be deleted.
		}
		else
		{
			//https://en.wikipedia.org/wiki/Damped_sine_wave
			var amp = 1.0;
			var lambda = 0.1; // is the decay constant, in the reciprocal of the time units of the X axis.
			var w = 5/this.durationSeconds; // angular frequency.
			var t = timeDiffSeconds;
			var fita = 0.0; // initial angle in t=0.
			zScale = amp*Math.pow(Math.E, -lambda*t)*(Math.cos(w*t+fita) + Math.sin(w*t+fita));
			zScale = (1.0-zScale)*Math.log(t/this.durationSeconds+1.1);
		}
		gl.uniform3fv(this.effectsManager.currShader.scaleLC_loc, [1.0, 1.0, zScale]); // init referencesMatrix.
		return effectFinished;
	}
	else if (this.effectType === "zBounceLinear")
	{
		var zScale = 1.0;
		if (timeDiffSeconds >= this.durationSeconds)
		{
			zScale = 1.0;
			effectFinished = true; // if return true, then this effect is finished, so this effect will be deleted.
		}
		else
		{
			zScale = timeDiffSeconds/this.durationSeconds;
		}
		gl.uniform3fv(this.effectsManager.currShader.scaleLC_loc, [1.0, 1.0, zScale]); // init referencesMatrix.
		return effectFinished;
	}
	else if (this.effectType === "borningLight")
	{
		var colorMultiplier = 1.0;
		if (timeDiffSeconds >= this.durationSeconds)
		{
			colorMultiplier = 1.0;
			effectFinished = true; // if return true, then this effect is finished, so this effect will be deleted.
		}
		else
		{
			var timeRatio = timeDiffSeconds/this.durationSeconds;
			colorMultiplier = 1/(timeRatio*timeRatio);
		}
		gl.uniform4fv(this.effectsManager.currShader.colorMultiplier_loc, [colorMultiplier, colorMultiplier, colorMultiplier, 1.0]);
		return effectFinished;
	}
	else if (this.effectType === "zMovement")
	{
		if (this.zVelocity === undefined)
		{ this.zVelocity = 1.0; }

		if (this.zMax === undefined)
		{ this.zMax = 1.0; }

		if (this.zMin === undefined)
		{ this.zMin = -1.0; }

		if (this.zOffset === undefined)
		{ this.zOffset = 0.0; }

		if (this.lastTime === undefined)
		{ this.lastTime = currTimeSec; }


		if (timeDiffSeconds >= this.durationSeconds)
		{
			this.zOffset = 0.0;
			effectFinished = true; // if return true, then this effect is finished, so this effect will be deleted.
		}
		else
		{
			var diffTime = currTimeSec - this.lastTime;
			this.zOffset += this.zVelocity * diffTime;

			if (this.zVelocity > 0.0)
			{
				if (this.zOffset > this.zMax)
				{
					var diff = (this.zOffset - this.zMax);
					this.zOffset = this.zMax - diff;
					this.zVelocity *= -1.0;
				}
			}
			else
			{
				if (this.zOffset < this.zMin)
				{
					var diff = (this.zOffset - this.zMin);
					this.zOffset = this.zMin - diff;
					this.zVelocity *= -1.0;
				}
			}
		}
		gl.uniform3fv(this.effectsManager.currShader.aditionalOffset_loc, [0.0, this.zOffset, 0.0 ]); // init referencesMatrix.
		this.lastTime = currTimeSec;
		return effectFinished;
	}
};
'use strict';

/**
 * @alias EffectsManager
 * @class EffectsManager
 */
var EffectsManager = function(options) 
{
	if (!(this instanceof EffectsManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.effectsObjectsMap = {};
	this.gl;
	this.currShader;
};

/**
 *
 */
EffectsManager.prototype.setCurrentShader = function(shader)
{
	this.currShader = shader;
};

/**
 *
 */
EffectsManager.prototype.getEffectsObject = function(id)
{
	return this.effectsObjectsMap[id];
};

EffectsManager.prototype.hasEffects = function(id) 
{
	
	if (!this.effectsObjectsMap[id]) 
	{
		return false;
	}

	if (!this.effectsObjectsMap[id].effectsArray || this.effectsObjectsMap[id].effectsArray.length === 0)
	{
		return false;
	}

	return true;
};


/**
 *
 */
EffectsManager.prototype.addEffect = function(id, effect)
{
	var effectsObject = this.getEffectsObject(id);
	
	if (effectsObject === undefined)
	{
		effectsObject = {};
		this.effectsObjectsMap[id] = effectsObject;
	}
	
	if (effectsObject.effectsArray === undefined)
	{ effectsObject.effectsArray = []; }
	
	effect.effectsManager = this;
	effectsObject.effectsArray.push(effect);
};

EffectsManager.prototype.executeEffects = function(id, currTime)
{
	var effectsObject = this.getEffectsObject(id);
	var effectExecuted = false;
	if (effectsObject === undefined)
	{ return false; }
	
	var effectsCount = effectsObject.effectsArray.length;
	for (var i=0; i<effectsCount; i++)
	{
		var effect = effectsObject.effectsArray[i];
		if (effect.execute(currTime/1000))
		{
			effectsObject.effectsArray.splice(i, 1);
			effectsCount = effectsObject.effectsArray.length;
		}
		effectExecuted = true;
		
		if (effectsObject.effectsArray.length === 0)
		{ 
			this.effectsObjectsMap[id] = undefined;
			delete this.effectsObjectsMap[id];
		}
	}
	
	return effectExecuted;
};




































'use strict';

/**
 * 버퍼 안의 데이터를 어떻게 읽어야 할지 키가 되는 객체
 * @deprecated NeoSimpleBuilding에서 인스턴스 생성하는 부분이 있으나 NeoSimpleBuilding도 사용하지 않고 있음
 * 
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @alias Accessor
 * @class Accessor
 */
var Accessor = function () 
{

	if (!(this instanceof Accessor)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.bufferId;
	// 0= position, 1= normal, 2= color, 3= texcoord.
	this.accesorType;
	this.bufferStart;
	// 버퍼의 시작 시점
	this.stride;
	// character, int 등
	this.dataType;
	// 2차원, 3차원
	this.dimension;

	// 데이터가 포함되어 있는 x,y,z의 한계를 바운드라고 한다. 바운드 좌표
	this.minX = 0.0;
	this.minY = 0.0;
	this.minZ = 0.0;
	this.maxX = 0.0;
	this.maxY = 0.0;
	this.maxZ = 0.0;
};

'use strict';

/**
 * 블럭 모델
 * 
 * @class Block
 * 
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 아래 문서의 1.3 Models Folder의 항목 참조
 * @link https://github.com/Gaia3D/F4DConverter/blob/master/doc/F4D_SpecificationV1.pdf
 */
var Block = function() 
{
	if (!(this instanceof Block)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * This class is the container which holds the VBO Cache Keys.
	 * @type {VBOVertexIdxCacheKeysContainer}
	 */
	this.vBOVertexIdxCacheKeysContainer = new VBOVertexIdxCacheKeysContainer();

	/**
	 * @deprecated
	 * @type {number}
	 * @default -1
	 */
	this.mIFCEntityType = -1;

	/**
	 * small object flag. 
	 * if bbox.getMaxLength() < 0.5, isSmallObj = true
	 * 
	 * @type {Boolean} 
	 * @default false
	 */
	this.isSmallObj = false;
	
	/**
	 * block bounding box
	 * 
	 * @type {BoundingBox} 
	 * @default undefined
	 */
	this.bbox;

	/**
	 * block radius
	 * 일반적으로 bbox.getMaxLength() / 2.0 로 선언됨.
	 * 
	 * @type {Boolean} 
	 * @default 10
	 */
	this.radius = 10;

	/**
	 * only for test.delete this.
	 * @deprecated
	 */
	this.vertexCount = 0;

	/**
	 * 각각의 사물중 복잡한 모델이 있을 경우 Lego로 처리
	 * 현재는 사용하지 않으나 추후에 필요할 수 있어서 그대로 둠.
	 * legoBlock.
	 * @type {Lego}
	 */
	this.lego;
};

/**
 * block 초기화. gl에서 해당 block 및 lego 삭제
 * 
 * @param {WebGLRenderingContext} gl 
 * @param {VboManager} vboMemManager 
 */
Block.prototype.deleteObjects = function(gl, vboMemManager) 
{
	this.vBOVertexIdxCacheKeysContainer.deleteGlObjects(gl, vboMemManager);
	this.vBOVertexIdxCacheKeysContainer = undefined;
	this.mIFCEntityType = undefined;
	this.isSmallObj = undefined;
	this.radius = undefined;
	// only for test. delete this.
	this.vertexCount = undefined;

	if (this.lego) { this.lego.deleteGlObjects(gl); }

	this.lego = undefined;
};

/**
 * render할 준비가 됬는지 체크
 * 
 * @param {NeoReference} neoReference magoManager의 objectSelected와 비교 하기 위한 neoReference 객체
 * @param {MagoManager} magoManager 
 * @param {Number} maxSizeToRender block의 radius와 비교하기 위한 ref number.
 * @returns {Boolean} block의 radius가 maxSizeToRender보다 크고, block의 radius가 magoManager의 보다 크고, 카메라가 움직이고 있지 않고, magoManager의 objectSelected와 neoReference가 같을 경우 true 반환
 */ 
Block.prototype.isReadyToRender = function(neoReference, magoManager, maxSizeToRender) 
{
	if (maxSizeToRender && (this.radius < maxSizeToRender))
	{ return false; }
	
	if (magoManager.isCameraMoving && this.radius < magoManager.smallObjectSize && magoManager.objectSelected !== neoReference)
	{ return false; }

	return true;
};

'use strict';

/**
 * 블록의 내용이 엄청 많아서 나눠서 받아야 할 경우 사용하기 위한 객체. 현재는 미구현 상태. 추후 f4d v0.0.2 이상부터 적용 될 예정
 * 
 * @class BlocksArrayPartition
 * 
 * @exception {Error} Messages.CONSTRUCT_ERROR
 */
var BlocksArrayPartition = function(version) 
{
	if (!(this instanceof BlocksArrayPartition)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	// 0 = no started to load. 1 = started loading. 2 = finished loading. 3 = parse started. 4 = parse finished.
	this.fileLoadState = CODE.fileLoadState.READY;
	this.dataArraybuffer; // file loaded data, that is no parsed yet.

};
'use strict';

/**
 * 블록 리스트 객체
 * - 이 클래스는 Octree 클래스의 prepareModelReferencesListData 호출 통해 생성된다
 * 
 * @class BlocksList
 * 
 * @param {String} version
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @see Octree#prepareModelReferencesListData
 */
var BlocksList = function(version) 
{
	if (!(this instanceof BlocksList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * 블록 리스트 명
	 * @type {String}
	 * @default ''
	 */
	this.name = "";

	/**
	 * f4d 버전
	 * @type {String}
	 */
	this.version = version || "";

	/**
	 * 블락 리스트
	 * @type {Block[]}
	 */
	this.blocksArray;

	/**
	 *  block file load state. Default is 0(READY)
	 * "READY"            : 0,
	 * "LOADING_STARTED"  : 1,
	 * "LOADING_FINISHED" : 2,
	 * "PARSE_STARTED"    : 3,
	 * "PARSE_FINISHED"   : 4,
	 * "IN_QUEUE"         : 5,
	 * "LOAD_FAILED"      : 6
	 * @type {Number}
	 * 
	 * @see CODE#fileLoadState
	 */
	this.fileLoadState = CODE.fileLoadState.READY;

	/**
	 * block data array buffer.
	 * file loaded data, that is no parsed yet.
	 * @type {ArrayBuffer}
	 */
	this.dataArraybuffer;
	
	/**
	 * If true, keep block data array buffer after binding to GPU.
	 * @type {BOOLEAN}
	 */
	this.keepDataArrayBuffers;

	/**
	 * file request.
	 */
	this.xhr;
	
	/**
	 * BlocksArrayPartition 리스트 관련 변수들.
	 * f4d 버전 0.0.2 이후 부터 사용 계획있음 현재는 개발중
	 */
	this.blocksArrayPartitionsCount;
	this.blocksArrayPartitionsArray;
	this.blocksArrayPartitionsMasterPathName;
};

/**
 * 새 블록 생성 후 blocksArray에 푸쉬 및 반환
 * 
 * @returns {Block}
 */
BlocksList.prototype.newBlock = function() 
{
	if (this.blocksArray === undefined) { this.blocksArray = []; }

	var block = new Block();
	this.blocksArray.push(block);
	return block;
};

/**
 * 인덱스에 해당하는 블록 획득
 * @param {Number} idx
 * @returns {Block|null}
 */
BlocksList.prototype.getBlock = function(idx) 
{
	if (this.blocksArray === undefined) { return null; }

	if (idx >= 0 && idx < this.blocksArray.length) 
	{
		return this.blocksArray[idx];
	}
	return null;
};

/**
 * 블록 리스트 초기화. gl에서 해당 블록 리스트의 블록 및 lego 삭제
 * 
 * @param {WebGLRenderingContext} gl 
 * @param {VboManager} vboMemManager 
 */
BlocksList.prototype.deleteGlObjects = function(gl, vboMemManager) 
{
	if (this.xhr !== undefined)
	{
		this.xhr.abort();
		this.xhr = undefined;
	}
	
	if (this.blocksArray === undefined) { return; }

	for (var i = 0, blocksCount = this.blocksArray.length; i < blocksCount; i++ ) 
	{
		var block = this.blocksArray[i];
		block.vBOVertexIdxCacheKeysContainer.deleteGlObjects(gl, vboMemManager);
		block.vBOVertexIdxCacheKeysContainer = undefined; // Change this for "vbo_VertexIdx_CacheKeys_Container__idx".
		block.mIFCEntityType = undefined;
		block.isSmallObj = undefined;
		block.radius = undefined;
		block.vertexCount = undefined; // only for test. delete this.
		if (block.lego) 
		{
			block.lego.vbo_vicks_container.deleteGlObjects(gl, vboMemManager);
			block.lego.vbo_vicks_container = undefined;
		}
		block.lego = undefined; // legoBlock.
		this.blocksArray[i] = undefined;
	}
	this.blocksArray = undefined;
	this.name = undefined;
	this.fileLoadState = undefined;
	this.dataArraybuffer = undefined; // file loaded data, that is no parsed yet.
};

/**
 * 사용하지 않는 부분들 계산하기 위한 파싱과정. stepOver
 * 파싱을 위한 파싱..
 * 블록리스트 버퍼를 파싱(비대칭적)하는 과정.
 * F4D 버전이 0.0.1일 경우 사용
 * This function parses the geometry data from binary arrayBuffer.
 * 
 * @param {ArrayBuffer} arrayBuffer Binary data to parse.
 * @param {Number} bytesReaded readed bytes.
 * @param {ReaderWriter} readWriter Helper to read inside of the arrayBuffer.
 */
BlocksList.prototype.stepOverBlockVersioned = function(arrayBuffer, bytesReaded, readWriter) 
{
	var vertexCount;
	var verticesFloatValuesCount;
	var normalByteValuesCount;
	var shortIndicesValuesCount;
	var sizeLevels;
	var startBuff, endBuff;
	
	// Spec document Table 3-1
	// vboCount
	var vboDatasCount = readWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4);
	bytesReaded += 4;
	for ( var j = 0; j < vboDatasCount; j++ ) 
	{
		// 1) Positions array.
		// Spec document Table 3-2
		// vertexCount
		vertexCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4);bytesReaded += 4;
		verticesFloatValuesCount = vertexCount * 3;
		startBuff = bytesReaded;
		endBuff = bytesReaded + 4 * verticesFloatValuesCount;
		bytesReaded = bytesReaded + 4 * verticesFloatValuesCount; // updating data.

		// 2) Normals.
		// Spec document Table 3-2
		// normalCount
		vertexCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4);bytesReaded += 4;
		normalByteValuesCount = vertexCount * 3;
		bytesReaded = bytesReaded + 1 * normalByteValuesCount; // updating data.

		// 3) Indices.
		// Spec document Table 3-2
		// indexCount
		shortIndicesValuesCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4);bytesReaded += 4;
		sizeLevels = readWriter.readUInt8(arrayBuffer, bytesReaded, bytesReaded+1);bytesReaded += 1;
		bytesReaded = bytesReaded + sizeLevels * 4;
		bytesReaded = bytesReaded + sizeLevels * 4;
		bytesReaded = bytesReaded + 2 * shortIndicesValuesCount; // updating data.
	}
	
	return bytesReaded;
};

/**
 * 블록리스트 버퍼를 파싱(비대칭적)
 * vboData 파싱 부분
 * Spec document Table 3-1
 * This function parses the geometry data from binary arrayBuffer.
 * 
 * @param {ArrayBuffer} arrayBuffer Binary data to parse.
 * @param {Number} bytesReaded 지금까지 읽은 바이트 길이
 * @param {Block} block 정보를 담을 block.
 * @param {ReaderWriter} readWriter
 * @param {MagoManager} magoManager
 * 
 * @see VBOVertexIdxCacheKey#readPosNorIdx
 */
BlocksList.prototype.parseBlockVersioned = function(arrayBuffer, bytesReaded, block, readWriter, magoManager, options) 
{
	var vboMemManager = magoManager.vboMemoryManager;
	var vboDatasCount = readWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
	for ( var j = 0; j < vboDatasCount; j++ ) 
	{
		var vboViCacheKey = block.vBOVertexIdxCacheKeysContainer.newVBOVertexIdxCacheKey();
		
		if (this.keepDataArrayBuffers !== undefined && this.keepDataArrayBuffers)
		{ vboViCacheKey.keepDataArrayBuffers = true; }
	
		bytesReaded = vboViCacheKey.readPosNorIdx(arrayBuffer, vboMemManager, bytesReaded);
		block.vertexCount = vboViCacheKey.vertexCount;
	}
	
	return bytesReaded;
};

/**
 * 블록리스트 버퍼를 파싱(비대칭적)
 * F4D 버전이 0.0.1일 경우 사용
 * This function parses the geometry data from binary arrayBuffer.
 * 
 * @param {ArrayBuffer} arrayBuffer Binary data to parse.
 * @param {ReaderWriter} readWriter Helper to read inside of the arrayBuffer.
 * @param {Array.<Block>} motherBlocksArray Global blocks array.
 * @param {MagoManager} magoManager
 */
BlocksList.prototype.parseBlocksListVersioned_v001 = function(arrayBuffer, readWriter, motherBlocksArray, magoManager) 
{
	this.fileLoadState = CODE.fileLoadState.PARSE_STARTED;
	var bytesReaded = 0;
	var succesfullyGpuDataBinded = true;
	
	// read the version.
	var versionLength = 5;
	bytesReaded += versionLength;
	
	
	// modelCount
	var blocksCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded + 4); bytesReaded += 4;
	for ( var i = 0; i< blocksCount; i++ ) 
	{
		// modelIndex
		var blockIdx = readWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		
		// Check if block exist.
		if (motherBlocksArray[blockIdx]) 
		{
			// The block exists, then read data but no create a new block.
			bytesReaded += 4 * 6; // boundingBox.
			// step over vbo datas of the model.
			bytesReaded = this.stepOverBlockVersioned(arrayBuffer, bytesReaded, readWriter) ;
			
			// read lego if exist. (note: lego is exactly same of a model, is a mesh).
			var existLego = readWriter.readUInt8(arrayBuffer, bytesReaded, bytesReaded+1); bytesReaded += 1;
			if (existLego)
			{
				bytesReaded = this.stepOverBlockVersioned(arrayBuffer, bytesReaded, readWriter) ;
			}
			
			continue;
		}
		
		// The block doesn't exist, so creates a new block and read data.
		var block = new Block();
		block.idx = blockIdx;
		motherBlocksArray[blockIdx] = block;

		// 1rst, read bbox.
		block.bbox = new BoundingBox();
		var bbox = block.bbox;
		var minX = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;
		var minY = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;
		var minZ = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;

		var maxX = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;
		var maxY = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;
		var maxZ = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;
		bbox.minX = minX[0];
		bbox.minY = minY[0];
		bbox.minZ = minZ[0];

		bbox.maxX = maxX[0];
		bbox.maxY = maxY[0];
		bbox.maxZ = maxZ[0];

		var maxLength = bbox.getMaxLength();
		if (maxLength < 0.5) { block.isSmallObj = true; }
		else { block.isSmallObj = false; }

		block.radius = maxLength/2.0;

		bytesReaded = this.parseBlockVersioned(arrayBuffer, bytesReaded, block, readWriter, magoManager) ;
		
		// parse lego if exist.
		var existLego = readWriter.readUInt8(arrayBuffer, bytesReaded, bytesReaded+1); bytesReaded += 1;
		if (existLego)
		{
			if (block.lego === undefined)
			{ 
				block.lego = new Lego(); 
			}
			bytesReaded = this.parseBlockVersioned(arrayBuffer, bytesReaded, block.lego, readWriter, magoManager) ;
		}
	}
	this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
	return succesfullyGpuDataBinded;
};

/**
 * 블록리스트 버퍼를 파싱(비대칭적)
 * F4D 버전이 0.0.2일 경우 사용
 * 매개변수로 arrayBuffer 전달받지 않고 blocksArrayPartition에 있는 arrayBuffer를 이용.
 * 
 * @param {ReaderWriter} readWriter Helper to read inside of the arrayBuffer.
 * @param {Array.<Block>} motherBlocksArray Global blocks array.
 * @param {MagoManager} magoManager
 */
BlocksList.prototype.parseBlocksListVersioned_partitionsVersion = function(readWriter, motherBlocksArray, magoManager) 
{
	// 1rst, find the blocksArrayPartition to parse.
	var blocksArrayPartitionsCount = this.blocksArrayPartitionsArray.length;
	var blocksArrayPartition = this.blocksArrayPartitionsArray[blocksArrayPartitionsCount-1];
	if (blocksArrayPartition.fileLoadState !== CODE.fileLoadState.LOADING_FINISHED)
	{ return; }
	
	var arrayBuffer = blocksArrayPartition.dataArraybuffer;
	blocksArrayPartition.fileLoadState = CODE.fileLoadState.PARSE_STARTED;
	var bytesReaded = 0;
	var vboMemManager = magoManager.vboMemoryManager;
	var succesfullyGpuDataBinded = true;
	
	var blocksCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded + 4); bytesReaded += 4;
	for ( var i = 0; i< blocksCount; i++ ) 
	{
		var blockIdx = readWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var block;
		
		// Check if block exist.
		if (motherBlocksArray[blockIdx]) 
		{
			block = motherBlocksArray[blockIdx];
		}
		else 
		{
			// The block doesn't exist, so creates a new block and read data.
			block = new Block();
			block.idx = blockIdx;
			motherBlocksArray[blockIdx] = block;
		}
		
		// Now, read the blocks vbo's idx.
		var vboIdx = readWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		
		if (vboIdx === 0)
		{
			// Only if the vboIdx = 0 -> read the bbox.
			var bbox = new BoundingBox();
			bbox.minX = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;
			bbox.minY = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;
			bbox.minZ = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;

			bbox.maxX = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;
			bbox.maxY = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;
			bbox.maxZ = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)); bytesReaded += 4;

			var maxLength = bbox.getMaxLength();
			if (maxLength < 0.5) { block.isSmallObj = true; }
			else { block.isSmallObj = false; }

			block.radius = maxLength/2.0;
		}
		
		// check if the vbo exists.
		var vboViCacheKey = block.vBOVertexIdxCacheKeysContainer.vboCacheKeysArray[vboIdx];
		if (vboViCacheKey === undefined)
		{
			// Now, read the vbo (Pos-Nor-Idx).
			vboViCacheKey = new VBOVertexIdxCacheKey();
			block.vBOVertexIdxCacheKeysContainer.vboCacheKeysArray[vboIdx] = vboViCacheKey;
			bytesReaded = vboViCacheKey.readPosNorIdx(arrayBuffer, readWriter, vboMemManager, bytesReaded);
			block.vertexCount = vboViCacheKey.vertexCount;
		}
		else 
		{
			// step over.
			if (blocksCount > 1)
			{ bytesReaded = vboViCacheKey.stepOverPosNorIdx(arrayBuffer, readWriter, vboMemManager, bytesReaded); }
		}
	}
	blocksArrayPartition.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
	this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED; // test.
	return succesfullyGpuDataBinded;
};

/**
 * 블록리스트 버퍼를 파싱(비대칭적)
 * This function parses the geometry data from binary arrayBuffer.
 * @deprecated f4d 0.0.1 이전 버전에서 사용
 * 
 * @param {ArrayBuffer} arrayBuffer Binary data to parse.
 * @param {ReaderWriter} readWriter Helper to read inside of the arrayBuffer.
 * @param {Array.<Block>} motherBlocksArray Global blocks array.
 */
BlocksList.prototype.parseBlocksList = function(arrayBuffer, readWriter, motherBlocksArray, magoManager) 
{
	this.fileLoadState = CODE.fileLoadState.PARSE_STARTED;
	var bytesReaded = 0;
	var blocksCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded + 4); bytesReaded += 4;
	
	var vboMemManager = magoManager.vboMemoryManager;
	var succesfullyGpuDataBinded = true;

	for ( var i = 0; i< blocksCount; i++ ) 
	{
		var blockIdx = readWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		
		// Check if block exist.
		if (motherBlocksArray[blockIdx]) 
		{
			// The block exists, then read data but no create a new block.
			bytesReaded += 4 * 6; // boundingBox.
			// Read vbo datas (indices cannot superate 65535 value).
			var vboDatasCount = readWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
			
			for ( var j = 0; j < vboDatasCount; j++ ) 
			{
				// 1) Positions array.
				var vertexCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
				var verticesFloatValuesCount = vertexCount * 3;
				startBuff = bytesReaded;
				endBuff = bytesReaded + 4 * verticesFloatValuesCount;
				bytesReaded = bytesReaded + 4 * verticesFloatValuesCount; // updating data.

				// 2) Normals.
				vertexCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
				var normalByteValuesCount = vertexCount * 3;
				bytesReaded = bytesReaded + 1 * normalByteValuesCount; // updating data.

				// 3) Indices.
				var shortIndicesValuesCount = readWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
				var sizeLevels = readWriter.readUInt8(arrayBuffer, bytesReaded, bytesReaded+1); bytesReaded += 1;
				
				bytesReaded = bytesReaded + sizeLevels * 4;
				bytesReaded = bytesReaded + sizeLevels * 4;
				bytesReaded = bytesReaded + 2 * shortIndicesValuesCount; // updating data.
			}
			// Pendent to load the block's lego.
			continue;
		}
		
		// The block doesn't exist, so creates a new block and read data.
		var block = new Block();
		block.idx = blockIdx;
		motherBlocksArray[blockIdx] = block;
		
		// 1rst, read bbox.
		var bbox = new BoundingBox();
		bbox.minX = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4));
		bytesReaded += 4;
		bbox.minY = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4));
		bytesReaded += 4;
		bbox.minZ = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4));
		bytesReaded += 4;

		bbox.maxX = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4));
		bytesReaded += 4;
		bbox.maxY = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4));
		bytesReaded += 4;
		bbox.maxZ = new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4));
		bytesReaded += 4;

		var maxLength = bbox.getMaxLength();
		if (maxLength < 0.5) { block.isSmallObj = true; }
		else { block.isSmallObj = false; }

		block.radius = maxLength/2.0;

		bbox.deleteObjects();
		bbox = undefined;

		// New for read multiple vbo datas (indices cannot superate 65535 value).
		var vboDatasCount = readWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4);
		bytesReaded += 4;
		for ( var j = 0; j < vboDatasCount; j++ ) 
		{
			var vboViCacheKey = block.vBOVertexIdxCacheKeysContainer.newVBOVertexIdxCacheKey();
			bytesReaded = vboViCacheKey.readPosNorIdx(arrayBuffer, vboMemManager, bytesReaded);
			block.vertexCount = vboViCacheKey.vertexCount;
		}
		// Pendent to load the block's lego.
	}
	this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
	return succesfullyGpuDataBinded;
};

/**
 * 블록리스트의 blocksArrayPartition정보를 할당 및 체크.
 * F4D 버전이 0.0.2일 경우 사용
 * 
 * @param {MagoManager} magoManager
 * @param {MagoManager} octreeOwner
 */
BlocksList.prototype.prepareData = function(magoManager, octreeOwner) 
{
	if (this.version === "0.0.1")
	{
		// Provisionally this function is into octree.prepareModelReferencesListData(...).
	}
	else if (this.version === "0.0.2")
	{
		// Check the current loading state.
		if (this.blocksArrayPartitionsArray === undefined)
		{ this.blocksArrayPartitionsArray = []; }
		
		var currPartitionsCount = this.blocksArrayPartitionsArray.length;
		if (currPartitionsCount === 0)
		{
			// Proceed to load the 1rst partition.
			var partitionIdx = 0;
			var filePathInServer = this.blocksArrayPartitionsMasterPathName + partitionIdx.toString();
			var blocksArrayPartition = new BlocksArrayPartition();
			this.blocksArrayPartitionsArray.push(blocksArrayPartition);
			magoManager.readerWriter.getNeoBlocksArraybuffer_partition(filePathInServer, octreeOwner, blocksArrayPartition, magoManager);
		}
		else
		{
			// Check the last partition.
			var lastBlocksArrayPartition = this.blocksArrayPartitionsArray[currPartitionsCount-1];
			if (lastBlocksArrayPartition.fileLoadState === CODE.fileLoadState.PARSE_FINISHED)
			{
				if (currPartitionsCount < this.blocksArrayPartitionsCount)
				{
					// Proceed to load another partition.
					var partitionIdx = currPartitionsCount;
					var filePathInServer = this.blocksArrayPartitionsMasterPathName + partitionIdx.toString();
					var blocksArrayPartition = new BlocksArrayPartition();
					this.blocksArrayPartitionsArray.push(blocksArrayPartition);
					magoManager.readerWriter.getNeoBlocksArraybuffer_partition(filePathInServer, octreeOwner, blocksArrayPartition, magoManager);
				}
			}
		}
	
	}
};
'use strict';

/**
 * CollisionCheckOctree class object. 
 * @class CollisionCheckOctree
 * @param {CollisionCheckOctree} octreeOwner If octreeOwner is undefined, then this CollisionCheckOctree is the mother CollisionCheckOctree.
 */
var CollisionCheckOctree = function(octreeOwner) 
{
	if (!(this instanceof CollisionCheckOctree)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * The center position in local coordinates of the octree.
	 * @type {Point3D}
	 * @default (0,0,0)
	 */
	this.centerPos = new Point3D();
	this.transformedCenterPos;
	
	/**
	 * The half width of the octree in x-axis.
	 * @type {Number}
	 * @default 0.0
	 */
	this.half_dx = 0.0; 
	
	/**
	 * The half width of the octree in y-axis.
	 * @type {Number}
	 * @default 0.0
	 */
	this.half_dy = 0.0; 
	
	/**
	 * The half width of the octree in z-axis.
	 * @type {Number}
	 * @default 0.0
	 */
	this.half_dz = 0.0; 

	/**
	 * The octree's owner. If octree_owner is undefined, then this octree is the mother octree.
	 * @type {Octree}
	 * @default undefined
	 */
	this.octree_owner;
	if (octreeOwner) 
	{
		this.octree_owner = octreeOwner;
		this.octree_level = octreeOwner.octree_level + 1;
	}
	
	/**
	 * The octree's depth level. Mother octree's depth level is zero.
	 * @type {Number}
	 * @default 0
	 */
	this.octree_level = 0;
	
	// Octree number name.**
	// Bottom           Top              Y
	// +-----+-----+   +-----+-----+     ^
	// |  4  |  3  |   |  8  |  7  |     |
	// +-----+-----+   +-----+-----+     |
	// |  1  |  2  |   |  5  |  6  |     |------> X
	// +-----+-----+   +-----+-----+
	
	/**
	 * The octree's identifier. Accumulative number, starting from mother octree.
	 * @type {Number}
	 * @default 0
	 */
	this.octree_number_name = 0;
	
	/**
	 * The octree's neoBuildingOwner identifier.
	 * @type {String}
	 * @default undefined
	 */
	this.neoBuildingOwnerId;
	
	/**
	 * The octree's neoBuildingOwner.
	 * @type {NeoBuilding}
	 * @default undefined
	 */
	this.neoBuildingOwner;
	
	/**
	 * The octree's global unique identifier. It is compost by neoBuildingOwnerId + octree_number_name.
	 * @type {String}
	 * @default undefined
	 */
	this.octreeKey; 
	
	/**
	 * The octree's current LOD. Assigned by distance to camera when frustumCulling.
	 * @type {Number}
	 * @default undefined
	 */
	this.lod; 
	
	/**
	 * The octree's current fileLoadState.
	 * @type {Number}
	 * @default 0
	 */
	this.fileLoadState = CODE.fileLoadState.READY;

	/**
	 * The octree's children array. Array length must be 8.
	 * @type {Array}
	 * @default 0
	 */
	this.subOctrees_array = [];
	
	/**
	 * Pre-extracted leaf octrees, to speedUp.
	 * @type {Array}
	 * @default undefined
	 */
	this.lowestOctrees_array; // pre extract lowestOctrees for speedUp, if this is motherOctree.
	
	// auxiliar triangles array.
	this.trianglesArray;
	
	this.currentVisibleOctreesArray;
	
	this.collisionState = false;
	this.boundingSphere;
	this.collidedWithMeCollisionOctreesArray;
	this.vboKeysContainer;
	this.geoLocDataManager;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
CollisionCheckOctree.prototype.makeTreeByTrianglesArray = function(options) 
{
	if (this.trianglesArray === undefined || this.trianglesArray.length === 0)
	{ return; }
	
	if (options === undefined)
	{ return; }
	
	var desiredMinOctreeSize = options.desiredMinOctreeSize;
	var desiredHalfSize = desiredMinOctreeSize/2;
	
	if (this.half_dx > desiredHalfSize || this.half_dy > desiredHalfSize || this.half_dz > desiredHalfSize)
	{
		this.createChildren();

		for (var i=0; i<8; i++) 
		{
			this.subOctrees_array[i].takeIntersectedTriangles(this.trianglesArray);
		}
		
		for (var i=0; i<8; i++) 
		{
			this.subOctrees_array[i].makeTreeByTrianglesArray(options);
		}
		
		this.trianglesArray = undefined;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
CollisionCheckOctree.prototype.takeIntersectedTriangles = function(trianglesArray) 
{
	if (trianglesArray === undefined)
	{ return; }

	if (this.trianglesArray === undefined)
	{ this.trianglesArray = []; }

	var bbox = this.getBoundingBox();
	
	var trianglesCount = trianglesArray.length;
	for (var i=0; i<trianglesCount; i++)
	{
		var tri = trianglesArray[i];
		if (bbox.intersectsWithTriangle(tri))
		{
			this.trianglesArray.push(tri);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param result_octreesArray 변수
 */
CollisionCheckOctree.prototype.extractLowestOctreesIfHasTriangles = function(lowestOctreesArray) 
{
	if (this.subOctrees_array === undefined)
	{ return; }
	
	var subOctreesCount = this.subOctrees_array.length;

	if (this.trianglesArray !== undefined && this.trianglesArray.length > 0) 
	{
		lowestOctreesArray.push(this);
	}
	else 
	{
		for (var i=0; i<subOctreesCount; i++) 
		{
			this.subOctrees_array[i].extractLowestOctreesIfHasTriangles(lowestOctreesArray);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
CollisionCheckOctree.prototype.render = function(magoManager, shader, renderType, glPrimitive) 
{
	if (this.sphere === undefined)
	{
		var color4 = new Color();
		color4.setRGB(0.9, 0.1, 0.1);
		var options = {};
		options.color = color4;
		this.sphere = new Sphere(options);
		
		this.sphere.setRadius(this.getRadius());
		this.sphere.setCenterPoint(this.centerPos.x, this.centerPos.y, this.centerPos.z);
		return;
	}
	var bIsSelected = false;
	var gl = magoManager.getGl();
	gl.uniform1i(shader.hasAditionalMov_loc, false);
	//gl.uniform3fv(shader.aditionalMov_loc, [this.centerPos.x, this.centerPos.y, this.centerPos.z]); //.
	//shader.last_isAditionalMovedZero = false;
	
	var refMatrixType = 1;
	gl.uniform1i(shader.refMatrixType_loc, refMatrixType);
	gl.uniform3fv(shader.refTranslationVec_loc, [this.centerPos.x, this.centerPos.y, this.centerPos.z]); 
		
	this.sphere.renderLocal(magoManager, shader, renderType, glPrimitive, bIsSelected);
	
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
CollisionCheckOctree.prototype.hasChildren = function() 
{
	if (this.subOctrees_array !== undefined && this.subOctrees_array.length > 0)
	{ return true; }
	else { return false; }
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
CollisionCheckOctree.prototype.createChildren = function() 
{
	this.subOctrees_array = []; // Init array.
	
	for (var i=0; i<8; i++) 
	{
		var subOctree = this.new_subOctree();
		subOctree.octree_number_name = this.octree_number_name * 10 + (i+1);
		subOctree.neoBuildingOwnerId = this.neoBuildingOwnerId;
		subOctree.octreeKey = this.neoBuildingOwnerId + "_" + subOctree.octree_number_name;
	}

	this.setSizesSubBoxes();
};

/**
 * Creates a child octree.
 * @returns {Octree} subOctree Returns the created child octree.
 */
CollisionCheckOctree.prototype.new_subOctree = function() 
{
	var subOctree = new CollisionCheckOctree(this);
	subOctree.octree_level = this.octree_level + 1;
	this.subOctrees_array.push(subOctree);
	return subOctree;
};


/**
 * 어떤 일을 하고 있습니까?
 */
CollisionCheckOctree.prototype.setSizesSubBoxes = function() 
{
	// Octree number name.**
	// Bottom                      Top
	// +-----+-----+     +-----+-----+
	// |  3  |  2  |     |  7  |  6  |       Y
	// +-----+-----+     +-----+-----+       |
	// |  0  |  1  |     |  4  |  5  |       |
	// +-----+-----+     +-----+-----+       +---------> X

	if (this.subOctrees_array.length > 0) 
	{
		var half_x = this.centerPos.x;
		var half_y = this.centerPos.y;
		var half_z = this.centerPos.z;

		var min_x = this.centerPos.x - this.half_dx;
		var min_y = this.centerPos.y - this.half_dy;
		var min_z = this.centerPos.z - this.half_dz;

		var max_x = this.centerPos.x + this.half_dx;
		var max_y = this.centerPos.y + this.half_dy;
		var max_z = this.centerPos.z + this.half_dz;

		this.subOctrees_array[0].setBoxSize(min_x, half_x, min_y, half_y, min_z, half_z);
		this.subOctrees_array[1].setBoxSize(half_x, max_x, min_y, half_y, min_z, half_z);
		this.subOctrees_array[2].setBoxSize(half_x, max_x, half_y, max_y, min_z, half_z);
		this.subOctrees_array[3].setBoxSize(min_x, half_x, half_y, max_y, min_z, half_z);

		this.subOctrees_array[4].setBoxSize(min_x, half_x, min_y, half_y, half_z, max_z);
		this.subOctrees_array[5].setBoxSize(half_x, max_x, min_y, half_y, half_z, max_z);
		this.subOctrees_array[6].setBoxSize(half_x, max_x, half_y, max_y, half_z, max_z);
		this.subOctrees_array[7].setBoxSize(min_x, half_x, half_y, max_y, half_z, max_z);

		for (var i=0; i<8; i++) 
		{
			this.subOctrees_array[i].setSizesSubBoxes();
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param Min_x 변수
 * @param Max_x 변수
 * @param Min_y 변수
 * @param Max_y 변수
 * @param Min_z 변수
 * @param Max_z 변수
 */
CollisionCheckOctree.prototype.setBoxSize = function(Min_X, Max_X, Min_Y, Max_Y, Min_Z, Max_Z) 
{
	this.centerPos.x = (Max_X + Min_X)/2.0;
	this.centerPos.y = (Max_Y + Min_Y)/2.0;
	this.centerPos.z = (Max_Z + Min_Z)/2.0;

	this.half_dx = (Max_X - Min_X)/2.0; // half width.
	this.half_dy = (Max_Y - Min_Y)/2.0; // half length.
	this.half_dz = (Max_Z - Min_Z)/2.0; // half height.
};

/**
 * 어떤 일을 하고 있습니까?
 */
CollisionCheckOctree.prototype.getBoundingBox = function(resultBbox) 
{
	if (resultBbox === undefined)
	{ resultBbox = new BoundingBox(); }

	if ( this.transformedCenterPos === undefined)
	{ 
		this.transformedCenterPos = new Point3D(); 
		this.transformedCenterPos.copyFrom(this.centerPos);
	}

	resultBbox.set(this.transformedCenterPos.x - this.half_dx, this.transformedCenterPos.y - this.half_dy, this.transformedCenterPos.z - this.half_dz, 
		this.transformedCenterPos.x + this.half_dx, this.transformedCenterPos.y + this.half_dy, this.transformedCenterPos.z + this.half_dz);
	
	return resultBbox;
};

/**
 * 어떤 일을 하고 있습니까?
 */
CollisionCheckOctree.prototype.getRadius = function() 
{
	var bbox = this.getBoundingBox();
	return bbox.getRadius();
};

/**
 * 어떤 일을 하고 있습니까?
 */
CollisionCheckOctree.prototype.getBoundingSphere = function() 
{
	if ( this.transformedCenterPos === undefined)
	{ 
		this.transformedCenterPos = new Point3D(); 
		this.transformedCenterPos.copyFrom(this.centerPos);
	}
	this.boundingSphere = new BoundingSphere(this.transformedCenterPos.x, this.transformedCenterPos.y, this.transformedCenterPos.z, this.getRadius());
	return this.boundingSphere;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns intersects
 */
CollisionCheckOctree.prototype.checkCollision = function(collisionOctree, resultCollidedOctreesArray) 
{
	if (collisionOctree === undefined)
	{ return false; }

	var myBSphere = this.getBoundingSphere();
	var bSphere = collisionOctree.getBoundingSphere();
	
	var collisionType = myBSphere.intersectsWithBSphere(bSphere);
	if (collisionType === Constant.INTERSECTION_OUTSIDE)
	{ return false; }
	
	// check the radius of the spheres, and, the bigger collisionOctree descends.
	// check if the collisionOctrees has children.
	if (!this.hasChildren() && !collisionOctree.hasChildren())
	{
		if (collisionOctree.trianglesArray !== undefined && collisionOctree.trianglesArray.length !== 0 && this.trianglesArray !== undefined && this.trianglesArray.length !== 0)
		{ 
			resultCollidedOctreesArray.push(this);
		}

		return true;
	}
	
	if (myBSphere.r > bSphere.r)
	{
		// check if my children collides with bSphere.
		if (this.hasChildren())
		{
			var childrenCount = this.subOctrees_array.length;
			for (var i=0; i<childrenCount; i++)
			{
				var subOctree = this.subOctrees_array[i];
				subOctree.checkCollision(collisionOctree, resultCollidedOctreesArray);
			}
		}
		else
		{
			// check if bSphere children collides with me.
			var childrenCount = collisionOctree.subOctrees_array.length;
			for (var i=0; i<childrenCount; i++)
			{
				var subOctree = collisionOctree.subOctrees_array[i];
				this.checkCollision(subOctree, resultCollidedOctreesArray);
			}
		}
	}
	else 
	{
		// check if bSphere children collides with me.
		if (collisionOctree.hasChildren())
		{
			var childrenCount = collisionOctree.subOctrees_array.length;
			for (var i=0; i<childrenCount; i++)
			{
				var subOctree = collisionOctree.subOctrees_array[i];
				this.checkCollision(subOctree, resultCollidedOctreesArray);
			}
		}
		else
		{
			var childrenCount = this.subOctrees_array.length;
			for (var i=0; i<childrenCount; i++)
			{
				var subOctree = this.subOctrees_array[i];
				subOctree.checkCollision(collisionOctree, resultCollidedOctreesArray);
			}
		}
	}
	
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns intersects
 */
CollisionCheckOctree.prototype.translate = function(translationVector, bTransformFromOrigin) 
{
	if (translationVector === undefined)
	{ return; }
	
	if ( this.transformedCenterPos === undefined)
	{ 
		this.transformedCenterPos = new Point3D(); 
		this.transformedCenterPos.copyFrom(this.centerPos);
	}

	if (bTransformFromOrigin === undefined)
	{ bTransformFromOrigin = false; }
	
	if (bTransformFromOrigin)
	{ this.transformedCenterPos.copyFrom(this.centerPos); }
	
	this.transformedCenterPos.addPoint(translationVector);
	
	if (this.hasChildren())
	{
		var childrenCount = this.subOctrees_array.length;
		for (var i=0; i<childrenCount; i++)
		{
			this.subOctrees_array[i].translate(translationVector, bTransformFromOrigin);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns intersects
 */
CollisionCheckOctree.prototype.transformByMatrix4 = function(tMat, bTransformFromOrigin) 
{
	if (tMat === undefined)
	{ return; }

	if ( this.transformedCenterPos === undefined)
	{ 
		this.transformedCenterPos = new Point3D(); 
		this.transformedCenterPos.copyFrom(this.centerPos);
	}

	if (bTransformFromOrigin === undefined)
	{ bTransformFromOrigin = false; }
	
	if (bTransformFromOrigin)
	{ this.transformedCenterPos.copyFrom(this.centerPos); }
	
	this.transformedCenterPos = tMat.transformPoint3D(this.transformedCenterPos, this.transformedCenterPos);
	if (this.hasChildren())
	{
		var childrenCount = this.subOctrees_array.length;
		for (var i=0; i<childrenCount; i++)
		{
			this.subOctrees_array[i].transformByMatrix4(tMat, bTransformFromOrigin);
		}
	}
};













































'use strict';
/**
 * 프로젝트와 노드 목록 관리 객체.
 * 실질적으로 화면에 표출될 프로젝트와 노드들을 보관하고 있음.
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class HierarchyManager
 */
var HierarchyManager = function() 
{
	if (!(this instanceof HierarchyManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * 프로젝트 보관 객체
	 * @type {Object}
	 */
	this.projectsMap = {};
	
	/**
	 * StaticModelManager
	 * @type {StaticModelManager}
	 */
	this.staticModelsManager;
};

/**
 * node array와 prjectMap을 초기화. gl Context에서 그려진 내용들 제거
 */
HierarchyManager.prototype.deleteNodes = function(gl, vboMemoryManager) 
{
	for (var key in this.projectsMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.projectsMap, key))
		{
			var nodesMap = this.projectsMap[key];
			
			for (var nodesKey in nodesMap)
			{
				if (Object.prototype.hasOwnProperty.call(nodesMap, nodesKey))
				{
					var node = nodesMap[nodesKey];
					if (node instanceof Node)
					{						
						node.deleteObjects(gl, vboMemoryManager);
						delete nodesMap[nodesKey];
					}
				}
			}
			//nodesMap.clear();
			delete this.projectsMap[key];
		}
	}
	//this.projectsMap.clear();
	this.projectsMap = {};
};

/**
 * StaticModelsManager 반환
 * @returns {StaticModelsManager} 선언된 StaticModelsManager가 없을 시 인스턴스 생성하여 등록 후 반환.
 */
HierarchyManager.prototype.getStaticModelsManager = function() 
{
	if (this.staticModelsManager === undefined)
	{ this.staticModelsManager = new StaticModelsManager(); }
	
	return this.staticModelsManager;
};

/**
 * nodesMap에 있는 Node의 data의 attribute에 해당하는 값을 가진 Node를 반환.
 * @param {String} projectId
 * @param {String} dataName attribute 이름, 보통 nodeId 사용.
 * @param {String} dataNameValue attribute 값
 * 
 * @returns {Node}
 */
HierarchyManager.prototype.getNodeByDataName = function(projectId, dataName, dataNameValue) 
{
	// note: here "dataName" refers "nodeId", or other datas that can be inside of"data".
	var nodesMap = this.getNodesMap(projectId);
	
	if (nodesMap === undefined)
	{ return undefined; }
	
	var resultNode;
	
	//for (var value of nodesMap.values()) 
	for (var key in nodesMap)
	{
		if (Object.prototype.hasOwnProperty.call(nodesMap, key))
		{
			var value = nodesMap[key];
			if (value.data !== undefined && value.data[dataName] === dataNameValue)
			{
				resultNode = value;
				break;
			}
		}
	}
	
	return resultNode;
};

/**
 * projectId와 dataKey를 이용하여 nodesMap에 있는 Node를 반환.
 * @param {String} projectId
 * @param {String} dataKey
 * 
 * @returns {Node|undefined} nodesMap이 선언되지 않았을 경우 undefined반환.
 */
HierarchyManager.prototype.getNodeByDataKey = function(projectId, dataKey) 
{
	var nodesMap = this.getNodesMap(projectId);
	
	if (nodesMap === undefined)
	{ return undefined; }
	
	var resultNode = nodesMap[dataKey];
	
	return resultNode;
};

/**
 * node의 parent 속성이 비어있는 root node들을 반환.
 * @param {Array.<Node>} resultRootNodesArray
 * @returns {Array.<Node>}
 */
HierarchyManager.prototype.getRootNodes = function(projectId, resultRootNodesArray) 
{
	if (resultRootNodesArray === undefined)
	{ resultRootNodesArray = []; }

	var nodesMap = this.projectsMap[projectId];	
	for (var nodesKey in nodesMap)
	{
		if (Object.prototype.hasOwnProperty.call(nodesMap, nodesKey))
		{
			var node = nodesMap[nodesKey];
			if (node instanceof Node)
			{						
				if (node.parent === undefined)
				{
					resultRootNodesArray.push(node);
				}
			}
		}
	}
	
	return resultRootNodesArray;
};

/**
 * 넘겨받은 projectId에 해당하는 project가 projectMap에 등록되있는지 유무 반환.
 * @param {String} projectId
 * @returns {Boolean}
 */
HierarchyManager.prototype.existProject = function(projectId) 
{
	return this.projectsMap.hasOwnProperty(projectId);
};

/**
 * 넘겨받은 projectId에 해당하는 nodesMap을 반환.
 * @param {String} projectId
 * @param {Object} attributes undefined가 아닐 경우 해당 nodesMap에 등록.
 * @returns {Object} projectId에 해당하는 nodesMap 없으면 생성 후 반환.
 */
HierarchyManager.prototype.getNodesMap = function(projectId, attributes) 
{
	// 1rst, check if exist.
	var nodesMap = this.projectsMap[projectId];
	if (nodesMap === undefined)
	{
		nodesMap = {};
		if (attributes !== undefined)
		{ nodesMap.attributes = attributes; }
		this.projectsMap[projectId] = nodesMap;
	}
	else 
	{
		if (attributes !== undefined && nodesMap.attributes === undefined)
		{ nodesMap.attributes = attributes; }
	}
	return nodesMap;
};


/**
 * 넘겨받은 projectId와 id, attribute로 Node를 생성 후 반환. Node 생성 후 nodesArray와 nodesMap에 등록
 * @param {String} id datakey
 * @param {String} projectId
 * @param {Object} attributes undefined가 아닐 경우 해당 nodesMap에 등록.
 * @returns {Node}
 */
HierarchyManager.prototype.newNode = function(id, projectId, attributes) 
{
	var nodesMap = this.getNodesMap(projectId, attributes);
	
	var node = nodesMap[id];
	if (node === undefined)
	{
		var node = new Node();
		node.data = {"nodeId": id};
		nodesMap[id] = node;
	}

	return node;
};

































'use strict';

/**
 * @deprecated 사용안함.
 * 
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class InspectorBox
 */
var InspectorBox = function() 
{
	if (!(this instanceof InspectorBox)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
};
'use strict';

/**
 * F4D Lego 클래스
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @alias Lego
 * @class Lego
 * 
 * 아래 문서의 Table 2 (Overall Structure of LOD2 file) 참조
 * @link https://github.com/Gaia3D/F4DConverter/blob/master/doc/F4D_SpecificationV1.pdf
 */
var Lego = function() 
{
	if (!(this instanceof Lego)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * This class is the container which holds the VBO Cache Keys.
	 * @type {VBOVertexIdxCacheKeysContainer}
	 */
	this.vbo_vicks_container = new VBOVertexIdxCacheKeysContainer();

	/**
	 * lego file load state. Default is 0(READY)
	 * "READY"            : 0,
	 * "LOADING_STARTED"  : 1,
	 * "LOADING_FINISHED" : 2,
	 * "PARSE_STARTED"    : 3,
	 * "PARSE_FINISHED"   : 4,
	 * "IN_QUEUE"         : 5,
	 * "LOAD_FAILED"      : 6
	 * @type {Number}
	 */
	this.fileLoadState = CODE.fileLoadState.READY;

	/**
	 * lego bounding box
	 * @type {BoundingBox}
	 */
	this.bbox;

	/**
	 * lego data array buffer. parse가 끝난 후 undefined.
	 * @type {ArrayBuffer}
	 */
	this.dataArrayBuffer;

	/**
	 * lego data color. not used
	 * @deprecated
	 * @type {Color}
	 */
	this.selColor4;

	/**
	 * 텍스쳐 coord 유무
	 * @type {Boolean}
	 */
	this.hasTexCoords;

	/**
	 * 텍스쳐
	 * @type {Texture}
	 */
	this.texture;

	/**
	 * 텍스쳐 이름
	 * @type {String}
	 */
	this.textureName;

	/**
	 * lego key
	 * @type {String}
	 */
	this.legoKey;
	this.xhr;
	
	/**
	 * not use
	 * @deprecated
	 * @type {String}
	 */
	this.renderableType; // triangles, lines, points, etc.

	/**
	 * 칼라값 유무
	 * @type {Boolean}
	 */
	this.hasColors;

	/**
	 * blendAlpha
	 * @type {Number}
	 */
	this.blendAlpha = 0.0;

	/**
	 * birthTime
	 * @type {Date}
	 */
	this.birthTime;

	/**
	 * not use
	 * @deprecated
	 * @type {Boolean}
	 */
	this.isAdult = false;
	
	this.dataArrayBuffer;
	
};

/**
 * F4D Lego 자료를 읽어서 가져온 ArrayBuffer를 파싱.
 * 
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {ArrayBuffer} dataArraybuffer 
 * @param {MagoManager} magoManager 
 */
Lego.prototype.parseArrayBuffer = function(dataArraybuffer, magoManager)
{
	this.parseLegoData(dataArraybuffer, magoManager);
};

/**
 * BlendAlpha 반환
 * 
 * @param {Date} currTime not use
 * @returns {Number} always return 1.0
 */
Lego.prototype.getBlendAlpha = function(currTime) 
{
	return 1.0;
	/*
	if(!this.isAdult)
	{
		if(this.birthTime === undefined)
			this.birthTime = currTime;
		var increAlpha = (currTime - this.birthTime)*0.0001;
		this.blendAlpha += increAlpha;
		
		if(this.blendAlpha >= 1.0)
		{
			this.isAdult = true;
		}
	}
	else
		return 1.0;
	
	return this.blendAlpha;
	*/
};

/**
 * render할 준비가 됬는지 체크
 * @returns {Boolean} this.fileLoadState가 CODE.fileLoadState.PARSE_FINISHED(4)이거나 this.texture, this.texture.texId가 존재할때 true 반환
 */
Lego.prototype.isReadyToRender = function()
{
	if (this.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED)
	{ return false; }
	
	if (this.texture === undefined || this.texture.texId === undefined) // In the future, a skin can has no texture. TODO:
	{ return false; }
	
	return true;
};

/**
 * lego 초기화. gl에서 해당 lego 삭제
 * 
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {VboManager} vboMemManager 
 */
Lego.prototype.deleteObjects = function(gl, vboMemManager)
{
	/*
	if(this.xhr !== undefined)// && this.fileLoadState === CODE.fileLoadState.LOADING_STARTED)
	{
		this.xhr.abort();
		this.xhr = undefined;
	}
	*/
	
	if (this.vbo_vicks_container !== undefined)
	{
		this.vbo_vicks_container.deleteGlObjects(gl, vboMemManager);
		this.vbo_vicks_container = undefined;
	}
	this.fileLoadState = undefined;
	this.dataArrayBuffer = undefined;
	if (this.selColor4 !== undefined)
	{
		this.selColor4.deleteObjects();
		this.selColor4 = undefined;
	}
	
	this.textureName = undefined;
	if (this.texture)
	{
		this.texture.deleteObjects(gl);
	}
	this.texture = undefined;
	if (this.bbox)
	{
		this.bbox.deleteObjects();
	}
	this.bbox = undefined;
};

/**
 * F4D Lego 자료(point cloude data)를 읽어서 가져온 ArrayBuffer를 파싱.
 * vertex index cache key를 생성하여 담는다.
 * LOADING_FINISHED 상태일때 실행.
 * normal, texCoord는 없음
 * 
 * @param {ArrayBuffer} dataArraybuffer 
 * @param {WebGLRenderingContext} gl not use
 * @param {MagoManager} magoManager 
 */
Lego.prototype.parsePointsCloudData = function(buffer, gl, magoManager)
{
	// Provisional.
	if (this.fileLoadState !== CODE.fileLoadState.LOADING_FINISHED)	{ return; }
	var stream = new DataStream(buffer, 0, DataStream.LITTLE_ENDIAN);
	
	var verticesCount = stream.readInt32();
	
	var vboMemManager = magoManager.vboMemoryManager;
	this.fileLoadState = CODE.fileLoadState.PARSE_STARTED;

	this.bbox = new BoundingBox();
	var bbox = this.bbox;
	var vboCacheKey = this.vbo_vicks_container.newVBOVertexIdxCacheKey();

	// BoundingBox in float values.
	bbox.minX = stream.readFloat32();
	bbox.minY = stream.readFloat32();
	bbox.minZ = stream.readFloat32();
	bbox.maxX = stream.readFloat32();
	bbox.maxY = stream.readFloat32();
	bbox.maxZ = stream.readFloat32();
	
	// positionsBuffer.
	// read bPositionsCompressed. If this var is true -> positions is in uShort).
	this.bPositionsCompressed = stream.readInt8();
	var posByteSize = verticesCount * 3;
	var positionBuffer;
	
	
	if (this.bPositionsCompressed)
	{
		vboCacheKey.setDataArrayPos(stream.readUint16Array(verticesCount * 3), vboMemManager);
	}
	else 
	{
		vboCacheKey.setDataArrayPos(stream.readFloat32Array(verticesCount * 3), vboMemManager);
	}

	// normals.
	this.hasNormals = stream.readInt8();
	if (this.hasNormals)
	{
		// todo:
	}
	
	// colors.
	this.hasColors = stream.readInt8();
	if (this.hasColors)
	{
		var numColors = verticesCount;
		vboCacheKey.setDataArrayCol(stream.readUint8Array(numColors * 4), vboMemManager);
	}
	
	// texCoords.
	this.hasTexCoords = stream.readInt8();
	if (this.hasTexCoords)
	{
		// todo:
	}
	
	// indices.
	this.hasIndices = stream.readInt8();
	if (this.hasIndices)
	{
		// todo:
	}
	
	this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
};

/**
 * F4D Lego 자료를 읽어서 가져온 ArrayBuffer를 파싱.
 * vertex index cache key를 생성하여 담는다.
 * LOADING_FINISHED 상태일때 실행.
 * 
 * @param {ArrayBuffer} dataArraybuffer 
 * @param {WebGLRenderingContext} gl not use
 * @param {MagoManager} magoManager 
 */
Lego.prototype.parseLegoData = function(buffer, magoManager, bytesReaded)
{
	if (this.fileLoadState !== CODE.fileLoadState.LOADING_FINISHED && this.fileLoadState !== CODE.fileLoadState.IN_PARSE_QUEUE)	{ return; }
	
	if (buffer === undefined)
	{ buffer = this.dataArrayBuffer; }

	if (buffer === undefined)
	{ return bytesReaded; }
	
	var vboMemManager = magoManager.vboMemoryManager;
	var settings = magoManager._settings;
	var keepVboPositionDataArrayBuffers = settings.keepVboPositionDataArrayBuffers;
	
	if (bytesReaded === undefined)
	{ bytesReaded = 0; }

	if (this.vbo_vicks_container === undefined)
	{ 
		this.vbo_vicks_container = new VBOVertexIdxCacheKeysContainer(); 
	}

	//var stream = new DataStream(buffer, 0, DataStream.LITTLE_ENDIAN);
	this.fileLoadState = CODE.fileLoadState.PARSE_STARTED;

	this.bbox = new BoundingBox();
	var bbox = this.bbox;
	var vboCacheKey = this.vbo_vicks_container.newVBOVertexIdxCacheKey();
	
	

	// BoundingBox.
	bytesReaded = bbox.readData(buffer, bytesReaded);

	// VBO(Position Buffer) - x,y,z
	var numPositions = (new Int32Array(buffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	var byteSize = 4;
	var startBuff = bytesReaded;
	var endBuff = bytesReaded + byteSize * numPositions * 3;
	var posDataArray = new Float32Array(buffer.slice(startBuff, endBuff));
	vboCacheKey.setDataArrayPos(posDataArray, vboMemManager);
	bytesReaded = bytesReaded + byteSize * numPositions * 3; // updating data.
	
	if (keepVboPositionDataArrayBuffers)
	{
		vboCacheKey.vboBufferPos.bKeepDataArray = true;
	}
		
	//var numPositions = stream.readUint32();
	//var posDataArray = stream.readFloat32Array(numPositions * 3);
	//vboCacheKey.setDataArrayPos(posDataArray, vboMemManager);


	// VBO(Normal Buffer) - i,j,k
	var hasNormals = (new Uint8Array(buffer.slice(bytesReaded, bytesReaded+1)))[0]; bytesReaded += 1;
	if (hasNormals)
	{
		var numNormals = (new Int32Array(buffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
		byteSize = 1;
		startBuff = bytesReaded;
		endBuff = bytesReaded + byteSize * numNormals * 3;
		var norDataArray = new Int8Array(buffer.slice(startBuff, endBuff));
		vboCacheKey.setDataArrayNor(norDataArray, vboMemManager);
		bytesReaded = bytesReaded + byteSize * numNormals * 3; // updating data.
	}
	//var hasNormals = stream.readUint8();
	//if (hasNormals) 
	//{
	//	var numNormals = stream.readUint32();
	//	var norDataArray = stream.readInt8Array(numNormals * 3);
	//	vboCacheKey.setDataArrayNor(norDataArray, vboMemManager);
	//}

	// VBO(Color Buffer) - r,g,b,a
	var hasColors = (new Uint8Array(buffer.slice(bytesReaded, bytesReaded+1)))[0]; bytesReaded += 1;
	if (hasColors)
	{
		var numColors = (new Int32Array(buffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
		byteSize = 1;
		startBuff = bytesReaded;
		endBuff = bytesReaded + byteSize * numColors * 4;
		var colDataArray = new Int8Array(buffer.slice(startBuff, endBuff));
		vboCacheKey.setDataArrayCol(colDataArray, vboMemManager);
		bytesReaded = bytesReaded + byteSize * numColors * 4; // updating data.
	}
	//var hasColors = stream.readUint8();
	//if (hasColors)
	//{
	//	var numColors = stream.readUint32();
	//	var colDataArray = stream.readUint8Array(numColors * 4);
	//	vboCacheKey.setDataArrayCol(colDataArray, vboMemManager);
	//}

	// VBO(TextureCoord Buffer) - u,v
	this.hasTexCoords = (new Uint8Array(buffer.slice(bytesReaded, bytesReaded+1)))[0]; bytesReaded += 1;
	if (this.hasTexCoords)
	{
		var dataType = (new Uint16Array(buffer.slice(bytesReaded, bytesReaded+2)))[0]; bytesReaded += 2;
		var numCoords = (new Uint32Array(buffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
		byteSize = 4;
		startBuff = bytesReaded;
		endBuff = bytesReaded + byteSize * numCoords * 2;
		var texCoordDataArray = new Float32Array(buffer.slice(startBuff, endBuff));
		vboCacheKey.setDataArrayTexCoord(texCoordDataArray, vboMemManager);
		bytesReaded = bytesReaded + byteSize * numCoords * 2; // updating data.
	}
	//this.hasTexCoords = stream.readUint8();
	//if (this.hasTexCoords)
	//{
	//	var dataType = stream.readUint16();
	//	var numCoords = stream.readUint32();
	//	var texCoordDataArray = stream.readFloat32Array(numCoords * 2);
	//	vboCacheKey.setDataArrayTexCoord(texCoordDataArray, vboMemManager);
	//}

	this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
	
	return bytesReaded;
};

/**
 */
Lego.prototype.makeStencilShadowMesh = function(lightDirectionLC)
{
	if (this.vbo_vicks_container === undefined)
	{ return; }
	
	this.shadowMeshesArray = [];
	
	var vboKeysCount = this.vbo_vicks_container.getVbosCount();
	for (var i=0; i<vboKeysCount; i++)
	{
		var vboCacheKey = this.vbo_vicks_container.getVboKey(i);
		var shadowMaesh = Mesh.fromVbo(vboCacheKey);
		if (shadowMaesh !== undefined)
		{ this.shadowMeshesArray.push(shadowMaesh); }
	}
	
	return;
};

/**
 * F4D Lego 자료를 gl에 렌더
 * 
 * @param {MagoManager} magoManager
 * @param {Number} renderType
 * @param {Boolean} renderTexture
 * @param {PostFxShader} shader 
 */
Lego.prototype.renderStencilShadowMeshes = function(magoManager, renderType, renderTexture, shader, owner)
{
	
};

/**
 * F4D Lego 자료를 gl에 렌더
 * 
 * @param {MagoManager} magoManager
 * @param {Number} renderType
 * @param {Boolean} renderTexture
 * @param {PostFxShader} shader 
 */
Lego.prototype.render = function(magoManager, renderType, renderTexture, shader, owner)
{
	var rendered = false;
	var gl = magoManager.sceneState.gl;
	
	if (this.vbo_vicks_container.vboCacheKeysArray.length === 0) 
	{
		return false;
	}
	gl.frontFace(gl.CCW);
	
	// renderType = 0 -> depth render.
	// renderType = 1 -> normal render.
	// renderType = 2 -> colorSelection render.
	// renderType = 3 -> shadowMesh render.
	//--------------------------------------------
	if (renderType === 3)
	{
		var processCounterManager = magoManager.processCounterManager;
		
		if (owner === undefined)
		{ return; }
		
		if (this.shadowMeshesArray !== undefined)
		{
			// render the shadowMeshes.
			// render the shadowMeshes.
			
			var glPrimitive;
			var isSelected = false;
			var shadowMeshesCount = this.shadowMeshesArray.length;
			for (var i=0; i<shadowMeshesCount; i++)
			{
				var shadowMesh = this.shadowMeshesArray[i];
				shadowMesh.renderAsChild(magoManager, shader, renderType, glPrimitive, isSelected);
			}
		}
		else if (processCounterManager.shadowMeshesMadeCount === 0)
		{
			// make the shadow meshes.
			// Calculate sunDirLC.
			var nodeOwner = owner.nodeOwner;
			var geoLocDataManager = nodeOwner.data.geoLocDataManager;
			var geoLocData = geoLocDataManager.getCurrentGeoLocationData();
			var sunSystem = magoManager.sceneState.sunSystem;
			var sunDirWC = sunSystem.getSunDirWC();
			var sunDirLC = geoLocData.getRotatedRelativeVector(sunDirWC, sunDirLC);
			this.makeStencilShadowMesh(sunDirLC);
			
			processCounterManager.shadowMeshesMadeCount ++;
		}

		return;
	}
	
	var vbo_vicky = this.vbo_vicks_container.vboCacheKeysArray[0]; // there are only one.

	var vertices_count = vbo_vicky.vertexCount;
	if (vertices_count === 0) 
	{
		return false;
	}

	if (renderType === 0 || renderType === 2) // depth or colorSelection.
	{
		shader.disableVertexAttribArray(shader.texCoord2_loc);
		shader.disableVertexAttribArray(shader.normal3_loc);
		shader.disableVertexAttribArray(shader.color4_loc);
		
		// 1) Position.
		if (!vbo_vicky.bindDataPosition(shader, magoManager.vboMemoryManager))
		{ return false; }

		gl.drawArrays(gl.TRIANGLES, 0, vertices_count);
		rendered = true;
		
	}
	else if (renderType === 1) // color.
	{
		// Test external alpha.
		if (magoManager.isTrailRender === undefined || magoManager.isTrailRender === false) // check if mago is not rendering special effects.
		{
			var blendAlpha = this.getBlendAlpha(magoManager.currTime);
			gl.uniform1f(shader.externalAlpha_loc, blendAlpha);
		}
		// End test.---
	
		// 4) Texcoord.
		if (renderTexture)
		{
			if (!vbo_vicky.bindDataTexCoord(shader, magoManager.vboMemoryManager))
			{ return false; }
		}
		else 
		{
			gl.uniform1i(shader.bUse1Color_loc, false);
			shader.disableVertexAttribArray(shader.texCoord2_loc);
		}

		if (!vbo_vicky.bindDataPosition(shader, magoManager.vboMemoryManager))
		{ return false; }
		
		if (!vbo_vicky.bindDataNormal(shader, magoManager.vboMemoryManager))
		{ return false; }
	
		//if (!vbo_vicky.bindDataColor(shader, magoManager.vboMemoryManager))
		//{ return false; }

		// TODO:
		//if (vbo_vicky.meshColorCacheKey !== undefined )
		//{
		//if(shader.color4_loc != -1)shader.enableVertexAttribArray(shader.color4_loc);
		//gl.bindBuffer(gl.ARRAY_BUFFER, vbo_vicky.meshColorCacheKey);
		//gl.vertexAttribPointer(shader.color4_loc, 4, gl.UNSIGNED_BYTE, true, 0, 0);
		//}
		
		if (renderTexture && vbo_vicky.vboBufferTCoord !== undefined)
		{
			gl.uniform1i(shader.textureFlipYAxis_loc, false);
			// Provisionally flip tex coords here.
			/*if (magoManager.isCesiumGlobe())
			{ gl.uniform1i(shader.textureFlipYAxis_loc, false); }//.ppp
			else
			{ gl.uniform1i(shader.textureFlipYAxis_loc, true); }//.ppp
			*/
			//---------------------------------------------------------------------------
			
			shader.disableVertexAttribArray(shader.color4_loc); 
			
			if (!vbo_vicky.bindDataTexCoord(shader, magoManager.vboMemoryManager))
			{ return false; }
		}

		gl.drawArrays(gl.TRIANGLES, 0, vertices_count);
		
		// some stadistics.
		magoManager.sceneState.trianglesRenderedCount += vertices_count/3;
		
		
		rendered = true;
		shader.disableVertexAttribArray(shader.color4_loc);
	}
	
	return rendered;
};




















'use strict';

/**
 * LoadData
 * @deprecated 삭제예정
 * @alias LoadData
 * @class LoadData
 */
var LoadData = function() 
{
	if (!(this instanceof LoadData)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	// dataType:
	// 1. referencesArray.
	// 2. blocksArray.
	// 3. skinData. (octree's skinData & lod3,4,5 skinData).
	// 4. skinTexture.
	
	this.dataType;
	this.distToCam;
	this.lod;
	this.filePath;
	this.texFilePath;
	this.skinMesh;
	this.octree;
	this.texture;
};

LoadData.prototype.deleteObjects = function()
{
	// here deletes deletable objects.
	this.dataType = undefined;
	this.distToCam = undefined;
	this.lod = undefined;
	this.filePath = undefined;
	this.texFilePath = undefined;
	this.skinMesh = undefined;
	this.octree = undefined;
	this.texture = undefined;
};

/**
 * LoadQueue
 * @deprecated 삭제예정
 * 
 * @alias LoadQueue
 * @class LoadQueue
 */
var LoadQueue = function(magoManager) 
{
	if (!(this instanceof LoadQueue)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.magoManager;
	
	if (magoManager !== undefined)
	{ this.magoManager = magoManager; }
	
	this.lod2PCloudDataMap = {}; 

	this.tinTerrainDataMap = {};
};

LoadQueue.prototype.putLod2PCloudData = function(octree, filePath, texture, texFilePath, aValue)
{
	// "aValue" no used yet.
	octree.lego.fileLoadState = CODE.fileLoadState.IN_QUEUE;
	var loadData = new LoadData();
	loadData.filePath = filePath;
	loadData.octree = octree;
	
	loadData.texFilePath = texFilePath;
	loadData.texture = texture;
	
	this.lod2PCloudDataMap[filePath] = loadData;
};


LoadQueue.prototype.resetQueue = function()
{	
	for (var key in this.lod2PCloudDataMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.lod2PCloudDataMap, key))
		{
			var loadData = this.lod2PCloudDataMap[key];
			if (loadData.octree === undefined || loadData.octree.lego === undefined)
			{ continue; }
			
			loadData.octree.lego.fileLoadState = CODE.fileLoadState.READY;
		}
	}
	
	this.lod2PCloudDataMap = {};
};

LoadQueue.prototype.manageQueue = function()
{
	var maxFileLoad = 1;
	var readerWriter = this.magoManager.readerWriter;
	var gl = this.magoManager.sceneState.gl;
	var counter = 0;
	var remainLod2 = false;


	
	// Lod2 meshes, 1rst load texture..
	if (this.magoManager.fileRequestControler.isFullPlusLowLodImages())	
	{ 
		return; 
	}
	
	// pCloud data.
	counter = 0;
	for (var key in this.lod2PCloudDataMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.lod2PCloudDataMap, key))
		{
			var loadData = this.lod2PCloudDataMap[key];
			var octree = loadData.octree;
			var filePath = loadData.filePath;
			
			if (octree.lego !== undefined)
			{
				readerWriter.getOctreePCloudArraybuffer(filePath, octree, this.magoManager);
			}
			
			delete this.lod2PCloudDataMap[key];
			loadData.deleteObjects();
			loadData = undefined;
	
			counter++;
			if (counter > 4)
			{
				//this.lod2PCloudDataMap = {};
				remainLod2 = true;
				break;
			}
		}
	}
	
	this.resetQueue();
};
'use strict';

/**
 */
var LodBuilding = function() 
{
	if (!(this instanceof LodBuilding)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.attributes; // object.
	
	this.skinLego;
	this.texture;
};

/**
 * render할 준비가 됬는지 체크
 * @returns {Boolean} this.fileLoadState가 CODE.fileLoadState.PARSE_FINISHED(4)이거나 this.texture, this.texture.texId가 존재할때 true 반환
 */
LodBuilding.prototype.isReadyToRender = function()
{
	if (this.skinLego === undefined)
	{ return false; }
	
	if (this.skinLego.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED)
	{ return false; }
	
	if (this.skinLego.textureName !== "noTexture" )
	{
		if (this.texture === undefined || this.texture.texId === undefined) // In the future, a skin can has no texture. TODO:
		{ return false; }
	}
	
	return true;
};

/**
 * F4D Lego 자료를 gl에 렌더
 * 
 * @param {MagoManager} magoManager
 * @param {Number} renderType
 * @param {Boolean} renderTexture
 * @param {PostFxShader} shader 
 */
LodBuilding.prototype.render = function(magoManager, renderType, renderTexture, shader, owner)
{
	return this.skinLego.render(magoManager, renderType, renderTexture, shader, owner);
};
'use strict';

/**
 * F4D LodBuildingData 클래스
 * Node의 NeoBuilding안에서 사용.
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @alias LodBuildingData
 * @class LodBuildingData
 * 
 * 아래 문서의 Table 1-3 (lodInfo) 참조
 * @link https://github.com/Gaia3D/F4DConverter/blob/master/doc/F4D_SpecificationV1.pdf
 */
var LodBuildingData = function() 
{
	if (!(this instanceof LodBuildingData)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * lod of this data.
	 * @type {Number}
	 */
	this.lod;

	/**
	 * 모델 레퍼런스 유무 0 : false, 1 : true
	 * @type {Number}
	 */
	this.isModelRef;

	/**
	 * geometry 파일명, isModelRef가 0일 경우 선언.
	 * @type {String}
	 * 
	 * @example lod0, lod1
	 */
	this.geometryFileName;

	/**
	 * texture 파일명 lod가 2일 경우 혹은 isModelRef가 0일 경우 선언
	 * @type {String}
	 * 
	 * @example mosaicTextureLod0.jpg
	 */
	this.textureFileName;
	//this.dataType; // no used yet.
};
'use strict';

/**
 * F4D MetaData class.
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @alias MetaData
 * @class MetaData
 * 
 * 아래 문서의 Table 1 참조
 * @link https://github.com/Gaia3D/F4DConverter/blob/master/doc/F4D_SpecificationV1.pdf
 */
var MetaData = function() 
{
	if (!(this instanceof MetaData)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * guid. must be undefined initially.
	 * @type {String} 
	 */
	this.guid;

	/**
	 * f4d version
	 * @type {String} 
	 */
	this.version = "";

	/**
	 * f4d origin geographic coord. longitude, latitude, altitude.
	 * @type {GeographicCoord} 
	 */
	this.geographicCoord;

	/**
	 * heading. unit is degree.
	 * @type {Number} 
	 */
	this.heading;

	/**
	 * pitch. unit is degree.
	 * @type {Number} 
	 */
	this.pitch;

	/**
	 * roll. unit is degree.
	 * @type {Number} 
	 */
	this.roll;

	/**
	 * BoundingBox
	 * @type {BoundingBox} 
	 */
	this.bbox;

	/**
	 * not used
	 * @deprecated
	 */
	this.imageLodCount;

	/**
	 * Project_data_type (new in version 002).
	 * 1 = 3d model data type (normal 3d with interior & exterior data).
	 * 2 = single building skin data type (as vWorld or googleEarth data).
	 * 3 = multi building skin data type (as Shibuya & Odaiba data).
	 * 4 = pointsCloud data type.
	 * 5 = pointsCloud data type pyramidOctree test.
	 * @type {Number} 
	 */
	this.projectDataType;
	//-------------------------------------------------------------------------------
	
	/**
	 * offset x. Added since version 0.02
	 * @type {Number} 
	 */
	this.offSetX;

	/**
	 * offset y. Added since version 0.02
	 * @type {Number} 
	 */
	this.offSetY;

	/**
	 * offset z. Added since version 0.02
	 * @type {Number} 
	 */
	this.offSetZ;

	/**
	 * Buildings octree mother size.
	 * 
	 * @see Octree#setBoxSize
	 * @see ReaderWriter#getNeoHeaderAsimetricVersion
	 */ 

	 /**
	 * octree min x. octree.centerPos.x - octree.half_dx
	 * @type {Number} 
	 * @default 0.0
	 */
	this.oct_min_x = 0.0;

	 /**
	 * octree max x. octree.centerPos.x + octree.half_dx
	 * @type {Number} 
	 * @default 0.0
	 */
	this.oct_max_x = 0.0;

	/**
	 * octree min y. octree.centerPos.y - octree.half_dy
	 * @type {Number} 
	 * @default 0.0
	 */
	this.oct_min_y = 0.0;

	/**
	 * octree min y. octree.centerPos.y + octree.half_dy
	 * @type {Number} 
	 * @default 0.0
	 */
	this.oct_max_y = 0.0;

	/**
	 * octree min z. octree.centerPos.z - octree.half_dz
	 * @type {Number} 
	 * @default 0.0
	 */
	this.oct_min_z = 0.0;

	/**
	 * octree max z. octree.centerPos.z + octree.half_dz
	 * @type {Number} 
	 * @default 0.0
	 */
	this.oct_max_z = 0.0;

	/**
	 * small flag. 
	 * 
	 * when under condition, set true.
	 * bbox.maxX - bbox.minX < 40.0 && bbox.maxY - bbox.minY < 40.0 && bbox.maxZ - bbox.minZ < 30.0
	 * @deprecated
	 * 
	 * @type {Boolean} 
	 * @default false
	 */
	this.isSmall = false;

	/**
	 * lego file load state. Default is 0(READY)
	 * "READY"            : 0,
	 * "LOADING_STARTED"  : 1,
	 * "LOADING_FINISHED" : 2,
	 * "PARSE_STARTED"    : 3,
	 * "PARSE_FINISHED"   : 4,
	 * "IN_QUEUE"         : 5,
	 * "LOAD_FAILED"      : 6
	 * @type {Number}
	 */
	this.fileLoadState = CODE.fileLoadState.READY;
};

/**
 * MetaData 초기화
 */
MetaData.prototype.deleteObjects = function() 
{
	this.guid = undefined; // must be undefined initially.
	//this.version = undefined;
	if (this.geographicCoord)
	{ this.geographicCoord.deleteObjects(); }
	this.geographicCoord = undefined; // longitude, latitude, altitude.

	this.heading = undefined;
	this.pitch = undefined;
	this.roll = undefined;

	if (this.bbox)
	{ this.bbox.deleteObjects(); }
	this.bbox = undefined; // BoundingBox.
	this.imageLodCount = undefined;

	// Buildings octree mother size.
	this.oct_min_x = undefined;
	this.oct_max_x = undefined;
	this.oct_min_y = undefined;
	this.oct_max_y = undefined;
	this.oct_min_z = undefined;
	this.oct_max_z = undefined;

	this.isSmall = undefined;
	this.fileLoadState = undefined;
};

/**
 * HeaderAsimetric.hed 파일을 불러와서 metadata 부분을 파싱.
 * @param {ArrayBuffer} arrayBuffer
 * @param {ReaderWriter} readWriter 
 */
MetaData.prototype.parseFileHeaderAsimetricVersion = function(arrayBuffer, bytesReaded) 
{
	var version_string_length = 5;
	var intAux_scratch = 0;

	var enc = new TextDecoder("utf-8");

	// 1) Version(5 chars).
	this.version = "";
	//for (var j=0; j<version_string_length; j++)
	//{
	//	this.version += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1))[0]);bytesReaded += 1;
	//}
	this.version = enc.decode(new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ version_string_length))) ;bytesReaded += version_string_length;

	// 3) Global unique ID.
	if (this.guid === undefined) { this.guid =""; }

	intAux_scratch = ReaderWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
	this.guid = enc.decode(new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ intAux_scratch))) ;bytesReaded += intAux_scratch;
	//for (var j=0; j<intAux_scratch; j++)
	//{
	//	this.guid += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1))[0]);bytesReaded += 1;
	//}

	// 4) Location.
	if (this.longitude === undefined) 
	{
		this.longitude = (new Float64Array(arrayBuffer.slice(bytesReaded, bytesReaded+8)))[0]; bytesReaded += 8;
	}
	else { bytesReaded += 8; }

	if (this.latitude === undefined) 
	{
		this.latitude = (new Float64Array(arrayBuffer.slice(bytesReaded, bytesReaded+8)))[0]; bytesReaded += 8;
	}
	else { bytesReaded += 8; }

	if (this.altitude === undefined) 
	{
		this.altitude = (new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	}
	else { bytesReaded += 4; }

	if (this.bbox === undefined) { this.bbox = new BoundingBox(); }

	// 6) BoundingBox.
	bytesReaded = this.bbox.readData(arrayBuffer, bytesReaded);

	var isLarge = false;
	if (this.bbox.maxX - this.bbox.minX > 40.0 || this.bbox.maxY - this.bbox.minY > 40.0) 
	{
		isLarge = true;
	}

	if (!isLarge && this.bbox.maxZ - this.bbox.minZ < 30.0) 
	{
		this.isSmall = true;
	}
	
	this.projectDataType = 0; // Init a value.
	
	// if header version is "0.0.2", then must read extra parameters.
	if (this.version === "0.0.2")
	{
		// parse dataType (unsigned short).
		this.projectDataType = (new Uint16Array(arrayBuffer.slice(bytesReaded, bytesReaded+2)))[0]; bytesReaded += 2;
		
		// parse Project's offSet (double x 6).
		this.offSetX = (new Float64Array(arrayBuffer.slice(bytesReaded, bytesReaded+8)))[0]; bytesReaded += 8;
		this.offSetY = (new Float64Array(arrayBuffer.slice(bytesReaded, bytesReaded+8)))[0]; bytesReaded += 8;
		this.offSetZ = (new Float64Array(arrayBuffer.slice(bytesReaded, bytesReaded+8)))[0]; bytesReaded += 8;
	}
	return bytesReaded;
};


























'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class ModelReferencedGroup
 */
var ModelReferencedGroup = function() 
{
	if (!(this instanceof ModelReferencedGroup)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.modelIdx; // there are only one model.
	this.referencesIdxArray = []; // all references has the same model.
};


/**
 * 어떤 일을 하고 있습니까?
 * @class ModelReferencedGroupsList
 */
var ModelReferencedGroupsList = function() 
{
	if (!(this instanceof ModelReferencedGroupsList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.modelReferencedGroupsMap = [];
	this.modelReferencedGroupsArray = [];
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
ModelReferencedGroupsList.prototype.getModelReferencedGroup = function(modelIdx) 
{
	var modelReferencedGroup = this.modelReferencedGroupsMap[modelIdx];
	
	if (modelReferencedGroup === undefined)
	{
		modelReferencedGroup = new ModelReferencedGroup();
		modelReferencedGroup.modelIdx = modelIdx;
		this.modelReferencedGroupsMap[modelIdx] = modelReferencedGroup;
	}
	
	return modelReferencedGroup;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
ModelReferencedGroupsList.prototype.makeModelReferencedGroupsArray = function() 
{
	this.modelReferencedGroupsArray.length = 0;
	
	var modelRefGroupsCount = this.modelReferencedGroupsMap.length;
	for (var i=0; i<modelRefGroupsCount; i++)
	{
		if (this.modelReferencedGroupsMap[i] !== undefined)
		{ this.modelReferencedGroupsArray.push(this.modelReferencedGroupsMap[i]); }
	}
	this.modelReferencedGroupsMap.length = 0;
	
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
ModelReferencedGroupsList.prototype.createModelReferencedGroups = function(neoRefsIndices, motherNeoRefsList) 
{
	// Group all the references that has the same model.
	if (neoRefsIndices === undefined)
	{ return; }
	
	if (motherNeoRefsList === undefined)
	{ return; }
	
	var referenceIdx;
	var modelIdx;
	var modelRefGroup;
	var referencesCount = neoRefsIndices.length;
	for (var i=0; i<referencesCount; i++)
	{
		referenceIdx = neoRefsIndices[i];
		modelIdx = motherNeoRefsList[referenceIdx]._block_idx;
		modelRefGroup = this.getModelReferencedGroup(modelIdx);
		modelRefGroup.referencesIdxArray.push(referenceIdx);
	}
	
	// Now, delete the "modelReferencedGroupsMap" and make a simple array.
	this.makeModelReferencedGroupsArray();
	
};





'use strict';

/**
 * This is a group of skin-type buildings.
 * @class MultiBuildings
 */
var MultiBuildings = function() 
{
	if (!(this instanceof MultiBuildings)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	// The multiBuildings shares vboBuffers.
	this.skinBuildingsArray;
	this.fileLoadState = CODE.fileLoadState.READY;
	this.dataArrayBuffer;
	
	this.bbox;
	this.geoCoords;
	this.vboKeysContainer; // class: VBOVertexIdxCacheKeysContainer.
	
	this.multiBuildingsElementsArray = [];
};

/**
 * This function prepares data of multiBuilding to render.
 * @param {ManoManager} magoManager The main mago3d class. This object manages the main pipe-line of the Mago3D.
 */
MultiBuildings.prototype.prepareData = function(magoManager) 
{

	if (this.fileLoadState === CODE.fileLoadState.READY)
	{
		var node = this.nodeOwner;
		var projectFolderName = node.data.projectFolderName;
		var multiBuildingsFolderName = node.data.multiBuildingsFolderName;
		var multiBuildingsFileName = multiBuildingsFolderName; // the fileName is equal to folderName.
		var readerWriter = magoManager.readerWriter;
		var fileName = magoManager.readerWriter.geometryDataPath + "/" + projectFolderName + "/" + multiBuildingsFolderName + "/" + multiBuildingsFileName;
		readerWriter.getMultiBuildingsDataArrayBuffer(fileName, this, magoManager);
	}
};

/**
 * This function renders the multiBuilding.
 * @param {ManoManager} magoManager The main mago3d class. This object manages the main pipe-line of the Mago3D.
 */
MultiBuildings.prototype.render = function(magoManager, shader) 
{
	// 1rst, check if data is ready to render.
	if (!this.isReadyToRender())
	{ 
		return false; 
	}
	
	if (this.vboKeysContainer === undefined)
	{ return false; }
	
	var gl = magoManager.getGl();
	var nodeOwner = this.nodeOwner;
	var geoLocDataManager = nodeOwner.data.geoLocDataManager;
	var geoLoc = geoLocDataManager.getCurrentGeoLocationData();
	
	geoLoc.bindGeoLocationUniforms(gl, shader);
	
	// Bind the vbo.
	var vboMemManager = magoManager.vboMemoryManager;
	var vboKeysCount = this.vboKeysContainer.getVbosCount();
	
	if (vboKeysCount === 0)
	{ return false; }

	// Note: there are only one vboKey.
	var vboKey = this.vboKeysContainer.getVboKey(0);
	if (!vboKey.bindDataPosition(shader, vboMemManager))
	{ return false; }
	
	if (!vboKey.bindDataNormal(shader, vboMemManager))
	{ return false; }
	
	if (!vboKey.bindDataTexCoord(shader, vboMemManager))
	{ return false; }
		
	var multiBuildingElemsCount = this.multiBuildingsElementsArray.length;
	for (var i=0; i<multiBuildingElemsCount; i++)
	{
		var multiBuildingsElem = this.multiBuildingsElementsArray[i];
		multiBuildingsElem.render(magoManager, shader);
	}
	

};

/**
 * render할 준비가 됬는지 체크
 * @returns {Boolean} this.fileLoadState가 CODE.fileLoadState.PARSE_FINISHED(4)이거나 this.texture, this.texture.texId가 존재할때 true 반환
 */
MultiBuildings.prototype.isReadyToRender = function()
{
	if (this.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED)
	{ return false; }
	
	//if (this.texture === undefined || this.texture.texId === undefined) // In the future, a skin can has no texture. TODO:
	//{ return false; }
	
	return true;
};

/**
 * This function parses data of multiBuilding.
 * @param {ManoManager} magoManager The main mago3d class. This object manages the main pipe-line of the Mago3D.
 */
MultiBuildings.prototype.parseData = function(magoManager) 
{
	if (this.fileLoadState !== CODE.fileLoadState.LOADING_FINISHED)
	{ return false; }
	
	if (this.dataArrayBuffer === undefined)
	{ return false; }

	this.fileLoadState = CODE.fileLoadState.PARSE_STARTED;

	if (this.vboKeysContainer === undefined)
	{ this.vboKeysContainer = new VBOVertexIdxCacheKeysContainer(); }
	
	var vboKeys = this.vboKeysContainer.newVBOVertexIdxCacheKey();

	var arrayBuffer = this.dataArrayBuffer;
	var bytesReaded = 0;
	var vboMemManager = magoManager.vboMemoryManager;

	// Read the version. 5 chars.
	this.version = "";
	var version_string_length = 5;
	for (var j=0; j<version_string_length; j++)
	{
		this.version += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1))[0]);bytesReaded += 1;
	}
	
	// Bounding box.
	if (this.bbox === undefined)
	{ this.bbox = new BoundingBox(); }
	
	bytesReaded = this.bbox.readData(arrayBuffer, bytesReaded);
	
	// Read geographic coords.
	if (this.geoCoords === undefined)
	{ this.geoCoords = new GeographicCoord(); }
	
	this.geoCoords.longitude = (new Float64Array(arrayBuffer.slice(bytesReaded, bytesReaded+8)))[0]; bytesReaded += 8;
	this.geoCoords.latitude = (new Float64Array(arrayBuffer.slice(bytesReaded, bytesReaded+8)))[0]; bytesReaded += 8;
	this.geoCoords.altitude = (new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	
	// VBO.
	// Read positions dataType.
	bytesReaded = vboKeys.readPositions(arrayBuffer, vboMemManager, bytesReaded);
	
	// read if vertex has 1) normals, 2) texCoords and/or 3) colors. 
	var hasNormals = (new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+1)))[0]; bytesReaded += 1;
	if (hasNormals)
	{
		// read normals.
		bytesReaded = vboKeys.readNormals(arrayBuffer, vboMemManager, bytesReaded);
	}
	var hasTexCoords = (new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+1)))[0]; bytesReaded += 1;
	if (hasTexCoords)
	{
		// read tecCoords.
		bytesReaded = vboKeys.readTexCoords(arrayBuffer, vboMemManager, bytesReaded);
	}
	var hasColors = (new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+1)))[0]; bytesReaded += 1;
	if (hasColors)
	{
		// read colors.
		bytesReaded = vboKeys.readColors(arrayBuffer, vboMemManager, bytesReaded);
	}
	
	var hasIndices = (new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+1)))[0]; bytesReaded += 1;
	if (hasIndices)
	{
		// read indices.
		// Provisionally has no indices to read.
	}
	
	// Now read the city individual buildings.
	var cityBuildingsCount = (new Int32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	for (var i=0; i<cityBuildingsCount; i++)
	{
		var multiBuildingsElement = new MultiBuildingsElement();
		bytesReaded = multiBuildingsElement.parseData(arrayBuffer, bytesReaded);
		multiBuildingsElement.multiBuildingsOwner = this;
		
		this.multiBuildingsElementsArray.push(multiBuildingsElement);
	}
	
	// Now read LOD5-textures. The LOD5-textures is embedded.
	var imagesCount = (new Int32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	
	if (imagesCount > 0 && this.texturesManager === undefined)
	{ this.texturesManager = new TexturesManager(); }

	for (var i=0; i<imagesCount; i++)
	{
		// read imageId (material id).
		var imageId = (new Int32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
		
		// read imageFileName.
		var imageFileNameLength = (new Int32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
		var imageFileName = "";
		for (var j=0; j<imageFileNameLength; j++)
		{
			imageFileName += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1))[0]);bytesReaded += 1;
		}
		
		// read the image.
		var imageLength = (new Int32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
		var startBuff = bytesReaded;
		var byteSize = 1;
		var endBuff = bytesReaded + byteSize * imageLength;
		var imageBinaryData = arrayBuffer.slice(startBuff, endBuff);
		bytesReaded = bytesReaded + byteSize * imageLength; // updating data.
		
		// now create texture of the image.
		var texture = this.texturesManager.getOrNewTexture(imageId);
		texture.textureTypeName = "diffuse";
		texture.textureImageFileName = imageFileName;
		texture.imageBinaryData = imageBinaryData;
		texture.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
	}
	
	this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
};





































'use strict';

/**
 * This is an element (or member) of a multiBuildings object.
 * @class MultiBuildingsElement
 */
var MultiBuildingsElement = function() 
{
	if (!(this instanceof MultiBuildingsElement)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.multiBuildingsOwner;
	this.name;
	this.id;
	this.bbox;
	this.geoCoords;
	this.indexRange;
	this.localIndexRangesArray;
	
};

/**
 * This function renders the multiBuildingsElement.
 * @param {ManoManager} magoManager The main mago3d class. This object manages the main pipe-line of the Mago3D.
 */
MultiBuildingsElement.prototype.render = function(magoManager, shader) 
{
	if (this.localIndexRangesArray === undefined)
	{ return false; }

	var gl = magoManager.getGl();
	
	var localIndexRangesCount = this.localIndexRangesArray.length;
	for (var i=0; i<localIndexRangesCount; i++)
	{
		var localIndexRange = this.localIndexRangesArray[i];
		var first = localIndexRange.strIdx;
		var end = localIndexRange.endIdx;
		var verticesCount = end - first + 1; // must add +1 bcos "end" & "first" are indexes.
		
		var materialId = localIndexRange.attributes.materialId;
		if (materialId !== undefined && materialId >= 0)
		{
			var texturesManager = this.multiBuildingsOwner.texturesManager;
			var tex = texturesManager.getTexture(materialId);
			
			if (tex !== undefined && tex.texId === undefined)
			{
				// bind texture data.
				TexturesManager.newWebGlTextureByEmbeddedImage(gl, tex.imageBinaryData, tex);
				var flip_y_texCoords = false;
				//tex.texId = TexturesManager.handleTextureLoaded(gl, tex.imageBinaryData, flip_y_texCoords);
			}
			
			if (tex !== undefined && tex.texId !== undefined)
			{
				// bind texture.
				gl.uniform1i(shader.colorType_loc, 2); // 0= oneColor, 1= attribColor, 2= texture.
				if (shader.last_tex_id !== tex.texId) 
				{
					gl.activeTexture(gl.TEXTURE2);
					gl.bindTexture(gl.TEXTURE_2D, tex.texId);
					shader.last_tex_id = tex.texId;
				}
			}
		}
		
		gl.drawArrays(gl.TRIANGLES, first, verticesCount);
	}
	
	return true;
};

/**
 * This function parses data of multiBuilding.
 * @param {ManoManager} magoManager The main mago3d class. This object manages the main pipe-line of the Mago3D.
 */
MultiBuildingsElement.prototype.parseData = function(arrayBuffer, bytesReaded) 
{
	// Read name.
	this.name = "";
	var nameLength = (new Int16Array(arrayBuffer.slice(bytesReaded, bytesReaded+2)))[0]; bytesReaded += 2;
	for (var j=0; j<nameLength; j++)
	{
		this.name += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1))[0]);bytesReaded += 1;
	}
	
	// Read id.
	this.id = "";
	var idLength = (new Int16Array(arrayBuffer.slice(bytesReaded, bytesReaded+2)))[0]; bytesReaded += 2;
	for (var j=0; j<idLength; j++)
	{
		this.id += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1))[0]);bytesReaded += 1;
	}
	
	// read bbox.
	if (this.bbox === undefined)
	{ this.bbox = new BoundingBox(); }
	
	bytesReaded = this.bbox.readData(arrayBuffer, bytesReaded);
	
	// read geographic coords.
	if (this.geoCoords === undefined)
	{ this.geoCoords = new GeographicCoord(); }
	
	this.geoCoords.longitude = (new Float64Array(arrayBuffer.slice(bytesReaded, bytesReaded+8)))[0]; bytesReaded += 8;
	this.geoCoords.latitude = (new Float64Array(arrayBuffer.slice(bytesReaded, bytesReaded+8)))[0]; bytesReaded += 8;
	this.geoCoords.altitude = (new Float32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	
	// read indexRange. This is the indexRange of the global buffer of the owner.
	if (this.indexRange === undefined)
	{ this.indexRange = new IndexRange(); }
	
	this.indexRange.strIdx = (new Uint32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	this.indexRange.endIdx = (new Uint32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	
	// read local indexRanges. In the local indexRanges, there are divisions by the different textures.
	this.localIndexRangesArray = []; // init array.
	var localIndexRangesCount = (new Uint32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	for (var i=0; i<localIndexRangesCount; i++)
	{
		var localIndexRange = new IndexRange();
		localIndexRange.strIdx = (new Uint32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
		localIndexRange.endIdx = (new Uint32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
		
		var materialId = (new Uint32Array(arrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
		localIndexRange.attributes = {
			"materialId": materialId
		};
		this.localIndexRangesArray.push(localIndexRange);
	}
	
	return bytesReaded;
};

























































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class NeoBuilding
 */
var NeoBuilding = function() 
{
	if (!(this instanceof NeoBuilding)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.name = "";
	this.metaData;
	this.buildingId;
	this.buildingType; // use this for classify a building.
	this.buildingFileName = "";
	
	// Bounding box.
	this.bbox;
	this.bboxAbsoluteCenterPos;
	
	// References and Models.
	this.motherNeoReferencesArray = []; 
	this.motherNeoReferencesMap; 
	this.motherBlocksArray = []; 
	
	// Aditional Color.
	this.isHighLighted;
	this.isColorChanged;
	this.aditionalColor; // use for colorChanged.

	// Textures loaded.
	this.texturesLoaded; // material textures. OLD.
	this.texturesManager;
	

	// The octree.**
	this.octree; // f4d_octree. 

	// Auxiliar vars. This vars must be updated before to call render.
	this.currentLod; // Must be updated before to call render.
	this.currentVisibleOctreesControler; // Must be updated before to call render.
	this.myCameraRelative; // Must be updated before to call render.

	// The simple building.**
	this.simpleBuilding3x3Texture; // old version.
	
	// In version 001, there are 6 lods.
	this.lodMeshesMap;
	this.lodBuildingDatasMap;
	this.lodBuildingMap; // new.
	
	// Render settings.
	// provisionally put this here.
	this.applyOcclusionCulling;
	
	// header = metadata + octree's structute + textures list + lodBuildingData.
	this.headerDataArrayBuffer;
	
	this.attributes;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns {Boolean} applyOcclusionCulling
 */
NeoBuilding.prototype.getImageFileNameForLOD = function(lod) 
{
	var lodBuildingData = this.getLodBuildingData(lod);
	
	if (lodBuildingData === undefined)
	{ return undefined; }
	
	return lodBuildingData.textureFileName;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns {Boolean} applyOcclusionCulling
 */
NeoBuilding.prototype.setAttribute = function(attributeKey, attributeValue) 
{
	if (this.attributes === undefined)
	{ this.attributes = {}; }
	
	this.attributes[attributeKey] = attributeValue;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns {Boolean} applyOcclusionCulling
 */
NeoBuilding.prototype.getReferenceObject = function(refObjectIndex) 
{
	if (this.motherNeoReferencesArray === undefined)
	{ return undefined; }
	return this.motherNeoReferencesArray[refObjectIndex];
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns {Boolean} applyOcclusionCulling
 */
NeoBuilding.prototype.getReferenceObjectsArrayByObjectId = function(objectId) 
{
	if (this.motherNeoReferencesMap === undefined)
	{ return undefined; }

	var refObject = this.motherNeoReferencesMap[objectId];
	return refObject;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns {Boolean} applyOcclusionCulling
 */
NeoBuilding.prototype.putReferenceObject = function(refObject, refObjectIdx) 
{
	// function called by "NeoReferencesMotherAndIndices.prototype.parseArrayBufferReferencesVersioned".
	if (this.motherNeoReferencesArray === undefined)
	{ this.motherNeoReferencesArray = []; }

	this.motherNeoReferencesArray[refObjectIdx] = refObject;
	
	// Additionally, make a objects map.
	if (this.motherNeoReferencesMap === undefined)
	{ this.motherNeoReferencesMap = {}; }
	
	var objectsArray = this.motherNeoReferencesMap[refObject.objectId];
	if (objectsArray === undefined)
	{ objectsArray = []; }
	
	objectsArray.push(refObject);
	
	this.motherNeoReferencesMap[refObject.objectId] = objectsArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns {Boolean} applyOcclusionCulling
 */
NeoBuilding.prototype.getRenderSettingApplyOcclusionCulling = function() 
{
	return this.applyOcclusionCulling;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns {Boolean} applyOcclusionCulling
 */
NeoBuilding.prototype.setRenderSettingApplyOcclusionCulling = function(applyOcclusionCulling) 
{
	this.applyOcclusionCulling = applyOcclusionCulling;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.deleteObjectsModelReferences = function(gl, vboMemoryManager) 
{
	// 1rst, clear this.motherNeoReferencesMap.
	if (this.motherNeoReferencesMap)
	{ 
		this.motherNeoReferencesMap = {}; 
		this.motherNeoReferencesMap = undefined;
	}
	
	var blocksCount = this.motherBlocksArray.length;
	for (var i=0; i<blocksCount; i++)
	{
		if (this.motherBlocksArray[i])
		{ this.motherBlocksArray[i].deleteObjects(gl, vboMemoryManager); }
		this.motherBlocksArray[i] = undefined;
	}
	this.motherBlocksArray = [];

	var referencesCount = this.motherNeoReferencesArray.length;
	for (var i=0; i<referencesCount; i++)
	{
		if (this.motherNeoReferencesArray[i])
		{ this.motherNeoReferencesArray[i].deleteObjects(gl, vboMemoryManager); }
		this.motherNeoReferencesArray[i] = undefined;
	}
	this.motherNeoReferencesArray = [];
	
	// delete textures on the GPU..
	if (this.texturesLoaded)
	{
		var texture;
		var texturesCount = this.texturesLoaded.length;
		for (var i=0; i<texturesCount; i++)
		{
			texture = this.texturesLoaded[i];
			if (texture)
			{
				if (texture.texId)
				{
					gl.deleteTexture(texture.texId);
					texture.texId = undefined;
					texture.fileLoadState = CODE.fileLoadState.READY;
				}
			}
		}
	}

};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.deleteObjectsLodMesh = function(gl, vboMemoryManager, lodMeshKey) 
{
	// TEST delete lod 3.
	if (this.lodMeshesMap !== undefined)
	{
		if (Object.prototype.hasOwnProperty.call(this.lodMeshesMap, lodMeshKey))
		{
			var legoSkin = this.lodMeshesMap[lodMeshKey];
			if (legoSkin === undefined)
			{ return; }
			
			delete this.lodMeshesMap[lodMeshKey];
			legoSkin.deleteObjects(gl, vboMemoryManager);
			legoSkin = undefined;
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.deleteObjectsLod2 = function(gl, vboMemoryManager) 
{
	if (this.octree !== undefined)
	{ 
		// deletes the geometry and the texture.
		this.octree.deleteObjectsLego(gl, vboMemoryManager); 
	}
	
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.isDeletable = function() 
{
	if (this.attributes !== undefined)
	{
		if (this.attributes.isDeletable !== undefined && this.attributes.isDeletable === false)
		{ return false; }
	}
	
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.deleteObjects = function(gl, vboMemoryManager, deleteMetadata) 
{
	if (!this.isDeletable())
	{ return; }
	
	if (deleteMetadata)
	{
		this.metaData.deleteObjects();
		//this.metaData.fileLoadState = CODE.fileLoadState.READY;
	}
	
	// Must set ( fileLoadState = CODE.fileLoadState.READY ) bcos here deletes octree, so, must reload header 
	// and remake the octree if necessary.
	this.metaData.fileLoadState = CODE.fileLoadState.READY;

	this.deleteObjectsModelReferences(gl, vboMemoryManager);

	// The octree.
	if (this.octree !== undefined)
	{ this.octree.deleteObjects(gl, vboMemoryManager); }
	this.octree = undefined; // f4d_octree. Interior objects.
	
	//this.buildingFileName = "";

	this.allFilesLoaded = false;
	this.isReadyToRender = false;

	// delete textures.
	if (this.texturesLoaded)
	{
		var texturesCount = this.texturesLoaded.length;
		for (var i=0; i<texturesCount; i++)
		{
			if (this.texturesLoaded[i])
			{
				this.texturesLoaded[i].deleteObjects(gl);
			}
			this.texturesLoaded[i] = undefined;
		}
		this.texturesLoaded.length = 0;
	}
	this.texturesLoaded = undefined;
	
	// delete lod3, lod4, lod5.
	if (this.lodMeshesMap !== undefined)
	{
		for (var key in this.lodMeshesMap)
		{
			if (Object.prototype.hasOwnProperty.call(this.lodMeshesMap, key))
			{
				var legoSkin = this.lodMeshesMap[key];
				if (legoSkin === undefined)
				{ continue; }
			
				// Before delete the legoSkin, must erase the legoSkin from the parseQueue if exist.
				
				
				legoSkin.deleteObjects(gl, vboMemoryManager);
				legoSkin = undefined;
			}
		}
		this.lodMeshesMap = undefined;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.deleteLodMesh = function(gl, lod, vboMemoryManager) 
{
	if (this.lodMeshesMap !== undefined)
	{
		var legoSkin = this.lodMeshesMap[lod];
		if (legoSkin !== undefined)
		{
			legoSkin.deleteObjects(gl, vboMemoryManager);
			legoSkin = undefined;
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.getBBox = function() 
{
	if (this.bbox !== undefined)
	{ return this.bbox; }
	else if (this.metaData !== undefined && this.metaData.bbox !== undefined)
	{
		return this.metaData.bbox;
	}
	
	return undefined;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.getBBoxCenterPositionWorldCoord = function(geoLoc) 
{
	if (this.bboxAbsoluteCenterPos === undefined)
	{
		this.calculateBBoxCenterPositionWorldCoord(geoLoc);
	}
	
	return this.bboxAbsoluteCenterPos;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.calculateBBoxCenterPositionWorldCoord = function(geoLoc) 
{
	var bboxCenterPoint;
	
	bboxCenterPoint = this.bbox.getCenterPoint(bboxCenterPoint); // local bbox.
	this.bboxAbsoluteCenterPos = geoLoc.tMatrix.transformPoint3D(bboxCenterPoint, this.bboxAbsoluteCenterPos);
	
	// Now, must applicate the aditional translation vector. Aditional translation is made when we translate the pivot point.
	if (geoLoc.pivotPointTraslation)
	{
		var traslationVector;
		traslationVector = geoLoc.tMatrix.rotatePoint3D(geoLoc.pivotPointTraslation, traslationVector );
		this.bboxAbsoluteCenterPos.add(traslationVector.x, traslationVector.y, traslationVector.z);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.getTextureId = function(texture) 
{
	var texId;
	var texturesLoadedCount = this.texturesLoaded.length;
	var find = false;
	var i=0;
	while (!find && i < texturesLoadedCount ) 
	{
		if (this.texturesLoaded[i].textureImageFileName === texture.textureImageFileName) 
		{
			find = true;
			texId = this.texturesLoaded[i].texId;
		}
		i++;
	}

	return texId;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
NeoBuilding.prototype.getSameTexture = function(texture) 
{
	var sameTexture;
	var texturesLoadedCount = this.texturesLoaded.length;
	var find = false;
	var i=0;
	while (!find && i < texturesLoadedCount ) 
	{
		if (this.texturesLoaded[i].textureImageFileName === texture.textureImageFileName) 
		{
			find = true;
			sameTexture = this.texturesLoaded[i];
		}
		i++;
	}

	return sameTexture;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param eyeX 변수
 * @param eyeY 변수
 * @param eyeZ 변수
 */
NeoBuilding.prototype.updateCurrentVisibleIndicesExterior = function(eyeX, eyeY, eyeZ) 
{
	this._neoRefLists_Container.updateCurrentVisibleIndicesOfLists(eyeX, eyeY, eyeZ);
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoBuilding.prototype.updateCurrentAllIndicesExterior = function() 
{
	this._neoRefLists_Container.updateCurrentAllIndicesOfLists();
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns metaData.bbox.isPoint3dInside(eyeX, eyeY, eyeZ);
 */
NeoBuilding.prototype.isCameraInsideOfBuilding = function(eyeX, eyeY, eyeZ) 
{
	return this.metaData.bbox.isPoint3dInside(eyeX, eyeY, eyeZ);
	/*
	var intersectedOctree = this.octree.getIntersectedSubBoxByPoint3D(eyeX, eyeY, eyeZ);
	if(intersectedOctree)
	{
		if(intersectedOctree.triPolyhedronsCount > 0)
			return true;
		else
			return false;
	}
	else
		return false;
	*/
};

/**
 * 어떤 일을 하고 있습니까?
 * @param absoluteEyeX 변수
 * @param absoluteEyeY 변수
 * @param absoluteEyeZ 변수
 * @returns point3dScrath2
 */
NeoBuilding.prototype.getTransformedRelativeEyePositionToBuilding = function(absoluteEyeX, absoluteEyeY, absoluteEyeZ, resultRelEyePosToBuilding) 
{
	// 1rst, calculate the relative eye position.
	var buildingPosition = this.buildingPosition;
	var relativeEyePosX = absoluteEyeX - buildingPosition.x;
	var relativeEyePosY = absoluteEyeY - buildingPosition.y;
	var relativeEyePosZ = absoluteEyeZ - buildingPosition.z;

	if (this.buildingPosMatInv === undefined) 
	{
		this.buildingPosMatInv = new Matrix4();
		this.buildingPosMatInv.setByFloat32Array(this.moveMatrixInv);
	}

	var point3dScratch = new Point3D();
	
	if (resultRelEyePosToBuilding === undefined)
	{ resultRelEyePosToBuilding = new Point3D(); }
	
	point3dScratch.set(relativeEyePosX, relativeEyePosY, relativeEyePosZ);
	resultRelEyePosToBuilding = this.buildingPosMatInv.transformPoint3D(point3dScratch, resultRelEyePosToBuilding);

	return resultRelEyePosToBuilding;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param neoReference 변수
 */
NeoBuilding.prototype.getHeaderVersion = function() 
{
	if (this.metaData)
	{ return this.metaData.version; }
	else
	{ return undefined; }
};


/**
 * 어떤 일을 하고 있습니까?
 * @param lod 변수
 */
NeoBuilding.prototype.getLodBuildingData = function(lod) 
{
	if (this.lodBuildingDatasMap === undefined)
	{ return undefined; }
	
	return this.lodBuildingDatasMap[lod];
};

/**
 * 어떤 일을 하고 있습니까?
 * @param lod 변수
 */
NeoBuilding.prototype.getOrNewLodMesh = function(lodString) 
{
	if (this.lodMeshesMap === undefined)
	{ this.lodMeshesMap = {}; }

	var lowLodMesh = this.lodMeshesMap[lodString];
	if (lowLodMesh === undefined)
	{
		lowLodMesh = new Lego();
		lowLodMesh.fileLoadState = CODE.fileLoadState.READY;
		lowLodMesh.legoKey = this.buildingId + "_" + lodString;
		this.lodMeshesMap[lodString] = lowLodMesh;
	}
	return lowLodMesh;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param lod 변수
 */
NeoBuilding.prototype.getOrNewLodBuilding = function(lodString) 
{
	if (this.lodBuildingMap === undefined)
	{ this.lodBuildingMap = {}; }

	var lowLodBuilding = this.lodBuildingMap[lodString];
	if (lowLodBuilding === undefined)
	{
		lowLodBuilding = new LodBuilding();
		lowLodBuilding.attributes = {};
		this.lodBuildingMap[lodString] = lowLodBuilding;
	}
	return lowLodBuilding;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param neoReference 변수
 */
NeoBuilding.prototype.getCurrentLodString = function() 
{
	var currentLodString = undefined;
	var lodBuildingData = this.getLodBuildingData(this.currentLod);
	currentLodString = lodBuildingData.geometryFileName;
	return currentLodString;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param neoReference 변수
 */
NeoBuilding.prototype.getLowerSkinLodToLoad = function(currentLod) 
{
	// When load buildingSkin, must load respecting the LOD-order. Load 1rst lowerLod.
	// This function returns the lowerLod that is no loaded from currentLod.
	var lodToLoad;
	
	for (var lod = 5; lod >= 0; lod--)
	{
		if (lod < currentLod)
		{ break; }
		
		var lodStringAux = "lod"+lod.toString();
		var lowLodMeshAux;
		if (this.lodBuildingMap !== undefined)
		{ lowLodMeshAux = this.lodBuildingMap[lodStringAux]; }
	
		// Check if lowLodMeshAux if finished loading data.
		if (lowLodMeshAux === undefined || lowLodMeshAux.skinLego === undefined || lowLodMeshAux.skinLego.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED)
		{
			lodToLoad = lod;
			break;
		}
		else if (lowLodMeshAux.skinLego.vbo_vicks_container.vboCacheKeysArray === undefined)
		{
			lodToLoad = lod;
			break;
		}
		
		if (lowLodMeshAux.skinLego.vbo_vicks_container.vboCacheKeysArray[0] && lowLodMeshAux.skinLego.vbo_vicks_container.vboCacheKeysArray[0].vboBufferTCoord)
		{
			// this is the new version.
			if (lowLodMeshAux.texture === undefined)
			{
				lodToLoad = lod;
				break;
			}
			else
			{
				if (lowLodMeshAux.texture.texId === undefined)
				{
					if (lowLodMeshAux.texture.fileLoadState !== CODE.fileLoadState.BINDING_FINISHED && lowLodMeshAux.texture.fileLoadState !== CODE.fileLoadState.LOADING_STARTED)
					{
						lodToLoad = lod;
						break;
					}
					else
					{
						break;
					}
				}
			}

		}
		
		
		//if (lowLodMeshAux.texture === undefined || lowLodMeshAux.texture.texId === undefined)
		//{
		//	lodToLoad = lod;
		//	break;
		//}
	}

	return lodToLoad;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param neoReference 변수
 */
NeoBuilding.prototype.getLowerSkinLodToLoad__original = function(currentLod) 
{
	// When load buildingSkin, must load respecting the LOD-order. Load 1rst lowerLod.
	// This function returns the lowerLod that is no loaded from currentLod.
	var lodToLoad;
	
	for (var lod = 5; lod >= 0; lod--)
	{
		if (lod < currentLod)
		{ break; }
		
		var lodBuildingDataAux = this.getLodBuildingData(lod);
		
		if (lodBuildingDataAux === undefined)
		{ continue; }
	
		if (lodBuildingDataAux.isModelRef)
		{ continue; }
	
		var lodStringAux = lodBuildingDataAux.geometryFileName;
		var lowLodMeshAux;
		if (this.lodMeshesMap !== undefined)
		{ lowLodMeshAux = this.lodMeshesMap[lodStringAux]; }
			
		// Check if lowLodMeshAux if finished loading data.
		if (lowLodMeshAux === undefined || lowLodMeshAux.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED)
		{
			lodToLoad = lod;
			break;
		}
		else if (lowLodMeshAux.vbo_vicks_container.vboCacheKeysArray === undefined)
		{
			lodToLoad = lod;
			break;
		}
		
		if (lowLodMeshAux.vbo_vicks_container.vboCacheKeysArray[0] && lowLodMeshAux.vbo_vicks_container.vboCacheKeysArray[0].vboBufferTCoord)
		{
			// this is the new version.
			if (lowLodMeshAux.texture === undefined || lowLodMeshAux.texture.texId === undefined)
			{
				lodToLoad = lod;
				break;
			}
		}
		
		
		//if (lowLodMeshAux.texture === undefined || lowLodMeshAux.texture.texId === undefined)
		//{
		//	lodToLoad = lod;
		//	break;
		//}
	}

	return lodToLoad;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param neoReference 변수
 */
NeoBuilding.prototype.getCurrentSkin = function() 
{
	if (this.lodMeshesMap === undefined)
	{ return undefined; }
	
	var skinLego;
	var lodBuildingData = this.getLodBuildingData(this.currentLod);
	if (lodBuildingData === undefined)
	{ return; }
		
	//textureFileName = lodBuildingData.textureFileName;
	var lodString = lodBuildingData.geometryFileName;
	//skinLego = this.lodMeshesMap[lodString];
	var lodBuilding = this.lodBuildingMap[lodString];
		
	if (lodBuilding !== undefined && lodBuilding.isReadyToRender())
	{ return lodBuilding; }
		
	
	if (this.currentLod === 0)
	{
		lodBuilding = this.lodBuildingMap.lod0;
		
		if (lodBuilding === undefined || !lodBuilding.isReadyToRender())
		{
			lodBuilding = this.lodBuildingMap.lod1;
			if (lodBuilding === undefined || !lodBuilding.isReadyToRender())
			{
				lodBuilding = this.lodBuildingMap.lod2;
				if (lodBuilding === undefined || !lodBuilding.isReadyToRender())
				{
					lodBuilding = this.lodBuildingMap.lod3;
					if (lodBuilding === undefined || !lodBuilding.isReadyToRender())
					{
						lodBuilding = this.lodBuildingMap.lod4;
						if (lodBuilding === undefined || !lodBuilding.isReadyToRender())
						{
							lodBuilding = this.lodBuildingMap.lod5;
						}
					}
				}
			}
		}
		
	}
	else if (this.currentLod === 1)
	{
		lodBuilding = this.lodBuildingMap.lod1;
		
		if (lodBuilding === undefined || !lodBuilding.isReadyToRender())
		{
			lodBuilding = this.lodBuildingMap.lod2;
			if (lodBuilding === undefined || !lodBuilding.isReadyToRender())
			{
				lodBuilding = this.lodBuildingMap.lod3;
				if (lodBuilding === undefined || !lodBuilding.isReadyToRender())
				{
					lodBuilding = this.lodBuildingMap.lod4;
					if (lodBuilding === undefined || !lodBuilding.isReadyToRender())
					{
						lodBuilding = this.lodBuildingMap.lod5;
					}
				}
			}
		}
		
	}
	else if (this.currentLod === 2)
	{
		lodBuilding = this.lodBuildingMap.lod2;
		
		if (lodBuilding === undefined || !lodBuilding.isReadyToRender())
		{
			lodBuilding = this.lodBuildingMap.lod3;
			if (lodBuilding === undefined || !lodBuilding.isReadyToRender())
			{
				lodBuilding = this.lodBuildingMap.lod4;
				if (lodBuilding === undefined || !lodBuilding.isReadyToRender())
				{
					lodBuilding = this.lodBuildingMap.lod5;
				}
			}
		}
		
	}
	else if (this.currentLod === 3)
	{
		lodBuilding = this.lodBuildingMap.lod3;
		
		if (lodBuilding === undefined || !lodBuilding.isReadyToRender())
		{
			lodBuilding = this.lodBuildingMap.lod4;
			if (lodBuilding === undefined || !lodBuilding.isReadyToRender())
			{
				lodBuilding = this.lodBuildingMap.lod5;
			}
		}
		
	}
	else if (this.currentLod === 4)
	{
		lodBuilding = this.lodBuildingMap.lod4;
		
		if (lodBuilding === undefined || !lodBuilding.isReadyToRender())
		{
			lodBuilding = this.lodBuildingMap.lod5;
		}
		
	}
	else if (this.currentLod === 5)
	{
		lodBuilding = this.lodBuildingMap.lod5;
	}

	return lodBuilding;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param neoReference 변수
 */
NeoBuilding.prototype.getCurrentSkin__original = function() 
{
	if (this.lodMeshesMap === undefined)
	{ return undefined; }
	
	var skinLego;
	var lodBuildingData = this.getLodBuildingData(this.currentLod);
	if (lodBuildingData === undefined)
	{ return; }
		
	//textureFileName = lodBuildingData.textureFileName;
	var lodString = lodBuildingData.geometryFileName;
	skinLego = this.lodMeshesMap[lodString];
		
	if (skinLego !== undefined && skinLego.isReadyToRender())
	{ return skinLego; }
		
	
	if (this.currentLod === 0)
	{
		skinLego = this.lodMeshesMap.lod0;
		
		if (skinLego === undefined || !skinLego.isReadyToRender())
		{
			skinLego = this.lodMeshesMap.lod1;
			if (skinLego === undefined || !skinLego.isReadyToRender())
			{
				skinLego = this.lodMeshesMap.lod2;
				if (skinLego === undefined || !skinLego.isReadyToRender())
				{
					skinLego = this.lodMeshesMap.lod3;
					if (skinLego === undefined || !skinLego.isReadyToRender())
					{
						skinLego = this.lodMeshesMap.lod4;
						if (skinLego === undefined || !skinLego.isReadyToRender())
						{
							skinLego = this.lodMeshesMap.lod5;
						}
					}
				}
			}
		}
		
	}
	else if (this.currentLod === 1)
	{
		skinLego = this.lodMeshesMap.lod1;
		
		if (skinLego === undefined || !skinLego.isReadyToRender())
		{
			skinLego = this.lodMeshesMap.lod2;
			if (skinLego === undefined || !skinLego.isReadyToRender())
			{
				skinLego = this.lodMeshesMap.lod3;
				if (skinLego === undefined || !skinLego.isReadyToRender())
				{
					skinLego = this.lodMeshesMap.lod4;
					if (skinLego === undefined || !skinLego.isReadyToRender())
					{
						skinLego = this.lodMeshesMap.lod5;
					}
				}
			}
		}
		
	}
	else if (this.currentLod === 2)
	{
		skinLego = this.lodMeshesMap.lod2;
		
		if (skinLego === undefined || !skinLego.isReadyToRender())
		{
			skinLego = this.lodMeshesMap.lod3;
			if (skinLego === undefined || !skinLego.isReadyToRender())
			{
				skinLego = this.lodMeshesMap.lod4;
				if (skinLego === undefined || !skinLego.isReadyToRender())
				{
					skinLego = this.lodMeshesMap.lod5;
				}
			}
		}
		
	}
	else if (this.currentLod === 3)
	{
		skinLego = this.lodMeshesMap.lod3;
		
		if (skinLego === undefined || !skinLego.isReadyToRender())
		{
			skinLego = this.lodMeshesMap.lod4;
			if (skinLego === undefined || !skinLego.isReadyToRender())
			{
				skinLego = this.lodMeshesMap.lod5;
			}
		}
		
	}
	else if (this.currentLod === 4)
	{
		skinLego = this.lodMeshesMap.lod4;
		
		if (skinLego === undefined || !skinLego.isReadyToRender())
		{
			skinLego = this.lodMeshesMap.lod5;
		}
		
	}
	else if (this.currentLod === 5)
	{
		skinLego = this.lodMeshesMap.lod5;
	}

	return skinLego;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param neoReference 변수
 */
NeoBuilding.prototype.manageNeoReferenceTexture = function(neoReference, magoManager) 
{
	if (this.texturesManager === undefined)
	{ this.texturesManager = new TexturesManager(); }
	
	var texture = undefined;
	var version = this.metaData.version;
	if (version[0] === "v")
	{
		// this is the version beta.
		if (neoReference.texture === undefined)
		{ return undefined; }
		
		if (neoReference.texture.texId === undefined && neoReference.texture.textureImageFileName !== "") 
		{
			// 1rst, check if the texture is loaded.
			if (this.texturesLoaded === undefined)
			{ this.texturesLoaded = []; }
			
			var sameTexture = this.getSameTexture(neoReference.texture);
			if (sameTexture === undefined)
			{
				if (magoManager.backGround_fileReadings_count > 10) 
				{ return; }
			
				if (neoReference.texture.fileLoadState === CODE.fileLoadState.READY) 
				{
					var gl = magoManager.sceneState.gl;
					neoReference.texture.texId = gl.createTexture();
					// Load the texture.
					var projectFolderName = this.projectFolderName;
					var geometryDataPath = magoManager.readerWriter.geometryDataPath;
					var filePath_inServer = geometryDataPath + "/" + projectFolderName + "/" + this.buildingFileName + "/Images_Resized/" + neoReference.texture.textureImageFileName;

					this.texturesLoaded.push(neoReference.texture);
					magoManager.readerWriter.readNeoReferenceTexture(gl, filePath_inServer, neoReference.texture, this, magoManager);
					magoManager.backGround_fileReadings_count ++;
				}
			}
			else 
			{
				if (sameTexture.fileLoadState === CODE.fileLoadState.LOADING_FINISHED)
				{
					neoReference.texture = sameTexture;
				}
			}
		}
		
		return neoReference.texture.fileLoadState;
	}
	else if (version[0] === '0' && version[2] === '0' && version[4] === '1' )
	{
		if (neoReference.texture === undefined || neoReference.texture.fileLoadState === CODE.fileLoadState.READY)
		{
			// provisionally use materialId as textureId.
			var textureId = neoReference.materialId;
			texture = this.texturesLoaded[textureId];
			neoReference.texture = texture;
			
			if (texture && texture.texId === undefined && texture.textureImageFileName !== "")
			{
				if (magoManager.backGround_fileReadings_count > 10) 
				{ return undefined; }
	
				if (texture.fileLoadState === CODE.fileLoadState.READY) 
				{
					var gl = magoManager.sceneState.gl;
					texture.texId = gl.createTexture();
					// Load the texture.
					var projectFolderName = this.projectFolderName;
					var geometryDataPath = magoManager.readerWriter.getCurrentDataPath();
					var filePath_inServer = geometryDataPath + "/" + projectFolderName + "/" + this.buildingFileName + "/Images_Resized/" + texture.textureImageFileName;

					magoManager.readerWriter.readNeoReferenceTexture(gl, filePath_inServer, texture, this, magoManager);
					magoManager.backGround_fileReadings_count ++;
				}
			}
		}
		
		if (neoReference.texture)
		{ return neoReference.texture.fileLoadState; }
	}
	else if (version[0] === '0' && version[2] === '0' && version[4] === '2' )
	{
		// Project_data_type (new in version 002).
		// 1 = 3d model data type (normal 3d with interior & exterior data).
		// 2 = single building skin data type (as vWorld or googleEarth data).
		// 3 = multi building skin data type (as Shibuya & Odaiba data).
		// 4 = pointsCloud data type.
		// 5 = pointsCloud data type pyramidOctree test.	
		if (this.metaData.projectDataType === undefined || this.metaData.projectDataType > 3)
		{ return neoReference.texture.fileLoadState; }
	
		if (neoReference.texture === undefined || neoReference.texture.fileLoadState === CODE.fileLoadState.READY)
		{
			// provisionally use materialId as textureId.
			var textureId = neoReference.materialId;
			texture = this.texturesLoaded[textureId];
			neoReference.texture = texture;
			
			if (texture && texture.texId === undefined && texture.textureImageFileName !== "")
			{
				if (magoManager.backGround_fileReadings_count > 10) 
				{ return undefined; }
	
				if (texture.fileLoadState === CODE.fileLoadState.READY) 
				{
					var gl = magoManager.sceneState.gl;
					texture.texId = gl.createTexture();
					// Load the texture.
					var projectFolderName = this.projectFolderName;
					var geometryDataPath = magoManager.readerWriter.getCurrentDataPath();
					var filePath_inServer = geometryDataPath + "/" + projectFolderName + "/" + this.buildingFileName + "/Images_Resized/" + texture.textureImageFileName;

					magoManager.readerWriter.readNeoReferenceTexture(gl, filePath_inServer, texture, this, magoManager);
					magoManager.backGround_fileReadings_count ++;
				}
			}
		}
		
		if (neoReference.texture)
		{ return neoReference.texture.fileLoadState; }
	}
	
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoBuilding.prototype.getShaderName = function(lod, projectType, renderType) 
{
	var shaderName;
	
	// renderType = 0 -> depth render.
	// renderType = 1 -> normal render.
	// renderType = 2 -> colorSelection render.
	//--------------------------------------------
	
	if (renderType === 0)
	{
		if (lod <= 1)
		{
			shaderName = "modelRefDepth";
		}
	}
	else if (renderType === 1)
	{
		if (lod <= 2)
		{
			shaderName = "modelRefSsao";
		}
	}
	else if (renderType === 2)
	{
		if (lod <= 1)
		{
			shaderName = "modelRefSsao";
		}
	}

	return shaderName;
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoBuilding.prototype.parseTexturesList = function(arrayBuffer, bytesReaded) 
{
	var decoder = new TextDecoder('utf-8');
	// read materials list.
	var materialsCount = ReaderWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
	for (var i=0; i<materialsCount; i++)
	{
		var textureTypeName = "";
		var textureImageFileName = "";

		// Now, read the texture_type and texture_file_name.***
		var texture_type_nameLegth = ReaderWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		textureTypeName = decoder.decode(new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ texture_type_nameLegth))) ;bytesReaded += texture_type_nameLegth;

		var texture_fileName_Legth = ReaderWriter.readUInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var charArray = new Uint8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ texture_fileName_Legth)); bytesReaded += texture_fileName_Legth;
		
		textureImageFileName = decoder.decode(charArray);
		
		if (texture_fileName_Legth > 0)
		{
			var texture = new Texture();
			texture.textureTypeName = textureTypeName;
			texture.textureImageFileName = textureImageFileName;
			
			if (this.texturesLoaded === undefined)
			{ this.texturesLoaded = []; }
			
			this.texturesLoaded.push(texture);
		}
		
	}
	
	return bytesReaded;
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoBuilding.prototype.getTriangles = function(resultTrianglesArray) 
{
	if (this.motherNeoReferencesArray === undefined || this.motherBlocksArray === undefined)
	{ return false; }

	if (resultTrianglesArray === undefined)
	{ resultTrianglesArray = []; }
	
	var reference;
	var objectsCount = this.motherNeoReferencesArray.length;
	for (var i=0; i<objectsCount; i++)
	{
		reference = this.motherNeoReferencesArray[i];
		if (reference !== undefined)
		{ resultTrianglesArray = reference.getTriangles(this, resultTrianglesArray); }
	}
	
	return resultTrianglesArray;
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoBuilding.prototype.allModelsAndReferencesAreParsed = function(magoManager) 
{
	if (this.octree === undefined)
	{ return false; }
	
	var lowestOctreesArray = [];
	this.octree.extractLowestOctreesIfHasTriPolyhedrons(lowestOctreesArray);
	var lowestOctreesCount = lowestOctreesArray.length;
	for (var i=0; i<lowestOctreesCount; i++)
	{
		var lowestOctree = lowestOctreesArray[i];
		
		// check if models & references is already loaded.
		if (lowestOctree.neoReferencesMotherAndIndices === undefined)
		{ return false; }
		
		if (lowestOctree.neoReferencesMotherAndIndices.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED)
		{ return false; }
	
		var blocksList = lowestOctree.neoReferencesMotherAndIndices.blocksList;
		if (blocksList.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED)
		{ return false; }
	}
	
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoBuilding.prototype.forceToLoadModelsAndReferences = function(magoManager) 
{
	// Load all models & references.
	var allModelsAndReferencesAreLoaded = true;
	
	var options = {};
	options.parseImmediately = true;
	
	var lowestOctreesArray = [];
	this.octree.extractLowestOctreesIfHasTriPolyhedrons(lowestOctreesArray);
	var lowestOctreesCount = lowestOctreesArray.length;
	for (var i=0; i<lowestOctreesCount; i++)
	{
		var lowestOctree = lowestOctreesArray[i];
		
		if (lowestOctree.triPolyhedronsCount === 0) 
		{ continue; }


		var geometryDataPath = magoManager.readerWriter.geometryDataPath;
		var buildingFolderName = this.buildingFileName;
		var projectFolderName = this.projectFolderName;
		
		var keepDataArrayBuffers = false;
		var attrib = this.attributes;
		if (attrib !== undefined)
		{
			if (attrib.keepDataArrayBuffers !== undefined && attrib.keepDataArrayBuffers === true)
			{
				keepDataArrayBuffers = true;
			}
		}
		
		if (lowestOctree.neoReferencesMotherAndIndices === undefined)
		{
			lowestOctree.neoReferencesMotherAndIndices = new NeoReferencesMotherAndIndices();
			lowestOctree.neoReferencesMotherAndIndices.motherNeoRefsList = this.motherNeoReferencesArray;
		}
		
		if (lowestOctree.neoReferencesMotherAndIndices.fileLoadState === CODE.fileLoadState.READY)
		{
			if (lowestOctree.neoReferencesMotherAndIndices.blocksList === undefined)
			{ lowestOctree.neoReferencesMotherAndIndices.blocksList = new BlocksList("0.0.1"); }
		
			if (keepDataArrayBuffers)
			{	
				lowestOctree.neoReferencesMotherAndIndices.blocksList.keepDataArrayBuffers = keepDataArrayBuffers;
			}

			var subOctreeNumberName = lowestOctree.octree_number_name.toString();
			var references_folderPath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/References";
			var intRef_filePath = references_folderPath + "/" + subOctreeNumberName + "_Ref";
			magoManager.readerWriter.getNeoReferencesArraybuffer(intRef_filePath, lowestOctree, magoManager, options);
		}
		else if (lowestOctree.neoReferencesMotherAndIndices.fileLoadState === CODE.fileLoadState.LOADING_FINISHED)
		{
			ParseQueue.parseOctreesLod0References(lowestOctree, magoManager);
		}
		
		
		// 4 = parsed.
		// now, check if the blocksList is loaded & parsed.
		var blocksList = lowestOctree.neoReferencesMotherAndIndices.blocksList;
		if (blocksList === undefined)
		{ return; }
		if (blocksList.fileLoadState === CODE.fileLoadState.READY) 
		{
			// must read blocksList.
			var subOctreeNumberName = lowestOctree.octree_number_name.toString();
			var blocks_folderPath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/Models";
			var filePathInServer = blocks_folderPath + "/" + subOctreeNumberName + "_Model";
			magoManager.readerWriter.getNeoBlocksArraybuffer(filePathInServer, lowestOctree, magoManager, options);
		}
		else if (blocksList.fileLoadState === CODE.fileLoadState.LOADING_FINISHED) 
		{
			ParseQueue.parseArrayOctreesLod0Models(lowestOctree, magoManager);
		}
	}

	return allModelsAndReferencesAreLoaded;
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoBuilding.prototype.makeCollisionCheckOctree = function(desiredMinOctreeSize) 
{
	// 1rst, must force to load all models & references.
	// Models & references are in leaf octrees.
	
	if (this.motherNeoReferencesArray === undefined || this.motherBlocksArray === undefined)
	{ return false; }

	if (this.collisionCheckOctree === undefined)
	{
		// Using the motherOctree (this.octree), make the 1rst approximation to the collisionCheckOctree.
		var collisionCheckOctree = new CollisionCheckOctree();
		var octree = this.octree;
		collisionCheckOctree.centerPos.copyFrom(octree.centerPos);
		collisionCheckOctree.half_dx = octree.half_dx; // half width.
		collisionCheckOctree.half_dy = octree.half_dy; // half length.
		collisionCheckOctree.half_dz = octree.half_dz; // half height.
		collisionCheckOctree.octree_level = octree.octree_level;
		
		collisionCheckOctree.trianglesArray = this.getTriangles();

		    
		if (!collisionCheckOctree.trianglesArray ) 
		{
			return false;
		}
		
		var options = {};
		options.desiredMinOctreeSize = desiredMinOctreeSize;
		collisionCheckOctree.makeTreeByTrianglesArray(options);
		this.collisionCheckOctree = collisionCheckOctree;
	}
	
	// Now, must transform the collisionCheckOctree with the neoBuilding's transforms.
	var nodeOwner = this.nodeOwner;
	var data = nodeOwner.data;
	var geoLocDataManager = data.geoLocDataManager;
	var geoLocationData = geoLocDataManager.getCurrentGeoLocationData();
	var pivotPointTraslationLC = geoLocationData.pivotPointTraslationLC;
	
	// Transform from origin only the 1rst time.
	var bTransformFromOrigin = true;
	if (pivotPointTraslationLC !== undefined)
	{
		this.collisionCheckOctree.translate(pivotPointTraslationLC, bTransformFromOrigin);
		bTransformFromOrigin = false;
	}
	
	var tMat = geoLocationData.tMatrix;
	this.collisionCheckOctree.transformByMatrix4(tMat, bTransformFromOrigin);
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoBuilding.prototype.getCollisionCheckOctree = function() 
{
	return this.collisionCheckOctree;
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoBuilding.prototype.parseHeader = function(arrayBuffer, bytesReaded) 
{
	// In the header file, there are:
	// 1) metaData.
	// 2) octree's structure.
	// 3) textures list.
	// 4) lodBuilding data.
	
	// metadata.
	if (this.metaData === undefined) 
	{ this.metaData = new MetaData(); }

	if (bytesReaded === undefined)
	{ bytesReaded = 0; }
			
	var metaData = this.metaData;
	bytesReaded = metaData.parseFileHeaderAsimetricVersion(arrayBuffer, bytesReaded);
	
	
	// Now, make the neoBuilding's octree.***
	if (this.octree === undefined) { this.octree = new Octree(undefined); }
	this.octree.neoBuildingOwnerId = this.buildingId;
	this.octree.octreeKey = this.buildingId + "_" + this.octree.octree_number_name;
	
	// now, parse octreeAsimetric or octreePyramid (check metadata.projectDataType).***
	if (metaData.projectDataType === 5)
	{ bytesReaded = this.octree.parsePyramidVersion(arrayBuffer, bytesReaded, this); }
	else
	{ bytesReaded = this.octree.parseAsimetricVersion(arrayBuffer, bytesReaded, this); }

	metaData.oct_min_x = this.octree.centerPos.x - this.octree.half_dx;
	metaData.oct_max_x = this.octree.centerPos.x + this.octree.half_dx;
	metaData.oct_min_y = this.octree.centerPos.y - this.octree.half_dy;
	metaData.oct_max_y = this.octree.centerPos.y + this.octree.half_dy;
	metaData.oct_min_z = this.octree.centerPos.z - this.octree.half_dz;
	metaData.oct_max_z = this.octree.centerPos.z + this.octree.half_dz;

	
	if (metaData.version === "0.0.1" || metaData.version === "0.0.2")
	{
		// read materials list.
		bytesReaded = this.parseTexturesList(arrayBuffer, bytesReaded);

		// read geometry type data.***
		bytesReaded = this.parseLodBuildingData(arrayBuffer, bytesReaded);
	}

	metaData.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
	this.headerDataArrayBuffer = undefined;
	
	this.bbox = this.metaData.bbox;
	
	return bytesReaded;
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoBuilding.prototype.parseLodBuildingData = function(arrayBuffer, bytesReaded) 
{
	var lod;
	var nameLength;
	var lodBuildingDatasCount = (new Uint8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1)))[0];bytesReaded += 1;
	if (lodBuildingDatasCount !== undefined)
	{
		this.lodBuildingDatasMap = {};
		var decoder = new TextDecoder('utf-8');
		
		for (var i =0; i<lodBuildingDatasCount; i++)
		{
			var lodBuildingData = new LodBuildingData();
			lodBuildingData.lod = (new Uint8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1)))[0];bytesReaded += 1;
			lodBuildingData.isModelRef = (new Uint8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1)))[0];bytesReaded += 1;
			
			if (lodBuildingData.lod === 2)
			{
				// read the lod2_textureFileName.***
				nameLength = (new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1)))[0];bytesReaded += 1;
				lodBuildingData.textureFileName = "";
				lodBuildingData.textureFileName = decoder.decode(new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ nameLength))) ;bytesReaded += nameLength;
			}
			
			if (!lodBuildingData.isModelRef)
			{
				nameLength = (new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1)))[0];bytesReaded += 1;
				lodBuildingData.geometryFileName = "";
				lodBuildingData.geometryFileName = decoder.decode(new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ nameLength))) ;bytesReaded += nameLength;
				
				nameLength = (new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1)))[0];bytesReaded += 1;
				lodBuildingData.textureFileName = "";
				lodBuildingData.textureFileName = decoder.decode(new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ nameLength))) ;bytesReaded += nameLength;
			}
			this.lodBuildingDatasMap[lodBuildingData.lod] = lodBuildingData;
		}
		
		// read a endMark.
		var endMark = (new Uint8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ 1)))[0];bytesReaded += 1;
	}
	
	return bytesReaded;
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoBuilding.prototype.prepareSkin = function(magoManager) 
{
	var headerVersion = this.getHeaderVersion();
	if (headerVersion === undefined)
	{ return false; }
	
	if (headerVersion[0] !== "0")
	{ return false; }

	if (!this.currentLod)
	{ this.currentLod = this.nodeOwner.data.currentLod; }

	// Must respect the lodLoading order: must load the lowerLod if is not loaded.
	var lodToLoad;
	lodToLoad = this.getLowerSkinLodToLoad(this.currentLod);
	

	var lodBuildingData = this.getLodBuildingData(lodToLoad);
	if (lodBuildingData === undefined)
	{ return false; }

	if (lodBuildingData.isModelRef)
	{ return false; }

	var projectFolderName = this.projectFolderName;
	var buildingFolderName = this.buildingFileName;
	var geometryDataPath = magoManager.readerWriter.geometryDataPath;
	var textureFileName = lodBuildingData.textureFileName;

	// check if exist lodBuilding in lodBuildingMap.
	var lodBuildingName = "lod"+lodBuildingData.lod.toString();
	var lodBuilding = this.getOrNewLodBuilding(lodBuildingName);
	
	if (textureFileName !== "noTexture")
	{
		lodBuilding.attributes.hasTexture = true;
		lodBuilding.textureName = textureFileName;
	}
	
	// check if exist the lodMesh in lodMeshMap.
	var lodString = lodBuildingData.geometryFileName;
	var lowLodMesh = this.getOrNewLodMesh(lodString);
	lowLodMesh.textureName = textureFileName;
	
	lodBuilding.skinLego = lowLodMesh;
	
	if (lowLodMesh.fileLoadState === -1)
	{
		// if a lodObject has "fileLoadState" = -1 means that there are no file in server.
		return false;
	}
	
	// Check if this neoBuilding is fromSmartTile.***
	var fromSmartTile = this.nodeOwner.data.attributes.fromSmartTile;
	if (fromSmartTile === undefined)
	{ fromSmartTile = false; }
	
	if (lowLodMesh.fileLoadState === CODE.fileLoadState.READY) 
	{
		if (fromSmartTile)
		{
			// No load lod5, lod4 & lod3.***
			if (lodToLoad <3)
			{
				if (magoManager.readerWriter.skinLegos_requested < 5)
				{
					var lodMeshFilePath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/" + lodString;
					magoManager.readerWriter.getLegoArraybuffer(lodMeshFilePath, lowLodMesh, magoManager);
					if (lowLodMesh.vbo_vicks_container.vboCacheKeysArray === undefined)
					{ lowLodMesh.vbo_vicks_container.vboCacheKeysArray = []; }
				}
			}
		}
		else
		{
			if (magoManager.readerWriter.skinLegos_requested < 5)
			{
				var lodMeshFilePath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/" + lodString;
				magoManager.readerWriter.getLegoArraybuffer(lodMeshFilePath, lowLodMesh, magoManager);
				if (lowLodMesh.vbo_vicks_container.vboCacheKeysArray === undefined)
				{ lowLodMesh.vbo_vicks_container.vboCacheKeysArray = []; }
			}
			
		}
	}
	else if (lowLodMesh.fileLoadState === CODE.fileLoadState.LOADING_FINISHED) 
	{
		////magoManager.parseQueue.putSkinLegosToParse(lowLodMesh);
		////magoManager.readerWriter.skinLegos_requested ++;
		
		lowLodMesh.parseArrayBuffer(lowLodMesh.dataArrayBuffer, magoManager);
	}
	
	else if (lowLodMesh.vbo_vicks_container.vboCacheKeysArray[0] && lowLodMesh.vbo_vicks_container.vboCacheKeysArray[0].vboBufferTCoord)
	{
		// this is the new version.
		if (lodBuilding.texture === undefined)
		{
			if (fromSmartTile)
			{
				if (lodToLoad <3)
				{
					//if (magoManager.readerWriter.skinLegos_requested < 4)
					if (magoManager.fileRequestControler.lowLodImagesRequestedCount < 4)
					{
						lodBuilding.texture = new Texture();
						var filePath_inServer = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/" + textureFileName;
						var gl = magoManager.sceneState.gl;
						var flip_y_texCoords = true;
						magoManager.readerWriter.readLegoSimpleBuildingTexture(gl, filePath_inServer, lodBuilding.texture, magoManager, flip_y_texCoords); 
					}
				}
			}
			else
			{
				//if (magoManager.readerWriter.skinLegos_requested < 4)
				if (magoManager.fileRequestControler.lowLodImagesRequestedCount < 4)
				{
					lodBuilding.texture = new Texture();
					var filePath_inServer = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/" + textureFileName;
					var gl = magoManager.sceneState.gl;
					var flip_y_texCoords = true;
					magoManager.readerWriter.readLegoSimpleBuildingTexture(gl, filePath_inServer, lodBuilding.texture, magoManager, flip_y_texCoords); 
				}
			}
			
		}
		else if (lodBuilding.texture.fileLoadState === CODE.fileLoadState.LOADING_FINISHED && lodBuilding.texture.texId === undefined)
		{
			// then make the image to bind into gpu.
			var gl = magoManager.sceneState.gl;
			TexturesManager.newWebGlTextureByEmbeddedImage(gl, lodBuilding.texture.imageBinaryData, lodBuilding.texture);
			magoManager.readerWriter.skinLegos_requested ++;
			
		}
	}
	
	
	return true;
};
/**
 * 어떤 일을 하고 있습니까?
 */
NeoBuilding.prototype.renderCollisionCheckSpheres = function(magoManager, shader, renderType) 
{
	if (this.collisionCheckOctree === undefined)
	{ return; }

	var lowestOctreesArray = [];
	this.collisionCheckOctree.extractLowestOctreesIfHasTriangles(lowestOctreesArray);
	
	var checkOctreesCount = lowestOctreesArray.length;
	for (var i=0; i<checkOctreesCount; i++)
	{
		var checkOctree = lowestOctreesArray[i];
		
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoBuilding.prototype.render = function(magoManager, shader, renderType, refMatrixIdxKey, flipYTexCoord, currentLod) 
{
	var gl = magoManager.sceneState.gl;
	//gl.uniform1f(shader.externalAlpha_loc, 1.0);
	
	if (currentLod !== undefined)
	{ this.currentLod = currentLod; }
	
	// Check metaData.projectDataType.
	if (this.metaData.projectDataType === 5)
	{
		// Render pointsCloud pyramidMode.
		return;
	}
	/*
	if (renderType === 3)
	{
		// Render the shadowMesh.
		var lod = 5;
		var lodBuildingData = this.getLodBuildingData(lod);
		if (lodBuildingData && !lodBuildingData.isModelRef)
		{
			// This building is skinType data.
			this.renderSkin(magoManager, shader, renderType);
		}
		
		return;
	}
	*/
	
	if (this.currentLod <= 2)
	{
		// There are buildings that are only skin, so check projectType of the building.
		var lodBuildingData = this.getLodBuildingData(this.currentLod);
		
		if (this.currentLod === 2 && this.buildingId === "7D6_1")
		{ var hola = 0; }
		
		if (lodBuildingData && !lodBuildingData.isModelRef)
		{
			// This building is skinType data.
			this.renderSkin(magoManager, shader, renderType);
		}
		else
		{
			var octreesRenderedCount = this.renderDetailed(magoManager, shader, renderType, refMatrixIdxKey, flipYTexCoord);
			
			if (this.currentVisibleOctreesControler === undefined)
			{
				this.renderSkin(magoManager, shader, renderType);
			}
			else
			{
				var lowestOctreesCount0 = this.currentVisibleOctreesControler.currentVisibles0.length;
				var lowestOctreesCount1 = this.currentVisibleOctreesControler.currentVisibles1.length;
				var lowestOctreesCount2 = this.currentVisibleOctreesControler.currentVisibles2.length;
				
				// If octreesRenderedsCount is minor than 60% of total of visibleOctrees, then render the buildingSkin.
				// Project_data_type (new in version 002).
				// 1 = 3d model data type (normal 3d with interior & exterior data).
				// 2 = single building skin data type (as vWorld or googleEarth data).
				// 3 = multi building skin data type (as Shibuya & Odaiba data).
				// 4 = pointsCloud data type.
				// 5 = pointsCloud data type pyramidOctree test.

				if (this.metaData.projectDataType === 2)
				{
					if (octreesRenderedCount <= 0 )
					{ this.renderSkin(magoManager, shader, renderType); }
				}
				else 
				{
					if (octreesRenderedCount < (lowestOctreesCount0 + lowestOctreesCount1 + lowestOctreesCount2)*0.4)
					{ this.renderSkin(magoManager, shader, renderType); }
				}
			}
		}
		
		// Now, check how many octrees are rendered. If rendered only a few, then render the buildingSkin.
		
	}
	else if (this.currentLod > 2)
	{
		this.renderSkin(magoManager, shader, renderType);
	}
	
	// test.
	if (this.collisionCheckOctree !== undefined && this.collisionCheckOctree.currentVisibleOctreesArray !== undefined)
	{
		gl.uniform1i(shader.refMatrixType_loc, 0); // in this case, there are not referencesMatrix.
		var collisionOctreesArray = this.collisionCheckOctree.currentVisibleOctreesArray;
		var visibleCollisionOctreesCount = collisionOctreesArray.length;
		for (var i=0; i<visibleCollisionOctreesCount; i++)
		{
			collisionOctreesArray[i].render(magoManager, shader, renderType, undefined);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoBuilding.prototype.renderShadowMesh = function(magoManager, shader, renderType) 
{
	var skinLego = this.getCurrentSkin();
	// Note: skinLego is "LodBuilding" class object.
		
	if (skinLego === undefined)
	{ return; }

	if (!skinLego.isReadyToRender())
	{ return; }

	var gl = magoManager.sceneState.gl;
	
	var renderTexture = true;
	
	// if the building is highlighted, the use highlight oneColor4.
	gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
	gl.uniform4fv(shader.oneColor4_loc, [0.7, 0.7, 0.7, 1.0]);
	
	gl.uniform1i(shader.refMatrixType_loc, 0); // in this case, there are not referencesMatrix.
	skinLego.render(magoManager, renderType, renderTexture, shader, this);
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoBuilding.prototype.renderSkin = function(magoManager, shader, renderType) 
{
	var skinLego = this.getCurrentSkin();
	// Note: skinLego is "LodBuilding" class object.
		
	if (skinLego === undefined)
	{ return; }

	if (!skinLego.isReadyToRender())
	{ return; }

	var gl = magoManager.sceneState.gl;

	magoManager.renderer.currentObjectsRendering.curOctree = this;
	
	var currentObjectsRendering = magoManager.renderer.currentObjectsRendering;
	var selCandidates;
	var selectionColor;
	var currentNode;
	var currentOctree;
	
	if (renderType === 2)
	{
		selCandidates = magoManager.selectionManager;
		selectionColor = magoManager.selectionColor;
		renderTexture = false; // reassign value for this var.
		currentNode = currentObjectsRendering.curNode;
		currentOctree = currentObjectsRendering.curOctree;
	}
	
	var renderTexture = true;
	
	// if the building is highlighted, the use highlight oneColor4.
	if (renderType === 1)
	{
		gl.uniform4fv(shader.oneColor4_loc, [0.7, 0.7, 0.7, 1.0]);
		if (this.isHighLighted)
		{
			//gl.uniform1i(shader.bUse1Color_loc, true);
			gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
			gl.uniform4fv(shader.oneColor4_loc, this.highLightColor4); //.
			renderTexture = false;
		}
		else if (this.isColorChanged)
		{
			//gl.uniform1i(shader.bUse1Color_loc, true);
			gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
			gl.uniform4fv(shader.oneColor4_loc, [this.aditionalColor.r, this.aditionalColor.g, this.aditionalColor.b, this.aditionalColor.a]); //.
			renderTexture = false;
		}

		//----------------------------------------------------------------------------------
		if (renderTexture)
		{
			if (skinLego.texture !== undefined && skinLego.texture.texId)
			{
				
				shader.enableVertexAttribArray(shader.texCoord2_loc);
				gl.uniform1i(shader.colorType_loc, 2); // 0= oneColor, 1= attribColor, 2= texture.
				if (shader.last_tex_id !== skinLego.texture.texId)
				{
					gl.activeTexture(gl.TEXTURE2);
					gl.bindTexture(gl.TEXTURE_2D, skinLego.texture.texId);
					shader.last_tex_id = skinLego.texture.texId;
				}
			}
			else 
			{
				//return;
				if (magoManager.textureAux_1x1 !== undefined)
				{
					shader.enableVertexAttribArray(shader.texCoord2_loc);
					gl.uniform1i(shader.colorType_loc, 2); // 0= oneColor, 1= attribColor, 2= texture.
					gl.activeTexture(gl.TEXTURE2);
					gl.bindTexture(gl.TEXTURE_2D, magoManager.textureAux_1x1);
				}
				else 
				{
					gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
				}
			}
		}
	}
	else if (renderType === 2)
	{
		// Color selction mode.
		var colorAux;
		colorAux = magoManager.selectionColor.getAvailableColor(colorAux);
		var idxKey = magoManager.selectionColor.decodeColor3(colorAux.r, colorAux.g, colorAux.b);
		magoManager.selectionManager.setCandidates(idxKey, undefined, undefined, this, currentNode);
		
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
		gl.uniform4fv(shader.oneColor4_loc, [colorAux.r/255.0, colorAux.g/255.0, colorAux.b/255.0, 1.0]);
	}
	else if (renderType === 3)
	{
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
		gl.uniform4fv(shader.oneColor4_loc, [0.7, 0.7, 0.7, 1.0]);

	}
	
	gl.uniform1i(shader.refMatrixType_loc, 0); // in this case, there are not referencesMatrix.
	skinLego.render(magoManager, renderType, renderTexture, shader, this);
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoBuilding.prototype.renderSkin__original = function(magoManager, shader, renderType) 
{
	var skinLego = this.getCurrentSkin();
		
	if (skinLego === undefined)
	{ return; }

	if (skinLego.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED)
	{ return; }

	var gl = magoManager.sceneState.gl;
	
	magoManager.renderer.currentObjectsRendering.curOctree = this;
	
	var currentObjectsRendering = magoManager.renderer.currentObjectsRendering;
	var selCandidates;
	var selectionColor;
	var currentNode;
	var currentOctree;
	
	if (renderType === 2)
	{
		selCandidates = magoManager.selectionManager;
		selectionColor = magoManager.selectionColor;
		renderTexture = false; // reassign value for this var.
		currentNode = currentObjectsRendering.curNode;
		currentOctree = currentObjectsRendering.curOctree;
	}
	
	var renderTexture = true;
	
	// if the building is highlighted, the use highlight oneColor4.
	if (renderType === 1)
	{
		gl.uniform4fv(shader.oneColor4_loc, [0.7, 0.7, 0.7, 1.0]);
		if (this.isHighLighted)
		{
			//gl.uniform1i(shader.bUse1Color_loc, true);
			gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
			gl.uniform4fv(shader.oneColor4_loc, this.highLightColor4); //.
			renderTexture = false;
		}
		else if (this.isColorChanged)
		{
			//gl.uniform1i(shader.bUse1Color_loc, true);
			gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
			gl.uniform4fv(shader.oneColor4_loc, [this.aditionalColor.r, this.aditionalColor.g, this.aditionalColor.b, this.aditionalColor.a]); //.
			renderTexture = false;
		}
		else
		{
			//gl.uniform1i(shader.bUse1Color_loc, false);
		}
		//----------------------------------------------------------------------------------
		if (renderTexture)
		{
			if (skinLego.texture !== undefined && skinLego.texture.texId)
			{
				
				shader.enableVertexAttribArray(shader.texCoord2_loc);
				gl.uniform1i(shader.colorType_loc, 2); // 0= oneColor, 1= attribColor, 2= texture.
				if (shader.last_tex_id !== skinLego.texture.texId)
				{
					gl.activeTexture(gl.TEXTURE2);
					gl.bindTexture(gl.TEXTURE_2D, skinLego.texture.texId);
					shader.last_tex_id = skinLego.texture.texId;
				}
			}
			else 
			{
				//return;
				if (magoManager.textureAux_1x1 !== undefined)
				{
					shader.enableVertexAttribArray(shader.texCoord2_loc);
					gl.uniform1i(shader.colorType_loc, 2); // 0= oneColor, 1= attribColor, 2= texture.
					gl.activeTexture(gl.TEXTURE2);
					gl.bindTexture(gl.TEXTURE_2D, magoManager.textureAux_1x1);
				}
				else 
				{
					gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
				}
			}
		}
	}
	else if (renderType === 2)
	{
		// Color selction mode.
		var colorAux;
		colorAux = magoManager.selectionColor.getAvailableColor(colorAux);
		var idxKey = magoManager.selectionColor.decodeColor3(colorAux.r, colorAux.g, colorAux.b);
		magoManager.selectionManager.setCandidates(idxKey, undefined, undefined, this, currentNode);
		
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
		gl.uniform4fv(shader.oneColor4_loc, [colorAux.r/255.0, colorAux.g/255.0, colorAux.b/255.0, 1.0]);
	}
	
	gl.uniform1i(shader.refMatrixType_loc, 0); // in this case, there are not referencesMatrix.
	skinLego.render(magoManager, renderType, renderTexture, shader);
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoBuilding.prototype.renderDetailed = function(magoManager, shader, renderType, refMatrixIdxKey, flipYTexCoord) 
{	
	var octreesRenderedCount = 0;
	if (this.currentVisibleOctreesControler === undefined)
	{ return octreesRenderedCount; }
	
	var renderTexture = false;	
	var gl = magoManager.sceneState.gl;
	
	if (renderType === 0)
	{
		renderTexture = false;
	}
	else if (renderType === 1)
	{
		if (this.texturesLoaded && this.texturesLoaded.length>0)
		{
			renderTexture = true;
		}
		else { renderTexture = false; }
	}
	//else if (renderType === 2) // No need to do any function.
	
	// set the currentObjectsRendering.
	magoManager.renderer.currentObjectsRendering.curBuilding = this;
	
	var lowestOctree;
	var refMatrixIdxKey = 0;
	var isInterior = false; // old var.
	
	var applyOcclusionCulling = this.getRenderSettingApplyOcclusionCulling();
	if (applyOcclusionCulling === undefined)
	{ applyOcclusionCulling = true; }
	
	var relCamPosX, relCamPosY, relCamPosZ; 
	if (applyOcclusionCulling)
	{
		relCamPosX = this.myCameraRelative.position.x;
		relCamPosY = this.myCameraRelative.position.y;
		relCamPosZ = this.myCameraRelative.position.z;
	}
	
	if (this.buildingId === "gangnam_del")
	{ var hola = 0; }
	
	// LOD0.
	var minSize = 0.0;
	var lowestOctreesCount = this.currentVisibleOctreesControler.currentVisibles0.length;
	for (var j=0; j<lowestOctreesCount; j++) 
	{
		lowestOctree = this.currentVisibleOctreesControler.currentVisibles0[j];
		if (lowestOctree.neoReferencesMotherAndIndices === undefined) 
		{ continue; }
		
		lowestOctree.neoReferencesMotherAndIndices.updateCurrentVisibleIndices(relCamPosX, relCamPosY, relCamPosZ, applyOcclusionCulling);
		
		lowestOctree.lod = 0; // set current lod to octree.
		if (lowestOctree.renderContent(magoManager, this, renderType, renderTexture, shader, minSize, refMatrixIdxKey, flipYTexCoord))
		{ octreesRenderedCount++; }
	}
	
	// LOD1.
	minSize = 0.45;
	lowestOctreesCount = this.currentVisibleOctreesControler.currentVisibles1.length;
	for (var j=0; j<lowestOctreesCount; j++) 
	{
		lowestOctree = this.currentVisibleOctreesControler.currentVisibles1[j];
		if (lowestOctree.neoReferencesMotherAndIndices === undefined) 
		{ continue; }
	
		lowestOctree.neoReferencesMotherAndIndices.updateCurrentVisibleIndices(relCamPosX, relCamPosY, relCamPosZ, applyOcclusionCulling);
		
		lowestOctree.lod = 1; // set current lod to octree.
		if (lowestOctree.renderContent(magoManager, this, renderType, renderTexture, shader, minSize, refMatrixIdxKey, flipYTexCoord))
		{ octreesRenderedCount++; }
	}
	
	// LOD2.
	shader.disableVertexAttribArray(shader.color4_loc);
	lowestOctreesCount = this.currentVisibleOctreesControler.currentVisibles2.length;
	for (var j=0; j<lowestOctreesCount; j++) 
	{
		// Render the lowestOctree.lego.
		lowestOctree = this.currentVisibleOctreesControler.currentVisibles2[j];
		if (lowestOctree.lego === undefined) 
		{ continue; }
		
		lowestOctree.lod = 2; // set current lod to octree.
		if (lowestOctree.renderContent(magoManager, this, renderType, renderTexture, shader, minSize, refMatrixIdxKey, flipYTexCoord))
		{ octreesRenderedCount++; }
	}
	
	return octreesRenderedCount;
};






































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class NeoBuildingsList
 */
var NeoBuildingsList = function() 
{
	if (!(this instanceof NeoBuildingsList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	//Array.apply(this, arguments);

	this.neoBuildingsArray = [];
};
//NeoBuildingsList.prototype = Object.create(Array.prototype);

/**
 * 어떤 일을 하고 있습니까?
 * @returns neoBuilding
 */
NeoBuildingsList.prototype.newNeoBuilding = function() 
{
	var neoBuilding = new NeoBuilding();
	this.neoBuildingsArray.push(neoBuilding);
	return neoBuilding;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns neoBuilding
 */
NeoBuildingsList.prototype.getNeoBuildingByTypeId = function(buildingType, buildingId) 
{
	var resultBuilding;
	var buildingsCount = this.neoBuildingsArray.length;
	var found = false;
	var i=0;
	while (!found && i < buildingsCount)
	{
		if (this.neoBuildingsArray[i].buildingType === buildingType && this.neoBuildingsArray[i].buildingId === buildingId)
		{
			found = true;
			resultBuilding = this.neoBuildingsArray[i];
		}
		i++;
	}

	return resultBuilding;
};


NeoBuildingsList.prototype.get = function (index)
{
	return this.neoBuildingsArray[index];
};

NeoBuildingsList.prototype.add = function (item)
{
	if (item !== undefined)	{ this.neoBuildingsArray.push(item); }
};
'use strict';

/**
 * Reference 파일에 대한 객체
 * lod1일 경우 model과 Reference파일을 참조.
 * 
 * Geometry object. The real geometry data is a model, and this referenceObject has the model's index.
 * 
 * @class NeoReference
 * 
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * 아래 문서 1.4 Reference Folder 참조
 * @link https://github.com/Gaia3D/F4DConverter/blob/master/doc/F4D_SpecificationV1.pdf
 */
var NeoReference = function() 
{
	if (!(this instanceof NeoReference)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * The object's index on motherReferenceArray.
	 * @type {Number}
	 * @default 0
	 */
	this._id = 0;

	/**
	 * The object's identifier.
	 * @type {String}
	 * @default ""
	 */
	this.objectId = "";

	/**
	 * The model's index.
	 * @type {Number}
	 * @default -1
	 */
	this._block_idx = -1;
	
	/**
	 * The model-reference transformation matrix.(do not modify).
	 * @type {Matrix4}
	 * @default Identity matrix
	 */
	this._originalMatrix4 = new Matrix4(); 

	/**
	 * The final transformation matrix. Is calculated by multiplication between model-reference-matrix and building-matrix.
	 * @type {Matrix4}
	 * @default Identity matrix
	 */
	this._matrix4 = new Matrix4(); 
	
	/**
	 * Array used to store finalTransformationMatrices, chronological transformations, or two positions mode for example.
	 * @type {Array}
	 * @default undefined
	 */
	this.tMatrixAuxArray; 
	
	/**
	 * Parameter that specifies the type of the transformation matrix. 0 = identity matrix, 1 = translation matrix, 2 = transformation matrix.
	 * @type {Number}
	 * @default 2
	 */
	this.refMatrixType = 2; 
	
	/**
	 * Position vector of the translation matrix. Use this if "refMatrixType" = 1.
	 * @type {Float32Array(3)}
	 * @default undefined
	 */
	this.refTranslationVec; 
	
	/**
	 * VBOs container.
	 * @type {VBOVertexIdxCacheKeysContainer}
	 * @default undefined
	 */
	this.vBOVertexIdxCacheKeysContainer; 

	/**
	 * Material index.
	 * @type {Number}
	 * @default undefined
	 */
	this.materialId;
	
	/**
	 * Parameter that indicates if this object has texture.
	 * @type {Boolean}
	 * @default false
	 */
	this.hasTexture = false;
	
	/**
	 * Texture object.
	 * @type {Texture}
	 * @default undefined
	 */
	this.texture; 

	/**
	 * Object's color if has not texture.
	 * @type {Color}
	 * @default undefined
	 */
	this.color4; 
	
	/**
	 * Object's aditional color. Used when object color was changed.
	 * @type {Color}
	 * @default undefined
	 */
	this.aditionalColor; 

	/**
	 * Object's movement vector in local coordinates.
	 * @type {Point3D}
	 * @default undefined
	 */
	this.moveVectorRelToBuilding; 
	
	/**
	 * Object's movement vector in world coordinates.
	 * @type {Point3D}
	 * @default undefined
	 */
	this.moveVector; 

	/**
	 * Object's current rendering phase. Parameter to avoid duplicated render on scene.
	 * @type {Boolean}
	 * @default false
	 */
	this.renderingFase = false;
	
	/**
	 * Object's translucent alpha. Used when born the reference object until adult.
	 * @type {Number}
	 * @default false
	 */
	this.blendAlpha = 0.0;
	
	/**
	 * Object's born date.
	 * @type {Number}
	 * @default undefined
	 */
	this.birthTime;
	
	/**
	 * Parameter that indicates if the object is adult. If is adult, then do no apply blendAlpha.
	 * @type {Number}
	 * @default undefined
	 */
	this.isAdult = false;
};

/**
 * Commutate the renderingFase value: true - false.
 */
NeoReference.prototype.swapRenderingFase = function() 
{
	this.renderingFase = !this.renderingFase;
};

/**
 * Returns the blending alpha value in current time.
 * 
 * @param {Number} currTime The current time.
 */
NeoReference.prototype.getBlendAlpha = function(currTime) 
{
	if (!this.isAdult)
	{
		if (this.birthTime === undefined)
		{ this.birthTime = currTime; }
	
		if (this.blendAlpha === undefined)
		{ this.blendAlpha = 0.0; }
		
		var increAlpha = (currTime - this.birthTime)*0.0001;
		this.blendAlpha += increAlpha;
		
		if (this.blendAlpha >= 1.0)
		{
			this.isAdult = true;
		}
	}
	else
	{ return 1.0; }
	
	return this.blendAlpha;
};

/**
 * _originalMatrix4와 파라미터로 받은 matrix를 4차원 행렬의 곱셈을 계산한 결과를 _matrix4에 할당
 * 
 * @param {Matrix4} matrix
 */
NeoReference.prototype.multiplyTransformMatrix = function(matrix) 
{
	this._matrix4 = this._originalMatrix4.getMultipliedByMatrix(matrix); // Original.
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoReference.prototype.multiplyKeyTransformMatrix = function(idxKey, matrix) 
{
	// this function multiplies the originalMatrix by "matrix" and stores it in the "idxKey" position.
	if (this.tMatrixAuxArray === undefined)
	{ this.tMatrixAuxArray = []; }

	this.tMatrixAuxArray[idxKey] = this._originalMatrix4.getMultipliedByMatrix(matrix, this.tMatrixAuxArray[idxKey]);
	
	if (this.moveVectorRelToBuilding)
	{
		this.moveVector = matrix.rotatePoint3D(this.moveVectorRelToBuilding, this.moveVector); 
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoReference.prototype.hasKeyMatrix = function(idxKey) 
{
	if (this.tMatrixAuxArray === undefined)
	{ return false; }

	if (this.tMatrixAuxArray[idxKey] === undefined)
	{ return false; }
	else
	{ return true; }
};

/**{Boolean}
 * 어떤 일을 하고 있습니까?
 * 
  * @returns {Boolean} returns if the neoReference is ready to render.
 */
NeoReference.prototype.isReadyToRender = function() 
{
	if (this.tMatrixAuxArray === undefined)
	{
		//this.multiplyKeyTransformMatrix(refMatrixIdxKey, neoBuilding.geoLocationDataAux.rotMatrix);
		// we must collect all the neoReferences that has no tMatrixAuxArray and make it.
		return false;
	}
	
	return true;
};

/**
 * Renders the content.
 */
NeoReference.prototype.solveReferenceColorOrTexture = function(magoManager, neoBuilding, shader, currentObjectsRendering) 
{
	var gl = magoManager.sceneState.gl;
	
	// Check if we are under a selected data structure.
	var selectionManager = magoManager.selectionManager;
	var referenceObjectIsSelected = false;
	if (selectionManager.parentSelected && magoManager.objectSelected === this)
	{
		referenceObjectIsSelected = true;
	}
	
	// Check the color or texture of reference object.
	if (neoBuilding.isHighLighted)
	{
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
		gl.uniform4fv(shader.oneColor4_loc, magoManager.highLightColor4);
	}
	else if (neoBuilding.isColorChanged)
	{
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
		//if (referenceObjectIsSelected) 
		//{
		//	gl.uniform4fv(shader.oneColor4_loc, [255.0/255.0, 0/255.0, 0/255.0, 255.0/255.0]);
		//}
		//else
		//{
		//	gl.uniform4fv(shader.oneColor4_loc, [neoBuilding.aditionalColor.r, neoBuilding.aditionalColor.g, neoBuilding.aditionalColor.b, neoBuilding.aditionalColor.a] );
		//}
		gl.uniform4fv(shader.oneColor4_loc, [neoBuilding.aditionalColor.r, neoBuilding.aditionalColor.g, neoBuilding.aditionalColor.b, neoBuilding.aditionalColor.a] );
	}
	else if (this.aditionalColor)
	{
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
		//if (referenceObjectIsSelected) 
		//{
		//	gl.uniform4fv(shader.oneColor4_loc, [255.0/255.0, 0/255.0, 0/255.0, 255.0/255.0]);
		//}
		//else
		//{
		//	gl.uniform4fv(shader.oneColor4_loc, [this.aditionalColor.r, this.aditionalColor.g, this.aditionalColor.b, this.aditionalColor.a] );
		//}
		gl.uniform4fv(shader.oneColor4_loc, [this.aditionalColor.r, this.aditionalColor.g, this.aditionalColor.b, this.aditionalColor.a] );
	}
	else
	{
		// Normal rendering.
		if (magoManager.magoPolicy.getObjectMoveMode() === CODE.moveMode.OBJECT && referenceObjectIsSelected) 
		{
			gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
			gl.uniform4fv(shader.oneColor4_loc, [255.0/255.0, 0/255.0, 0/255.0, 255.0/255.0]);
		}
		else if (magoManager.magoPolicy.colorChangedObjectId === this.objectId)
		{
			gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
			gl.uniform4fv(shader.oneColor4_loc, [magoManager.magoPolicy.color[0], magoManager.magoPolicy.color[1], magoManager.magoPolicy.color[2], 1.0]);
		}
		else
		{
			if (this.hasTexture) 
			{
				if (this.texture !== undefined && this.texture.texId !== undefined) 
				{
					gl.uniform1i(shader.colorType_loc, 2); // 0= oneColor, 1= attribColor, 2= texture.
					if (shader.last_tex_id !== this.texture.texId) 
					{
						gl.activeTexture(gl.TEXTURE2);
						gl.bindTexture(gl.TEXTURE_2D, this.texture.texId);
						shader.last_tex_id = this.texture.texId;
					}
				}
				else 
				{
					gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
					gl.uniform4fv(shader.oneColor4_loc, [0.8, 0.0, 0.8, 1.0]);
				}
			}
			else 
			{
				// if no render texture, then use a color.
				gl.uniform1i(shader.bUse1Color_loc, true); //.
				if (this.color4) 
				{
					gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
					gl.uniform4fv(shader.oneColor4_loc, [this.color4.r/255.0, this.color4.g/255.0, this.color4.b/255.0, this.color4.a/255.0]);
				}
				else
				{
					gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
					gl.uniform4fv(shader.oneColor4_loc, [0.8, 0.8, 0.8, 1.0]);
				}
			}
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * 
 * @param mag{Boolean}
 * @returns {Boolean} returns if the neoReference was rendered.
 */
NeoReference.prototype.getTriangles = function(neoBuilding, resultTrianglesArray) 
{
	if (neoBuilding === undefined || neoBuilding.motherBlocksArray === undefined)
	{ return motherBlocksArray; }
	
	if (resultTrianglesArray === undefined)
	{ resultTrianglesArray = []; }
	
	var neoReference = this;
	var block_idx = neoReference._block_idx;
	var block = neoBuilding.motherBlocksArray[block_idx];
	if (!block) 
	{
		return resultTrianglesArray;
	}
	var cacheKeys_count = block.vBOVertexIdxCacheKeysContainer.vboCacheKeysArray.length;
	var refTMat = neoReference._originalMatrix4;
	var vboKey;
	var vertexMap = {};
	
	for (var n=0; n<cacheKeys_count; n++) // Original.
	{
		vboKey = block.vBOVertexIdxCacheKeysContainer.vboCacheKeysArray[n];

		var posArray = vboKey.keepedPosDataArray;
		if (posArray === undefined)
		{ return resultTrianglesArray; }
		
		var positionsCount = posArray.length/3;
		
		var idxArray = vboKey.keepedIdxDataArray;
		var indicesCount = idxArray.length;
		
		var trianglesCount = indicesCount/3;
		
		for (var i=0; i<trianglesCount; i++)
		{
			var idx_1 = idxArray[i*3];
			var idx_2 = idxArray[i*3+1];
			var idx_3 = idxArray[i*3+2];
			
			var vertex_1 = vertexMap[idx_1];
			if (vertex_1 === undefined)
			{
				var pos_1 = new Point3D(posArray[idx_1*3], posArray[idx_1*3+1], posArray[idx_1*3+2]);
				//Parameter that specifies the type of the transformation matrix. 0 = identity matrix, 1 = translation matrix, 2 = transformation matrix.
				if (neoReference.refMatrixType === 1)
				{
					pos_1.add(neoReference.refTranslationVec[0], neoReference.refTranslationVec[1], neoReference.refTranslationVec[2]);
				}
				else if (neoReference.refMatrixType === 2)
				{
					// Now, transform points with refTMat (reference transformation matrix).
					pos_1 = refTMat.transformPoint3D(pos_1, pos_1);
				}
				
				vertex_1 = new Vertex(pos_1);
				vertexMap[idx_1] = vertex_1;
			}
			
			var vertex_2 = vertexMap[idx_2];
			if (vertex_2 === undefined)
			{
				var pos_2 = new Point3D(posArray[idx_2*3], posArray[idx_2*3+1], posArray[idx_2*3+2]);
				//Parameter that specifies the type of the transformation matrix. 0 = identity matrix, 1 = translation matrix, 2 = transformation matrix.
				if (neoReference.refMatrixType === 1)
				{
					pos_2.add(neoReference.refTranslationVec[0], neoReference.refTranslationVec[1], neoReference.refTranslationVec[2]);
				}
				else if (neoReference.refMatrixType === 2)
				{
					// Now, transform points with refTMat (reference transformation matrix).
					pos_2 = refTMat.transformPoint3D(pos_2, pos_2);
				}
				vertex_2 = new Vertex(pos_2);
				vertexMap[idx_2] = vertex_2;
			}
			
			var vertex_3 = vertexMap[idx_3];
			if (vertex_3 === undefined)
			{
				var pos_3 = new Point3D(posArray[idx_3*3], posArray[idx_3*3+1], posArray[idx_3*3+2]);
				//Parameter that specifies the type of the transformation matrix. 0 = identity matrix, 1 = translation matrix, 2 = transformation matrix.
				if (neoReference.refMatrixType === 1)
				{
					pos_3.add(neoReference.refTranslationVec[0], neoReference.refTranslationVec[1], neoReference.refTranslationVec[2]);
				}
				else if (neoReference.refMatrixType === 2)
				{
					// Now, transform points with refTMat (reference transformation matrix).
					pos_3 = refTMat.transformPoint3D(pos_3, pos_3);
				}
				vertex_3 = new Vertex(pos_3);
				vertexMap[idx_3] = vertex_3;
			}
			
			var triangle = new Triangle(vertex_1, vertex_2, vertex_3);
			resultTrianglesArray.push(triangle);
		}
	}
	return resultTrianglesArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * 
 * @param mag{Boolean}
 * @returns {Boolean} returns if the neoReference was rendered.
 */
NeoReference.prototype.render = function(magoManager, neoBuilding, renderType, renderTexture, shader, refMatrixIdxKey, minSizeToRender) 
{
	var neoReference = this;
	
	if (!neoReference.isReadyToRender())
	{ return false; }

	// Check if the texture is loaded.
	//if (neoReference.texture !== undefined || neoReference.materialId != -1)
	if (neoReference.hasTexture)// && neoReference.texture !== undefined)
	{
		// note: in the future use only "neoReference.materialId".
		var texFileLoadState = neoBuilding.manageNeoReferenceTexture(neoReference, magoManager);
		if (texFileLoadState !== CODE.fileLoadState.LOADING_FINISHED)
		{ return false; }
	
		if (neoReference.texture === undefined)
		{ return false; }
	
		if (neoReference.texture.texId === undefined)
		{ return false; }
	}
	
	var currentObjectsRendering = magoManager.renderer.currentObjectsRendering;
	var selectionManager;
	var selectionColor;
	var currentNode;
	var currentOctree;
	
	if (renderType === 2)
	{
		selectionManager = magoManager.selectionManager;
		selectionColor = magoManager.selectionColor;
		renderTexture = false; // reassign value for this var.
		currentNode = currentObjectsRendering.curNode;
		currentOctree = currentObjectsRendering.curOctree;
	}
	
	var gl = magoManager.sceneState.gl;
	
	var block_idx = neoReference._block_idx;
	var block = neoBuilding.motherBlocksArray[block_idx];
	
	if (block === undefined)
	{ return false; }
	
	if (magoManager.mouseLeftDown || magoManager.mouseMiddleDown)
	{ minSizeToRender = 0.5; }
	
	// If colorCodeRendering, then must render all objects, without filtering by size.
	if (magoManager.currentProcess !== CODE.magoCurrentProcess.ColorCodeRendering)// && !block.isReadyToRender(neoReference, magoManager, minSizeToRender))
	{ 
		if (!block.isReadyToRender(neoReference, magoManager, minSizeToRender))
		{
			if (magoManager.objectSelected !== neoReference)
			{ return false; } 
		}
	}

	// Check the color or texture of reference object.
	if (renderType === 1)
	{
		neoReference.solveReferenceColorOrTexture(magoManager, neoBuilding, shader, currentObjectsRendering);
	}
	else if (renderType === 2)
	{
		neoReference.selColor4 = selectionColor.getAvailableColor(neoReference.selColor4); 
		var idxKey = selectionColor.decodeColor3(neoReference.selColor4.r, neoReference.selColor4.g, neoReference.selColor4.b);

		selectionManager.setCandidates(idxKey, neoReference, currentOctree, neoBuilding, currentNode);
		if (neoReference.selColor4) 
		{
			gl.uniform4fv(shader.oneColor4_loc, [neoReference.selColor4.r/255.0, neoReference.selColor4.g/255.0, neoReference.selColor4.b/255.0, 1.0]);
		}
	}
	// End check color or texture of reference object.-----------------------------------------------------------------------------
	
	//Now erase the aditional information (aditionalColor & moveVector).
	this.aditionalColor = undefined; // Is needed when use static objects.
	
	// Test external alpha.
	if (magoManager.isTrailRender === undefined || magoManager.isTrailRender === false) // check if mago is not rendering special effects.
	{
		var blendAlpha = neoReference.getBlendAlpha(magoManager.currTime);
		gl.uniform1f(shader.externalAlpha_loc, blendAlpha);
	}
	
	// End test.---
	
	var cacheKeys_count = block.vBOVertexIdxCacheKeysContainer.vboCacheKeysArray.length;
	// Must applicate the transformMatrix of the reference object.

	gl.uniform1i(shader.refMatrixType_loc, neoReference.refMatrixType);

	if (neoReference.refMatrixType === 1)
	{ gl.uniform3fv(shader.refTranslationVec_loc, neoReference.refTranslationVec); }
	else if (neoReference.refMatrixType === 2)
	{ gl.uniformMatrix4fv(shader.refMatrix_loc, false, neoReference.tMatrixAuxArray[refMatrixIdxKey]._floatArrays); }
	

	if (neoReference.moveVector !== undefined) 
	{
		gl.uniform1i(shader.hasAditionalMov_loc, true);
		gl.uniform3fv(shader.aditionalMov_loc, [neoReference.moveVector.x, neoReference.moveVector.y, neoReference.moveVector.z]); //.
		shader.last_isAditionalMovedZero = false;
	}
	else 
	{
		if (!shader.last_isAditionalMovedZero)
		{
			gl.uniform1i(shader.hasAditionalMov_loc, false);
			gl.uniform3fv(shader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.
			shader.last_isAditionalMovedZero = true;
		}
	}
	
	var vboKey;
	for (var n=0; n<cacheKeys_count; n++) // Original.
	{
		//var mesh_array = block.viArraysContainer._meshaderrays[n];
		vboKey = block.vBOVertexIdxCacheKeysContainer.vboCacheKeysArray[n];
		
		// Positions.
		if (!vboKey.bindDataPosition(shader, magoManager.vboMemoryManager))
		{ return false; }

		if (renderType === 1)
		{
			// Normals.
			if (!vboKey.bindDataNormal(shader, magoManager.vboMemoryManager))
			{ return false; }

			// TexCoords.
			if (renderTexture && neoReference.hasTexture) 
			{
				if (block.vertexCount <= neoReference.vertexCount) 
				{
					var refVboData = neoReference.vBOVertexIdxCacheKeysContainer.vboCacheKeysArray[n];
					if (!refVboData.bindDataTexCoord(shader, magoManager.vboMemoryManager))
					{ return false; }
				}
				else 
				{
					shader.disableVertexAttribArray(shader.texCoord2_loc); 
				}
			}
			else 
			{
				shader.disableVertexAttribArray(shader.texCoord2_loc); 
			}
		}

		// Indices.
		var indicesCount;
		if (magoManager.isCameraMoving)// && !isInterior && magoManager.isCameraInsideBuilding)
		{
			indicesCount = vboKey.indicesCount;
		}
		else
		{
			if (magoManager.thereAreUrgentOctrees)
			{
				indicesCount = vboKey.bigTrianglesIndicesCount;
				if (indicesCount > vboKey.indicesCount)
				{ indicesCount = vboKey.indicesCount; }
			}
			else 
			{
				indicesCount = vboKey.indicesCount;
			}
		}
		if (!vboKey.bindDataIndice(shader, magoManager.vboMemoryManager))
		{ return false; }
		gl.drawElements(gl.TRIANGLES, indicesCount, gl.UNSIGNED_SHORT, 0); // Fill.
		
		if (renderType === 1)
		{
			// some stadistics.
			magoManager.sceneState.trianglesRenderedCount += indicesCount/3;
		}
	}
		
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 */
NeoReference.prototype.deleteObjects = function(gl, vboMemManager) 
{
	// 1) Object ID.
	this._id = undefined;

	// 2) Block Idx.
	this._block_idx = undefined;

	// 3) Transformation Matrix.
	this._matrix4._floatArrays = undefined;
	this._matrix4 = undefined;
	this._originalMatrix4._floatArrays = undefined;
	this._originalMatrix4 = undefined; //

	// 5) The texture image.
	this.hasTexture = undefined;
	// no delete the texture, only break the referencing.
	this.texture = undefined; // Texture

	// 6) 1 color.
	if (this.color4)
	{ this.color4.deleteObjects(); }
	this.color4 = undefined; //new Color();

	// 7) selection color.
	if (this.selColor4)
	{ this.selColor4.deleteObjects(); }
	this.selColor4 = undefined; //new Color(); // use for selection only.

	// 8) movement of the object.
	if (this.moveVector)
	{ this.moveVector.deleteObjects(); }
	this.moveVector = undefined; // Point3D.

	this.bRendered = undefined;
	
	if (this.vBOVertexIdxCacheKeysContainer !== undefined)
	{
		this.vBOVertexIdxCacheKeysContainer.deleteGlObjects(gl, vboMemManager);
		this.vBOVertexIdxCacheKeysContainer = undefined;
	}
};

'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class NeoReferencesMotherAndIndices
 */
var NeoReferencesMotherAndIndices = function() 
{
	if (!(this instanceof NeoReferencesMotherAndIndices)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.motherNeoRefsList; // this is a NeoReferencesList pointer.
	this.neoRefsIndices = []; // All objects(references) of this class.
	this.modelReferencedGroupsList; // (for new format. No used yet).
	this.blocksList;

	this.fileLoadState = 0; // init as "READY".
	this.dataArraybuffer;
	this.succesfullyGpuDataBinded;

	this.exterior_ocCullOctree; // octree that contains the visible indices.
	this.interior_ocCullOctree; // octree that contains the visible indices.
	
	this.currentVisibleIndices = [];
	this.currentVisibleMRG; // MRG = ModelReferencedGroup (for new format).
	this.xhr;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param matrix 변수
 */
NeoReferencesMotherAndIndices.prototype.multiplyKeyTransformMatrix = function(idxKey, matrix) 
{
	var refIndicesCount = this.neoRefsIndices.length;
	var reference;
	for (var i=0; i<refIndicesCount; i++)
	{
		reference = this.motherNeoRefsList[this.neoRefsIndices[i]];
		if (reference)
		{ reference.multiplyKeyTransformMatrix(idxKey, matrix); }
	}
};

NeoReferencesMotherAndIndices.prototype.updateCurrentVisibleIndices = function(eye_x, eye_y, eye_z, applyOcclusionCulling) 
{
	if (applyOcclusionCulling === undefined)
	{ applyOcclusionCulling = true; }

	// check if is interior.
	var isExterior = false;
	if (this.interior_ocCullOctree !== undefined)
	{
		var thisHasOcCullData = false;
		if (this.interior_ocCullOctree._subBoxesArray && this.interior_ocCullOctree._subBoxesArray.length > 0)
		{ thisHasOcCullData = true; }
	
		if (thisHasOcCullData && applyOcclusionCulling)
		{
			//if (this.currentVisibleMRG === undefined)
			//{ this.currentVisibleMRG = new ModelReferencedGroupsList(); }
			
			var intersectedSubBox = this.interior_ocCullOctree.getIntersectedSubBoxByPoint3D(eye_x, eye_y, eye_z);
			if (intersectedSubBox !== undefined && intersectedSubBox._indicesArray.length > 0) 
			{
				this.currentVisibleIndices = intersectedSubBox._indicesArray;
				//if (result_modelReferencedGroup)
				//{
				//	result_modelReferencedGroup = this.modelReferencedGroupsList;
				//}
				isExterior = false;
			}
			else 
			{
				isExterior = true;
			}
		}
		else
		{
			// In this case there are no occlusionCulling data.
			this.currentVisibleIndices = this.neoRefsIndices;
			this.currentVisibleMRG = this.modelReferencedGroupsList;
		}
	}
	
	if (isExterior)
	{
		if (this.exterior_ocCullOctree !== undefined)
		{
			var thisHasOcCullData = false;
			if (this.exterior_ocCullOctree._subBoxesArray && this.exterior_ocCullOctree._subBoxesArray.length > 0)
			{ thisHasOcCullData = true; }
		
			if (thisHasOcCullData && applyOcclusionCulling)
			{
				if (this.currentVisibleMRG === undefined)
				{ this.currentVisibleMRG = new ModelReferencedGroupsList(); }
				
				this.currentVisibleIndices = this.exterior_ocCullOctree.getIndicesVisiblesForEye(eye_x, eye_y, eye_z, this.currentVisibleIndices, this.currentVisibleMRG);
			}
			else 
			{
				// In this case there are no occlusionCulling data.
				this.currentVisibleIndices = this.neoRefsIndices;
				this.currentVisibleMRG = this.modelReferencedGroupsList;
			}
		}
	}
};

/**
 * Returns the neoReference
 * @param matrix 변수
 */
NeoReferencesMotherAndIndices.prototype.getNeoReference = function(idx) 
{
	return this.motherNeoRefsList[this.neoRefsIndices[idx]];
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
NeoReferencesMotherAndIndices.prototype.deleteObjects = function(gl, vboMemManager) 
{
	if (this.xhr !== undefined)
	{
		this.xhr.abort();
		this.xhr = undefined;
	}
	
	this.motherNeoRefsList = undefined; // this is a NeoReferencesList pointer.
	this.neoRefsIndices = undefined;
	
	if (this.blocksList !== undefined && this.blocksList.xhr !== undefined && this.fileLoadState !== CODE.fileLoadState.READY)
	{
		this.blocksList.xhr.abort();
		this.blocksList.xhr = undefined;
	}
	this.blocksList = undefined;

	this.fileLoadState = undefined;
	this.dataArraybuffer = undefined;

	this.exterior_ocCullOctree = undefined;
	this.interior_ocCullOctree = undefined;
};

/**
 * 어떤 일을 하고 있습니까?
  * @returns {Boolean} returns if the neoReferencesMotherAndIndices is ready to render.
 */
NeoReferencesMotherAndIndices.prototype.isReadyToRender = function() 
{
	if (this.neoRefsIndices === undefined || this.neoRefsIndices.length === 0) 
	{ return false; }

	if (this.blocksList === undefined)
	{ return false; }

	if (this.blocksList.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED) 
	{ return false; }

	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
NeoReferencesMotherAndIndices.prototype.setRenderedFalseToAllReferences = function() 
{
	var refIndicesCount = this.neoRefsIndices.length;
	for (var i=0; i<refIndicesCount; i++)
	{
		this.motherNeoRefsList[this.neoRefsIndices[i]].bRendered = false;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
NeoReferencesMotherAndIndices.prototype.createModelReferencedGroups = function() 
{
	// Group all the references that has the same model.
	if (this.neoRefsIndices === undefined)
	{ return; }
	
	if (this.modelReferencedGroupsList === undefined)
	{ this.modelReferencedGroupsList = new ModelReferencedGroupsList(); }

	this.modelReferencedGroupsList.createModelReferencedGroups(this.neoRefsIndices, this.motherNeoRefsList);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param arrayBuffer 변수
 * @param neoBuilding 변수
 * @param readWriter 변수
 */
NeoReferencesMotherAndIndices.prototype.parseArrayBufferReferencesVersioned = function(arrayBuffer, readWriter, neoBuilding, tMatrix4, magoManager) 
{
	this.fileLoadState = CODE.fileLoadState.PARSE_STARTED;
	
	var gl = magoManager.getGl();

	var startBuff;
	var endBuff;
	var bytes_readed = 0;
	var testIdentityMatsCount = 0;
	var stadistic_refMat_Identities_count = 0;
	var stadistic_refMat_Translates_count = 0;
	var stadistic_refMat_Transforms_count = 0;
	var vboMemManager = magoManager.vboMemoryManager;
	var classifiedTCoordByteSize = 0, classifiedColByteSize = 0;
	var colByteSize, tCoordByteSize;
	this.succesfullyGpuDataBinded = true;
	var translationX, translationY, translationZ;
	
	// read the version.
	var versionLength = 5;
	var version = String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+versionLength)));
	bytes_readed += versionLength;

	var neoRefsCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
	for (var i = 0; i < neoRefsCount; i++) 
	{
		var neoRef = new NeoReference();

		// 1) Id.
		var ref_ID =  readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		neoRef._id = ref_ID;

		this.motherNeoRefsList = neoBuilding.motherNeoReferencesArray;
		if (this.motherNeoRefsList[neoRef._id] !== undefined)
		{
			// pass this neoReference because exist in the motherNeoReferencesArray.
			neoRef = this.motherNeoRefsList[neoRef._id];
			if (this.neoRefsIndices === undefined)
			{ this.neoRefsIndices = []; }
			
			this.neoRefsIndices.push(neoRef._id);

			var objectIdLength = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed +=1;
			var objectId = String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+objectIdLength)));
			
			//neoRef.objectId = objectId;
			bytes_readed += objectIdLength;

			// 2) Block's Idx.
			var blockIdx =   readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

			// 3) Transform Matrix4.
			// in versioned mode read the matrixType first.
			var matrixType = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			if (matrixType === 0)
			{ 
				// do nothing.
			}
			else if (matrixType === 1)
			{
				// read the translation vector.
				bytes_readed += 4 * 3;
			}
			else if (matrixType === 2)
			{
				// read the transformation matrix.
				bytes_readed += 4 * 16;
			}

			// Float mode.**
			var has_1_color = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			if (has_1_color) 
			{
				// "type" : one of following
				// 5120 : signed byte, 5121 : unsigned byte, 5122 : signed short, 5123 : unsigned short, 5126 : float
				var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
				var dim = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

				var daya_bytes;
				if (data_type === 5121) { daya_bytes = 1; }

				var r = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var g = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var b = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var alfa = 255;

				if (dim === 4) 
				{
					alfa = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				}
			}
			
			var has_colors = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			var has_texCoords = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			
			if (has_colors || has_texCoords)
			{
				var vboDatasCount = readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				
				for (var j=0; j<vboDatasCount; j++)
				{
					if (has_colors)
					{
						var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
						var dim = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

						var daya_bytes; // (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
						if (data_type === 5120 || data_type === 5121) { daya_bytes = 1; }
						else if (data_type === 5122 || data_type === 5123) { daya_bytes = 2; }
						else if (data_type === 5126) { daya_bytes = 4; }
						
						var vertexCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
						var verticesFloatValuesCount = vertexCount * dim;
						startBuff = bytes_readed;
						endBuff = bytes_readed + daya_bytes * verticesFloatValuesCount; 
						bytes_readed += daya_bytes * verticesFloatValuesCount; // updating data.
					}
					
					if (has_texCoords)
					{
						var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
						
						var daya_bytes; // (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
						if (data_type === 5120 || data_type === 5121) { daya_bytes = 1; }
						else if (data_type === 5122 || data_type === 5123) { daya_bytes = 2; }
						else if (data_type === 5126) { daya_bytes = 4; }
						
						var vertexCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
						var verticesFloatValuesCount = vertexCount * 2; // 2 = dimension of texCoord.
						startBuff = bytes_readed;
						endBuff = bytes_readed + daya_bytes * verticesFloatValuesCount; 
						bytes_readed += daya_bytes * verticesFloatValuesCount;
					}
				}
			}
			
			// 4) short texcoords. OLD. Change this for Materials.
			var materialIdAux = readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			
			// do the stadistic recount.
			if (neoRef.refMatrixType === 0){ stadistic_refMat_Identities_count +=1; }
			if (neoRef.refMatrixType === 1){ stadistic_refMat_Translates_count +=1; }
			if (neoRef.refMatrixType === 2){ stadistic_refMat_Transforms_count +=1; }
		}
		else
		{
			
			if (this.neoRefsIndices === undefined)
			{ this.neoRefsIndices = []; }
			
			this.neoRefsIndices.push(neoRef._id);

			var objectIdLength = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed +=1;
			var objectId = String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+objectIdLength)));
			if (objectId === "noObjectId" || objectId.length === 0)
			{ objectId = neoRef._id.toString(); }
		
			neoRef.objectId = objectId;
			bytes_readed += objectIdLength;
			
			neoBuilding.putReferenceObject(neoRef, neoRef._id);

			// 2) Block's Idx.
			var blockIdx =   readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._block_idx = blockIdx;

			// 3) Transform Matrix4.
			neoRef.refMatrixType = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			if (neoRef.refMatrixType === 0)
			{ 
				// do nothing.
				stadistic_refMat_Identities_count +=1;
			}
			else if (neoRef.refMatrixType === 1)
			{
				// read the translation vector.
				translationX = readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				translationY = readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				translationZ = readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef.refTranslationVec = new Float32Array([translationX, translationY, translationZ]);
				
				stadistic_refMat_Translates_count +=1;
			}
			else if (neoRef.refMatrixType === 2)
			{
				// read the transformation matrix.
				neoRef._originalMatrix4._floatArrays[0] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[1] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[2] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[3] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

				neoRef._originalMatrix4._floatArrays[4] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[5] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[6] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[7] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

				neoRef._originalMatrix4._floatArrays[8] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[9] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[10] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[11] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

				neoRef._originalMatrix4._floatArrays[12] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[13] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[14] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				neoRef._originalMatrix4._floatArrays[15] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				
				stadistic_refMat_Transforms_count +=1;
			}

			// Float mode.**
			var has_1_color = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			if (has_1_color) 
			{
				// "type" : one of following
				// 5120 : signed byte, 5121 : unsigned byte, 5122 : signed short, 5123 : unsigned short, 5126 : float
				var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
				var dim = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

				var daya_bytes;
				if (data_type === 5121) { daya_bytes = 1; }

				var r = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var g = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var b = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var alfa = 255;

				if (dim === 4) 
				{
					alfa = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				}

				neoRef.color4 = new Color();
				neoRef.color4.set(r, g, b, alfa);
			}
			
			var has_colors = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			var has_texCoords = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			
			if (has_colors || has_texCoords)
			{
				var vboDatasCount = readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				
				if (vboDatasCount > 0)
				{
					if (neoRef.vBOVertexIdxCacheKeysContainer === undefined)
					{ neoRef.vBOVertexIdxCacheKeysContainer = new VBOVertexIdxCacheKeysContainer(); }
				}
				
				for (var j=0; j<vboDatasCount; j++)
				{
					var vboViCacheKey = neoRef.vBOVertexIdxCacheKeysContainer.newVBOVertexIdxCacheKey();
					
					if (has_colors)
					{
						var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
						var dim = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

						var daya_bytes; // (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
						if (data_type === 5120 || data_type === 5121) { daya_bytes = 1; }
						else if (data_type === 5122 || data_type === 5123) { daya_bytes = 2; }
						else if (data_type === 5126) { daya_bytes = 4; }
						
						var vertexCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
						var verticesFloatValuesCount = vertexCount * dim;
						//colByteSize = daya_bytes * verticesFloatValuesCount; // error...
						colByteSize = verticesFloatValuesCount;
						classifiedColByteSize = vboMemManager.getClassifiedBufferSize(colByteSize);
						
						neoRef.vertexCount = vertexCount; // no necessary.
						startBuff = bytes_readed;
						endBuff = bytes_readed + daya_bytes * verticesFloatValuesCount; 
						//vboViCacheKey.colVboDataArray = new Float32Array(arrayBuffer.slice(startBuff, endBuff)); // original.
						// TODO: Float32Array or UintArray depending of dataType.
						var colVboDataArray = new Float32Array(arrayBuffer.slice(startBuff, endBuff));
						vboViCacheKey.setDataArrayColor(colVboDataArray, vboMemManager);

						bytes_readed += daya_bytes * verticesFloatValuesCount; // updating data.
						
						// send data to gpu.
						if (!vboViCacheKey.isReadyColors(gl, magoManager.vboMemoryManager))
						{
							this.succesfullyGpuDataBinded = false;
						}
					}
					
					if (has_texCoords)
					{
						var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
						
						var daya_bytes; // (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
						if (data_type === 5120 || data_type === 5121) { daya_bytes = 1; }
						else if (data_type === 5122 || data_type === 5123) { daya_bytes = 2; }
						else if (data_type === 5126) { daya_bytes = 4; }
						
						var vertexCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
						var verticesFloatValuesCount = vertexCount * 2; // 2 = dimension of texCoord.

						neoRef.vertexCount = vertexCount; // no necessary.
						startBuff = bytes_readed;
						endBuff = bytes_readed + daya_bytes * verticesFloatValuesCount; 

						var texCoordDataArray = new Float32Array(arrayBuffer.slice(startBuff, endBuff));
						vboViCacheKey.setDataArrayTexCoord(texCoordDataArray, vboMemManager);
		
						bytes_readed += daya_bytes * verticesFloatValuesCount;
						
						// send data to gpu.
						/*
						if (!vboViCacheKey.isReadyTexCoords(gl, magoManager.vboMemoryManager))
						{
							this.succesfullyGpuDataBinded = false;
						}
						*/
					}
				}
			}

			// 4) read the reference material id.
			neoRef.materialId = readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			if (neoRef.materialId === -1)
			{ neoRef.hasTexture = false; }
			else 
			{ 
				neoRef.hasTexture = true; 
			}

			if (tMatrix4)
			{
				// multiply the building transformation matrix with the reference matrix, then we save additional multiplications inside the shader.
				neoRef.multiplyTransformMatrix(tMatrix4);
			}
		}

	}
	
	// finally read the triangles count.
	var trianglesCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
	
	//this.createModelReferencedGroups(); // test for stadistics.
	

	// Now occlusion cullings.
	// Occlusion culling octree data.**
	if (this.exterior_ocCullOctree === undefined)
	{ this.exterior_ocCullOctree = new OcclusionCullingOctreeCell(); }

	var infiniteOcCullBox = this.exterior_ocCullOctree;
	//bytes_readed = this.readOcclusionCullingOctreeCell(arrayBuffer, bytes_readed, infiniteOcCullBox); // old.
	bytes_readed = this.exterior_ocCullOctree.parseArrayBuffer(arrayBuffer, bytes_readed, readWriter);
	infiniteOcCullBox.expandBox(1000); // Only for the infinite box.
	infiniteOcCullBox.setSizesSubBoxes();
	infiniteOcCullBox.createModelReferencedGroups(this.motherNeoRefsList);

	if (this.interior_ocCullOctree === undefined)
	{ this.interior_ocCullOctree = new OcclusionCullingOctreeCell(); }

	var ocCullBox = this.interior_ocCullOctree;
	//bytes_readed = this.readOcclusionCullingOctreeCell(arrayBuffer, bytes_readed, ocCullBox); // old.
	bytes_readed = this.interior_ocCullOctree.parseArrayBuffer(arrayBuffer, bytes_readed, readWriter);
	ocCullBox.setSizesSubBoxes();
	ocCullBox.createModelReferencedGroups(this.motherNeoRefsList);

	this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
	return this.succesfullyGpuDataBinded;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param arrayBuffer 변수
 * @param neoBuilding 변수
 * @param readWriter 변수
 */
NeoReferencesMotherAndIndices.prototype.parseArrayBufferReferences = function(arrayBuffer, readWriter, neoBuilding, tMatrix4, magoManager) 
{
	this.fileLoadState = CODE.fileLoadState.PARSE_STARTED;
	
	var gl = magoManager.getGl();

	var startBuff;
	var endBuff;
	var bytes_readed = 0;
	var neoRefsCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
	var testIdentityMatsCount = 0;
	var stadistic_refMat_Identities_count = 0;
	var stadistic_refMat_Translates_count = 0;
	var stadistic_refMat_Transforms_count = 0;
	var vboMemManager = magoManager.vboMemoryManager;
	var classifiedTCoordByteSize = 0, classifiedColByteSize = 0;
	var colByteSize, tCoordByteSize;
	this.succesfullyGpuDataBinded = true;

	for (var i = 0; i < neoRefsCount; i++) 
	{
		var neoRef = new NeoReference();

		// 1) Id.
		var ref_ID =  readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
		neoRef._id = ref_ID;
		
		
		this.motherNeoRefsList = neoBuilding.motherNeoReferencesArray;
		if (this.motherNeoRefsList[neoRef._id] !== undefined)
		{
			// pass this neoReference because exist in the motherNeoReferencesArray.
			neoRef = this.motherNeoRefsList[neoRef._id];
			if (this.neoRefsIndices === undefined)
			{ this.neoRefsIndices = []; }
			
			this.neoRefsIndices.push(neoRef._id);

			var objectIdLength = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed +=1;
			var objectId = String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+objectIdLength)));
			bytes_readed += objectIdLength;

			// 2) Block's Idx.
			var blockIdx =   readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._block_idx = blockIdx;

			// 3) Transform Matrix4.
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

			// Float mode.**
			// New modifications for xxxx 20161013.**
			var has_1_color = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			if (has_1_color) 
			{
				// "type" : one of following
				// 5120 : signed byte, 5121 : unsigned byte, 5122 : signed short, 5123 : unsigned short, 5126 : float
				var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
				var dim = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

				var daya_bytes;
				if (data_type === 5121) { daya_bytes = 1; }

				var r = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var g = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var b = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var alfa = 255;

				if (dim === 4) 
				{
					alfa = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				}
			}
			
			var has_colors = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			var has_texCoords = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			
			if (has_colors || has_texCoords)
			{
				var vboDatasCount = readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				
				for (var j=0; j<vboDatasCount; j++)
				{
					if (has_colors)
					{
						var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
						var dim = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

						var daya_bytes; // (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
						if (data_type === 5120 || data_type === 5121) { daya_bytes = 1; }
						else if (data_type === 5122 || data_type === 5123) { daya_bytes = 2; }
						else if (data_type === 5126) { daya_bytes = 4; }
						
						var vertexCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
						var verticesFloatValuesCount = vertexCount * dim;
						startBuff = bytes_readed;
						endBuff = bytes_readed + daya_bytes * verticesFloatValuesCount; 
						bytes_readed += daya_bytes * verticesFloatValuesCount; // updating data.
					}
					
					if (has_texCoords)
					{
						var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
						
						var daya_bytes; // (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
						if (data_type === 5120 || data_type === 5121) { daya_bytes = 1; }
						else if (data_type === 5122 || data_type === 5123) { daya_bytes = 2; }
						else if (data_type === 5126) { daya_bytes = 4; }
						
						var vertexCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
						var verticesFloatValuesCount = vertexCount * 2; // 2 = dimension of texCoord.
						startBuff = bytes_readed;
						endBuff = bytes_readed + daya_bytes * verticesFloatValuesCount; 
						bytes_readed += daya_bytes * verticesFloatValuesCount;
					}
				}
			}
			
			// 4) short texcoords. OLD. Change this for Materials.
			var textures_count = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4; // this is only indicative that there are a texcoords.
			if (textures_count > 0) 
			{

				// Now, read the texture_type and texture_file_name.
				var texture_type_nameLegth = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				for (var j=0; j<texture_type_nameLegth; j++) 
				{
					bytes_readed += 1; // for example "diffuse".
				}

				var texture_fileName_Legth = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				for (var j=0; j<texture_fileName_Legth; j++) 
				{
					bytes_readed += 1;
				}
			} 
			
			// do the stadistic recount.
			if (neoRef.refMatrixType === 0){ stadistic_refMat_Identities_count +=1; }
			if (neoRef.refMatrixType === 1){ stadistic_refMat_Translates_count +=1; }
			if (neoRef.refMatrixType === 2){ stadistic_refMat_Transforms_count +=1; }
		}
		else
		{
			if (this.neoRefsIndices === undefined)
			{ this.neoRefsIndices = []; }
			
			this.neoRefsIndices.push(neoRef._id);

			var objectIdLength = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed +=1;
			var objectId = String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+objectIdLength)));
			if (objectId === "noObjectId" || objectId === "")
			{ objectId = neoRef._id; }
		
			neoRef.objectId = objectId;
			bytes_readed += objectIdLength;
			
			neoBuilding.putReferenceObject(neoRef, neoRef._id);

			// 2) Block's Idx.
			var blockIdx =   readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._block_idx = blockIdx;

			// 3) Transform Matrix4.
			neoRef._originalMatrix4._floatArrays[0] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[1] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[2] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[3] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

			neoRef._originalMatrix4._floatArrays[4] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[5] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[6] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[7] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

			neoRef._originalMatrix4._floatArrays[8] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[9] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[10] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[11] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;

			neoRef._originalMatrix4._floatArrays[12] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[13] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[14] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			neoRef._originalMatrix4._floatArrays[15] =  readWriter.readFloat32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
			
			// Compute the references matrix type.
			neoRef.refMatrixType = neoRef._originalMatrix4.computeMatrixType();
			if (neoRef.refMatrixType === 0){ stadistic_refMat_Identities_count +=1; }
			if (neoRef.refMatrixType === 1)
			{
				neoRef.refTranslationVec = new Float32Array([neoRef._originalMatrix4._floatArrays[12], neoRef._originalMatrix4._floatArrays[13], neoRef._originalMatrix4._floatArrays[14]]);
				stadistic_refMat_Translates_count +=1;
			}
			if (neoRef.refMatrixType === 2){ stadistic_refMat_Transforms_count +=1; }

			// Float mode.**
			// New modifications for xxxx 20161013.**
			var has_1_color = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			if (has_1_color) 
			{
				// "type" : one of following
				// 5120 : signed byte, 5121 : unsigned byte, 5122 : signed short, 5123 : unsigned short, 5126 : float
				var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
				var dim = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

				var daya_bytes;
				if (data_type === 5121) { daya_bytes = 1; }

				var r = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var g = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var b = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				var alfa = 255;

				if (dim === 4) 
				{
					alfa = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+daya_bytes); bytes_readed += daya_bytes;
				}

				neoRef.color4 = new Color();
				neoRef.color4.set(r, g, b, alfa);
			}
			
			var has_colors = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			var has_texCoords = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;
			
			if (has_colors || has_texCoords)
			{
				var vboDatasCount = readWriter.readInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				
				if (vboDatasCount > 0)
				{
					if (neoRef.vBOVertexIdxCacheKeysContainer === undefined)
					{ neoRef.vBOVertexIdxCacheKeysContainer = new VBOVertexIdxCacheKeysContainer(); }
				}
				
				for (var j=0; j<vboDatasCount; j++)
				{
					var vboViCacheKey = neoRef.vBOVertexIdxCacheKeysContainer.newVBOVertexIdxCacheKey();
					
					if (has_colors)
					{
						var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
						var dim = readWriter.readUInt8(arrayBuffer, bytes_readed, bytes_readed+1); bytes_readed += 1;

						var daya_bytes; // (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
						if (data_type === 5120 || data_type === 5121) { daya_bytes = 1; }
						else if (data_type === 5122 || data_type === 5123) { daya_bytes = 2; }
						else if (data_type === 5126) { daya_bytes = 4; }
						
						var vertexCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
						var verticesFloatValuesCount = vertexCount * dim;
						colByteSize = daya_bytes * verticesFloatValuesCount;
						classifiedColByteSize = vboMemManager.getClassifiedBufferSize(colByteSize);
						
						neoRef.vertexCount = vertexCount; // no necessary.
						startBuff = bytes_readed;
						endBuff = bytes_readed + daya_bytes * verticesFloatValuesCount; 
						//vboViCacheKey.colVboDataArray = new Float32Array(arrayBuffer.slice(startBuff, endBuff)); // original.
						// TODO: Float32Array or UintArray depending of dataType.
						vboViCacheKey.colVboDataArray = new Float32Array(classifiedColByteSize);
						vboViCacheKey.colVboDataArray.set(new Float32Array(arrayBuffer.slice(startBuff, endBuff)));
						vboViCacheKey.colArrayByteSize = classifiedColByteSize;
						bytes_readed += daya_bytes * verticesFloatValuesCount; // updating data.
						
						// send data to gpu.
						if (!vboViCacheKey.isReadyColors(gl, magoManager.vboMemoryManager))
						{
							this.succesfullyGpuDataBinded = false;
						}
					}
					
					if (has_texCoords)
					{
						var data_type = readWriter.readUInt16(arrayBuffer, bytes_readed, bytes_readed+2); bytes_readed += 2;
						
						var daya_bytes; // (5120 signed byte), (5121 unsigned byte), (5122 signed short), (5123 unsigned short), (5126 float)
						if (data_type === 5120 || data_type === 5121) { daya_bytes = 1; }
						else if (data_type === 5122 || data_type === 5123) { daya_bytes = 2; }
						else if (data_type === 5126) { daya_bytes = 4; }
						
						var vertexCount = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
						var verticesFloatValuesCount = vertexCount * 2; // 2 = dimension of texCoord.
						// example: posByteSize = 4 * verticesFloatValuesCount;
						tCoordByteSize = daya_bytes * verticesFloatValuesCount;
						classifiedTCoordByteSize = vboMemManager.getClassifiedBufferSize(tCoordByteSize);
						
						neoRef.vertexCount = vertexCount; // no necessary.
						startBuff = bytes_readed;
						endBuff = bytes_readed + daya_bytes * verticesFloatValuesCount; 
						//vboViCacheKey.tcoordVboDataArray = new Float32Array(arrayBuffer.slice(startBuff, endBuff)); // original.
						vboViCacheKey.tcoordVboDataArray = new Float32Array(classifiedTCoordByteSize);
						vboViCacheKey.tcoordVboDataArray.set(new Float32Array(arrayBuffer.slice(startBuff, endBuff)));
						vboViCacheKey.tcoordArrayByteSize = classifiedTCoordByteSize;
						bytes_readed += daya_bytes * verticesFloatValuesCount;
						
					}
				}
			}

			// 4) short texcoords. OLD. Change this for Materials.
			var textures_count = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4; // this is only indicative that there are a texcoords.
			if (textures_count > 0) 
			{
				var textureTypeName = "";
				var textureImageFileName = "";

				// Now, read the texture_type and texture_file_name.
				var texture_type_nameLegth = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				for (var j=0; j<texture_type_nameLegth; j++) 
				{
					textureTypeName += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+ 1)));bytes_readed += 1; // for example "diffuse".
				}

				var texture_fileName_Legth = readWriter.readUInt32(arrayBuffer, bytes_readed, bytes_readed+4); bytes_readed += 4;
				
				// utf8.
				var charArray = new Uint8Array(arrayBuffer.slice(bytes_readed, bytes_readed+ texture_fileName_Legth)); bytes_readed += texture_fileName_Legth;
				var decoder = new TextDecoder('utf-8');
				textureImageFileName = decoder.decode(charArray);
					
				//for (var j=0; j<texture_fileName_Legth; j++) 
				//{
				//	textureImageFileName += String.fromCharCode(new Int8Array(arrayBuffer.slice(bytes_readed, bytes_readed+ 1)));bytes_readed += 1;
				//}
				
				if (texture_fileName_Legth > 0)
				{
					neoRef.texture = new Texture();
					neoRef.hasTexture = true;
					neoRef.texture.textureTypeName = textureTypeName;
					neoRef.texture.textureImageFileName = textureImageFileName;
				}

				/*
				// 1pixel texture, wait for texture to load.**
				if(neoRef.texture.texId === undefined)
					neoRef.texture.texId = gl.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, neoRef.texture.texId);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([90, 80, 85, 255])); // red
				gl.bindTexture(gl.TEXTURE_2D, null);
				*/
			}
			else 
			{
				neoRef.hasTexture = false;
			}

			if (tMatrix4)
			{
				neoRef.multiplyTransformMatrix(tMatrix4);
			}
		}

	}
	
	//this.createModelReferencedGroups(); // test for new format.
	

	// Now occlusion cullings.
	// Occlusion culling octree data.**
	if (this.exterior_ocCullOctree === undefined)
	{ this.exterior_ocCullOctree = new OcclusionCullingOctreeCell(); }

	var infiniteOcCullBox = this.exterior_ocCullOctree;
	//bytes_readed = this.readOcclusionCullingOctreeCell(arrayBuffer, bytes_readed, infiniteOcCullBox); // old.
	bytes_readed = this.exterior_ocCullOctree.parseArrayBuffer(arrayBuffer, bytes_readed, readWriter);
	infiniteOcCullBox.expandBox(1000); // Only for the infinite box.
	infiniteOcCullBox.setSizesSubBoxes();
	infiniteOcCullBox.createModelReferencedGroups(this.motherNeoRefsList);

	if (this.interior_ocCullOctree === undefined)
	{ this.interior_ocCullOctree = new OcclusionCullingOctreeCell(); }

	var ocCullBox = this.interior_ocCullOctree;
	//bytes_readed = this.readOcclusionCullingOctreeCell(arrayBuffer, bytes_readed, ocCullBox); // old.
	bytes_readed = this.interior_ocCullOctree.parseArrayBuffer(arrayBuffer, bytes_readed, readWriter);
	ocCullBox.setSizesSubBoxes();
	ocCullBox.createModelReferencedGroups(this.motherNeoRefsList);

	this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
	return this.succesfullyGpuDataBinded;
};

/**
 * Renders the content.
 */
NeoReferencesMotherAndIndices.prototype.render = function(magoManager, neoBuilding, renderType, renderTexture, shader, maxSizeToRender, refMatrixIdxKey) 
{
	var allRendered = true;
	
	if (!this.isReadyToRender())
	{ return false; }
	
	if (renderType === 2)
	{
		renderTexture = false; // reassign value for this var.
	}
	
	var gl = magoManager.sceneState.gl;
	
	if (renderType === 2)
	{
		shader.disableVertexAttribArray(shader.texCoord2_loc);
		shader.disableVertexAttribArray(shader.normal3_loc);
	}
	if (renderType === 0)
	{
		shader.disableVertexAttribArray(shader.texCoord2_loc);
		shader.disableVertexAttribArray(shader.normal3_loc);
		shader.disableVertexAttribArray(shader.color4_loc);
	}
	
	if (renderTexture) 
	{
		gl.activeTexture(gl.TEXTURE2); // ...
		if (renderType === 1) 
		{ 
			gl.uniform1i(shader.colorType_loc, 2); // 0= oneColor, 1= attribColor, 2= texture.
		} 
	}

	// New version. Use occlussion indices.
	//var visibleIndices_count = this.neoRefsIndices.length; // no occludeCulling mode.
	var visibleIndices_count = this.currentVisibleIndices.length;
	var noRenderedsCount = 0;

	for (var k=0; k<visibleIndices_count; k++) 
	{
		//var neoReference = this.motherNeoRefsList[this.neoRefsIndices[k]]; // no occludeCulling mode.
		var neoReference = this.motherNeoRefsList[this.currentVisibleIndices[k]];
		
		if (neoReference === undefined)
		{ continue; }
		
		if (magoManager.currentProcess === CODE.magoCurrentProcess.SilhouetteDepthRendering)
		{
			neoReference.render(magoManager, neoBuilding, renderType, renderTexture, shader, refMatrixIdxKey, maxSizeToRender);
		}
		else 
		{
			// Check renderingFase.
			if (neoReference.renderingFase === magoManager.renderingFase)
			{ continue; }
			
			// Render the referenceObject.
			if (!neoReference.render(magoManager, neoBuilding, renderType, renderTexture, shader, refMatrixIdxKey, maxSizeToRender))
			{
				noRenderedsCount ++;
			}

			// Swap renderingFase.
			neoReference.swapRenderingFase(); 
		}
	}
	
	if ((visibleIndices_count - noRenderedsCount)/visibleIndices_count < 0.4)
	{ allRendered = false; }

	if (noRenderedsCount/visibleIndices_count > 0.2)
	{ allRendered = false; }
	
	return allRendered;
};






































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class NeoSimpleBuilding
 */
var NeoSimpleBuilding = function() 
{
	if (!(this instanceof NeoSimpleBuilding)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.accesorsArray = [];
	this.vbo_vicks_container = new VBOVertexIdxCacheKeysContainer();
	this.texturesArray = [];
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns accesor
 */
NeoSimpleBuilding.prototype.newAccesor = function() 
{
	var accesor = new Accessor();
	this.accesorsArray.push(accesor);
	return accesor;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns texture
 */
NeoSimpleBuilding.prototype.newTexture = function() 
{
	var texture = new NeoTexture();
	this.texturesArray.push(texture);
	return texture;
};

'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class NeoTexture
 */
var NeoTexture = function() 
{
	if (!(this instanceof NeoTexture)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.lod;
	this.textureId; // texture id in gl.
	this.texImage; // image. delete this once upload to gl.
	this.loadStarted = false;
	this.loadFinished = false;
};
'use strict';

/**
 * This is the geometry container. Is the minimum independent project.
 * @class Node
 */
var Node = function() 
{
	if (!(this instanceof Node)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * Parent (owner) of this node object. If undefined, this node is the root node.
	 * @type {Node}
	 * @default undefined
	 */
	this.parent;
	
	/**
	 * Children array. This array contains Node objects.
	 * @type {Array}
	 * @default Default length = 0.
	 */
	this.children = []; 
	
	/**
	 * An object that contains all referent data, geometry data, location data, etc.
	 * @type {Object}
	 * @default undefined.
	 */
	this.data; 
};

/**
 * Returns true if this node is a "reference" type node. "Reference" type nodes uses StaticModels geometry.
 * @returns {Boolean} true if this node is a "reference" type node.
 */
Node.prototype.isReferenceNode = function() 
{
	var isReference = false;
	if (this.data !== undefined)
	{
		var attributes = this.data.attributes;
		if (attributes !== undefined)
		{
			if (attributes.isReference !== undefined)
			{ isReference = attributes.isReference; }
		}
	}
	
	return isReference;
};

/**
 * get node state of rander
 * @return {boolean} return this node is ready to render
 */
Node.prototype.isReadyToRender = function()
{
	var geoLocDataManager = this.getNodeGeoLocDataManager();
	if (geoLocDataManager === undefined)
	{ return false; }
	var geoLocData = geoLocDataManager.getCurrentGeoLocationData();
	if (geoLocData === undefined)
	{ return false; }
	var geoCoords = geoLocData.getGeographicCoords();
	if (geoCoords === undefined)
	{ return false; } 
	
	if (geoCoords.longitude === undefined || geoCoords.latitude === undefined || geoCoords.altitude === undefined)
	{
		return false;
	}

	return true;
};

/**
 * Deletes all datas and all datas of children.
 */
Node.prototype.deleteObjects = function(gl, vboMemoryManager) 
{
	this.parent = undefined;
	var data = this.data;
	if (data !== undefined)
	{
		// Check if this is a reference node.
		var isReference = this.isReferenceNode();
		
		// No delete neoBuilding if this node is a reference node.
		if (isReference)
		{ return; }

		if (data.neoBuilding)
		{
			data.neoBuilding.deleteObjects(gl, vboMemoryManager);
			data.neoBuilding = undefined;
		}
		
		if (data.geographicCoord)
		{
			data.geographicCoord.deleteObjects();
			data.geographicCoord = undefined;
		}
		
		if (data.rotationsDegree)
		{
			data.rotationsDegree.deleteObjects();
			data.rotationsDegree = undefined;
		}
		
		if (data.bbox)
		{
			data.bbox.deleteObjects();
			data.bbox = undefined;
		}
		
		// Delete geoLocationDataManager, etc. TODO.
		
		this.data = undefined;
	}
	
	if (this.children)
	{
		var childrenCount = this.children.length;
		for (var i=0; i<childrenCount; i++)
		{
			this.children[i].deleteObjects(gl, vboMemoryManager);
			this.children[i] = undefined;
		}
		this.children = undefined;
	}
};

/**
 * Calculates the geographicLocationData of the node.
 * @param {MagoManager} magoManager Main class object of Mago3D.
 * @returns {GeoLocationData} geoLoc The calculated geoLocationData of this node.
 */
Node.prototype.calculateGeoLocData = function(magoManager) 
{
	// This function creates the geoLocationData of "node".
	// Called from magomanager.tilesMultiFrustumCullingFinished(...), flyToBuilding(...)
	var nodeRoot = this.getRoot();

	if (nodeRoot.data.geoLocDataManager === undefined)
	{ nodeRoot.data.geoLocDataManager = new GeoLocationDataManager(); }
	var geoLocDataManager = nodeRoot.data.geoLocDataManager;
	var geoLoc = geoLocDataManager.getCurrentGeoLocationData();
		
	if (geoLoc === undefined)
	{ 
		geoLoc = geoLocDataManager.newGeoLocationData("deploymentLoc"); 
	}
	
	var geographicCoord;
	var rotationsDegree;
	
	if (this.data.geographicCoord === undefined)
	{
		var buildingSeed = this.data.buildingSeed;
		geographicCoord = buildingSeed.geographicCoord;
		rotationsDegree = buildingSeed.rotationsDegree;
	}
	else 
	{
		geographicCoord = this.data.geographicCoord;
		rotationsDegree = this.data.rotationsDegree;
	}
	
	if (rotationsDegree === undefined)
	{ rotationsDegree = new Point3D(0.0, 0.0, 0.0); }
	
	var longitude = geographicCoord.longitude;
	var latitude = geographicCoord.latitude;
	var altitude = geographicCoord.altitude;
	var heading = rotationsDegree.z;
	var pitch = rotationsDegree.x;
	var roll = rotationsDegree.y;
	ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude, heading, pitch, roll, geoLoc, magoManager);

	this.correctGeoLocationDataByMappingType(geoLoc);
	/*
	// check if use "centerOfBoundingBoxAsOrigin".
	if (this.data.mapping_type === undefined)
	{ this.data.mapping_type= "origin"; }

	if (this.data.mapping_type.toLowerCase() === "boundingboxcenter")
	{
		var rootNode = this.getRoot();
		if (rootNode)
		{
			// now, calculate the root center of bbox.
			var buildingSeed = this.data.buildingSeed;
			var buildingSeedBBox = buildingSeed.bBox;
			this.pointSC = buildingSeedBBox.getCenterPoint(this.pointSC);
			ManagerUtils.translatePivotPointGeoLocationData(geoLoc, this.pointSC );
		}
	}
	else if (this.data.mapping_type.toLowerCase() === "boundingboxbottomcenter")
	{
		var rootNode = this.getRoot();
		if (rootNode)
		{
			// now, calculate the root center of bbox.
			var buildingSeed = this.data.buildingSeed;
			var buildingSeedBBox = buildingSeed.bBox;
			this.pointSC = buildingSeedBBox.getBottomCenterPoint(this.pointSC);
			ManagerUtils.translatePivotPointGeoLocationData(geoLoc, this.pointSC );
		}
	}
	
	*/
	return geoLoc;
};

/**
 * Calculates the geographicLocationData of the node.
 * @param {MagoManager} magoManager Main class object of Mago3D.
 * @returns {GeoLocationData} geoLoc The calculated geoLocationData of this node.
 */
Node.prototype.correctGeoLocationDataByMappingType = function(geoLoc) 
{
	if (this.data.mapping_type === undefined)
	{ 
		this.data.mapping_type= "origin"; 
		return;
	}

	// check if use "centerOfBoundingBoxAsOrigin".
	var buildingSeed = this.data.buildingSeed;
	if (buildingSeed === undefined)
	{ return; }

	var buildingSeedBBox = buildingSeed.bBox;
		
	if (this.data.mapping_type.toLowerCase() === "boundingboxcenter")
	{
		// now, calculate the root center of bbox.
		this.pointSC = buildingSeedBBox.getCenterPoint(this.pointSC);
	}
	else if (this.data.mapping_type.toLowerCase() === "boundingboxbottomcenter")
	{
		// now, calculate the root center of bbox.
		this.pointSC = buildingSeedBBox.getBottomCenterPoint(this.pointSC);
	}
	else
	{
		geoLoc.pivotPointTraslationLC = undefined;
		this.pointSC =new Point3D(0, 0, 0);
	}

	ManagerUtils.translatePivotPointGeoLocationData(geoLoc, this.pointSC );
};

Node.prototype.checkChangesHistoryMovements = function() 
{
	var moveHistoryMap = this.data.moveHistoryMap;
	if (moveHistoryMap === undefined)
	{ return; }
	
	var neoBuilding = this.data.neoBuilding;
	///for (var changeHistory of moveHistoryMap.values()) 
	
	for (var key in moveHistoryMap)
	{
		if (Object.prototype.hasOwnProperty.call(moveHistoryMap, key)) 
		{
			var changeHistory = moveHistoryMap[key];
			var objectIndexOrder = changeHistory.getObjectIndexOrder();
			var refObject = neoBuilding.getReferenceObject(objectIndexOrder);
			if (refObject === undefined)
			{ continue; }
			
			if (refObject.moveVector === undefined)
			{ refObject.moveVector = new Point3D(); }
			
			if (refObject.moveVectorRelToBuilding === undefined)
			{ refObject.moveVectorRelToBuilding = new Point3D(); }
			
			var moveVector = changeHistory.getReferenceObjectAditionalMovement();
			var moveVectorRelToBuilding = changeHistory.getReferenceObjectAditionalMovementRelToBuilding();
			refObject.moveVectorRelToBuilding.set(moveVectorRelToBuilding.x, moveVectorRelToBuilding.y, moveVectorRelToBuilding.z);
			refObject.moveVector.set(moveVector.x, moveVector.y, moveVector.z);
			
			// now check if the building was rotated.
			var rootNode = this.getRoot();
			if (rootNode === undefined)
			{ continue; }
			
			var geoLocdataManager = rootNode.getNodeGeoLocDataManager();
			var geoLoc = geoLocdataManager.getCurrentGeoLocationData();
			// if was rotated then recalculate the move vector.
			refObject.moveVector = geoLoc.tMatrix.rotatePoint3D(refObject.moveVectorRelToBuilding, refObject.moveVector); 
			
			// if was no rotated, then set the moveVector of the changeHistory.
			//refObject.moveVectorRelToBuilding.set(moveVectorRelToBuilding.x, moveVectorRelToBuilding.y, moveVectorRelToBuilding.z);	
		}
	}
};

/**
 * Checks if there are some objects that was changed the color.
 */
Node.prototype.checkChangesHistoryColors = function() 
{
	var data = this.data;
	
	if (data === undefined)
	{ return; }
	
	var colorChangedHistoryMap = data.colorChangedHistoryMap;
	
	if (colorChangedHistoryMap === undefined)
	{ return; }
	
	var node = this;
	
	for (var key in colorChangedHistoryMap)
	{
		if (Object.prototype.hasOwnProperty.call(colorChangedHistoryMap, key)) 
		{
			var changeHistory = colorChangedHistoryMap[key];
			if (changeHistory.objectId === null || changeHistory.objectId === undefined || changeHistory.objectId === "" )
			{
				if (changeHistory.property === null || changeHistory.property === undefined || changeHistory.property === "" )
				{
					// change color for all node.
					data.isColorChanged = true;
					if (data.aditionalColor === undefined)
					{ data.aditionalColor = new Color(); }
					
					data.aditionalColor.setRGBA(changeHistory.color[0], changeHistory.color[1], changeHistory.color[2], changeHistory.color[3]);
				}
				else 
				{
					// there are properties.
					var nodesArray = [];
					node.extractNodes(nodesArray);
					var nodesCount = nodesArray.length;
					var aNode;
					for (var i=0; i<nodesCount; i++)
					{
						aNode = nodesArray[i];
						var propertyKey = changeHistory.propertyKey;
						var propertyValue = changeHistory.propertyValue;
						// 1rst, check if this has the same "key" and same "value".
						if (aNode.data.attributes[propertyKey] !== undefined && aNode.data.attributes[propertyKey].toString() === propertyValue)
						{
							data.isColorChanged = true;
							if (data.aditionalColor === undefined)
							{ data.aditionalColor = new Color(); }
							
							data.aditionalColor.setRGBA(changeHistory.color[0], changeHistory.color[1], changeHistory.color[2], changeHistory.color[3]);
						}
					}
				}
			}
			else 
			{
				// change color for an object.
				var neoBuilding = node.data.neoBuilding;
				
				if (neoBuilding === undefined)
				{ return; }
				
				var objectId = changeHistory.objectId;
				var objectsArray = neoBuilding.getReferenceObjectsArrayByObjectId(objectId);
				if (objectsArray)
				{
					var objectsCount = objectsArray.length;
					for (var j=0; j<objectsCount; j++)
					{
						var object = objectsArray[j];
						if (object.aditionalColor === undefined)
						{ object.aditionalColor = new Color(); }
						
						object.aditionalColor.setRGBA(changeHistory.color[0], changeHistory.color[1], changeHistory.color[2], changeHistory.color[3]);
					}
				}
			}	
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Node.prototype.renderContent = function(magoManager, shader, renderType, refMatrixIdxKey) 
{
	// This function renders the renderables that exists in "data".
	// renderType = 0 -> depth render.
	// renderType = 1 -> normal render.
	// renderType = 2 -> colorSelection render.
	// renderType = 3 -> shadowMesh render.
	//--------------------------------------------
	var data = this.data;
	if (data === undefined)
	{ return; }

	if (this.renderCondition && typeof this.renderCondition === 'function') 
	{
		this.renderCondition.call(this, data);
	}

	// Check if there are renderables.***
	var renderable = data.renderable;
	if (renderable)
	{
		renderable.render(magoManager, shader, renderType);
		return;
	}
	
	var attributes = data.attributes;
	
	if (attributes)
	{
		if (attributes.isVisible !== undefined && attributes.isVisible === false) 
		{
			return;
		}
		
		if (magoManager.currentProcess === CODE.magoCurrentProcess.DepthShadowRendering)
		{
			if (attributes.castShadow !== undefined && attributes.castShadow === false) 
			{
				return;
			}
		}
	}

	// Check if there are effects.
	if (renderType !== 2 && magoManager.currentProcess !== CODE.magoCurrentProcess.StencilSilhouetteRendering)
	{ var executedEffects = magoManager.effectsManager.executeEffects(data.nodeId, magoManager.getCurrentTime()); }
	
	// check if this is a multiBuildings.
	//if(data.attributes.objectType === "multiBuildingsTile")
	var multiBuildings = data.multiBuildings;
	if (multiBuildings)
	{
		multiBuildings.render(magoManager, shader);
		return;
	}

	// Check if we are under selected data structure.***
	var selectionManager = magoManager.selectionManager;
	if (magoManager.nodeSelected === this)
	{ selectionManager.parentSelected = true; }
	else 
	{ selectionManager.parentSelected = false; }
	
	var neoBuilding = data.neoBuilding;
	if (neoBuilding === undefined)
	{ return; }

	// Update visibleOctreesControler of the neoBuilding & the relativeCurrentCamera.
	// Note: currentVisibleOctreesControler & myCameraRelative are calculated on MagoManager.getRenderablesDetailedNeoBuildingAsimetricVersion(...).
	neoBuilding.currentVisibleOctreesControler = data.currentVisibleOctreesControler;
	neoBuilding.myCameraRelative = data.myCameraRelative;
	neoBuilding.isColorChanged = data.isColorChanged;
	neoBuilding.aditionalColor = data.aditionalColor;
	
	this.checkChangesHistoryColors();
	this.checkChangesHistoryMovements();

	// Check projectType.*
	var metaData = neoBuilding.metaData;
	var projectsType = metaData.projectDataType;
	//--------------------------------------------
	
	var rootNode = this.getRoot();
	var geoLocDataManager = rootNode.data.geoLocDataManager;

	// 1rst, determine the shader.
	var gl = magoManager.sceneState.gl;
	
	// check attributes of the project.
	var project = magoManager.hierarchyManager.getNodesMap(data.projectId);
	if (project.attributes !== undefined && project.attributes.specularLighting !== undefined && shader.bApplySpecularLighting_loc !== undefined)
	{
		var applySpecLighting = project.attributes.specularLighting;
		if (applySpecLighting)
		{ gl.uniform1i(shader.bApplySpecularLighting_loc, true); }
		else
		{ gl.uniform1i(shader.bApplySpecularLighting_loc, false); }
	}
	// end check attributes of the project.----------------------------------------
	
	
	// set the currentObjectsRendering.
	magoManager.renderer.currentObjectsRendering.curNode = this;
	
	var flipYTexCoord = false;
	if (data.attributes.flipYTexCoords !== undefined)
	{ flipYTexCoord = data.attributes.flipYTexCoords; }

	gl.uniform1i(shader.textureFlipYAxis_loc, flipYTexCoord);
	
	// Check the geoLocationDatasCount & check if is a ghost-trail-render (trail as ghost).
	var currRenderingFase = magoManager.renderingFase;
	if (this.isReferenceNode())
	{ magoManager.renderingFase = -10; } // set a strange value to skip avoiding rendering fase of references objects.
	
	// Check if is trail-render.*
	var isTrailRender = this.data.isTrailRender;
	if (isTrailRender !== undefined && isTrailRender === true)
	{
		magoManager.isTrailRender = true;
		gl.depthRange(0.1, 1); // reduce depthRange to minimize blending flickling.
		var geoLocDatasCount = geoLocDataManager.getGeoLocationDatasCount();
		//for(var i=geoLocDatasCount - 1; i>0; i--)
		for (var i=1; i<geoLocDatasCount; i++ )
		{
			var buildingGeoLocation = geoLocDataManager.getGeoLocationData(i);
			buildingGeoLocation.bindGeoLocationUniforms(gl, shader);
						
			var externalAlpha = (geoLocDatasCount - i)/(geoLocDatasCount*7);
			gl.uniform1f(shader.externalAlpha_loc, externalAlpha);

			// If this node is a referenceNode type, then, must render all references avoiding the renderingFase.
			neoBuilding.currentLod = data.currentLod; // update currentLod.
			neoBuilding.render(magoManager, shader, renderType, refMatrixIdxKey, flipYTexCoord, data.currentLod);

		}
		gl.depthRange(0, 1);
		magoManager.isTrailRender = false;
	}
	//--------------------------------------------------------------------------------------------------------------------
	
	
	var geoLocDataIdx;
	if (geoLocDataManager.getGeoLocationDatasCount() > 1)
	{ geoLocDataIdx = 1; }
	else
	{ geoLocDataIdx = 0; }
	var buildingGeoLocation = geoLocDataManager.getGeoLocationData(geoLocDataIdx);
	buildingGeoLocation.bindGeoLocationUniforms(gl, shader);

	// magoManager.tempSettings.renderWithTopology === 0 -> render only Building.
	// magoManager.tempSettings.renderWithTopology === 1 -> render only Topology.
	// magoManager.tempSettings.renderWithTopology === 2 -> render both.

	// If this node is a referenceNode type, then, must render all references avoiding the renderingFase.
	gl.uniform1f(shader.externalAlpha_loc, 1.0);
	neoBuilding.currentLod = data.currentLod; // update currentLod.
	neoBuilding.render(magoManager, shader, renderType, refMatrixIdxKey, flipYTexCoord, data.currentLod);
	
	magoManager.renderingFase = currRenderingFase; // Return to current renderingFase.
	
	// Finally, if there are no animationData, then delete the trailEfect.
	if (this.data.animationData !== undefined && this.data.animationData.finished === true)
	{
		if (geoLocDataManager.getGeoLocationDatasCount() > 1)
		{ geoLocDataManager.popGeoLocationData(); }
		else
		{ 
			this.data.animationData = undefined;
		}
	}
	
	// Test.
	/*
	if (neoBuilding.network)
	{
		if(magoManager.tempSettings.renderWithTopology === 0 || magoManager.tempSettings.renderWithTopology === 2)
		{
			neoBuilding.render(magoManager, shader, renderType, refMatrixIdxKey, flipYTexCoord);
		}
	}
	else{
		neoBuilding.render(magoManager, shader, renderType, refMatrixIdxKey, flipYTexCoord);
	}
	
	if (neoBuilding.network)
	{
		// Note: topology data is loaded (if exist) when loads the metaData in "prepareNeoBuildingsAsimetricVersion" in magoManager.
		if(magoManager.tempSettings.renderWithTopology === 1 || magoManager.tempSettings.renderWithTopology === 2)
		{
			// render the topology.
			if (renderType !== 0)
			{
				gl.uniform1i(shader.bApplySsao_loc, false); // no apply ssao.
				gl.uniform1i(shader.refMatrixType_loc, 0); // in this case, there are not referencesMatrix.
				var network = neoBuilding.network;
				if (network)
				{
					network.render(magoManager, shader, renderType);
				}
				gl.uniform1i(shader.bApplySsao_loc, true); // apply ssao default.
			}
		}
	}
	*/
	
	if (executedEffects)
	{
		// must return all uniforms changed for effects.
		gl.uniform3fv(shader.scaleLC_loc, [1.0, 1.0, 1.0]); // init local scale.
		
		if (renderType === 1)
		{
			gl.uniform4fv(shader.colorMultiplier_loc, [1.0, 1.0, 1.0, 1.0]);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Node.prototype.addChildren = function(children) 
{
	children.setParent(this);
	this.children.push(children);
};

/**
 * 어떤 일을 하고 있습니까?
 */
Node.prototype.setParent = function(parent) 
{
	this.parent = parent;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Node.prototype.getRoot = function() 
{
	if (this.parent === undefined)
	{ return this; }
	else
	{
		return this.parent.getRoot();
	}
};

/**
 * @param {function} renderCondition
 */
Node.prototype.setRenderCondition = function(renderCondition) 
{
	if (!renderCondition || typeof renderCondition !== 'function') 
	{
		throw new Error('renderCondition is required.');
	}
	this.renderCondition = renderCondition;
};
/**
 * @return {function}
 */
Node.prototype.getRenderCondition = function() 
{
	return this.renderCondition;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Node.prototype.getClosestParentWithData = function(dataName) 
{
	if (this.data && this.data[dataName])
	{
		return this;
	}
	else 
	{
		if (this.parent)
		{ return this.parent.getClosestParentWithData(dataName); }
		else { return undefined; }
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Node.prototype.extractNodesByDataName = function(nodesArray, dataname) 
{
	// this function extracts nodes that has a data named dataname, including children.
	if (this.data[dataname])
	{
		nodesArray.push(this);
	}
	
	var childrenCount = this.children.length;
	for (var i=0; i<childrenCount; i++)
	{
		this.children[i].extractNodesByDataName(nodesArray, dataname);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Node.prototype.extractNodes = function(nodesArray) 
{
	// this function extracts nodes that has a data named dataname, including children.
	nodesArray.push(this);
	
	var childrenCount = this.children.length;
	for (var i=0; i<childrenCount; i++)
	{
		this.children[i].extractNodes(nodesArray);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
Node.prototype.getBBox = function() 
{
	var bbox;
	var data = this.data;
	if (data.bbox === undefined)
	{
		// 1rst, check if exist neoBuilding's metaData.
		var neoBuilding = data.neoBuilding;
		if (neoBuilding !== undefined && neoBuilding.metaData !== undefined)
		{
			var metaData = neoBuilding.metaData;
			data.bbox = new BoundingBox(); // Only create a node's bbox when exist neoBuilding's metaData.
			data.bbox.copyFrom(metaData.bbox);
			bbox = data.bbox;
		}
		else if (data.buildingSeed !== undefined)
		{
			var buildingSeed = data.buildingSeed;
			bbox = buildingSeed.bbox;
		}
	}
	else 
	{
		bbox = data.bbox;
	}
	
	return bbox;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
Node.prototype.getBBoxCenterPositionWorldCoord = function(geoLoc) 
{
	var bboxAbsoluteCenterPos;
	if (this.bboxAbsoluteCenterPos === undefined)
	{
		bboxAbsoluteCenterPos = this.calculateBBoxCenterPositionWorldCoord(geoLoc);
	}
	else 
	{
		bboxAbsoluteCenterPos = this.bboxAbsoluteCenterPos;
	}
	
	return bboxAbsoluteCenterPos;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param texture 변수
 * @returns texId
 */
Node.prototype.calculateBBoxCenterPositionWorldCoord = function(geoLoc) 
{
	var data = this.data;

	var mapping_type = data.mapping_type;
	
	if (mapping_type === undefined)
	{ mapping_type = "origin"; }

	var bboxAbsoluteCenterPosAux;
	var bboxCenterPoint = new Point3D(0, 0, 0);
	if (mapping_type.toLowerCase() === "origin")
	{
		if (!data.bbox) 
		{
			this.getBBox();
		}
		// this.data.bbox is the most important bbox.
		bboxCenterPoint = data.bbox.getCenterPoint(bboxCenterPoint); // local bbox.
	}
	else if (mapping_type.toLowerCase() === "boundingboxcenter")
	{
		bboxCenterPoint.set(0, 0, 0);
	}
	else if (mapping_type.toLowerCase() === "boundingboxbottomcenter")
	{
		var bboxHeight = data.bbox.getZLength();
		bboxCenterPoint.set(0, 0, bboxHeight/2);
	}

	bboxAbsoluteCenterPosAux = geoLoc.tMatrix.transformPoint3D(bboxCenterPoint, bboxAbsoluteCenterPosAux);
	
	// Now, must applicate the additional translation vector. Additional translation is made when we translate the pivot point.
	if (geoLoc.pivotPointTraslation)
	{
		var traslationVector;
		traslationVector = geoLoc.tMatrix.rotatePoint3D(geoLoc.pivotPointTraslation, traslationVector );
		bboxAbsoluteCenterPosAux.add(traslationVector.x, traslationVector.y, traslationVector.z);
	}
	
	return bboxAbsoluteCenterPosAux;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns {Boolean} applyOcclusionCulling
 */
Node.prototype.getBoundingSphereWC = function(resultBoundingSphere) 
{
	if (this.bboxAbsoluteCenterPos === undefined) 
	{ return resultBoundingSphere; }
	
	if (resultBoundingSphere === undefined)
	{ resultBoundingSphere = new BoundingSphere(); }
	
	var nodeRoot = this.getRoot();
	var geoLocDataManager = nodeRoot.data.geoLocDataManager;
	var geoLoc = geoLocDataManager.getCurrentGeoLocationData();
	
	var realBuildingPos = this.getBBoxCenterPositionWorldCoord(geoLoc);
	var radiusAprox;
	var bbox = this.getBBox();
	radiusAprox = bbox.getRadiusAprox(); 
	
	resultBoundingSphere.setCenterPoint(realBuildingPos.x, realBuildingPos.y, realBuildingPos.z);
	resultBoundingSphere.setRadius(radiusAprox);
	
	return resultBoundingSphere;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns {Boolean} applyOcclusionCulling
 */
Node.prototype.getDistToCamera = function(cameraPosition, boundingSphere_Aux) 
{
	var data = this.data;
	var attributes = data.attributes;
	
	if (attributes.objectType === "basicF4d")
	{
		// Traditional f4d data.
	}
	else if (attributes.objectType === "multiBuildingsTile")
	{
		// MultiBuildingsTile from cityGML style data.
	}
	
	var nodeRoot = this.getRoot();
	var geoLocDataManager = nodeRoot.data.geoLocDataManager;
	var geoLoc = geoLocDataManager.getCurrentGeoLocationData();
	
	// To calculate realBuildingPosition, we need this.data.bbox.
	// If this.data.bbox no exist, then calculate a provisional value.
	if (this.bboxAbsoluteCenterPos === undefined) 
	{
		if (data.mapping_type === undefined)
		{ data.mapping_type = "origin"; }
		
		var bboxCenterPoint = new Point3D(0, 0, 0);
		if (data.mapping_type.toLowerCase() === "origin")
		{
			if (!this.data.bbox) 
			{
				this.getBBox();
			}
			// this.data.bbox is the most important bbox.
			bboxCenterPoint = this.data.bbox.getCenterPoint(bboxCenterPoint); // local bbox.
		}
		else if (data.mapping_type.toLowerCase() === "boundingboxcenter")
		{
			bboxCenterPoint.set(0, 0, 0);
		}
		else if (data.mapping_type.toLowerCase() === "boundingboxbottomcenter")
		{
			var bboxHeight = this.data.bbox.getZLength();
			bboxCenterPoint.set(0, 0, bboxHeight/2);
		}
		
		this.bboxAbsoluteCenterPos = geoLoc.tMatrix.transformPoint3D(bboxCenterPoint, this.bboxAbsoluteCenterPos);
	}
	
	var realBuildingPos = this.getBBoxCenterPositionWorldCoord(geoLoc);
	var radiusAprox;
	var bbox = this.getBBox();
	radiusAprox = bbox.getRadiusAprox(); 
	
	boundingSphere_Aux.setCenterPoint(realBuildingPos.x, realBuildingPos.y, realBuildingPos.z);
	boundingSphere_Aux.setRadius(radiusAprox);
	
	// Special treatment for point-cloud data. 
	if (attributes.objectType === "basicF4d")
	{
		var neoBuilding = data.neoBuilding;
		var metaData = neoBuilding.metaData;
		var projectsType = metaData.projectDataType;
		if (projectsType && (projectsType === 4 || projectsType === 5))
		{
			// This is pointsCloud projectType.
			// Calculate the distance to camera with lowestOctrees.
			var octree = neoBuilding.octree;
			if (octree === undefined)
			{ return undefined; }
			
			var relativeCamPos;
			relativeCamPos = geoLoc.getTransformedRelativePosition(cameraPosition, relativeCamPos);
			//relativeCam = neoBuilding.getTransformedRelativeEyePositionToBuilding(cameraPosition.x, cameraPosition.y, cameraPosition.z, relativeCam);
			var octreesMaxSize = 120;
			data.distToCam = octree.getMinDistToCameraInTree(relativeCamPos, boundingSphere_Aux, octreesMaxSize);
			boundingSphere_Aux.setCenterPoint(realBuildingPos.x, realBuildingPos.y, realBuildingPos.z);
			boundingSphere_Aux.setRadius(neoBuilding.bbox.getRadiusAprox());
		}
		/*
		else 
		{
			// This is mesh projectType.
			data.distToCam = cameraPosition.distToSphere(boundingSphere_Aux);
		}
		*/
	}
	
	data.distToCam = cameraPosition.distToSphere(boundingSphere_Aux);

	return data.distToCam;
};

/**
 */
Node.prototype.getNodeGeoLocDataManager = function() 
{
	var closestRootNode = this.getClosestParentWithData("geoLocDataManager");
	
	if (closestRootNode === undefined)
	{ return undefined; }

	if (closestRootNode.data === undefined)
	{ return undefined; }
	
	var rootNodeGeoLocDataManager = closestRootNode.data.geoLocDataManager;
	return rootNodeGeoLocDataManager;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Node.prototype.finishedAnimation = function(magoManager) 
{
	var finished = false;
	var animData = this.data.animationData;
	
	if (animData === undefined)
	{ return true; }

	var currTime = magoManager.getCurrentTime();
	
	var nextLongitude;
	var nextLatitude;
	var nextAltitude;
	var nextHeading;
	var nextPitch;
	var nextRoll;

	// Check animationType.***
	var autoChangeRotation = animData.autoChangeRotation;
	if (autoChangeRotation === undefined)
	{ autoChangeRotation = false; }
	
	var animType = animData.animationType;
	if (animType === CODE.animationType.PATH)
	{
		// Test.***
		var nextPosLine = AnimationManager.getNextPosition(animData, currTime, magoManager);
		
		if (nextPosLine === undefined)
		{ 
			animData.finished = true;
			return true; 
		}
	
		var path = animData.path;
		var pathGeoLocDataManager = path.getGeoLocationDataManager();
		var pathGeoLocData = pathGeoLocDataManager.getCurrentGeoLocationData();
		
		// Now, calculate the geographic coords of the position.***
		var posLocal = nextPosLine.point;
		var dir = nextPosLine.direction;
		
		// calculate worldPos.***
		var tMat = pathGeoLocData.tMatrix;
		var posWC = tMat.transformPoint3D(posLocal, undefined);
		
		var geographicCoords = Globe.CartesianToGeographicWgs84(posWC.x, posWC.y, posWC.z, undefined);
		nextLatitude = geographicCoords.latitude;
		nextLongitude = geographicCoords.longitude;
		nextAltitude = geographicCoords.altitude;
		//var headingAngle;
		
		if (autoChangeRotation)
		{
			// now calculate heading, pitch & roll.***
			var yAxis = new Point2D(0, 1);
			var dir2d = new Point2D(dir.x, dir.y);
			dir2d.unitary();
			nextHeading = yAxis.angleDegToVector(dir2d);
			if (dir2d.x > 0.0)
			{
				nextHeading *= -1;
			}

			// pitch 랑  roll은 어떡하나요?
		}
		else 
		{
			nextHeading = animData.targetHeading;
			nextPitch = animData.targetPitch;
			nextRoll = animData.targetRoll;
		}
		
		this.changeLocationAndRotation(nextLatitude, nextLongitude, nextAltitude, nextHeading, nextPitch, nextRoll, magoManager);
		
		// finally update "lastTime".
		animData.lastTime = currTime;
		return finished;
	}

	//애니메이션 종료시 true 반환. 
	if (animData.finished)
	{ return true; }


	if (animData.startLongitude === undefined || animData.startLatitude === undefined || animData.startAltitude === undefined)
	{ return true; }
	
	// calculate the currentLocation and currentRotation.
	if (animData.lastTime === undefined)
	{ animData.lastTime = animData.birthTime; }
	
	var totalDeltaTime = (currTime - animData.birthTime)/1000.0; // in seconds.

	// calculate velocity.
	var velocityLon = (animData.targetLongitude - animData.startLongitude)/(animData.durationInSeconds);
	var velocityLat = (animData.targetLatitude - animData.startLatitude)/(animData.durationInSeconds);
	var velocityAlt = (animData.targetAltitude - animData.startAltitude)/(animData.durationInSeconds);

	var geoLocDatamanager = this.getNodeGeoLocDataManager();
	if (geoLocDatamanager === undefined)
	{
		return true;
	}
	var geoLocationData = geoLocDatamanager.getCurrentGeoLocationData();
	if (geoLocationData === undefined)
	{
		return true;
	}
	var geographicCoord = geoLocationData.geographicCoord;

	if (totalDeltaTime > animData.durationInSeconds)
	{
		nextLongitude = animData.targetLongitude;
		nextLatitude = animData.targetLatitude;
		nextAltitude = animData.targetAltitude;

		nextHeading = animData.targetHeading;
		nextPitch = animData.targetPitch;
		nextRoll = animData.targetRoll;
		
		// finish the process.
		finished = true;
		this.data.animationData.finished = true;
	}
	else
	{
		var ratio = totalDeltaTime/animData.durationInSeconds;
		var completeHeadingRatio = 0.3;
		if (ratio > completeHeadingRatio)
		{
			nextHeading = animData.targetHeading;
			nextPitch = animData.targetPitch;
			nextRoll = animData.targetRoll;
		}
		else 
		{
			var diffHeading = (animData.targetHeading - animData.startHeading);
			nextHeading = animData.startHeading + diffHeading * ratio / completeHeadingRatio;
			nextPitch = animData.startPitch;
			nextRoll = animData.startRoll;
		}

		// calculate by durationInSeconds.
		var targetLongitude = animData.targetLongitude;
		var targetLatitude = animData.targetLatitude;
		var targetAltitude = animData.targetAltitude;
		
		nextLongitude = animData.startLongitude + velocityLon * totalDeltaTime;
		nextLatitude = animData.startLatitude + velocityLat * totalDeltaTime;
		nextAltitude = animData.startAltitude + velocityAlt * totalDeltaTime;
		
		// finally update "lastTime".
		animData.lastTime = currTime;
		finished = false;
	}
	this.changeLocationAndRotation(nextLatitude, nextLongitude, nextAltitude, nextHeading, nextPitch, nextRoll, magoManager);
	
	return finished;
};

/**
 * 어떤 일을 하고 있습니까?
 */
 
Node.prototype.changeLocationAndRotationAnimated = function(latitude, longitude, elevation, heading, pitch, roll, magoManager, animationOption) 
{
	// Provisionally set a geoLocationData target.
	if (this.data.animationData === undefined)
	{ this.data.animationData = new AnimationData(); }
	
	var animData = this.data.animationData;
	animData.finished = false;
	
	// New for animation by path.***
	animData.animationType = animationOption.animationType;
	animData.path = animationOption.path;
	animData.linearVelocityInMetersSecond = animationOption.linearVelocityInMetersSecond;
	animData.autoChangeRotation = animationOption.autoChangeRotation;
	// End animation by path.***
	
	var geoLocDataManager = this.getNodeGeoLocDataManager();
	if (geoLocDataManager === undefined)
	{ return; }
	var geoLocData = geoLocDataManager.getCurrentGeoLocationData();
	if (geoLocData === undefined)
	{ return; }
	var prevGeoLocData = geoLocDataManager.getGeoLocationData(1);
	if (prevGeoLocData === undefined)
	{ prevGeoLocData = geoLocDataManager.getCurrentGeoLocationData(); }
	var geoCoords = geoLocData.getGeographicCoords();
	if (geoCoords === undefined)
	{ return; } 
	
	if (geoCoords.longitude === undefined || geoCoords.latitude === undefined || geoCoords.altitude === undefined)
	{
		return;
	}
	
	// Check if the target location is equal to the current location.***
	// 대상 정지 시 gps 신호가 고르지 않아 일정 길이 이하의 차이 일 시 움직이지 않는다.
	var lonDiff = geoCoords.longitude - longitude;
	var latDiff = geoCoords.latitude - latitude; 
	var altDiff = geoCoords.altitude - elevation;

	var geoDist = Math.sqrt(lonDiff*lonDiff + latDiff*latDiff);
	var errTolerance = 0.000065;//0.000056;	
	if (geoDist < errTolerance)
	{
		animData.finished = true;
		return;
	}
	animData.birthTime = magoManager.getCurrentTime();
	// start location.***
	animData.startLongitude = geoCoords.longitude;
	animData.startLatitude = geoCoords.latitude;
	animData.startAltitude = geoCoords.altitude;


	while (geoLocData.heading > 360) 
	{
		geoLocData.heading -= 360;
	}

	while (geoLocData.heading < -360) 
	{
		geoLocData.heading += 360;
	}

	animData.startHeading = geoLocData.heading;
	animData.startPitch = geoLocData.pitch;
	animData.startRoll = geoLocData.roll;
	
	// target location.
	animData.targetLongitude = longitude;
	animData.targetLatitude = latitude;
	animData.targetAltitude = elevation;
	
	// calculate rotation (heading & pitch).
	var currLongitude = geoCoords.longitude;
	var currLatitude = geoCoords.latitude;
	var currAltitude = geoCoords.altitude;

	// target rotation.
	animData.targetHeading = heading;
	animData.targetPitch = pitch;
	animData.targetRoll = roll;

	//geoLocData.heading = animData.targetHeading;
	//geoLocData.pitch = animData.targetPitch;
	//geoLocData.roll = animData.targetRoll;

	//Duration For compatibility with lower versions, lower version parameter is just duration(number).
	var isAnimOption = typeof animationOption === 'object' && isNaN(animationOption);
	var durationInSeconds = 3.0;
	if (isAnimOption)
	{
		if (animationOption.duration)
		{
			durationInSeconds = animationOption.duration;
		}
		if (animationOption.autoChangeRotation)
		{
			var nextPos = Globe.geographicToCartesianWgs84(animData.targetLongitude, animData.targetLatitude, animData.targetAltitude, undefined);
			var nextPoint3d = new Point3D(nextPos[0], nextPos[1], nextPos[2]);
			var relativeNextPos;
			relativeNextPos = prevGeoLocData.getTransformedRelativePositionNoApplyHeadingPitchRoll(nextPoint3d, relativeNextPos);

			relativeNextPos.unitary();
			var yAxis = new Point2D(0, 1);


			var relNextPos2D = new Point2D(relativeNextPos.x, relativeNextPos.y);
			relNextPos2D.unitary();
			
			
			var headingAngle = yAxis.angleDegToVector(relNextPos2D);
			if (relativeNextPos.x > 0)
			{
				headingAngle *= -1;
			}
			//if (headingAngle < 0) { headingAngle += 360; }

			//var diffAngle = headingAngle - animData.startHeading;
			if (headingAngle > 180)
			{ headingAngle -= 360; }
			else if (headingAngle < 180)
			{ headingAngle += 360; }
			
			// calculate heading (initially yAxis to north).
			var nextHeading = headingAngle;//Math.atan(-relativeNextPos.x/relativeNextPos.y)*180.0/Math.PI;
			var nextPosModule2d = Math.sqrt(relativeNextPos.x*relativeNextPos.x + relativeNextPos.y*relativeNextPos.y);
			var nextPitch = 0;//Math.atan(relativeNextPos.z/nextPosModule2d)*180.0/Math.PI;


			while (nextHeading > 360) 
			{
				nextHeading -= 360;
			}

			while (nextHeading < -360) 
			{
				nextHeading += 360;
			}

			var diffHeading = (nextHeading - animData.startHeading);
			if (diffHeading > 180) 
			{
				nextHeading -= 360;
			}
			else if (diffHeading < -180) 
			{
				nextHeading += 360;
			}

			if (geoDist < errTolerance*1.5 && relNextPos2D.y < 0.1)
			{
				nextHeading = animData.startHeading;
			}

			animData.targetHeading = nextHeading;
			animData.targetPitch = nextPitch;
			// roll is always zero.
			animData.targetRoll = roll;  
		}
		else 
		{
			while (heading > 360) 
			{
				heading -= 360;
			}

			while (heading < -360) 
			{
				heading += 360;
			}

			var diffHeading = (heading - animData.startHeading);
			if (diffHeading > 180) 
			{
				heading -= 360;
			}
			else if (diffHeading < -180) 
			{
				heading += 360;
			}
			animData.targetHeading = heading;
		}
	}
	else
	{
		durationInSeconds = animationOption;
	}

	//if (durationInSeconds === undefined)
	//{ durationInSeconds = 3.0; }
	animData.durationInSeconds = durationInSeconds;
	// linear velocity in m/s.
	//animData.linearVelocityInMetersSecond = 40.0;
				
	// angular velocity deg/s.
	//animData.headingAngDegSecondVelocity = 10.0;
	//animData.pitchAngDegSecondVelocity = 0.0;
	//animData.rollAngDegSecondVelocity = 0.0;
	// end setting geoLocDataTarget.--------------------------------------------------
	
	
};

/**
 * 어떤 일을 하고 있습니까?
 */
Node.prototype.nodeMoved = function(node) 
{
	// node was moved, so, check if is out of the smartTileOwner.
	// If node is out of the smartTileOwner, then, erase the node from the smartTileOwner, and then put the node in the corresponent smartTile.
	if (node === undefined)
	{ return; }
	
	var smartTileOwner = node.data.smartTileOwner;
	if (!smartTileOwner.intersectsNode(node))
	{
		smartTileOwner.eraseNode(node);
				
		// Now, put the node in the corresponent smartTile.
		var targetDepth = smartTileOwner.targetDepth;
		magoManager.smartTileManager.putNode(targetDepth, node, magoManager);
	}
};


/**
 * 
 * TODO : ARGS CHANGE OBJECT
 * 어떤 일을 하고 있습니까?
 * 
 */
Node.prototype.changeLocationAndRotation = function(latitude, longitude, elevation, heading, pitch, roll, magoManager) 
{
	
	var nodeRoot;
	//nodeRoot = this.getRoot(); // original.
	nodeRoot = this.getClosestParentWithData("geoLocDataManager");
	// 126.60625627706231
	
	if (nodeRoot === undefined)
	{ return; }
	
	if (!nodeRoot.data.bbox)
	{
		return;
	}
	// now, extract all buildings of the nodeRoot.
	var nodesArray = [];
	nodeRoot.extractNodesByDataName(nodesArray, "neoBuilding");
	
	nodeRoot.data.geographicCoord.longitude = longitude; 
	nodeRoot.data.geographicCoord.latitude = latitude; 
	nodeRoot.data.geographicCoord.altitude = elevation;
	
	var aNode;
	var buildingSelected;
	var nodesCount = nodesArray.length;
	for (var i=0; i<nodesCount; i++)
	{
		aNode = nodesArray[i];
		var geoLocDatamanager = aNode.getNodeGeoLocDataManager();
		if (geoLocDatamanager === undefined)
		{ continue; }
		var geoLocationData;
		if (this.data.animationData !== undefined)
		{
			geoLocationData = geoLocDatamanager.newGeoLocationData();
		}
		else 
		{
			geoLocationData = geoLocDatamanager.getCurrentGeoLocationData(); // original.
		}
		if (geoLocationData === undefined)
		{ continue; }
	
		geoLocationData = ManagerUtils.calculateGeoLocationData(longitude, latitude, elevation, heading, pitch, roll, geoLocationData, magoManager);
		this.correctGeoLocationDataByMappingType(geoLocationData);
		
		if (geoLocationData === undefined)
		{ continue; }
	
		if (geoLocationData.geographicCoord === undefined)
		{ continue; } 
	
		// Change the geoCoords of the buildingSeed.
		var buildingSeed = aNode.data.buildingSeed;
		if (buildingSeed)
		{
			buildingSeed.geographicCoordOfBBox.longitude = longitude;
			buildingSeed.geographicCoordOfBBox.latitude = latitude;
		}

		
		// now, must change the keyMatrix of the references of the octrees of all buildings of this node.
		var neoBuilding = aNode.data.neoBuilding;
		if (neoBuilding.octree)
		{
			neoBuilding.octree.multiplyKeyTransformMatrix(0, geoLocationData.rotMatrix);
		}
		neoBuilding.calculateBBoxCenterPositionWorldCoord(geoLocationData);
		nodeRoot.bboxAbsoluteCenterPos = undefined; // provisional.
		nodeRoot.bboxAbsoluteCenterPos = nodeRoot.calculateBBoxCenterPositionWorldCoord(geoLocationData); // provisional.
		
		aNode.bboxAbsoluteCenterPos = undefined; // provisional.
		aNode.bboxAbsoluteCenterPos = aNode.calculateBBoxCenterPositionWorldCoord(geoLocationData); // provisional.
		
		// Now, calculate the geoCoords of the bbox.
		if (nodeRoot.data.bbox.geographicCoord === undefined)
		{ nodeRoot.data.bbox.geographicCoord = new GeographicCoord(); }
		
		nodeRoot.data.bbox.geographicCoord.setLonLatAlt(longitude, latitude, elevation); // provisional. Must calculate the ... TODO:
		
		// aNode was moved, so, check if is out of the smartTileOwner.
		// If aNode is out of the smartTileOwner, then, erase the node from the smartTileOwner, and then put the node in the corresponent smartTile.
		var smartTileOwner = aNode.data.smartTileOwner;
		if (!smartTileOwner.intersectsNode(aNode))
		{
			smartTileOwner.eraseNode(aNode);
					
			// Now, put the node in the corresponent smartTile.
			var targetDepth = smartTileOwner.depth;
			magoManager.smartTileManager.putNode(targetDepth, aNode, magoManager);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
/*
Node.prototype.test__octreeModelRefAndIndices_changed = function() 
{
	var data = this.data;
	
	if(data === undefined)
		return false;
	
	var neoBuilding = data.neoBuilding;
	if(neoBuilding === undefined)
		return false;
	
	var octree = neoBuilding.octree;
	if(octree === undefined)
		return true;
	
	var modelRefMotherAndIndices = octree.neoReferencesMotherAndIndices;
	if(modelRefMotherAndIndices === undefined)
		return true;
	
	if(modelRefMotherAndIndices.neoRefsIndices.length === 0 || modelRefMotherAndIndices.motherNeoRefsList.length === 0)
		return true;
	
	return false;
};
*/
















'use strict';

/**
 * Octree class object. The octree contains detailed geometry data (meshes, points cloud, etc.).
 * @class Octree
 * @param {Octree} octreeOwner If octreeOwner is undefined, then this octree is the mother octree.
 */
var Octree = function(octreeOwner) 
{
	if (!(this instanceof Octree)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * The center position in local coordinates of the octree.
	 * @type {Point3D}
	 * @default (0,0,0)
	 */
	this.centerPos = new Point3D();
	
	/**
	 * The half width of the octree in x-axis.
	 * @type {Number}
	 * @default 0.0
	 */
	this.half_dx = 0.0; 
	
	/**
	 * The half width of the octree in y-axis.
	 * @type {Number}
	 * @default 0.0
	 */
	this.half_dy = 0.0; 
	
	/**
	 * The half width of the octree in z-axis.
	 * @type {Number}
	 * @default 0.0
	 */
	this.half_dz = 0.0; 

	/**
	 * The octree's owner. If octree_owner is undefined, then this octree is the mother octree.
	 * @type {Octree}
	 * @default undefined
	 */
	this.octree_owner;
	if (octreeOwner) 
	{
		this.octree_owner = octreeOwner;
		this.octree_level = octreeOwner.octree_level + 1;
	}
	
	/**
	 * The octree's depth level. Mother octree's depth level is zero.
	 * @type {Number}
	 * @default 0
	 */
	this.octree_level = 0;
	
	// Octree number name.**
	// Bottom           Top              Y
	// +-----+-----+   +-----+-----+     ^
	// |  4  |  3  |   |  8  |  7  |     |
	// +-----+-----+   +-----+-----+     |
	// |  1  |  2  |   |  5  |  6  |     |------> X
	// +-----+-----+   +-----+-----+
	
	/**
	 * The octree's identifier. Accumulative number, starting from mother octree.
	 * @type {Number}
	 * @default 0
	 */
	this.octree_number_name = 0;
	
	/**
	 * The octree's neoBuildingOwner identifier.
	 * @type {String}
	 * @default undefined
	 */
	this.neoBuildingOwnerId;
	
	/**
	 * The octree's neoBuildingOwner.
	 * @type {NeoBuilding}
	 * @default undefined
	 */
	this.neoBuildingOwner;
	
	/**
	 * The octree's global unique identifier. It is compost by neoBuildingOwnerId + octree_number_name.
	 * @type {String}
	 * @default undefined
	 */
	this.octreeKey; 
	
	/**
	 * The octree's current LOD. Assigned by distance to camera when frustumCulling.
	 * @type {Number}
	 * @default undefined
	 */
	this.lod; 
	
	/**
	 * The octree's current distance to camera.
	 * @type {Number}
	 * @default undefined
	 */
	this.distToCamera;
	
	/**
	 * The octree's meshes count. Readed when parsing.
	 * @type {Number}
	 * @default 0
	 */
	this.triPolyhedronsCount = 0; 
	
	/**
	 * The octree's current fileLoadState.
	 * @type {Number}
	 * @default 0
	 */
	this.fileLoadState = CODE.fileLoadState.READY;

	/**
	 * The octree's children array. Array length must be 8.
	 * @type {Array}
	 * @default 0
	 */
	this.subOctrees_array = [];
	
	/**
	 * The octree's meshes. The meshes of the octree are referenced by an indice.
	 * @type {NeoReferencesMotherAndIndices}
	 * @default undefined
	 */
	this.neoReferencesMotherAndIndices; 
	
	/**
	 * Pre-extracted leaf octrees, to speedUp.
	 * @type {Array}
	 * @default undefined
	 */
	this.lowestOctrees_array; // pre extract lowestOctrees for speedUp, if this is motherOctree.

	/**
	 * Can be a mesh or poitsCloudPartition. Generally used to contain LOD2 meshes.
	 * @type {Lego}
	 * @default undefined
	 */
	this.lego; 
	
	/**
	 * PointsCloudPartitions count.
	 * @type {Number}
	 * @default undefined
	 */
	this.pCloudPartitionsCount; // No used.
	
	/**
	 * PointsCloudPartitions.
	 * @type {Array}
	 * @default undefined
	 */
	this.pCloudPartitionsArray;
	
	// gereral objects.
	this.objectsArray;
	
};

/**
 * Creates a child octree.
 * @returns {Octree} subOctree Returns the created child octree.
 */
Octree.prototype.new_subOctree = function() 
{
	var subOctree = new Octree(this);
	subOctree.octree_level = this.octree_level + 1;
	this.subOctrees_array.push(subOctree);
	return subOctree;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
Octree.prototype.deleteObjectsModelReferences = function(gl, vboMemManager) 
{
	if (this.neoReferencesMotherAndIndices)
	{ this.neoReferencesMotherAndIndices.deleteObjects(gl, vboMemManager); }

	this.neoReferencesMotherAndIndices = undefined;

	if (this.subOctrees_array !== undefined) 
	{
		for (var i=0, subOctreesCount = this.subOctrees_array.length; i<subOctreesCount; i++) 
		{
			this.subOctrees_array[i].deleteObjectsModelReferences(gl, vboMemManager);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
Octree.prototype.deleteObjectsLego = function(gl, vboMemManager) 
{
	if (this.lego !== undefined) 
	{
		// deletes the geometry and the texture.
		this.lego.deleteObjects(gl, vboMemManager);
		this.lego = undefined;
	}
	
	if (this.subOctrees_array !== undefined) 
	{
		for (var i=0, subOctreesCount = this.subOctrees_array.length; i<subOctreesCount; i++) 
		{
			this.subOctrees_array[i].deleteObjectsLego(gl, vboMemManager);
		}
	}
	
};

/**
 * Deletes all objects of the octree.
 * @param gl : current gl.
 * @param vboMemManager : gpu memory manager
 */
Octree.prototype.deleteObjects = function(gl, vboMemManager) 
{
	if (this.lego !== undefined) 
	{
		this.lego.deleteObjects(gl, vboMemManager);
		this.lego = undefined;
	}
	
	this.legoDataArrayBuffer = undefined;
	if (this.centerPos)
	{ this.centerPos.deleteObjects(); }
	this.centerPos = undefined;
	this.half_dx = undefined; // half width.
	this.half_dy = undefined; // half length.
	this.half_dz = undefined; // half height.

	this.octree_owner = undefined;
	this.octree_level = undefined;
	this.octree_number_name = undefined;
	this.distToCamera = undefined;
	this.triPolyhedronsCount = undefined; // no calculated. Readed when parsing.
	this.fileLoadState = undefined; // 0 = no started to load. 1 = started loading. 2 = finished loading. 3 = parse started. 4 = parse finished.

	this.neoBuildingOwner = undefined;

	if (this.neoReferencesMotherAndIndices)
	{ this.neoReferencesMotherAndIndices.deleteObjects(gl, vboMemManager); }

	this.neoReferencesMotherAndIndices = undefined;
	
	// before deleteting child:
	this.deletePCloudObjects(gl, vboMemManager);

	if (this.subOctrees_array !== undefined) 
	{
		for (var i=0, subOctreesCount = this.subOctrees_array.length; i<subOctreesCount; i++) 
		{
			this.subOctrees_array[i].deleteObjects(gl, vboMemManager);
			this.subOctrees_array[i] = undefined;
		}
		this.subOctrees_array = undefined;
	}
	
	
};

/**
 * Deletes pointsCloud objects of the octree.
 * @param gl : current gl.
 * @param vboMemManager : gpu memory manager
 */
Octree.prototype.deletePCloudObjects = function(gl, vboMemManager) 
{
	//this.pCloudPartitionsCount; // pointsCloud-pyramid-tree mode.
	//this.pCloudPartitionsArray;
	
	if (this.pCloudPartitionsArray !== undefined)
	{ 
	
		var pCloudPartitionsCount = this.pCloudPartitionsArray.length;
		for (var i=0; i<pCloudPartitionsCount; i++)
		{
			var pCloudPartition = this.pCloudPartitionsArray[i];
			// Note: provisionally "pCloudPartition" is a lego class object.
			pCloudPartition.deleteObjects(gl, vboMemManager);
		}
		
		this.pCloudPartitionsArray = undefined;
	}
	
	// Now, delete child.
	if (this.subOctrees_array !== undefined)
	{
		var childsCount = this.subOctrees_array.length;
		for (var i=0; i<childsCount; i++)
		{
			var subOctree = this.subOctrees_array[i];
			subOctree.deletePCloudObjects(gl, vboMemManager);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
Octree.prototype.deleteLod0GlObjects = function(gl, vboMemManager) 
{
	if (this.neoReferencesMotherAndIndices)
	{ this.neoReferencesMotherAndIndices.deleteObjects(gl, vboMemManager); }

	if (this.subOctrees_array !== undefined) 
	{
		for (var i=0, subOctreesCount = this.subOctrees_array.length; i<subOctreesCount; i++) 
		{
			this.subOctrees_array[i].deleteLod0GlObjects(gl, vboMemManager);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
Octree.prototype.deleteLod2GlObjects = function(gl, vboMemManager) 
{
	if (this.lego !== undefined) 
	{
		this.lego.deleteObjects(gl, vboMemManager);
		this.lego = undefined;
	}
	
	if (this.neoReferencesMotherAndIndices)
	{ this.neoReferencesMotherAndIndices.deleteObjects(gl, vboMemManager); }

	if (this.subOctrees_array !== undefined) 
	{
		for (var i=0, subOctreesCount = this.subOctrees_array.length; i<subOctreesCount; i++) 
		{
			this.subOctrees_array[i].deleteLod2GlObjects(gl, vboMemManager);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
Octree.prototype.createChildren = function() 
{
	this.subOctrees_array = []; // Init array.
	
	for (var i=0; i<8; i++) 
	{
		var subOctree = this.new_subOctree();
		subOctree.octree_number_name = this.octree_number_name * 10 + (i+1);
		subOctree.neoBuildingOwnerId = this.neoBuildingOwnerId;
		subOctree.octreeKey = this.neoBuildingOwnerId + "_" + subOctree.octree_number_name;
	}

	this.setSizesSubBoxes();
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
Octree.prototype.makeTree = function(treeDepth) 
{
	// No used.
	if (this.octree_level < treeDepth) 
	{
		this.createChildren();

		for (var i=0; i<8; i++) 
		{
			this.subOctrees_array[i].makeTree(treeDepth);
		}
	}
};


/**
 * 어떤 일을 하고 있습니까?
 */
Octree.prototype.prepareData = function(magoManager) 
{
	// Function no used. Under construction.
	// This function prepares data in function of the current lod.
	if (this.lod < 2)
	{
		// Must prepare modelRefList data.
		this.prepareModelReferencesListData(magoManager);
	}
	else if (this.lod >= 2)
	{
		// Must prepare skin data.
		this.prepareSkinData(magoManager);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Octree.prototype.prepareSkinData = function(magoManager) 
{
	if (this.octree_number_name === undefined)
	{ return; }
	
	if (this.lego === undefined) 
	{
		this.lego = new Lego();
		this.lego.birthTime = magoManager.currTime;
		this.lego.fileLoadState = CODE.fileLoadState.READY;
		this.lego.legoKey = this.octreeKey + "_lego";
	}

	var neoBuilding = this.neoBuildingOwner;
	if (neoBuilding === undefined)
	{ return; }
	
	var gl = magoManager.sceneState.gl;
	var geometryDataPath = magoManager.readerWriter.geometryDataPath;
	var projectFolderName = neoBuilding.projectFolderName;
	var buildingFolderName = neoBuilding.buildingFileName;
	
	var headerVersion = neoBuilding.getHeaderVersion();

	if (this.lego.fileLoadState === CODE.fileLoadState.READY)
	{
		// must load the legoStructure of the lowestOctree.
		var subOctreeNumberName = this.octree_number_name.toString();
		var bricks_folderPath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/Bricks";
		var filePathInServer = bricks_folderPath + "/" + subOctreeNumberName + "_Brick";

		// finally check if there are legoSimpleBuildingTexture.
		if (headerVersion[0] === "v")
		{
			if (this.lego.vbo_vicks_container.vboCacheKeysArray[0] && this.lego.vbo_vicks_container.vboCacheKeysArray[0].meshTexcoordsCacheKey)
			{
				// this is the old version.
				if (neoBuilding.simpleBuilding3x3Texture === undefined)
				{
					neoBuilding.simpleBuilding3x3Texture = new Texture();
					var buildingFolderName = neoBuilding.buildingFileName;
					var texFilePath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/SimpleBuildingTexture3x3.png";
				}
				
				// Direct loading.
				if (neoBuilding.simpleBuilding3x3Texture !== undefined && neoBuilding.simpleBuilding3x3Texture.fileLoadState === CODE.fileLoadState.READY)
				{ 
					magoManager.readerWriter.readLegoSimpleBuildingTexture(gl, texFilePath, neoBuilding.simpleBuilding3x3Texture, magoManager);  
				}
				
				magoManager.readerWriter.getOctreeLegoArraybuffer(filePathInServer, this, magoManager);
				
			}
			else 
			{
				// there are no texture in this project.
				magoManager.readerWriter.getOctreeLegoArraybuffer(filePathInServer, this, magoManager);
				
			}
		}
		else 
		{
			var flip_y_texCoords = true;

			// This is the version 001.
			if (neoBuilding.simpleBuilding3x3Texture === undefined)
			{
				neoBuilding.simpleBuilding3x3Texture = new Texture();
			}

			var imageFilaName = neoBuilding.getImageFileNameForLOD(2);
			var texFilePath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/" + imageFilaName;

			// Direct loading.
			if (neoBuilding.simpleBuilding3x3Texture !== undefined && neoBuilding.simpleBuilding3x3Texture.fileLoadState === CODE.fileLoadState.READY)
			{ 
				magoManager.readerWriter.readLegoSimpleBuildingTexture(gl, texFilePath, neoBuilding.simpleBuilding3x3Texture, magoManager, flip_y_texCoords); 
			}
			
			magoManager.readerWriter.getOctreeLegoArraybuffer(filePathInServer, this, magoManager);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Octree.prototype.prepareModelReferencesListData = function(magoManager) 
{
	var neoBuilding = this.neoBuildingOwner;
		
	// 1rst check possibles errors.
	if (neoBuilding === undefined)
	{ return; }
	
	if (this.triPolyhedronsCount === 0) 
	{ return; }
	
	if (this.octree_number_name === undefined)
	{ return; }

	// Check the version.
	var version = neoBuilding.getHeaderVersion();
	/*
	if (version === "0.0.2")
	{
		this.prepareModelReferencesListData_v002(magoManager);
		return;
	}
	*/

	var geometryDataPath = magoManager.readerWriter.geometryDataPath;
	var buildingFolderName = neoBuilding.buildingFileName;
	var projectFolderName = neoBuilding.projectFolderName;
	
	var keepDataArrayBuffers = false;
	var attrib = neoBuilding.attributes;
	if (attrib !== undefined)
	{
		if (attrib.keepDataArrayBuffers !== undefined && attrib.keepDataArrayBuffers === true)
		{
			keepDataArrayBuffers = true;
		}
	}
	
	if (this.neoReferencesMotherAndIndices === undefined)
	{
		this.neoReferencesMotherAndIndices = new NeoReferencesMotherAndIndices();
		this.neoReferencesMotherAndIndices.motherNeoRefsList = neoBuilding.motherNeoReferencesArray;
	}
	
	if (this.neoReferencesMotherAndIndices.fileLoadState === CODE.fileLoadState.READY)
	{
		if (this.neoReferencesMotherAndIndices.blocksList === undefined)
		{ this.neoReferencesMotherAndIndices.blocksList = new BlocksList("0.0.1"); }
	
		if (keepDataArrayBuffers)
		{	
			this.neoReferencesMotherAndIndices.blocksList.keepDataArrayBuffers = keepDataArrayBuffers;
		}

		var subOctreeNumberName = this.octree_number_name.toString();
		var references_folderPath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/References";
		var intRef_filePath = references_folderPath + "/" + subOctreeNumberName + "_Ref";
		magoManager.readerWriter.getNeoReferencesArraybuffer(intRef_filePath, this, magoManager);
	}
	
	
	// 4 = parsed.
	// now, check if the blocksList is loaded & parsed.
	var blocksList = this.neoReferencesMotherAndIndices.blocksList;
	if (blocksList === undefined)
	{ return; }
	if (blocksList.fileLoadState === CODE.fileLoadState.READY) 
	{
		// must read blocksList.
		var subOctreeNumberName = this.octree_number_name.toString();
		var blocks_folderPath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/Models";
		var filePathInServer = blocks_folderPath + "/" + subOctreeNumberName + "_Model";
		magoManager.readerWriter.getNeoBlocksArraybuffer(filePathInServer, this, magoManager);
	}

};

/**
 * 어떤 일을 하고 있습니까?
 */
Octree.prototype.prepareModelReferencesListData_partitionsVersion = function(magoManager) 
{
	var neoBuilding = this.neoBuildingOwner;
		
	// 1rst check possibles errors.
	if (neoBuilding === undefined)
	{ return; }
	
	if (this.triPolyhedronsCount === 0) 
	{ return; }
	
	if (this.octree_number_name === undefined)
	{ return; }

	var geometryDataPath = magoManager.readerWriter.geometryDataPath;
	var buildingFolderName = neoBuilding.buildingFileName;
	var projectFolderName = neoBuilding.projectFolderName;
	
	if (this.neoReferencesMotherAndIndices === undefined)
	{
		this.neoReferencesMotherAndIndices = new NeoReferencesMotherAndIndices();
		this.neoReferencesMotherAndIndices.motherNeoRefsList = neoBuilding.motherNeoReferencesArray;
	}
	
	if (this.neoReferencesMotherAndIndices.fileLoadState === CODE.fileLoadState.READY)
	{
		if (this.neoReferencesMotherAndIndices.blocksList === undefined)
		{ 
			var blocksList = new BlocksList("0.0.2"); 
			this.neoReferencesMotherAndIndices.blocksList = blocksList; 
			
			// Set blocksList partitionData.
			blocksList.blocksArrayPartitionsCount = this.blocksListsPartitionsCount;

			var subOctreeNumberName = this.octree_number_name.toString();
			var blocks_folderPath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/Models";
			var masterPathName = blocks_folderPath + "/" + subOctreeNumberName + "_Model_";
			blocksList.blocksArrayPartitionsMasterPathName = masterPathName;
		}

		var subOctreeNumberName = this.octree_number_name.toString();
		var references_folderPath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/References";
		var intRef_filePath = references_folderPath + "/" + subOctreeNumberName + "_Ref";
		magoManager.readerWriter.getNeoReferencesArraybuffer(intRef_filePath, this, magoManager);
	}
	
	// BlocksList: must distinguish v001 to v002.
	// In v002, the blocksList is conformed by partitions.
	var blocksList = this.neoReferencesMotherAndIndices.blocksList;
	if (blocksList === undefined)
	{ return; }

	// if (blocksList.fileLoadState === CODE.fileLoadState.READY) 
	
	// Load blocksListsPartition.

	//if(this.blocksListsPartitionsParsedCount === undefined)
	//	this.blocksListsPartitionsParsedCount = 0;

	
	blocksList.prepareData(magoManager, this);
	
	/*
	var partitionIdx = this.blocksListsPartitionsParsedCount;
	if (partitionIdx < this.blocksListsPartitionsCount)
	{
		var subOctreeNumberName = this.octree_number_name.toString();
		var blocks_folderPath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/Models";
		var filePathInServer = blocks_folderPath + "/" + subOctreeNumberName + "_Model_" + partitionIdx.toString();
		magoManager.readerWriter.getNeoBlocksArraybuffer_partition(filePathInServer, this, magoManager);
	}
	*/
};

/**
 * 어떤 일을 하고 있습니까?
 * @param intNumber 변수
 * @returns numDigits
 */
Octree.prototype.renderSkin = function(magoManager, neoBuilding, renderType, renderTexture, shader) 
{
	var gl = magoManager.sceneState.gl;
	if (this.lego === undefined) 
	{
		this.lego = new Lego();
		this.lego.fileLoadState = CODE.fileLoadState.READY;
		this.lego.legoKey = this.octreeKey + "_lego";
		return false;
	}
	
	if (this.lego.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED)
	{ return false; }

	// if the building is highlighted, the use highlight oneColor4.
	renderTexture = true;
	gl.uniform1i(shader.refMatrixType_loc, 0); // in this case, there are not referencesMatrix.
	if (renderType === 1)
	{
		// Solve the color or texture of the skin.
		if (neoBuilding.isHighLighted)
		{
			gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
			gl.uniform4fv(shader.oneColor4_loc, this.highLightColor4); //.
			renderTexture = false;
		}
		else if (neoBuilding.isColorChanged)
		{
			gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
			gl.uniform4fv(shader.oneColor4_loc, [neoBuilding.aditionalColor.r, neoBuilding.aditionalColor.g, neoBuilding.aditionalColor.b, neoBuilding.aditionalColor.a]); //.
			renderTexture = false;
		}

		//----------------------------------------------------------------------------------
		
		if (neoBuilding.simpleBuilding3x3Texture !== undefined && neoBuilding.simpleBuilding3x3Texture.texId && renderTexture)
		{
			// Provisionally flip tex coords here.
			//gl.uniform1i(shader.textureFlipYAxis_loc, false);//.ppp
			gl.uniform1i(shader.colorType_loc, 2); // 0= oneColor, 1= attribColor, 2= texture.
			if (shader.last_tex_id !== neoBuilding.simpleBuilding3x3Texture.texId)
			{
				gl.activeTexture(gl.TEXTURE2); 
				gl.bindTexture(gl.TEXTURE_2D, neoBuilding.simpleBuilding3x3Texture.texId);
				shader.last_tex_id = neoBuilding.simpleBuilding3x3Texture.texId;
			}
		}
		else 
		{
			// Todo: If this building lod2 has no texture, then render with colors.
			//gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
			//shader.disableVertexAttribArray(shader.texCoord2_loc);
			//renderTexture = false;
			//-------------------------------------------------------------------------
			
			// If texture is no ready then return.
			return false;
		}
	}
	else if (renderType === 2)
	{
		// Color selction mode.
		var colorAux;
		colorAux = magoManager.selectionColor.getAvailableColor(colorAux);
		var idxKey = magoManager.selectionColor.decodeColor3(colorAux.r, colorAux.g, colorAux.b);
		var currentObjectsRendering = magoManager.renderer.currentObjectsRendering;
		var currentNode = currentObjectsRendering.curNode;
		magoManager.selectionManager.setCandidates(idxKey, undefined, this, neoBuilding, currentNode);
		
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
		gl.uniform4fv(shader.oneColor4_loc, [colorAux.r/255.0, colorAux.g/255.0, colorAux.b/255.0, 1.0]);
	}
	
	return this.lego.render(magoManager, renderType, renderTexture, shader);
};



/**
 * 어떤 일을 하고 있습니까?
 * @param intNumber 변수
 * @returns numDigits
 */
Octree.prototype.renderContent = function(magoManager, neoBuilding, renderType, renderTexture, shader, minSizeToRender, refMatrixIdxKey, flipYTexCoord) 
{
	// the content of the octree is "neoReferencesMotherAndIndices" & the netSurfaceMesh called "lego".
	// This function renders the "neoReferencesMotherAndIndices" or the lego.
	var rendered = false;
	var gl = magoManager.sceneState.gl;

	if (this.lod < 2)
	{
		// 1rst check if the "neoReferencesMotherAndIndices" is ready to be rendered.
		if (this.neoReferencesMotherAndIndices === undefined)
		{ return; }
		gl.uniform1i(shader.textureFlipYAxis_loc, flipYTexCoord);//.ppp
		rendered = this.neoReferencesMotherAndIndices.render(magoManager, neoBuilding, renderType, renderTexture, shader, minSizeToRender, refMatrixIdxKey);
		if (!rendered)
		{
			// render the skinLego.
			rendered = this.renderSkin(magoManager, neoBuilding, renderType, renderTexture, shader);
		}
	}
	else if (this.lod === 2)
	{
		// Render the skinLego.
		rendered = this.renderSkin(magoManager, neoBuilding, renderType, renderTexture, shader);
	}
	
	return rendered;
};

/**
 * Returns the pointsCloud-PartitionsData count to consider for the "lod".
 * @param {Number} lod Level of Detail.
 * @param {Number} realPartitionsCount The real pointsCloud-PartitionsData count.
 * @param {MagoManager} magoManager The main class manager.
 * @returns {Number} pCloudPartitionsCount The pointsCloud-PartitionsData count to consider for the "lod".
 */
Octree.prototype.getPartitionsCountsForLod = function(lod, realPartitionsCount, magoManager) 
{
	var pCloudPartitionsCount =1;
	if (lod === 0)
	{ 
		var pCloudSettings = magoManager.magoPolicy.getPointsCloudSettings();
		pCloudPartitionsCount = realPartitionsCount; 
		if (pCloudPartitionsCount > pCloudSettings.maxPartitionsLod0)
		{ pCloudPartitionsCount = pCloudSettings.maxPartitionsLod0; }
	}
	else if (lod === 1)
	{ 
		var pCloudSettings = magoManager.magoPolicy.getPointsCloudSettings();
		pCloudPartitionsCount = Math.ceil(realPartitionsCount/4); 
		if (pCloudPartitionsCount > pCloudSettings.maxPartitionsLod1)
		{ pCloudPartitionsCount = pCloudSettings.maxPartitionsLod1; }
	}
	else if (lod > 1)
	{ pCloudPartitionsCount = 1; }

	return pCloudPartitionsCount;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param {MagoManager} magoManager Main mago3d manager.
 * @returns {Boolean} Returns if requested the points cloud data.
 */
Octree.prototype.preparePCloudData = function(magoManager) 
{
	if (this.pCloudPartitionsCount === undefined && this.pCloudPartitionsCount === 0)
	{ return false; }

	var neoBuilding = this.neoBuildingOwner;
	if (neoBuilding === undefined)
	{ return false; }

	if (magoManager.processQueue.existOctreeToDeletePCloud(this))
	{ return false; }
	
	if (this.pCloudPartitionsArray === undefined)
	{ this.pCloudPartitionsArray = []; }
	
	var pCloudPartitionsCount = this.getPartitionsCountsForLod(this.lod, this.pCloudPartitionsCount, magoManager);
	
	for (var i=0; i<pCloudPartitionsCount; i++)
	{
		var pCloudPartition = this.pCloudPartitionsArray[i];
		if ( i < this.pCloudPartitionsArray.length)
		{
			// Note: "pCloudPartition" is a Lego class object provisionally.
			if (pCloudPartition !== undefined && pCloudPartition.fileLoadState === CODE.fileLoadState.LOADING_FINISHED)
			{
				// Parse data.
				if (magoManager.parseQueue.pCloudPartitionsParsed < 4)
				{
					var gl = magoManager.sceneState.gl;
					pCloudPartition.parsePointsCloudData(pCloudPartition.dataArrayBuffer, gl, magoManager);
					pCloudPartition.dataArrayBuffer = undefined;
					magoManager.parseQueue.pCloudPartitionsParsed++;
				}
			}
		}
		else
		{
			if (pCloudPartition === undefined )//&& pCloudPartition.fileLoadState === CODE.fileLoadState.READY)
			{
				// Create the pCloudPartition.
				var readWriter = magoManager.readerWriter;
				var pCloudPartitions_requested = 0;
				if (this.octree_level === 0)
				{
					pCloudPartitions_requested = readWriter.pCloudPartitionsMother_requested;
				}
				else 
				{
					pCloudPartitions_requested = readWriter.pCloudPartitions_requested;
				}
				if (pCloudPartitions_requested < 3 && magoManager.vboMemoryManager.currentMemoryUsage < magoManager.vboMemoryManager.buffersKeyWorld.bytesLimit/1.5)
				{
					//var pCloudPartition = this.pCloudPartitionsArray[i];
					var pCloudPartitionLego = new Lego();
					this.pCloudPartitionsArray.push(pCloudPartitionLego);
					pCloudPartitionLego.legoKey = this.octreeKey + "_" + i.toString();
						
					var projectFolderName = neoBuilding.projectFolderName;
					var buildingFolderName = neoBuilding.buildingFileName;
					var geometryDataPath = magoManager.readerWriter.geometryDataPath;
					var subOctreeNumberName = this.octree_number_name.toString();
					var references_folderPath = geometryDataPath + "/" + projectFolderName + "/" + buildingFolderName + "/References";
					var filePath = references_folderPath + "/" + subOctreeNumberName + "_Ref_" + i.toString(); // in this case the fileName is fixed.
						
					readWriter.getOctreePCloudPartitionArraybuffer(filePath, this, pCloudPartitionLego, magoManager);
					return true;
				}
			}
			
		}
	}
	
	return false;
	
};


/**
 * 어떤 일을 하고 있습니까?
 * @param intNumber 변수
 * @returns numDigits
 */
Octree.prototype.test__renderPCloud = function(magoManager, neoBuilding, renderType, shader, relativeCam, bPrepareData) 
{
	// Test function to render octreePyramid-pointsCloud.
	// 1rst, check the number of partitions of data.
	var partitionsCount = this.pCloudPartitionsCount;
	
	if (partitionsCount === undefined || partitionsCount === 0)
	{ return; }
	
	// Determine the distance from camera.
	var magoPolicy = magoManager.magoPolicy;
	var camera = magoManager.sceneState.camera;
	var cullingVolume = relativeCam.bigFrustum;
	
	// To calculate distToCamera use the relativeCamera.
	var cameraPosition = relativeCam.position;
	var distCenterToCamera = this.centerPos.distToPoint(cameraPosition);
	var distToCamera = distCenterToCamera - this.getRadiusAprox();
	this.distToCamera = distToCamera; // distCenterToCamera.
	
	// Put this octree into magoManager.visibleObjControlerPCloudOctrees, to load after. 
	if (renderType === 0) // Note: It can be "renderType === 0" or "renderType === 1". The important is do this only once a frame.
	{
		var vocPCloudOctrees = magoManager.visibleObjControlerPCloudOctrees;
		vocPCloudOctrees.putObjectToArraySortedByDist(vocPCloudOctrees.currentVisibles0, this);
	}
	
	// Provisionally, determine the LOD level by "distToCam".
	this.lod = magoPolicy.getLod(distToCamera);
	
	// Provisionally compare "this.lod" with "this.octreeLevel".
	var gl = magoManager.sceneState.gl;
	var ssao_idx = 1;
	
	var frustumCull = this.intersectionFrustum(cullingVolume, magoManager.boundingSphere_Aux);
	if (frustumCull !== Constant.INTERSECTION_OUTSIDE ) 
	{
		// Erase from deleting queue.
		magoManager.processQueue.eraseOctreeToDeletePCloud(this);
		
		var ssao_idx = 1;
		if (this.pCloudPartitionsArray === undefined)
		{ return; }
		
		var pCloudPartitionsCount = this.getPartitionsCountsForLod(this.lod, this.pCloudPartitionsCount, magoManager);
		var renderChildren = true;
		for (var i=0; i<pCloudPartitionsCount; i++)
		{
			var pCloudPartition = this.pCloudPartitionsArray[i];
			if (pCloudPartition !== undefined && pCloudPartition.fileLoadState === CODE.fileLoadState.PARSE_FINISHED)
			{
				// render.
				var posCompressed = pCloudPartition.bPositionsCompressed;
				gl.uniform1i(shader.bPositionCompressed_loc, posCompressed);
				var bbox = pCloudPartition.bbox;
				gl.uniform3fv(shader.bboxSize_loc, [bbox.getXLength(), bbox.getYLength(), bbox.getZLength()]); //.
				gl.uniform3fv(shader.minPosition_loc, [bbox.minX, bbox.minY, bbox.minZ]); //.
				
				magoManager.renderer.renderPCloud(gl, pCloudPartition, magoManager, shader, renderType, distToCamera, this.lod);
			}
			else 
			{ 
				renderChildren = false;
				break; 
			}
		}
		
		// If lod is higher, the restringe the octree's depth:
		if (this.lod > 2)
		{ renderChildren = false; }
		
		if (this.lod === 2 && this.octree_level > 0)
		{ renderChildren = false; }
		// End restringe rendering by lod distance.-----------------------
		
		if (renderChildren)
		{
			for (var i=0, subOctreesArrayLength = this.subOctrees_array.length; i<subOctreesArrayLength; i++ ) 
			{
				var subOctree = this.subOctrees_array[i];
				subOctree.test__renderPCloud(magoManager, neoBuilding, renderType, shader, relativeCam, bPrepareData);
			}
		}
		
		magoManager.processQueue.eraseOctreeToDeletePCloud(this);
		
	}
	else
	{
		// Delete unnecessary objects if ditToCam is big.
		if (distToCamera > 50.0)
		{
			// Put octree to delete pCloud, but before, delete from the parseQueue.
			if (this.pCloudPartitionsArray !== undefined)
			{
				var pCloudPartitionsCount = this.pCloudPartitionsArray.length;
				for (var i=0; i<pCloudPartitionsCount; i++)
				{
					var pCloudPartition = this.pCloudPartitionsArray[i];
					magoManager.parseQueue.eraseOctreePCloudPartitionToParse(pCloudPartition);
				}
			}
			
			// Put octree to delete pCloud.
			magoManager.processQueue.putOctreeToDeletePCloud(this);
		}
	}
};



/**
 * 어떤 일을 하고 있습니까?
 * @param intNumber 변수
 * @returns numDigits
 */
Octree.prototype.getNumberOfDigits = function(intNumber) 
{
	if (intNumber > 0) 
	{
		var numDigits = Math.floor(Math.log10(intNumber)+1);
		return numDigits;
	}
	else 
	{
		return 1;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Octree.prototype.getMotherOctree = function() 
{
	if (this.octree_owner === undefined) { return this; }

	return this.octree_owner.getMotherOctree();
};

/**
 * 어떤 일을 하고 있습니까?
 * @param octreeNumberName 변수
 * @param numDigits 변수
 * @returns subOctrees_array[idx-1].getOctree(rest_octreeNumberName, numDigits-1)
 */
Octree.prototype.getOctree = function(octreeNumberName, numDigits) 
{
	if (numDigits === 1) 
	{
		if (octreeNumberName === 0) { return this.getMotherOctree(); }
		else { return this.subOctrees_array[octreeNumberName-1]; }
	}

	// determine the next level octree.
	var exp = numDigits-1;
	var denominator = Math.pow(10, exp);
	var idx = Math.floor(octreeNumberName /denominator) % 10;
	var rest_octreeNumberName = octreeNumberName - idx * denominator;
	return this.subOctrees_array[idx-1].getOctree(rest_octreeNumberName, numDigits-1);
};

/**
 * 어떤 일을 하고 있습니까?
 * @param octreeNumberName 변수
 * @returns motherOctree.subOctrees_array[idx-1].getOctree(rest_octreeNumberName, numDigits-1)
 */
Octree.prototype.getOctreeByNumberName = function(octreeNumberName) 
{
	var motherOctree = this.getMotherOctree();
	var numDigits = this.getNumberOfDigits(octreeNumberName);
	if (numDigits === 1) 
	{
		if (octreeNumberName === 0) { return motherOctree; }
		else { return motherOctree.subOctrees_array[octreeNumberName-1]; }
	}

	if (motherOctree.subOctrees_array.length === 0) { return undefined; }

	// determine the next level octree.
	var exp = numDigits-1;
	var denominator = Math.pow(10, exp);
	var idx = Math.floor(octreeNumberName /denominator) % 10;
	var rest_octreeNumberName = octreeNumberName - idx * denominator;
	return motherOctree.subOctrees_array[idx-1].getOctree(rest_octreeNumberName, numDigits-1);
};

/**
 * 어떤 일을 하고 있습니까?
 */
Octree.prototype.setSizesSubBoxes = function() 
{
	// Octree number name.**
	// Bottom                      Top
	// |---------|---------|     |---------|---------|
	// |         |         |     |         |         |       Y
	// |    3    |    2    |     |    7    |    6    |       ^
	// |         |         |     |         |         |       |
	// |---------+---------|     |---------+---------|       |
	// |         |         |     |         |         |       |
	// |    0    |    1    |     |    4    |    5    |       |
	// |         |         |     |         |         |       |-----------> X
	// |---------|---------|     |---------|---------|

	if (this.subOctrees_array.length > 7) 
	{
		var half_x = this.centerPos.x;
		var half_y = this.centerPos.y;
		var half_z = this.centerPos.z;

		var min_x = this.centerPos.x - this.half_dx;
		var min_y = this.centerPos.y - this.half_dy;
		var min_z = this.centerPos.z - this.half_dz;

		var max_x = this.centerPos.x + this.half_dx;
		var max_y = this.centerPos.y + this.half_dy;
		var max_z = this.centerPos.z + this.half_dz;

		this.subOctrees_array[0].setBoxSize(min_x, half_x, min_y, half_y, min_z, half_z);
		this.subOctrees_array[1].setBoxSize(half_x, max_x, min_y, half_y, min_z, half_z);
		this.subOctrees_array[2].setBoxSize(half_x, max_x, half_y, max_y, min_z, half_z);
		this.subOctrees_array[3].setBoxSize(min_x, half_x, half_y, max_y, min_z, half_z);

		this.subOctrees_array[4].setBoxSize(min_x, half_x, min_y, half_y, half_z, max_z);
		this.subOctrees_array[5].setBoxSize(half_x, max_x, min_y, half_y, half_z, max_z);
		this.subOctrees_array[6].setBoxSize(half_x, max_x, half_y, max_y, half_z, max_z);
		this.subOctrees_array[7].setBoxSize(min_x, half_x, half_y, max_y, half_z, max_z);
		
		var subOctreesCount = this.subOctrees_array.length; // must be 8.
		for (var i=0; i<subOctreesCount; i++) 
		{
			this.subOctrees_array[i].setSizesSubBoxes();
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param Min_x 변수
 * @param Max_x 변수
 * @param Min_y 변수
 * @param Max_y 변수
 * @param Min_z 변수
 * @param Max_z 변수
 */
Octree.prototype.setBoxSize = function(Min_X, Max_X, Min_Y, Max_Y, Min_Z, Max_Z) 
{
	this.centerPos.x = (Max_X + Min_X)/2.0;
	this.centerPos.y = (Max_Y + Min_Y)/2.0;
	this.centerPos.z = (Max_Z + Min_Z)/2.0;

	this.half_dx = (Max_X - Min_X)/2.0; // half width.
	this.half_dy = (Max_Y - Min_Y)/2.0; // half length.
	this.half_dz = (Max_Z - Min_Z)/2.0; // half height.
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns centerPos
 */
Octree.prototype.getCenterPos = function() 
{
	return this.centerPos;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns Math.abs(this.half_dx*1.2);
 */
Octree.prototype.getRadiusAprox = function() 
{
	return this.half_dx*1.7;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param cullingVolume 변수
 * @param result_NeoRefListsArray 변수
 * @param boundingSphere_scratch 변수
 * @param eye_x 변수
 * @param eye_y 변수
 * @param eye_z 변수
 */
Octree.prototype.getFrustumVisibleLowestOctreesByLOD = function(cullingVolume, visibleObjControlerOctrees, globalVisibleObjControlerOctrees,
	boundingSphere_scratch, cameraPosition, squaredDistLod0, squaredDistLod1, squaredDistLod2) 
{
	var visibleOctreesArray = [];
	var find = false;

	//this.getAllSubOctrees(visibleOctreesArray); // Test.
	visibleOctreesArray = this.getFrustumVisibleOctreesNeoBuildingAsimetricVersion(cullingVolume, visibleOctreesArray, boundingSphere_scratch); // Original.

	// Now, we must sort the subOctrees near->far from eye.
	var visibleOctrees_count = visibleOctreesArray.length;
	for (var i=0; i<visibleOctrees_count; i++) 
	{
		visibleOctreesArray[i].setDistToCamera(cameraPosition);
	}

	for (var i=0; i<visibleOctrees_count; i++) 
	{
		if (visibleOctreesArray[i].distToCamera < squaredDistLod0) 
		{
			if (visibleOctreesArray[i].triPolyhedronsCount > 0) 
			{
				if (globalVisibleObjControlerOctrees)
				{ this.putOctreeInEyeDistanceSortedArray(globalVisibleObjControlerOctrees.currentVisibles0, visibleOctreesArray[i]); }
				visibleObjControlerOctrees.currentVisibles0.push(visibleOctreesArray[i]);
				visibleOctreesArray[i].lod = 0;
				find = true;
			}
		}
		else if (visibleOctreesArray[i].distToCamera < squaredDistLod1) 
		{
			if (visibleOctreesArray[i].triPolyhedronsCount > 0) 
			{
				if (globalVisibleObjControlerOctrees)
				{ this.putOctreeInEyeDistanceSortedArray(globalVisibleObjControlerOctrees.currentVisibles1, visibleOctreesArray[i]); }
				visibleObjControlerOctrees.currentVisibles1.push(visibleOctreesArray[i]);
				visibleOctreesArray[i].lod = 1;
				find = true;
			}
		}
		else if (visibleOctreesArray[i].distToCamera < squaredDistLod2) 
		{
			if (visibleOctreesArray[i].triPolyhedronsCount > 0) 
			{
				if (globalVisibleObjControlerOctrees)
				{ this.putOctreeInEyeDistanceSortedArray(globalVisibleObjControlerOctrees.currentVisibles2, visibleOctreesArray[i]); }
				visibleObjControlerOctrees.currentVisibles2.push(visibleOctreesArray[i]);
				visibleOctreesArray[i].lod = 2;
				find = true;
			}
		}
		else 
		{
			if (visibleOctreesArray[i].triPolyhedronsCount > 0) 
			{
				if (globalVisibleObjControlerOctrees)
				{ globalVisibleObjControlerOctrees.currentVisibles3.push(visibleOctreesArray[i]); }
				visibleObjControlerOctrees.currentVisibles3.push(visibleOctreesArray[i]);
				visibleOctreesArray[i].lod = 3; // must be 3!!!
				find = true;
			}
		}
	}

	visibleOctreesArray = undefined;
	return find;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 * @returns intersects
 */
Octree.prototype.getBoundingBox = function(resultBbox) 
{
	if (resultBbox === undefined)
	{ resultBbox = new BoundingBox(); }
	 
	resultBbox.set(this.centerPos.x - this.half_dx, this.centerPos.y - this.half_dy, this.centerPos.z - this.half_dz, 
		this.centerPos.x + this.half_dx, this.centerPos.y + this.half_dy, this.centerPos.z + this.half_dz);
	
	return resultBbox;
};


/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 * @returns intersects
 */
Octree.prototype.intersectsWithTriangle = function(triangle) 
{
	if (triangle === undefined)
	{ return false; }
	
	// 1) Check if triangle's bbox intersects with this octree.
	var myBbox = this.getBoundingBox();
	
	
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 * @returns intersects
 */
Octree.prototype.intersectsWithPoint3D = function(x, y, z) 
{
	//this.centerPos = new Point3D();
	//this.half_dx = 0.0; // half width.
	//this.half_dy = 0.0; // half length.
	//this.half_dz = 0.0; // half height.
	var minX = this.centerPos.x - this.half_dx;
	var minY = this.centerPos.y - this.half_dz;
	var minZ = this.centerPos.z - this.half_dz;
	var maxX = this.centerPos.x + this.half_dx;
	var maxY = this.centerPos.y + this.half_dz;
	var maxZ = this.centerPos.z + this.half_dz;
	
	var intersects = false;
	if (x> minX && x<maxX) 
	{
		if (y> minY && y<maxY) 
		{
			if (z> minZ && z<maxZ) 
			{
				intersects = true;
			}
		}
	}
	
	return intersects;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 * @returns intersectedSubBox
 */
Octree.prototype.getIntersectedSubBoxByPoint3D = function(x, y, z) 
{
	if (this.octree_owner === undefined) 
	{
		// This is the mother_cell.
		if (!this.intersectsWithPoint3D(x, y, z)) 
		{
			return false;
		}
	}
	
	var intersectedSubBox = undefined;
	var subBoxes_count = this.subOctrees_array.length;
	if (subBoxes_count > 0) 
	{
		var center_x = this.centerPos.x;
		var center_y = this.centerPos.y;
		var center_z = this.centerPos.z;
		
		var intersectedSubBox_aux = undefined;
		var intersectedSubBox_idx;
		if (x<center_x) 
		{
			// Here are the boxes number 0, 3, 4, 7.
			if (y<center_y) 
			{
				// Here are 0, 4.
				if (z<center_z) { intersectedSubBox_idx = 0; }
				else { intersectedSubBox_idx = 4; }
			}
			else 
			{
				// Here are 3, 7.
				if (z<center_z) { intersectedSubBox_idx = 3; }
				else { intersectedSubBox_idx = 7; }
			}
		}
		else 
		{
			// Here are the boxes number 1, 2, 5, 6.
			if (y<center_y) 
			{
				// Here are 1, 5.
				if (z<center_z) { intersectedSubBox_idx = 1; }
				else { intersectedSubBox_idx = 5; }
			}
			else 
			{
				// Here are 2, 6.
				if (z<center_z) { intersectedSubBox_idx = 2; }
				else { intersectedSubBox_idx = 6; }
			}
		}
		
		intersectedSubBox_aux = this.subOctrees_array[intersectedSubBox_idx];
		intersectedSubBox = intersectedSubBox_aux.getIntersectedSubBoxByPoint3D(x, y, z);
		
	}
	else 
	{
		intersectedSubBox = this;
	}
	
	return intersectedSubBox;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Octree.prototype.getMinDistToCamera = function(cameraPosition)
{
	// Old function. dont use this function.
	// Old function. dont use this function.
	// Old function. dont use this function.
	// this function returns the minDistToCamera of the lowestOctrees.
	var minDistToCam = 1000000.0;
	
	if (this.lowestOctrees_array === undefined)
	{
		this.lowestOctrees_array = [];
		this.extractLowestOctreesIfHasTriPolyhedrons(this.lowestOctrees_array);
	}
	
	var distToCamera;
	var lowestOctree;
	var lowestOctreesCount = this.lowestOctrees_array.length;
	for (var i=0; i<lowestOctreesCount; i++)
	{
		lowestOctree = this.lowestOctrees_array[i];
		distToCamera = lowestOctree.centerPos.distToPoint(cameraPosition) - this.getRadiusAprox();
		if (distToCamera < minDistToCam)
		{ minDistToCam = distToCamera; }
	}
	
	return minDistToCam;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param cullingVolume 변수
 * @param result_NeoRefListsArray 변수
 * @param boundingSphere_scratch 변수
 * @param eye_x 변수
 * @param eye_y 변수
 * @param eye_z 변수
 */
Octree.prototype.extractLowestOctreesByLOD = function(visibleObjControlerOctrees, globalVisibleObjControlerOctrees,
	boundingSphere_scratch, cameraPosition, squaredDistLod0, squaredDistLod1, squaredDistLod2 ) 
{
	var distAux = 0.0;
	var find = false;
	
	var eye_x = cameraPosition.x;
	var eye_y = cameraPosition.y;
	var eye_z = cameraPosition.z;
	if (this.lowestOctrees_array === undefined)
	{
		this.lowestOctrees_array = [];
		this.extractLowestOctreesIfHasTriPolyhedrons(this.lowestOctrees_array);
	}
	
	// Now, we must sort the subOctrees near->far from eye.
	var visibleOctrees_count = this.lowestOctrees_array.length;
	for (var i=0; i<visibleOctrees_count; i++) 
	{
		this.lowestOctrees_array[i].setDistToCamera(cameraPosition);
	}

	for (var i=0; i<visibleOctrees_count; i++) 
	{
		if (this.lowestOctrees_array[i].distToCamera < squaredDistLod0) 
		{
			if (this.lowestOctrees_array[i].triPolyhedronsCount > 0) 
			{
				if (globalVisibleObjControlerOctrees)
				{ this.putOctreeInEyeDistanceSortedArray(globalVisibleObjControlerOctrees.currentVisibles0, this.lowestOctrees_array[i]); }
				visibleObjControlerOctrees.currentVisibles0.push(this.lowestOctrees_array[i]);
				this.lowestOctrees_array[i].lod = 0;
				find = true;
			}
		}
		else if (this.lowestOctrees_array[i].distToCamera < squaredDistLod1) 
		{
			if (this.lowestOctrees_array[i].triPolyhedronsCount > 0) 
			{
				if (globalVisibleObjControlerOctrees)
				{ this.putOctreeInEyeDistanceSortedArray(globalVisibleObjControlerOctrees.currentVisibles1, this.lowestOctrees_array[i]); }
				visibleObjControlerOctrees.currentVisibles1.push(this.lowestOctrees_array[i]);
				this.lowestOctrees_array[i].lod = 1;
				find = true;
			}
		}
		else if (this.lowestOctrees_array[i].distToCamera < squaredDistLod2) 
		{
			if (this.lowestOctrees_array[i].triPolyhedronsCount > 0) 
			{
				if (globalVisibleObjControlerOctrees)
				{ this.putOctreeInEyeDistanceSortedArray(globalVisibleObjControlerOctrees.currentVisibles2, this.lowestOctrees_array[i]); }
				visibleObjControlerOctrees.currentVisibles2.push(this.lowestOctrees_array[i]);
				this.lowestOctrees_array[i].lod = 2;
				find = true;
			}
		}
		else 
		{
			if (this.lowestOctrees_array[i].triPolyhedronsCount > 0) 
			{
				if (globalVisibleObjControlerOctrees)
				{ globalVisibleObjControlerOctrees.currentVisibles3.push(this.lowestOctrees_array[i]); }
				visibleObjControlerOctrees.currentVisibles3.push(this.lowestOctrees_array[i]);
				this.lowestOctrees_array[i].lod = 3;
				find = true;
			}
		}
	}

	return find;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param cesium_cullingVolume 변수
 * @param result_octreesArray 변수
 * @param boundingSphere_scratch 변수
 */
Octree.prototype.intersectionFrustum = function(cullingVolume, boundingSphere_scratch) 
{
	if (boundingSphere_scratch === undefined) 
	{ boundingSphere_scratch = new Sphere(); } 

	boundingSphere_scratch.centerPoint.x = this.centerPos.x;
	boundingSphere_scratch.centerPoint.y = this.centerPos.y;
	boundingSphere_scratch.centerPoint.z = this.centerPos.z;
	boundingSphere_scratch.r = this.getRadiusAprox();

	return cullingVolume.intersectionSphere(boundingSphere_scratch);
};


/**
 * 어떤 일을 하고 있습니까?
 * @param cesium_cullingVolume 변수
 * @param result_octreesArray 변수
 * @param boundingSphere_scratch 변수
 */
Octree.prototype.getFrustumVisibleOctreesNeoBuildingAsimetricVersion = function(cullingVolume, result_octreesArray, boundingSphere_scratch) 
{
	// cullingVolume: Frustum class.
	if (this.subOctrees_array === undefined) { return; }

	if (this.subOctrees_array.length === 0 && this.triPolyhedronsCount === 0)
	{ return; }

	if (result_octreesArray === undefined) { result_octreesArray = []; }

	var frustumCull = this.intersectionFrustum(cullingVolume, boundingSphere_scratch);
	if (frustumCull === Constant.INTERSECTION_INSIDE ) 
	{
		this.getAllSubOctreesIfHasRefLists(result_octreesArray);
	}
	else if (frustumCull === Constant.INTERSECTION_INTERSECT  ) 
	{
		if (this.subOctrees_array.length === 0) 
		{
			result_octreesArray.push(this);
		}
		else 
		{
			for (var i=0, subOctreesArrayLength = this.subOctrees_array.length; i<subOctreesArrayLength; i++ ) 
			{
				this.subOctrees_array[i].getFrustumVisibleOctreesNeoBuildingAsimetricVersion(cullingVolume, result_octreesArray, boundingSphere_scratch);
			}
		}
	}
	
	return result_octreesArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param cesium_cullingVolume 변수
 * @param result_octreesArray 변수
 * @param boundingSphere_scratch 변수
 */
Octree.prototype.getBBoxIntersectedOctreesNeoBuildingAsimetricVersion = function(bbox, result_octreesArray, bbox_scratch) 
{
	if (this.subOctrees_array === undefined) { return; }

	if (this.subOctrees_array.length === 0 && this.triPolyhedronsCount === 0)
	{ return; }

	if (result_octreesArray === undefined) { result_octreesArray = []; }
	
	if (bbox_scratch === undefined) 
	{ bbox_scratch = new BoundingBox(); } 
	

	bbox_scratch.minX = this.centerPos.x - this.half_dx;
	bbox_scratch.maxX = this.centerPos.x + this.half_dx;
	bbox_scratch.minY = this.centerPos.y - this.half_dy;
	bbox_scratch.maxY = this.centerPos.y + this.half_dy;
	bbox_scratch.minZ = this.centerPos.z - this.half_dz;
	bbox_scratch.maxZ = this.centerPos.z + this.half_dz;

	var intersects = bbox.intersectsWithBBox(bbox_scratch);
	if (intersects)
	{
		this.getAllSubOctreesIfHasRefLists(result_octreesArray);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param eye_x 변수
 * @param eye_y 변수
 * @param eye_z 변수
 */
Octree.prototype.setDistToCamera = function(cameraPosition) 
{
	// distance to camera as a sphere.
	var distToCamera = this.centerPos.distToPoint(cameraPosition) - this.getRadiusAprox();
	this.distToCamera = distToCamera;
	return distToCamera;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param result_octreesArray 변수
 * @param octree 변수
 */
Octree.prototype.putOctreeInEyeDistanceSortedArray = function(result_octreesArray, octree) 
{
	// sorting is from minDist to maxDist.
	if (result_octreesArray.length > 0)
	{
		var startIdx = 0;
		var endIdx = result_octreesArray.length - 1;
		var insert_idx= ManagerUtils.getIndexToInsertBySquaredDistToEye(result_octreesArray, octree, startIdx, endIdx);

		result_octreesArray.splice(insert_idx, 0, octree);
	}
	else 
	{
		result_octreesArray.push(octree);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param result_octreesArray 변수
 */
Octree.prototype.getAllSubOctreesIfHasRefLists = function(result_octreesArray) 
{
	if (this.subOctrees_array === undefined) { return; }

	if (result_octreesArray === undefined) { result_octreesArray = []; }

	if (this.subOctrees_array.length > 0) 
	{
		for (var i=0, subOctreesArrayLength = this.subOctrees_array.length; i<subOctreesArrayLength; i++) 
		{
			this.subOctrees_array[i].getAllSubOctreesIfHasRefLists(result_octreesArray);
		}
	}
	else 
	{
		if (this.triPolyhedronsCount > 0) { result_octreesArray.push(this); } // there are only 1.
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param result_octreesArray 변수
 */
Octree.prototype.getAllSubOctrees = function(result_octreesArray) 
{
	if (result_octreesArray === undefined) { result_octreesArray = []; }

	if (this.subOctrees_array.length > 0) 
	{
		for (var i=0, subOctreesArrayLength = this.subOctrees_array.length; i<subOctreesArrayLength; i++) 
		{
			this.subOctrees_array[i].getAllSubOctrees(result_octreesArray);
		}
	}
	else 
	{
		result_octreesArray.push(this); // there are only 1.
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param result_octreesArray 변수
 */
Octree.prototype.extractLowestOctreesIfHasTriPolyhedrons = function(lowestOctreesArray) 
{
	if (this.subOctrees_array === undefined)
	{ return; }
	
	var subOctreesCount = this.subOctrees_array.length;

	if (subOctreesCount === 0 && this.triPolyhedronsCount > 0) 
	{
		lowestOctreesArray.push(this);
	}
	else 
	{
		for (var i=0; i<subOctreesCount; i++) 
		{
			this.subOctrees_array[i].extractLowestOctreesIfHasTriPolyhedrons(lowestOctreesArray);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param result_octreesArray 변수
 */
Octree.prototype.multiplyKeyTransformMatrix = function(idxKey, matrix) 
{
	var subOctreesCount = this.subOctrees_array.length;

	if (subOctreesCount === 0 && this.triPolyhedronsCount > 0) 
	{
		if (this.neoReferencesMotherAndIndices)
		{ this.neoReferencesMotherAndIndices.multiplyKeyTransformMatrix(idxKey, matrix); }
	}
	else 
	{
		for (var i=0; i<subOctreesCount; i++) 
		{
			this.subOctrees_array[i].multiplyKeyTransformMatrix(idxKey, matrix);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param result_octreesArray 변수
 */
Octree.prototype.parseAsimetricVersion = function(arrayBuffer, bytesReaded, neoBuildingOwner) 
{
	// Check the metaData version.
	var version = neoBuildingOwner.getHeaderVersion();
	
	
	var octreeLevel = ReaderWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;

	if (octreeLevel === 0) 
	{
		// this is the mother octree, so read the mother octree's size.
		var minX = ReaderWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var maxX = ReaderWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var minY = ReaderWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var maxY = ReaderWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var minZ = ReaderWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var maxZ = ReaderWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;

		this.setBoxSize(minX, maxX, minY, maxY, minZ, maxZ );
		this.octree_number_name = 0;
	}

	var subOctreesCount = ReaderWriter.readUInt8(arrayBuffer, bytesReaded, bytesReaded+1); bytesReaded += 1; // this must be 0 or 8.
	this.triPolyhedronsCount = ReaderWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
	if (this.triPolyhedronsCount > 0)
	{ this.neoBuildingOwner = neoBuildingOwner; }

	///if (version === "0.0.2")
	///{
	/// Read ModelLists partitions count.
	///this.blocksListsPartitionsCount = ReaderWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
	///}

	// 1rst, create the 8 subOctrees.
	if (subOctreesCount > 0)
	{ this.createChildren(); }

	for (var i=0; i<subOctreesCount; i++) 
	{
		var subOctree = this.subOctrees_array[i];
		bytesReaded = subOctree.parseAsimetricVersion(arrayBuffer, bytesReaded, neoBuildingOwner);
	}

	return bytesReaded;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param result_octreesArray 변수
 */
Octree.prototype.parsePyramidVersion = function(arrayBuffer, bytesReaded, neoBuildingOwner) 
{
	var octreeLevel = ReaderWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;

	if (octreeLevel === 0) 
	{
		// this is the mother octree, so read the mother octree's size.
		var minX = ReaderWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var maxX = ReaderWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var minY = ReaderWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var maxY = ReaderWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var minZ = ReaderWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		var maxZ = ReaderWriter.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;

		this.setBoxSize(minX, maxX, minY, maxY, minZ, maxZ );
		this.octree_number_name = 0;
	}

	var subOctreesCount = ReaderWriter.readUInt8(arrayBuffer, bytesReaded, bytesReaded+1); bytesReaded += 1; // this must be 0 or 8.
	this.triPolyhedronsCount = ReaderWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
	if (this.triPolyhedronsCount > 0)
	{ this.neoBuildingOwner = neoBuildingOwner; }

	// Now, read verticesArray partitions count.
	this.pCloudPartitionsCount = ReaderWriter.readInt32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;

	// 1rst, create the 8 subOctrees.
	for (var i=0; i<subOctreesCount; i++) 
	{
		var subOctree = this.new_subOctree();
		subOctree.octree_number_name = this.octree_number_name * 10 + (i+1);
		subOctree.neoBuildingOwnerId = this.neoBuildingOwnerId;
		subOctree.octreeKey = this.neoBuildingOwnerId + "_" + subOctree.octree_number_name;
	}

	// now, set size of subOctrees.
	this.setSizesSubBoxes();

	for (var i=0; i<subOctreesCount; i++) 
	{
		var subOctree = this.subOctrees_array[i];
		bytesReaded = subOctree.parsePyramidVersion(arrayBuffer, bytesReaded, neoBuildingOwner);
	}

	return bytesReaded;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Octree.prototype.getDistToCamera = function(cameraPosition, boundingSphere_Aux) 
{
	boundingSphere_Aux.setCenterPoint(this.centerPos.x, this.centerPos.y, this.centerPos.z);
	boundingSphere_Aux.setRadius(this.getRadiusAprox());
	return cameraPosition.distToSphere(boundingSphere_Aux);
};

/**
 * 어떤 일을 하고 있습니까?
 */
Octree.prototype.getMinDistToCameraInTree = function(cameraPosition, boundingSphere_Aux, octreesMaxSize) 
{
	// If this octree size > octreesMaxSize -> down in tree.
	var octreeSize = this.getRadiusAprox();
	var subOctreesCount = this.subOctrees_array.length;
	var dist;
	if (octreeSize > octreesMaxSize && subOctreesCount > 0)
	{
		// Calculate the nearest subOctree to camera.
		var currDist;
		var distCandidate;
		var subOctreeCandidate;
		for (var i=0; i<subOctreesCount; i++)
		{
			// Check if subOctree has content.
			var hasContent = false;
			var subOctree = this.subOctrees_array[i];
			if (subOctree.pCloudPartitionsCount && subOctree.pCloudPartitionsCount > 0)
			{ hasContent = true; }
			if (subOctree.triPolyhedronsCount && subOctree.triPolyhedronsCount > 0)
			{ hasContent = true; }
			
			if (!hasContent)
			{ continue; }
			
			//currDist = subOctree.getDistToCamera(cameraPosition, boundingSphere_Aux); // original.
			currDist = subOctree.centerPos.squareDistToPoint(cameraPosition); // test.
			if (distCandidate === undefined) 
			{
				distCandidate = currDist;
				subOctreeCandidate = subOctree;
			}
			else 
			{
				if (currDist < distCandidate)
				{
					distCandidate = currDist;
					subOctreeCandidate = subOctree;
				}
			}
		}
		
		if (subOctreeCandidate)
		{
			return subOctreeCandidate.getMinDistToCameraInTree(cameraPosition, boundingSphere_Aux, octreesMaxSize);
		}
	}
	else 
	{
		//dist = this.getDistToCamera(cameraPosition, boundingSphere_Aux); // original.
		dist = this.centerPos.distToPoint(cameraPosition); // test.
	}
	
	return dist;
};

































'use strict';

/**
 * ParseQueue
 * 
 * @alias ParseQueue
 * @class ParseQueue
 */
var ParseQueue = function() 
{
	if (!(this instanceof ParseQueue)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	// General objects.
	this.objectsToParseMap = {};
	
	// Particular objects.
	this.octreesLod0ReferencesToParseMap = {};
	this.octreesLod0ModelsToParseMap = {};
	this.octreesLod2LegosToParseMap = {};
	this.octreesPCloudToParseMap = {};
	this.octreesPCloudPartitionToParseMap = {}; 
	this.skinLegosToParseMap = {};
	this.tinTerrainsToParseMap = {};
	this.multiBuildingsToParseMap = {};
	
	this.maxNumParses = 10; // default 1.***
	
	// parse counters.***
	this.smartTileF4dParsesCount = 0;
	
	// Test for pCloudPartitions.***
	this.pCloudPartitionsParsed = 0;
	
	// Auxiliar vars.
	this.lowlodMeshesParsed = 0;

};

ParseQueue.prototype.putMultiBuildingsToParse = function(multiBuildings, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }
	
	this.multiBuildingsToParseMap[multiBuildings.id] = multiBuildings;
};

ParseQueue.prototype.eraseMultiBuildingsToParse = function(multiBuildings)
{
	if (multiBuildings === undefined)
	{ return; }
	
	var key = multiBuildings.id;
	if (this.multiBuildingsToParseMap.hasOwnProperty(key)) 
	{
		delete this.multiBuildingsToParseMap[key];
		return true;
	}
	return false;
};


ParseQueue.prototype.putTinTerrainToParse = function(tinTerrain, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }
	
	this.tinTerrainsToParseMap[tinTerrain.getPathName()] = tinTerrain;
};

ParseQueue.prototype.eraseTinTerrainToParse = function(tinTerrain)
{
	if (tinTerrain === undefined)
	{ return; }
	
	var key = tinTerrain.getPathName();
	if (this.tinTerrainsToParseMap.hasOwnProperty(key)) 
	{
		delete this.tinTerrainsToParseMap[key];
		return true;
	}
	return false;
};

ParseQueue.prototype.parseMultiBuildings = function(gl, nodesArray, magoManager)
{
	if (Object.keys(this.multiBuildingsToParseMap).length > 0)
	{
		var node;
		var maxParsesCount = this.maxNumParses;
		var nodesCount = nodesArray.length;
		for (var i=0; i<nodesCount; i++)
		{
			node = nodesArray[i];
			var multiBuildings = node.data.multiBuildings;
			if (this.eraseMultiBuildingsToParse(multiBuildings))
			{
				multiBuildings.parseData(magoManager);
			}
		}
	}
};

ParseQueue.prototype.parseArraySkins = function(gl, nodesArray, magoManager)
{
	if (Object.keys(this.skinLegosToParseMap).length > 0)
	{
		var node;
		var skinLego;
		var neoBuilding;
		var skinsParsedCount = 0;
		var maxParsesCount = this.maxNumParses;
		
		maxParsesCount = 50;
		
		var lod3buildingsCount = nodesArray.length;
		for (var i=0; i<lod3buildingsCount; i++)
		{
			node = nodesArray[i];
			neoBuilding = node.data.neoBuilding;
			
			if (neoBuilding === undefined || neoBuilding.lodMeshesMap === undefined)
			{ continue; }
		
		    // check the current lod of the building.***
			var currentBuildingLod = neoBuilding.currentLod;
			var lodIdx = currentBuildingLod;
			
			if (lodIdx < 0)
			{ continue; }// old.***
		
			var lodString = undefined;
			if (currentBuildingLod === 0)
			{ lodString = "lod0"; }
			else if (currentBuildingLod === 1)
			{ lodString = "lod1"; }
			else if (currentBuildingLod === 2)
			{ lodString = "lod2"; }
			else if (currentBuildingLod === 3)
			{ lodString = "lod3"; }
			else if (currentBuildingLod === 4)
			{ lodString = "lod4"; }
			else if (currentBuildingLod === 5)
			{ lodString = "lod5"; }

			if (lodString === undefined)
			{ continue; }
			
			///skinLego = neoBuilding.lodMeshesMap.get(lodString);
			//skinLego = neoBuilding.lodMeshesMap[lodString];
			skinLego = neoBuilding.getLowerSkinLodToLoad(currentBuildingLod);
			
			if (skinLego === undefined)
			{ continue; }
			
			if (this.eraseSkinLegosToParse(skinLego))
			{
				skinLego.parseArrayBuffer(skinLego.dataArrayBuffer, magoManager);
				skinLego.dataArrayBuffer = undefined;
				
				/*if (!node.data.onlyPosDataArray && skinLego.vbo_vicks_container.getVbosCount() > 0) 
				{
					var posDataArray = skinLego.vbo_vicks_container.getVboKey(0).vboBufferPos.dataArray;
					node.data.onlyPosDataArray = posDataArray;
				}*/
				
				skinsParsedCount++;
			}
			if (skinsParsedCount > maxParsesCount)
			{ break; }
		}
		
		//if (skinsParsedCount === 0)
		{
			for (var key in this.skinLegosToParseMap)
			{
				if (Object.prototype.hasOwnProperty.call(this.skinLegosToParseMap, key))
				{
					skinLego = this.skinLegosToParseMap[key];
				
					if (skinLego === undefined)
					{ continue; }
					if (this.eraseSkinLegosToParse(skinLego))
					{
						skinLego.parseArrayBuffer(skinLego.dataArrayBuffer, magoManager);
						skinLego.dataArrayBuffer = undefined;
						/*var neoBuildingOwner = skinLego.owner;
						var node = neoBuildingOwner.nodeOwner;

						if (!node.data.onlyPosDataArray && skinLego.vbo_vicks_container.getVbosCount() > 0) 
						{
							var posDataArray = skinLego.vbo_vicks_container.getVboKey(0).vboBufferPos.dataArray;
							node.data.onlyPosDataArray = posDataArray;
						}*/

						skinsParsedCount++;
					}
					if (skinsParsedCount > maxParsesCount)
					{ break; }	
				}
			}
		}
		
		
	}
};

ParseQueue.prototype.parseArrayOctreesPCloud = function(gl, octreesArray, magoManager)
{
	// Test function.***
	if (Object.keys(this.octreesPCloudToParseMap).length > 0)
	{
		var maxParsesCount = this.maxNumParses;
		var octreesParsedCount = 0;
		var lowestOctree;
		
		var octreesLod0Count = octreesArray.length;
		for (var i=0; i<octreesLod0Count; i++)
		{
			lowestOctree = octreesArray[i];
			if (this.eraseOctreePCloudToParse(lowestOctree))
			{
				if (lowestOctree.lego === undefined)
				{ continue; }
				
				lowestOctree.lego.parsePointsCloudData(gl, lowestOctree.lego.dataArrayBuffer, magoManager);
				lowestOctree.lego.dataArrayBuffer = undefined;
				
				octreesParsedCount++;
			}
			if (octreesParsedCount > maxParsesCount)
			{ break; }
		}
		
		if (octreesParsedCount === 0)
		{
			for (var key in this.octreesPCloudToParseMap)
			{
				if (Object.prototype.hasOwnProperty.call(this.octreesPCloudToParseMap, key))
				{
					lowestOctree = this.octreesPCloudToParseMap[key];
					if (this.eraseOctreePCloudToParse(lowestOctree))
					{
						if (lowestOctree.lego === undefined)
						{ continue; }
						
						lowestOctree.lego.parsePointsCloudData(lowestOctree.lego.dataArrayBuffer, gl, magoManager);
						lowestOctree.lego.dataArrayBuffer = undefined;
						
						octreesParsedCount++;
					}
					if (octreesParsedCount > maxParsesCount)
					{ break; }	
				}
				
			}
		}
		
		if (octreesParsedCount > 0)
		{
			if (this.selectionFbo)
			{ this.selectionFbo.dirty = true; }
		}
	}
};

ParseQueue.prototype.parseArrayOctreesPCloudPartition = function(gl, octreesArray, magoManager)
{
	// Test function.***
	if (Object.keys(this.octreesPCloudPartitionToParseMap).length > 0)
	{
		var maxParsesCount = this.maxNumParses;
		var octreesParsedCount = 0;
		var lowestOctree;
		
		var octreesLod0Count = octreesArray.length;
		for (var i=0; i<octreesLod0Count; i++)
		{
			lowestOctree = octreesArray[i];
			
			// Check if has pCloudPartitions.***
			if (lowestOctree.pCloudPartitionsArray === undefined)
			{ continue; }
			
			var pCloudPartitionsCount = lowestOctree.pCloudPartitionsArray.length;
			for (var j=0; j<pCloudPartitionsCount; j++)
			{
				var pCloudPartition = lowestOctree.pCloudPartitionsArray[j];
				if (this.eraseOctreePCloudPartitionToParse(pCloudPartition))
				{
					pCloudPartition.parsePointsCloudData(gl, pCloudPartition.dataArrayBuffer, magoManager);
					pCloudPartition.dataArrayBuffer = undefined;
					octreesParsedCount++;
				}
			}
			
			//if (this.eraseOctreePCloudPartitionToParse(lowestOctree))
			//{
			//if (lowestOctree.lego === undefined)
			//{ continue; }
				
			//lowestOctree.lego.parsePointsCloudData(gl, lowestOctree.lego.dataArrayBuffer, magoManager);
			//lowestOctree.lego.dataArrayBuffer = undefined;
				
			//octreesParsedCount++;
			//}
			if (octreesParsedCount > maxParsesCount)
			{ break; }
		}
		
		if (octreesParsedCount === 0)
		{
			for (var key in this.octreesPCloudPartitionToParseMap)
			{
				if (Object.prototype.hasOwnProperty.call(this.octreesPCloudPartitionToParseMap, key))
				{
					lowestOctree = this.octreesPCloudPartitionToParseMap[key];
					if (this.eraseOctreePCloudPartitionToParse(lowestOctree))
					{
						//if (lowestOctree.lego === undefined)
						//{ continue; }
						
						pCloudPartition.parsePointsCloudData(gl, pCloudPartition.dataArrayBuffer, magoManager);
						pCloudPartition.dataArrayBuffer = undefined;
						octreesParsedCount++;
					}
					if (octreesParsedCount > maxParsesCount)
					{ break; }	
				}
			}
		}
		
		if (octreesParsedCount > 0)
		{
			if (this.selectionFbo)
			{ this.selectionFbo.dirty = true; }
		}
	}
};

ParseQueue.prototype.parseArrayOctreesLod2Legos = function(gl, octreesArray, magoManager)
{
	if (Object.keys(this.octreesLod2LegosToParseMap).length > 0)
	{
		var maxParsesCount = this.maxNumParses;
		var octreesParsedCount = 0;
		var lowestOctree;
	
		var octreesLod0Count = octreesArray.length;
		for (var i=0; i<octreesLod0Count; i++)
		{
			lowestOctree = octreesArray[i];
			if (this.eraseOctreeLod2LegosToParse(lowestOctree))
			{
				if (lowestOctree.lego === undefined)
				{ continue; }
				
				lowestOctree.lego.parseArrayBuffer(lowestOctree.lego.dataArrayBuffer, magoManager);
				lowestOctree.lego.dataArrayBuffer = undefined;
				
				octreesParsedCount++;
			}
			if (octreesParsedCount > maxParsesCount)
			{ break; }
		}
		/*
		if (octreesParsedCount === 0)
		{
			for (var key in this.octreesLod2LegosToParseMap)
			{
				var lowestOctree = this.octreesLod2LegosToParseMap[key];
				if(this.eraseOctreeLod2LegosToParse(lowestOctree))
				{
					if (lowestOctree.lego === undefined)
					{ continue; }
					
					lowestOctree.lego.parseArrayBuffer(lowestOctree.lego.dataArrayBuffer, magoManager);
					lowestOctree.lego.dataArrayBuffer = undefined;
					
					octreesParsedCount++;
				}
				if (octreesParsedCount > maxParsesCount)
				{ break; }	

			}
		}
		*/
		if (octreesParsedCount > 0)
		{
			if (magoManager.selectionFbo)
			{ magoManager.selectionFbo.dirty = true; }
		}
	}
};

ParseQueue.parseArrayOctreesLod0Models = function(lowestOctree, magoManager)
{
	if (lowestOctree.neoReferencesMotherAndIndices === undefined)
	{ return; }
	
	var blocksList = lowestOctree.neoReferencesMotherAndIndices.blocksList;
	if (blocksList === undefined)
	{ return; }
	
	var neoBuilding = lowestOctree.neoBuildingOwner;
	var headerVersion = neoBuilding.getHeaderVersion();
	
	if (blocksList.dataArraybuffer === undefined)
	{ return; }

	if (blocksList.fileLoadState !== CODE.fileLoadState.LOADING_FINISHED)
	{ return; }
	
	if (headerVersion[0] === "v")
	{
		// parse the beta version.***
		blocksList.parseBlocksList(blocksList.dataArraybuffer, magoManager.readerWriter, neoBuilding.motherBlocksArray, magoManager);
	}
	else if (headerVersion === "0.0.1" || headerVersion === "0.0.2")
	{
		// parse versioned.***
		blocksList.parseBlocksListVersioned_v001(blocksList.dataArraybuffer, magoManager.readerWriter, neoBuilding.motherBlocksArray, magoManager);
	}
	blocksList.dataArraybuffer = undefined;
};

ParseQueue.prototype.parseArrayOctreesLod0Models = function(octreesArray, magoManager)
{
	if (Object.keys(this.octreesLod0ModelsToParseMap).length > 0)
	{
		var maxParsesCount = this.maxNumParses;
		var octreesParsedCount = 0;
		// 1rst parse the currently closest lowestOctrees to camera.
		var neoBuilding;
		var headerVersion;
		var lowestOctree;
		
		var octreesLod0Count = octreesArray.length;
		for (var i=0; i<octreesLod0Count; i++)
		{
			lowestOctree = octreesArray[i];
			
			if (this.eraseOctreeLod0ModelsToParse(lowestOctree))
			{
				ParseQueue.parseArrayOctreesLod0Models(lowestOctree, magoManager);
				octreesParsedCount++;
			}

			if (octreesParsedCount > maxParsesCount)
			{ break; }
		}
		/*
		if (octreesParsedCount === 0)
		{
			for (var key in this.octreesLod0ModelsToParseMap)
			{
				var lowestOctree = this.octreesLod0ModelsToParseMap[key];
				if(this.eraseOctreeLod0ModelsToParse(lowestOctree))
				{
					ParseQueue.parseArrayOctreesLod0Models(lowestOctree, magoManager);
					octreesParsedCount++;
					if (octreesParsedCount > maxParsesCount)
					{ break; }	
				}
				
			}
		}
		*/
		
		
		if (octreesParsedCount > 0)
		{
			if (magoManager.selectionFbo)
			{ magoManager.selectionFbo.dirty = true; }
		}
	}
};

ParseQueue.prototype.parseArrayOctreesLod0References = function(octreesArray, magoManager)
{
	if (Object.keys(this.octreesLod0ReferencesToParseMap).length > 0)
	{
		var maxParsesCount = this.maxNumParses;
		var octreesParsedCount = 0;
		var lowestOctree;
		
		// 1rst parse the currently closest lowestOctrees to camera.
		var octreesLod0Count = octreesArray.length;
		for (var i=0; i<octreesLod0Count; i++)
		{
			lowestOctree = octreesArray[i];
			if (this.parseOctreesLod0References(lowestOctree, magoManager))
			{
				octreesParsedCount++;
			}

			if (octreesParsedCount > maxParsesCount)
			{ break; }
		}
		/*
		if (octreesParsedCount === 0)
		{
			for (var key in this.octreesLod0ReferencesToParseMap)
			{
				var lowestOctree = this.octreesLod0ReferencesToParseMap[key];
				if(this.parseOctreesLod0References(lowestOctree, magoManager))
				{
					octreesParsedCount++;
					if (octreesParsedCount > maxParsesCount)
					{ break; }
				}
			}
		}
		*/

		if (octreesParsedCount > 0)
		{
			if (magoManager.selectionFbo)
			{ magoManager.selectionFbo.dirty = true; }
		}
	}
};

ParseQueue.prototype.parseOctreesLod0References = function(lowestOctree, magoManager)
{
	var parsed = false;
	if (this.eraseOctreeLod0ReferencesToParse(lowestOctree))
	{
		ParseQueue.parseOctreesLod0References(lowestOctree, magoManager);
		parsed = true;
	}
	
	return parsed;
};

ParseQueue.parseOctreesLod0References = function(lowestOctree, magoManager)
{
	if (lowestOctree.neoReferencesMotherAndIndices === undefined)
	{ return false; }
	
	if (lowestOctree.neoReferencesMotherAndIndices.dataArraybuffer === undefined)
	{ return false; }

	if (lowestOctree.neoReferencesMotherAndIndices.fileLoadState !== CODE.fileLoadState.LOADING_FINISHED)
	{ return false; }
	
	var neoBuilding = lowestOctree.neoBuildingOwner;
			
	var node = neoBuilding.nodeOwner;
	var rootNode;
	if (node)
	{ rootNode = node.getRoot(); }
	else
	{ rootNode = undefined; }
	
	if (rootNode === undefined)
	{ return false; }
	
	if (rootNode.data === undefined)
	{ return false; }
	
	var geoLocDataManager = rootNode.data.geoLocDataManager;
	
	if (geoLocDataManager === undefined)
	{ return false; }

	if (magoManager.matrix4SC === undefined)
	{ magoManager.matrix4SC = new Matrix4(); }
	
	var buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
	var headerVersion = neoBuilding.getHeaderVersion();
	magoManager.matrix4SC.setByFloat32Array(buildingGeoLocation.rotMatrix._floatArrays);
	if (headerVersion[0] === "v")
	{
		// parse beta version.
		lowestOctree.neoReferencesMotherAndIndices.parseArrayBufferReferences(lowestOctree.neoReferencesMotherAndIndices.dataArraybuffer, 
			magoManager.readerWriter, neoBuilding, magoManager.matrix4SC, magoManager);
	}
	else 
	{
		// parse vesioned.
		lowestOctree.neoReferencesMotherAndIndices.parseArrayBufferReferencesVersioned(lowestOctree.neoReferencesMotherAndIndices.dataArraybuffer, 
			magoManager.readerWriter, neoBuilding, magoManager.matrix4SC, magoManager);
	}
	lowestOctree.neoReferencesMotherAndIndices.multiplyKeyTransformMatrix(0, buildingGeoLocation.rotMatrix);
	lowestOctree.neoReferencesMotherAndIndices.dataArraybuffer = undefined;
	return true;
};


ParseQueue.prototype.putOctreeLod0ReferencesToParse = function(octree, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }
	
	this.octreesLod0ReferencesToParseMap[octree.octreeKey] = octree;

};

ParseQueue.prototype.eraseOctreeLod0ReferencesToParse = function(octree)
{
	var key = octree.octreeKey;
	if (this.octreesLod0ReferencesToParseMap.hasOwnProperty(key))
	{
		delete this.octreesLod0ReferencesToParseMap[key];
		return true;
	}
	return false;
};

ParseQueue.prototype.putOctreeLod0ModelsToParse = function(octree, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }
	
	this.octreesLod0ModelsToParseMap[octree.octreeKey] = octree;
	//octree.fileLoadState = CODE.fileLoadState.IN_QUEUE;
};

ParseQueue.prototype.eraseOctreeLod0ModelsToParse = function(octree)
{
	var key = octree.octreeKey;
	if (this.octreesLod0ModelsToParseMap.hasOwnProperty(key))
	{
		delete this.octreesLod0ModelsToParseMap[key];
		return true;
	}
	return false;
};

ParseQueue.prototype.putOctreeLod2LegosToParse = function(octree, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }
	
	this.octreesLod2LegosToParseMap[octree.octreeKey] = octree;
};

ParseQueue.prototype.eraseOctreeLod2LegosToParse = function(octree)
{
	var key = octree.octreeKey;
	if (this.octreesLod2LegosToParseMap.hasOwnProperty(key))
	{
		delete this.octreesLod2LegosToParseMap[key];
		return true;
	}
	return false;
};

ParseQueue.prototype.putOctreePCloudToParse = function(octree, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }
	
	this.octreesPCloudToParseMap[octree.octreeKey] = octree;
};

ParseQueue.prototype.eraseOctreePCloudToParse = function(octree)
{
	if (octree === undefined)
	{ return false; }
	
	var key = octree.octreeKey;
	if (this.octreesPCloudToParseMap.hasOwnProperty(key)) 
	{
		delete this.octreesPCloudToParseMap[key];
		return true;
	}
	return false;
};

ParseQueue.prototype.putOctreePCloudPartitionToParse = function(pCloudPartitionLego, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }
	
	this.octreesPCloudPartitionToParseMap[pCloudPartitionLego.legoKey] = pCloudPartitionLego;
};

ParseQueue.prototype.eraseOctreePCloudPartitionToParse = function(pCloudPartitionLego)
{
	if (pCloudPartitionLego === undefined)
	{ return false; }
	
	var key = pCloudPartitionLego.legoKey;
	if (this.octreesPCloudPartitionToParseMap.hasOwnProperty(key)) 
	{
		delete this.octreesPCloudPartitionToParseMap[key];
		return true;
	}
	return false;
};

ParseQueue.prototype.putSkinLegosToParse = function(skinLego, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }
	
	this.skinLegosToParseMap[skinLego.legoKey] = skinLego;
	skinLego.fileLoadState = CODE.fileLoadState.IN_PARSE_QUEUE;
};

ParseQueue.prototype.eraseSkinLegosToParse = function(skinLego)
{
	var key = skinLego.legoKey;
	if (this.skinLegosToParseMap.hasOwnProperty(key))
	{
		delete this.skinLegosToParseMap[key];
		return true;
	}
	return false;
};

ParseQueue.prototype.clearAll = function()
{
	this.octreesLod0ReferencesToParseMap = {};
	this.octreesLod0ModelsToParseMap = {};
	this.octreesLod2LegosToParseMap = {};
};

ParseQueue.prototype.eraseAny = function(octree)
{
	this.eraseOctreeLod0ReferencesToParse(octree);
	this.eraseOctreeLod0ModelsToParse(octree);
	this.eraseOctreeLod2LegosToParse(octree);
};

ParseQueue.prototype.initCounters = function()
{
	this.smartTileF4dParsesCount = 0;
	this.pCloudPartitionsParsed = 0;
};




















'use strict';

/**
 * ProcessQueue
 * 
 * @alias ProcessQueue
 * @class ProcessQueue
 */
var ProcessQueue = function() 
{
	if (!(this instanceof ProcessQueue)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.nodesToDeleteMap = {};
	this.nodesToDeleteModelReferencesMap = {};
	this.nodesToDeleteLessThanLod3Map = {};
	this.nodesToDeleteLessThanLod4Map = {};
	this.nodesToDeleteLessThanLod5Map = {};
	this.nodesToDeleteLodMeshMap = {}; // no used.
	this.tinTerrainsToDeleteMap = {};
	this.smartTilesToDeleteMap = {};
	
	// Test.
	this.octreeToDeletePCloudsMap = {};
};

ProcessQueue.prototype.putSmartTileToDelete = function(smartTile, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }

	if (smartTile === undefined)
	{ return; }
	
	var key = smartTile.getId();
	this.smartTilesToDeleteMap[key] = smartTile;
};

ProcessQueue.prototype.eraseSmartTileToDelete = function(smartTile)
{
	// this erases the smartTile from the "smartTilesToDeleteMap".
	if (smartTile === undefined)
	{ return false; }
	
	var key = smartTile.getId();
	if (this.smartTilesToDeleteMap.hasOwnProperty(key)) 
	{
		delete this.smartTilesToDeleteMap[key];
		return true;
	}
	return false;
};

ProcessQueue.prototype.putOctreeToDeletePCloud = function(octree, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }

	if (octree === undefined)
	{ return; }
	
	var key = octree.octreeKey;
	this.octreeToDeletePCloudsMap[key] = octree;
};

ProcessQueue.prototype.existOctreeToDeletePCloud = function(octree)
{
	if (octree === undefined)
	{ return false; }
	
	var key = octree.octreeKey;
	if (this.octreeToDeletePCloudsMap.hasOwnProperty(key)) 
	{
		return true;
	}
	return false;
};

ProcessQueue.prototype.eraseOctreeToDeletePCloud = function(octree)
{
	// this erases the octree from the "octreeToDeletePCloudsMap".
	if (octree === undefined)
	{ return false; }
	
	var key = octree.octreeKey;
	if (this.octreeToDeletePCloudsMap.hasOwnProperty(key)) 
	{
		delete this.octreeToDeletePCloudsMap[key];
		return true;
	}
	return false;
};

ProcessQueue.prototype.putNodeToDeleteLodMesh = function(node, aValue)
{
	if (node.isReferenceNode())
	{ return; }
	
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }

	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	this.nodesToDeleteLodMeshMap[key] = node;
	
	//this.nodesToDeleteLodMeshMap.set(node, aValue);
};

ProcessQueue.prototype.eraseNodeToDeleteLodMesh = function(node)
{
	// this erases the node from the "nodesToDeleteLessThanLod3Map".
	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	if (this.nodesToDeleteLodMeshMap.hasOwnProperty(key)) 
	{
		delete this.nodesToDeleteLodMeshMap[key];
		return true;
	}
	return false;
	//return this.nodesToDeleteLodMeshMap.delete(node);
};

ProcessQueue.prototype.putTinTerrainToDelete = function(tinTerrain, aValue)
{
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }

	if (tinTerrain === undefined)
	{ return; }
	
	var key = tinTerrain.pathName;
	this.tinTerrainsToDeleteMap[key] = tinTerrain;
};

ProcessQueue.prototype.eraseTinTerrainToDelete = function(tinTerrain)
{
	// this erases the tinTerrain from the "tinTerrainsToDeleteMap".
	if (tinTerrain === undefined)
	{ return false; }
	
	var key = tinTerrain.pathName;
	if (this.tinTerrainsToDeleteMap.hasOwnProperty(key)) 
	{
		delete this.tinTerrainsToDeleteMap[key];
		return true;
	}
	return false;
};

ProcessQueue.prototype.putNodeToDeleteLessThanLod3 = function(node, aValue)
{
	if (node.isReferenceNode())
	{ return; }
	
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }

	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	this.nodesToDeleteLessThanLod3Map[key] = node;
};

ProcessQueue.prototype.eraseNodeToDeleteLessThanLod3 = function(node)
{
	// this erases the node from the "nodesToDeleteLessThanLod3Map".
	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	if (this.nodesToDeleteLessThanLod3Map.hasOwnProperty(key)) 
	{
		delete this.nodesToDeleteLessThanLod3Map[key];
		return true;
	}
	return false;
};

ProcessQueue.prototype.putNodeToDeleteLessThanLod4 = function(node, aValue)
{
	if (node.isReferenceNode())
	{ return; }
	
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }

	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	this.nodesToDeleteLessThanLod4Map[key] = node;
};

ProcessQueue.prototype.eraseNodeToDeleteLessThanLod4 = function(node)
{
	// this erases the node from the "nodesToDeleteLessThanLod4Map".
	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	if (this.nodesToDeleteLessThanLod4Map.hasOwnProperty(key)) 
	{
		delete this.nodesToDeleteLessThanLod4Map[key];
		return true;
	}
	return false;
};

ProcessQueue.prototype.putNodeToDeleteLessThanLod5 = function(node, aValue)
{
	if (node.isReferenceNode())
	{ return; }
	
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }

	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	this.nodesToDeleteLessThanLod5Map[key] = node;
};

ProcessQueue.prototype.eraseNodeToDeleteLessThanLod5 = function(node)
{
	// this erases the node from the "nodesToDeleteLessThanLod5Map".
	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	if (this.nodesToDeleteLessThanLod5Map.hasOwnProperty(key)) 
	{
		delete this.nodesToDeleteLessThanLod5Map[key];
		return true;
	}
	return false;
};

ProcessQueue.prototype.putNodeToDeleteModelReferences = function(node, aValue)
{
	// In this case check if the node is reference node type.
	if (node.isReferenceNode())
	{ return; }
	
	// this puts the node to the "nodesToDeleteModelReferencesMap".
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }

	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	this.nodesToDeleteModelReferencesMap[key] = node;
	//this.nodesToDeleteModelReferencesMap.set(node, aValue);
};

ProcessQueue.prototype.eraseNodeToDeleteModelReferences = function(node)
{
	// this erases the node from the "nodesToDeleteModelReferencesMap".
	if (!node || node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	if (this.nodesToDeleteModelReferencesMap.hasOwnProperty(key)) 
	{
		delete this.nodesToDeleteModelReferencesMap[key];
		return true;
	}
	return false;
	//return this.nodesToDeleteModelReferencesMap.delete(node);
};

ProcessQueue.prototype.putNodeToDelete = function(node, aValue)
{
	if (node.isReferenceNode())
	{ return; }
	
	// this puts the node to the "nodesToDeleteMap".
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }

	if (node.data === undefined || node.data.neoBuilding === undefined)
	{ return; }
	
	var key = node.data.neoBuilding.buildingId;
	this.nodesToDeleteMap[key] = node;
};

ProcessQueue.prototype.putNodesArrayToDelete = function(nodesToDeleteArray, aValue)
{
	if (nodesToDeleteArray === undefined)
	{ return; }
	
	// this puts the nodesToDeleteArray to the "nodesToDeleteArray".
	// provisionally "aValue" can be anything.
	if (aValue === undefined)
	{ aValue = 0; }
	
	var nodesToDeleteCount = nodesToDeleteArray.length;
	for (var i=0; i<nodesToDeleteCount; i++)
	{
		this.putNodeToDelete(nodesToDeleteArray[i], aValue);
	}
};

ProcessQueue.prototype.eraseNodeToDelete = function(node)
{
	// this erases the node from the "nodesToDeleteMap".
	var key = node.data.neoBuilding.buildingId;
	if (this.nodesToDeleteMap.hasOwnProperty(key)) 
	{
		delete this.nodesToDeleteMap[key];
		return true;
	}
	return false;
};

ProcessQueue.prototype.eraseNodesArrayToDelete = function(nodesToEraseArray)
{
	// this erases the node from the "nodesToDeleteMap".
	var key;
	var nodesCount = nodesToEraseArray.length;
	for (var i=0; i<nodesCount; i++)
	{
		key = nodesToEraseArray[i].data.neoBuilding.buildingId;
		delete this.nodesToDeleteMap[key];
	}
};

ProcessQueue.prototype.clearAll = function()
{
	this.nodesToDeleteMap = {};
	this.nodesToDeleteModelReferencesMap = {};
};

/**
 * 어떤 일을 하고 있습니까?
 * @param frustumVolume 변수
 * @param neoVisibleBuildingsArray 변수
 * @param cameraPosition 변수
 * @returns neoVisibleBuildingsArray
 */
ProcessQueue.prototype.deleteNeoBuilding = function(gl, neoBuilding, magoManager) 
{
	// check if the neoBuilding id the selected building.
	var vboMemoryManager = magoManager.vboMemoryManager;
	if (neoBuilding === magoManager.buildingSelected)
	{
		magoManager.buildingSelected = undefined;
		magoManager.octreeSelected = undefined;
		magoManager.objectSelected = undefined;
	}
	
	neoBuilding.deleteObjects(gl, vboMemoryManager);
	
};

ProcessQueue.prototype.deleteSmartTiles = function(magoManager)
{
	var deletedCount = 0;
	var gl = magoManager.sceneState.gl;
	var node;
	var neoBuilding;

	for (var key in this.smartTilesToDeleteMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.smartTilesToDeleteMap, key))
		{
			var smartTile = this.smartTilesToDeleteMap[key];
			
			if (smartTile === undefined)
			{ continue; }

			if (this.eraseSmartTileToDelete(smartTile))
			{
				// Delete the smartTile.
				if (smartTile.nodesArray !== undefined)
				{
					var nodesCount = smartTile.nodesArray.length;
					for (var i=0; i<nodesCount; i++)
					{
						node = smartTile.nodesArray[i];
						neoBuilding = node.data.neoBuilding;
						//if (this.eraseNodeToDelete(node))
						{
							if (neoBuilding === undefined)
							{ continue; }
						
							this.deleteNeoBuilding(gl, neoBuilding, magoManager);
							node.data.neoBuilding = undefined;
							//deletedCount++;
							//if (deletedCount >= 10)
							//{ break; }
						}
					}
				}
				else
				{ smartTile.nodesArray = []; }
				
				smartTile.nodesArray.length = 0;
				if (smartTile.smartTileF4dSeedArray !== undefined)
				{
					var smartTileF4dSeedsCount = smartTile.smartTileF4dSeedArray.length;
					for (var i=0; i<smartTileF4dSeedsCount; i++)
					{
						smartTile.smartTileF4dSeedArray[i].fileLoadState = CODE.fileLoadState.READY;
					}
				}
				
				deletedCount++;
				if (deletedCount >= 1)
				{ break; }
			}
		}
	}
};

ProcessQueue.prototype.manageDeleteQueue = function(magoManager)
{
	var gl = magoManager.sceneState.gl;
	var maxDeleteNodesCount = 8;
	var nodesToDeleteCount = Object.keys(this.nodesToDeleteMap).length;
	if (nodesToDeleteCount < maxDeleteNodesCount)
	{ maxDeleteNodesCount = nodesToDeleteCount; }
	
	var neoBuilding;
	var node;
	var rootNode;
	var deletedCount = 0;
	
	// incompatibility gulp.
	//for (var key of this.buildingsToDeleteMap.keys())
	//{
	//	this.deleteNeoBuilding(gl, key);
	//	this.buildingsToDeleteMap.delete(key);
	//	deletedCount += 1;
	//	if (deletedCount > maxDeleteBuildingsCount)
	//	{ break; }
	//}
	
	this.deleteSmartTiles(magoManager);
	

	for (var key in this.nodesToDeleteMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.nodesToDeleteMap, key))
		{
			//node = nodesToDeleteArray[i];
			node = this.nodesToDeleteMap[key];
			
			if (node === undefined)
			{ continue; }

			neoBuilding = node.data.neoBuilding;
			if (this.eraseNodeToDelete(node))
			{
				if (neoBuilding === undefined)
				{ continue; }
			
				//var deleteMetaData = true;
				//if (key === 1)
				//{ deleteMetaData = false; }
				this.deleteNeoBuilding(gl, neoBuilding, magoManager);
				deletedCount++;
				if (deletedCount >= 10)
				{ break; }
			}
		}
	}
	
	// now delete modelReferences of lod2Octrees.
	var modelRefsDeletedCount = 0;
	for (var key in this.nodesToDeleteModelReferencesMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.nodesToDeleteModelReferencesMap, key))
		{
			//node = nodesToDeleteModelReferencesArray[i];
			node = this.nodesToDeleteModelReferencesMap[key];
			
			if (node.data === undefined)
			{ continue; }
		
			neoBuilding = node.data.neoBuilding;
			this.eraseNodeToDeleteModelReferences(node);
			if (neoBuilding === undefined)
			{ continue; }

			if (neoBuilding.octree)
			{
				neoBuilding.octree.deleteObjectsModelReferences(gl, magoManager.vboMemoryManager);
				neoBuilding.octree.deletePCloudObjects(gl, magoManager.vboMemoryManager);
			}
			if (neoBuilding.motherBlocksArray.length > 0 || neoBuilding.motherNeoReferencesArray.length > 0)
			{
				modelRefsDeletedCount ++;
			}
			neoBuilding.deleteObjectsModelReferences(gl, magoManager.vboMemoryManager);
			
			if (modelRefsDeletedCount > 10)
			{ break; }
		}
	}
	
	
	var deletedCount = 0;
	for (var key in this.nodesToDeleteLessThanLod3Map)
	{
		if (Object.prototype.hasOwnProperty.call(this.nodesToDeleteLessThanLod3Map, key))
		{
			node = this.nodesToDeleteLessThanLod3Map[key];
			//node = nodesToDeleteLod2Lod4Lod5Array[i];
			if (node.data === undefined)
			{ continue; }
		
			if (this.eraseNodeToDeleteLessThanLod3(node))
			{
				neoBuilding = node.data.neoBuilding;
				if (neoBuilding === undefined)
				{ continue; }
				
				if (neoBuilding.octree)
				{
					neoBuilding.octree.deleteObjectsModelReferences(gl, magoManager.vboMemoryManager);
					neoBuilding.octree.deletePCloudObjects(gl, magoManager.vboMemoryManager);
				}
				if (neoBuilding.motherBlocksArray.length > 0 || neoBuilding.motherNeoReferencesArray.length > 0)
				{
					modelRefsDeletedCount ++;
				}
					
				neoBuilding.deleteObjectsModelReferences(gl, magoManager.vboMemoryManager);
				neoBuilding.deleteObjectsLod2(gl, magoManager.vboMemoryManager);
				deletedCount++;
				
				if (deletedCount > 10)
				{ break; }
			}
		}
	}
	
	deletedCount = 0;
	for (var key in this.nodesToDeleteLessThanLod4Map)
	{
		if (Object.prototype.hasOwnProperty.call(this.nodesToDeleteLessThanLod4Map, key))
		{
			node = this.nodesToDeleteLessThanLod4Map[key];
			if (node.data === undefined)
			{ continue; }
		
			if (this.eraseNodeToDeleteLessThanLod4(node))
			{
				neoBuilding = node.data.neoBuilding;
				if (neoBuilding === undefined)
				{ continue; }
			
				neoBuilding.deleteObjectsModelReferences(gl, magoManager.vboMemoryManager);
				neoBuilding.deleteObjectsLod2(gl, magoManager.vboMemoryManager);
				neoBuilding.deleteObjectsLodMesh(gl, magoManager.vboMemoryManager, "lod3");
				deletedCount++;
				
				if (deletedCount > 10)
				{ break; }
			}
		}
	}
	
	deletedCount = 0;
	for (var key in this.nodesToDeleteLessThanLod5Map)
	{
		if (Object.prototype.hasOwnProperty.call(this.nodesToDeleteLessThanLod5Map, key))
		{
			node = this.nodesToDeleteLessThanLod5Map[key];
			if (node.data === undefined)
			{ continue; }
		
			if (this.eraseNodeToDeleteLessThanLod5(node))
			{
				neoBuilding = node.data.neoBuilding;
				if (neoBuilding === undefined)
				{ continue; }
			
				neoBuilding.deleteObjectsModelReferences(gl, magoManager.vboMemoryManager);
				neoBuilding.deleteObjectsLod2(gl, magoManager.vboMemoryManager);
				neoBuilding.deleteObjectsLodMesh(gl, magoManager.vboMemoryManager, "lod3");
				neoBuilding.deleteObjectsLodMesh(gl, magoManager.vboMemoryManager, "lod4");
				deletedCount++;
				
				if (deletedCount > 10)
				{ break; }
			}
		}
	}
	
	
	// now, delete lod0, lod1, lod2.
	// now, delete tinTerrains.
	var deletedCount = 0;
	for (var key in this.tinTerrainsToDeleteMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.tinTerrainsToDeleteMap, key))
		{
			var tinTerrain = this.tinTerrainsToDeleteMap[key];
			if (tinTerrain === undefined)
			{ continue; }
			
			if (this.eraseTinTerrainToDelete(tinTerrain))
			{
				tinTerrain.deleteObjects(magoManager);
				tinTerrain = undefined;
				deletedCount++;
			}
			
			if (deletedCount > 10)
			{ break; }
		}
	}
	
	// PointsCloud.
	var deletedCount = 0;
	for (var key in this.octreeToDeletePCloudsMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.octreeToDeletePCloudsMap, key))
		{
			var octree = this.octreeToDeletePCloudsMap[key];
			if (octree === undefined)
			{ continue; }
			
			if (this.eraseOctreeToDeletePCloud(octree))
			{
				octree.deletePCloudObjects(gl, magoManager.vboMemoryManager);
				octree = undefined;
				deletedCount++;
			}
			
			if (deletedCount > 10000)
			{ break; }
		}
	}
};
'use strict';

/**
 * @class ProjectTree
 */
var ProjectTree = function() 
{
	if (!(this instanceof ProjectTree)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.root;
	
	this.nodesArray = [];
};

'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class ReaderWriter
 */
var ReaderWriter = function() 
{
	if (!(this instanceof ReaderWriter)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	//this.geometryDataPath = "/F4D_GeometryData";
	var serverPolicy = MagoConfig.getPolicy();
	if (serverPolicy !== undefined)
	{ this.geometryDataPath = serverPolicy.geo_data_path; }
	
	if (!this.geometryDataPath) { this.geometryDataPath = '/f4d'; }

	this.geometrySubDataPath;

	this.j_counter;
	this.k_counter;
	this.referencesList_requested = 0;
	this.blocksList_requested = 0;
	this.blocksListPartitioned_requested = 0;
	this.octreesSkinLegos_requested = 0;
	this.skinLegos_requested = 0;
	this.pCloudPartitionsMother_requested = 0;
	this.pCloudPartitions_requested = 0;
	this.smartTileF4d_requested = 0;

	this.gl;
	this.incre_latAng = 0.001;
	this.incre_longAng = 0.001;
	this.GAIA3D__offset_latitude = -0.001;
	this.GAIA3D__offset_longitude = -0.001;
	this.GAIA3D__counter = 0;

	// Var for reading files.
	this.uint32;
	this.uint16;
	this.int16;
	this.float32;
	this.float16;
	this.int8;
	this.int8_value;
	this.max_color_value = 126;

	this.startBuff;
	this.endBuff;

	this.filesReadings_count = 0;

	// SCRATCH.*** 
	this.temp_var_to_waste;
	this.countSC;
	this.xSC;
	this.ySC;
	this.zSC;
	this.point3dSC = new Point3D();
	this.bboxSC = new BoundingBox();
};

/**
 * 버퍼에서 데이터를 읽어서 32비트 부호없는 정수값에 대한 배열의 0번째 값을 돌려줌
 */
ReaderWriter.prototype.getCurrentDataPath = function() 
{
	var currentDataPath;
	
	if (this.geometrySubDataPath !== undefined && this.geometrySubDataPath !== "")
	{
		currentDataPath = this.geometryDataPath + "/" + this.geometrySubDataPath;
	}
	else
		
	{
		currentDataPath = this.geometryDataPath;
	}
	
	return currentDataPath;
};

/**
 * 버퍼에서 데이터를 읽어서 32비트 부호없는 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns uint32[0]
 */
ReaderWriter.prototype.readUInt32 = function(buffer, start, end) 
{
	var uint32 = new Uint32Array(buffer.slice(start, end));
	return uint32[0];
};

/**
 * 버퍼에서 데이터를 읽어서 32비트 부호없는 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns uint32[0]
 */
ReaderWriter.readUInt32 = function(buffer, start, end) 
{
	var uint32 = new Uint32Array(buffer.slice(start, end));
	return uint32[0];
};

/**
 * 버퍼에서 데이터를 읽어서 32비트 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns int32[0]
 */
ReaderWriter.prototype.readInt32 = function(buffer, start, end) 
{
	var int32 = new Int32Array(buffer.slice(start, end));
	return int32[0];
};

/**
 * 버퍼에서 데이터를 읽어서 32비트 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns int32[0]
 */
ReaderWriter.readInt32 = function(buffer, start, end) 
{
	var int32 = new Int32Array(buffer.slice(start, end));
	return int32[0];
};

/**
 * 버퍼에서 데이터를 읽어서 16비트 부호없는 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns uint16[0]
 */
ReaderWriter.prototype.readUInt16 = function(buffer, start, end) 
{
	var uint16 = new Uint16Array(buffer.slice(start, end));
	return uint16[0];
};

/**
 * 버퍼에서 데이터를 읽어서 16비트 부호없는 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns uint16[0]
 */
ReaderWriter.readUInt16 = function(buffer, start, end) 
{
	var uint16 = new Uint16Array(buffer.slice(start, end));
	return uint16[0];
};

/**
 * 버퍼에서 데이터를 읽어서 32비트 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns int16[0]
 */
ReaderWriter.prototype.readInt16 = function(buffer, start, end) 
{
	var int16 = new Int16Array(buffer.slice(start, end));
	return int16[0];
};

/**
 * 버퍼에서 데이터를 읽어서 32비트 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns int16[0]
 */
ReaderWriter.readInt16 = function(buffer, start, end) 
{
	var int16 = new Int16Array(buffer.slice(start, end));
	return int16[0];
};

/**
 * 버퍼에서 데이터를 읽어서 64비트 float값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns float64[0]
 */
ReaderWriter.prototype.readFloat64 = function(buffer, start, end) 
{
	var float64 = new Float64Array(buffer.slice(start, end));
	return float64[0];
};

/**
 * 버퍼에서 데이터를 읽어서 64비트 float값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns float64[0]
 */
ReaderWriter.readFloat64 = function(buffer, start, end) 
{
	var float64 = new Float64Array(buffer.slice(start, end));
	return float64[0];
};

/**
 * 버퍼에서 데이터를 읽어서 32비트 float값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns float32[0]
 */
ReaderWriter.prototype.readFloat32 = function(buffer, start, end) 
{
	var float32 = new Float32Array(buffer.slice(start, end));
	return float32[0];
};

/**
 * 버퍼에서 데이터를 읽어서 32비트 float값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns float32[0]
 */
ReaderWriter.readFloat32 = function(buffer, start, end) 
{
	var float32 = new Float32Array(buffer.slice(start, end));
	return float32[0];
};

/**
 * 버퍼에서 데이터를 읽어서 32비트 부호없는 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns float16[0]
 */
ReaderWriter.prototype.readFloat16 = function(buffer, start, end) 
{
	var float16 = new Float32Array(buffer.slice(start, end));
	return float16[0];
};

/**
 * 버퍼에서 데이터를 읽어서 8비트 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns int8[0]
 */
ReaderWriter.prototype.readInt8 = function(buffer, start, end) 
{
	var int8 = new Int8Array(buffer.slice(start, end));
	return int8[0];
};

/**
 * 버퍼에서 데이터를 읽어서 8비트 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns int8[0]
 */
ReaderWriter.readInt8 = function(buffer, start, end) 
{
	var int8 = new Int8Array(buffer.slice(start, end));
	return int8[0];
};

/**
 * 버퍼에서 데이터를 읽어서 8비트 부호없는 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns uint8[0]
 */
ReaderWriter.prototype.readUInt8 = function(buffer, start, end) 
{
	var uint8 = new Uint8Array(buffer.slice(start, end));
	return uint8[0];
};

/**
 * 버퍼에서 데이터를 읽어서 8비트 부호없는 정수값에 대한 배열의 0번째 값을 돌려줌
 * @param buffer 복사할 버퍼
 * @param start 시작 바이트 인덱스
 * @param end 끝 바이트 인덱스
 * @returns uint8[0]
 */
ReaderWriter.readUInt8 = function(buffer, start, end) 
{
	var uint8 = new Uint8Array(buffer.slice(start, end));
	return uint8[0];
};

/**
 * 어떤 일을 하고 있습니까?
 * @param buffer 변수
 * @param start 변수
 * @param end 변수
 * @returns int8_value
 */
ReaderWriter.prototype.readInt8ByteColor = function(buffer, start, end) 
{
	var int8 = new Int8Array(buffer.slice(start, end));
	var int8_value = int8[0];

	if (int8_value > max_color_value) { int8_value = max_color_value; }

	if (int8_value < 0) { int8_value += 256; }

	return int8_value;
};




function loadWithXhr_deprecated(fileName, xhr, timeOut) 
{
	// 1) 사용될 jQuery Deferred 객체를 생성한다.
	var deferred = $.Deferred();
	
	if (xhr === undefined)
	{ xhr = new XMLHttpRequest(); }
	
	xhr.open("GET", fileName, true);
	xhr.responseType = "arraybuffer";
	if (timeOut !== undefined)
	{ xhr.timeout = timeOut; } // time in milliseconds
	  
	// 이벤트 핸들러를 등록한다.
	xhr.onload = function() 
	{
		if (xhr.status < 200 || xhr.status >= 300) 
		{
			deferred.reject(xhr.status);
			return;
		}
		else 
		{
			// 3.1) DEFERRED를 해결한다. (모든 done()...을 동작시킬 것이다.)
			deferred.resolve(xhr.response);
		} 
	};
	
	xhr.ontimeout = function (e) 
	{
		// XMLHttpRequest timed out.***
		deferred.reject(-1);
	};
	
	xhr.onerror = function(e) 
	{
		console.log("Invalid XMLHttpRequest response type.");
		deferred.reject(xhr.status);
	};

	// 작업을 수행한다.
	xhr.send(null);
	
	// 참고: jQuery.ajax를 사용할 수 있었고 해야할 수 있었다.
	// 참고: jQuery.ajax는 Promise를 반환하지만 다른 Deferred/Promise를 사용하여 애플리케이션에 의미있는 구문으로 감싸는 것은 언제나 좋은 생각이다.
	// ---- /AJAX 호출 ---- //
	  
	// 2) 이 deferred의 promise를 반환한다.
	return deferred.promise();
};

ReaderWriter.prototype.getNeoBlocksArraybuffer = function(fileName, lowestOctree, magoManager, options) 
{
	magoManager.fileRequestControler.modelRefFilesRequestedCount += 1;
	var blocksList = lowestOctree.neoReferencesMotherAndIndices.blocksList;
	blocksList.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	var xhr;
	//xhr = new XMLHttpRequest();
	blocksList.xhr = xhr; // possibility to cancel.***
	
	var parseImmediately = false;
	if (options !== undefined)
	{
		if (options.parseImmediately !== undefined)
		{ parseImmediately = options.parseImmediately; }
	}
	
	this.blocksList_requested++;
	
	loadWithXhr(fileName, xhr).then(function(response) 
	{	
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			blocksList.dataArraybuffer = arrayBuffer;
			blocksList.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
			arrayBuffer = null;
			
			if (parseImmediately)
			{
				// parse immediately.
				ParseQueue.parseArrayOctreesLod0Models(lowestOctree, magoManager);
			}
			else 
			{
				magoManager.parseQueue.putOctreeLod0ModelsToParse(lowestOctree);
			}
		}
		else 
		{
			blocksList.fileLoadState = 500;
		}
	}, 
	function(status) 
	{
		console.log("Invalid XMLHttpRequest status = " + status);
		if (status === 0) { blocksList.fileLoadState = 500; }
		else if (status === -1) { blocksList.fileLoadState = CODE.fileLoadState.READY; }
		else { blocksList.fileLoadState = status; }
	}).finally(function() 
	{
		magoManager.readerWriter.blocksList_requested--;
		magoManager.fileRequestControler.modelRefFilesRequestedCount -= 1;
		if (magoManager.fileRequestControler.modelRefFilesRequestedCount < 0) { magoManager.fileRequestControler.modelRefFilesRequestedCount = 0; }
	});
};

ReaderWriter.prototype.getNeoBlocksArraybuffer_partition = function(fileName, lowestOctree, blocksArrayPartition, magoManager) 
{
	magoManager.fileRequestControler.modelRefFilesRequestedCount += 1;
	blocksArrayPartition.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	var xhr;
	
	this.blocksListPartitioned_requested++;
	
	loadWithXhr(fileName, xhr).then(function(response) 
	{	
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			blocksArrayPartition.dataArraybuffer = arrayBuffer;
			blocksArrayPartition.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
			arrayBuffer = null;
			
			
			magoManager.parseQueue.putOctreeLod0ModelsToParse(lowestOctree);
		}
		else 
		{
			blocksArrayPartition.fileLoadState = 500;
		}
	},
	function(status) 
	{
		console.log("Invalid XMLHttpRequest status = " + status);
		if (status === 0) { blocksArrayPartition.fileLoadState = 500; }
		else if (status === -1) { blocksArrayPartition.fileLoadState = CODE.fileLoadState.READY; }
		else { blocksArrayPartition.fileLoadState = status; }
	}).finally(function() 
	{
		magoManager.readerWriter.blocksListPartitioned_requested--;
		//magoManager.fileRequestControler.modelRefFilesRequestedCount -= 1;
		if (magoManager.fileRequestControler.blocksListPartitioned_requested < 0) { magoManager.fileRequestControler.blocksListPartitioned_requested = 0; }
	});
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param fileName 파일명
 * @param magoManager 변수
 */
ReaderWriter.prototype.getNeoReferencesArraybuffer = function(fileName, lowestOctree, magoManager, options) 
{
	if (lowestOctree.neoReferencesMotherAndIndices === undefined)
	{ return; }
	
	magoManager.fileRequestControler.modelRefFilesRequestedCount += 1;
	lowestOctree.neoReferencesMotherAndIndices.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	var xhr;
	//xhr = new XMLHttpRequest();
	lowestOctree.neoReferencesMotherAndIndices.xhr = xhr;
	var parseImmediately = false;
	if (options !== undefined)
	{
		if (options.parseImmediately !== undefined)
		{ parseImmediately = options.parseImmediately; }
	}
	
	this.referencesList_requested++;
	loadWithXhr(fileName, xhr).then(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			var neoRefsList = lowestOctree.neoReferencesMotherAndIndices;
			if (neoRefsList)
			{
				neoRefsList.dataArraybuffer = arrayBuffer;
				neoRefsList.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
				if (parseImmediately)
				{
					// parse immediately.
					ParseQueue.parseOctreesLod0References(lowestOctree, magoManager);
				}
				else 
				{
					magoManager.parseQueue.putOctreeLod0ReferencesToParse(lowestOctree);
				}
			}
			arrayBuffer = null;
			
		}
		else 
		{
			lowestOctree.neoReferencesMotherAndIndices.fileLoadState = CODE.fileLoadState.LOAD_FAILED;
		}
	},
	function(status) 
	{
		console.log("xhr status = " + status);
		if (status === 0) 
		{ lowestOctree.neoReferencesMotherAndIndices.fileLoadState = CODE.fileLoadState.LOAD_FAILED; }
		else if (status === -1) 
		{ lowestOctree.neoReferencesMotherAndIndices.fileLoadState = CODE.fileLoadState.READY; }
		else 
		{ lowestOctree.neoReferencesMotherAndIndices.fileLoadState = status; }
	}).finally(function() 
	{
		magoManager.readerWriter.referencesList_requested--;
		magoManager.fileRequestControler.modelRefFilesRequestedCount -= 1;
		if (magoManager.fileRequestControler.modelRefFilesRequestedCount < 0) { magoManager.fileRequestControler.modelRefFilesRequestedCount = 0; }
	});
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param fileName 파일명
 * @param magoManager 변수
 */
ReaderWriter.prototype.getOctreeLegoArraybuffer = function(fileName, lowestOctree, magoManager) 
{
	if (lowestOctree.lego === undefined)
	{ return; }
	this.octreesSkinLegos_requested ++;
	magoManager.fileRequestControler.filesRequestedCount += 1;
	lowestOctree.lego.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	
	var xhr = new XMLHttpRequest();
	lowestOctree.lego.xhr = xhr;
	
	loadWithXhr(fileName, xhr).then(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			if (lowestOctree.lego)
			{
				lowestOctree.lego.dataArrayBuffer = arrayBuffer;
				lowestOctree.lego.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
				magoManager.parseQueue.putOctreeLod2LegosToParse(lowestOctree);
			}
			else 
			{
				lowestOctree = undefined;
			}
			arrayBuffer = null;
		}
		else 
		{
			lowestOctree.lego.fileLoadState = 500;
		}
	},
	function(status) 
	{
		console.log("xhr status = " + status);
		if (status === 0) { lowestOctree.lego.fileLoadState = 500; }
		else { lowestOctree.lego.fileLoadState = status; }
	}).finally(function() 
	{
		magoManager.readerWriter.octreesSkinLegos_requested --;
		magoManager.fileRequestControler.filesRequestedCount -= 1;
		if (magoManager.fileRequestControler.filesRequestedCount < 0) { magoManager.fileRequestControler.filesRequestedCount = 0; }
	});
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param fileName 파일명
 * @param magoManager 변수
 */
ReaderWriter.prototype.getOctreePCloudArraybuffer = function(fileName, lowestOctree, magoManager) 
{
	if (lowestOctree.lego === undefined)
	{ return; }
	
	magoManager.fileRequestControler.filesRequestedCount += 1;
	lowestOctree.lego.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	
	loadWithXhr(fileName).then(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			if (lowestOctree.lego)
			{
				lowestOctree.lego.dataArrayBuffer = arrayBuffer;
				lowestOctree.lego.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
				magoManager.parseQueue.putOctreePCloudToParse(lowestOctree);
			}
			else 
			{
				lowestOctree = undefined;
			}
			arrayBuffer = null;
		}
		else 
		{
			lowestOctree.lego.fileLoadState = 500;
		}
	},
	function(status) 
	{
		console.log("xhr status = " + status);
		if (status === 0) { lowestOctree.lego.fileLoadState = 500; }
		else { lowestOctree.lego.fileLoadState = status; }
	}).finally(function() 
	{
		magoManager.fileRequestControler.filesRequestedCount -= 1;
		if (magoManager.fileRequestControler.filesRequestedCount < 0) { magoManager.fileRequestControler.filesRequestedCount = 0; }
	});
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param fileName 파일명
 * @param magoManager 변수
 */
ReaderWriter.prototype.getOctreePCloudPartitionArraybuffer = function(fileName, lowestOctree, pCloudPartitionLego, magoManager) 
{
	pCloudPartitionLego.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	var octreeDepth = lowestOctree.octree_level;
	if (octreeDepth === 0)
	{ magoManager.readerWriter.pCloudPartitionsMother_requested++; }
	else
	{ magoManager.readerWriter.pCloudPartitions_requested ++; }
	
	loadWithXhr(fileName).then(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			if (lowestOctree && pCloudPartitionLego)
			{
				pCloudPartitionLego.dataArrayBuffer = arrayBuffer;
				pCloudPartitionLego.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
				//magoManager.parseQueue.putOctreePCloudPartitionToParse(pCloudPartitionLego); // NO. Old. Now parse directly.***
			}
			arrayBuffer = null;
		}
		else 
		{
			pCloudPartitionLego.fileLoadState = 500;
		}
	},
	function(status) 
	{
		console.log("xhr status = " + status);
		if (status === 0) { pCloudPartitionLego.fileLoadState = 500; }
		else { pCloudPartitionLego.fileLoadState = status; }
	}).finally(function() 
	{
		if (octreeDepth === 0)
		{
			magoManager.readerWriter.pCloudPartitionsMother_requested --;
			if (magoManager.readerWriter.pCloudPartitionsMother_requested < 0)
			{ magoManager.readerWriter.pCloudPartitionsMother_requested = 0; }
		}
		else
		{
			
			magoManager.readerWriter.pCloudPartitions_requested--;
			if (magoManager.readerWriter.pCloudPartitions_requested < 0)
			{ magoManager.readerWriter.pCloudPartitions_requested = 0; }
		}
	
		//magoManager.readerWriter.pCloudPartitions_requested--;
		//if (magoManager.readerWriter.pCloudPartitions_requested < 0)
		//{ magoManager.readerWriter.pCloudPartitions_requested = 0; }
	});
};


/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param fileName 파일명
 * @param magoManager 변수
 */
ReaderWriter.prototype.getLegoArraybuffer = function(fileName, legoMesh, magoManager) 
{
	this.skinLegos_requested++;
	//magoManager.fileRequestControler.filesRequestedCount += 1;
	magoManager.fileRequestControler.lowLodDataRequestedCount += 1;
	legoMesh.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	
	var xhr;
	//xhr = new XMLHttpRequest();
	legoMesh.xhr = xhr;
	
	loadWithXhr(fileName, xhr).then(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			if (legoMesh)
			{
				legoMesh.dataArrayBuffer = arrayBuffer;
				legoMesh.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
				magoManager.parseQueue.putSkinLegosToParse(legoMesh);
			}
			arrayBuffer = null;
		}
		else 
		{
			legoMesh.fileLoadState = 500;
		}
	},
	function(status) 
	{
		console.log("xhr status = " + status);
		if (status === 0) { legoMesh.fileLoadState = 500; }
		//else { legoMesh.fileLoadState = status; }
		else 
		{ 
			legoMesh.fileLoadState = -1; 
		}
	}).finally(function() 
	{
		magoManager.readerWriter.skinLegos_requested--;
		//magoManager.fileRequestControler.filesRequestedCount -= 1;
		magoManager.fileRequestControler.lowLodDataRequestedCount -= 1;
		//if (magoManager.fileRequestControler.filesRequestedCount < 0) { magoManager.fileRequestControler.filesRequestedCount = 0; }
		if (magoManager.fileRequestControler.lowLodDataRequestedCount < 0) { magoManager.fileRequestControler.lowLodDataRequestedCount = 0; }
	});
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 * @param {string} fileName 파일명
 * @param {MagoManager} magoManager 파일 처리를 담당
 */
ReaderWriter.prototype.getObjectIndexFileMultiBuildings = function(fileName, projectFolderName, magoManager) 
{
	loadWithXhr(fileName).then(function(response) 
	{	
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			if (magoManager.smartTileManager === undefined)
			{
				magoManager.smartTileManager = new SmartTileManager();
			}
			var smartTileManager = magoManager.smartTileManager;
			var smartTilesMultiBuildingsMap = smartTileManager.parseSmartTilesMultiBuildingsIndexFile(arrayBuffer, projectFolderName, magoManager);
			
			arrayBuffer = undefined;
		}
		else 
		{
			// Error.***
		}
	},
	function(status) 
	{
		console.log("xhr status = " + status);
	}).finally(function() 
	{
		//	For the moment, do nothing.***
	});
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 * @param {string} fileName 파일명
 * @param {MagoManager} magoManager 파일 처리를 담당
 */
ReaderWriter.prototype.getObjectIndexFileSmartTileF4d = function(fileName, projectFolderName, magoManager) 
{
	loadWithXhr(fileName).then(function(response) 
	{	
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			if (magoManager.smartTileManager === undefined)
			{
				magoManager.smartTileManager = new SmartTileManager();
			}
			var smartTileManager = magoManager.smartTileManager;
			smartTileManager.parseSmartTilesF4dIndexFile(arrayBuffer, projectFolderName, magoManager);
			
			arrayBuffer = undefined;
		}
		else 
		{
			// Error.***
		}
	},
	function(status) 
	{
		console.log("xhr status = " + status);
	}).finally(function() 
	{
		//	For the moment, do nothing.***
	});
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 * @param {string} fileName 파일명
 * @param {MagoManager} magoManager 파일 처리를 담당
 */
ReaderWriter.prototype.getSmartTileF4d = function(fileName, smartTileF4dSeed, smartTileOwner, magoManager) 
{
	this.smartTileF4d_requested ++;
	smartTileF4dSeed.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	loadWithXhr(fileName).then(function(response) 
	{	
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			smartTileF4dSeed.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
			// put smartTileOwner into parse queue.***
			smartTileF4dSeed.dataArrayBuffer = arrayBuffer;
			//smartTileOwner.parseSmartTileF4d(arrayBuffer);
			arrayBuffer = undefined;
		}
		else 
		{
			// Error.***
			smartTileF4dSeed.fileLoadState = CODE.fileLoadState.LOAD_FAILED;
		}
		
		magoManager.readerWriter.smartTileF4d_requested --;
		if (magoManager.readerWriter.smartTileF4d_requested < 0)
		{ magoManager.readerWriter.smartTileF4d_requested = 0; }
	},
	function(status) 
	{
		console.log("xhr status = " + status);
	}).finally(function() 
	{
		//	For the moment, do nothing.***
		
	});
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param fileName 파일명
 * @param magoManager 변수
 */
ReaderWriter.prototype.getMultiBuildingsDataArrayBuffer = function(fileName, multiBuildings, magoManager) 
{
	// Function to load multiBuildings data.
	this.skinLegos_requested++;
	magoManager.fileRequestControler.multiBuildingsDataRequestedCount += 1;
	multiBuildings.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	var xhr;
	loadWithXhr(fileName, xhr).then(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			if (multiBuildings)
			{
				multiBuildings.dataArrayBuffer = arrayBuffer;
				multiBuildings.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
				magoManager.parseQueue.putMultiBuildingsToParse(multiBuildings, 0);
			}
			arrayBuffer = null;
		}
		else 
		{
			multiBuildings.fileLoadState = 500;
		}
	},
	function(status) 
	{
		console.log("xhr status = " + status);
		if (status === 0) { multiBuildings.fileLoadState = 500; }
		else 
		{ 
			multiBuildings.fileLoadState = -1; 
		}
	}).finally(function() 
	{
		magoManager.fileRequestControler.multiBuildingsDataRequestedCount -= 1;
		if (magoManager.fileRequestControler.multiBuildingsDataRequestedCount < 0) { magoManager.fileRequestControler.multiBuildingsDataRequestedCount = 0; }
	});
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 * @param gl gl context
 * @param {string} fileName 파일명
 * @param {MagoManager} magoManager 파일 처리를 담당
 * @param {BuildingSeedList} buildingSeedList 빌딩 씨앗 리스트
 * @param {string} projectId 프로젝트 아이디.
 */
ReaderWriter.prototype.getObjectIndexFileForSmartTile = function(fileName, magoManager, buildingSeedList, projectId) 
{
	loadWithXhr(fileName).then(function(response) 
	{	
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			buildingSeedList.dataArrayBuffer = arrayBuffer;
			buildingSeedList.parseBuildingSeedArrayBuffer();
			
			magoManager.makeSmartTile(buildingSeedList, projectId);
			arrayBuffer = null;
		}
		else 
		{
			// blocksList.fileLoadState = 500;
		}
	},
	function(status) 
	{
		console.log("xhr status = " + status);
		//		if(status === 0) blocksList.fileLoadState = 500;
		//		else blocksList.fileLoadState = status;
	}).finally(function() 
	{
		//		magoManager.fileRequestControler.filesRequestedCount -= 1;
		//		if(magoManager.fileRequestControler.filesRequestedCount < 0) magoManager.fileRequestControler.filesRequestedCount = 0;
	});
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 * @param gl gl context
 * @param {string} fileName 파일명
 * @param {MagoManager} magoManager 파일 처리를 담당
 * @param {string} projectId 프로젝트 아이디.
 * @param {Array<string>} newDataKeys 추가할 데이터 키 목록
 * @param {Array<object> | object} f4dObject 추가할 데이터 object.
 */
ReaderWriter.prototype.getObjectIndexFileForData = function(fileName, magoManager, projectId, newDataKeys, f4dObject) 
{
	loadWithXhr(fileName).then(function(response) 
	{	
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			var buildingSeedList = new BuildingSeedList(); 
			buildingSeedList.dataArrayBuffer = arrayBuffer;
			buildingSeedList.parseBuildingSeedArrayBuffer();

			var buildingSeedMap = {};
			var buildingSeedsCount = buildingSeedList.buildingSeedArray.length;
			for (var i=0; i<buildingSeedsCount; i++)
			{
				var buildingSeed = buildingSeedList.buildingSeedArray[i];
				var buildingId = buildingSeed.buildingId;

				if (newDataKeys.indexOf(buildingId) >= 0) 
				{
					buildingSeedMap[buildingId] = buildingSeed;	
				}
				
			}
			var seedCnt = Object.keys(buildingSeedMap).length;

			//object 인덱스파일에 새로운 데이터에 대한 정보가 없으면 에러 발생.
			if (seedCnt !== newDataKeys.length) 
			{
				throw new Error('ObjectIndexFile is not ready. Please make objectIndexFile and try add data.'); 
			}
			
			magoManager.makeSmartTile(buildingSeedMap, projectId, f4dObject, buildingSeedMap);
			arrayBuffer = null;
		}
		else 
		{
			// blocksList.fileLoadState = 500;
		}
	},
	function(status) 
	{
		console.log("xhr status = " + status);
		//		if(status === 0) blocksList.fileLoadState = 500;
		//		else blocksList.fileLoadState = status;
	}).finally(function() 
	{
		//		magoManager.fileRequestControler.filesRequestedCount -= 1;
		//		if(magoManager.fileRequestControler.filesRequestedCount < 0) magoManager.fileRequestControler.filesRequestedCount = 0;
	});
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 * @param gl gl context
 * @param fileName 파일명
 * @param readerWriter 파일 처리를 담당
 * @param neoBuildingsList object index 파일을 파싱한 정보를 저장할 배열
 */
ReaderWriter.prototype.getObjectIndexFile = function(fileName, readerWriter, neoBuildingsList, magoManager) 
{
	loadWithXhr(fileName).then(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			readerWriter.parseObjectIndexFile(arrayBuffer, neoBuildingsList);
			arrayBuffer = null;
			magoManager.createDeploymentGeoLocationsForHeavyIndustries();
		}
		else 
		{
			//			blocksList.fileLoadState = 500;
		}
	},
	function(status) 
	{
		console.log("xhr status = " + status);
		//		if(status === 0) blocksList.fileLoadState = 500;
		//		else blocksList.fileLoadState = status;
	}).finally(function() 
	{
		//		magoManager.fileRequestControler.filesRequestedCount -= 1;
		//		if(magoManager.fileRequestControler.filesRequestedCount < 0) magoManager.fileRequestControler.filesRequestedCount = 0;
	});
};

/**
 * object index 파일을 읽어서 빌딩 개수, 포지션, 크기 정보를 배열에 저장
 * @param arrayBuffer object index file binary data
 * @param neoBuildingsList object index 파일을 파싱한 정보를 저장할 배열
 */
ReaderWriter.prototype.parseObjectIndexFile = function(arrayBuffer, neoBuildingsList) 
{
	var bytesReaded = 0;
	var buildingNameLength;
	var longitude;
	var latitude;
	var altitude;

	var buildingsCount = this.readInt32(arrayBuffer, bytesReaded, bytesReaded+4);
	bytesReaded += 4;
	for (var i =0; i<buildingsCount; i++) 
	{
		// read the building location data.***
		var neoBuilding = neoBuildingsList.newNeoBuilding();
		if (neoBuilding.metaData === undefined) 
		{
			neoBuilding.metaData = new MetaData();
		}

		if (neoBuilding.metaData.geographicCoord === undefined)
		{ neoBuilding.metaData.geographicCoord = new GeographicCoord(); }

		if (neoBuilding.metaData.bbox === undefined) 
		{
			neoBuilding.metaData.bbox = new BoundingBox();
		}

		buildingNameLength = this.readInt32(arrayBuffer, bytesReaded, bytesReaded+4);
		bytesReaded += 4;
		var buildingName = String.fromCharCode.apply(null, new Int8Array(arrayBuffer.slice(bytesReaded, bytesReaded+ buildingNameLength)));
		bytesReaded += buildingNameLength;

		longitude = this.readFloat64(arrayBuffer, bytesReaded, bytesReaded+8); bytesReaded += 8;
		latitude = this.readFloat64(arrayBuffer, bytesReaded, bytesReaded+8); bytesReaded += 8;
		altitude = this.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;

		neoBuilding.bbox = new BoundingBox();
		neoBuilding.bbox.minX = this.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		neoBuilding.bbox.minY = this.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		neoBuilding.bbox.minZ = this.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		neoBuilding.bbox.maxX = this.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		neoBuilding.bbox.maxY = this.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;
		neoBuilding.bbox.maxZ = this.readFloat32(arrayBuffer, bytesReaded, bytesReaded+4); bytesReaded += 4;

		// create a building and set the location.***
		neoBuilding.buildingId = buildingName.substr(4, buildingNameLength-4);
		neoBuilding.buildingType = "basicBuilding";
		neoBuilding.buildingFileName = buildingName;
		neoBuilding.metaData.geographicCoord.setLonLatAlt(longitude, latitude, altitude);
	}

	neoBuildingsList.neoBuildingsArray.reverse();
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param fileName 변수
 * @param neoBuilding 변수
 * @param readerWriter 변수
 * @param magoManager 변수
 */
ReaderWriter.prototype.getNeoHeaderAsimetricVersion = function(gl, fileName, neoBuilding, readerWriter, magoManager) 
{
	function Utf8ArrayToStr(array) 
	{
		var out, i, len, c;
		var char2, char3;

		out = "";
		len = array.length;
		i = 0;
		while (i < len) 
		{
			c = array[i++];
			switch (c >> 4)
			{ 
			case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
				// 0xxxxxxx
				out += String.fromCharCode(c);
				break;
			case 12: case 13:
				// 110x xxxx   10xx xxxx
				char2 = array[i++];
				out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));
				break;
			case 14:
				// 1110 xxxx  10xx xxxx  10xx xxxx
				char2 = array[i++];
				char3 = array[i++];
				out += String.fromCharCode(((c & 0x0F) << 12) |
                       ((char2 & 0x3F) << 6) |
                       ((char3 & 0x3F) << 0));
				break;
			}
		}

		return out;
	};

	//BR_Project._f4d_header_readed = true;
	magoManager.fileRequestControler.headerFilesRequestedCount += 1;
	neoBuilding.metaData.fileLoadState = CODE.fileLoadState.LOADING_STARTED;

	loadWithXhr(fileName).then(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			var bytesReaded = 0;
			neoBuilding.metaData.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
			neoBuilding.headerDataArrayBuffer = arrayBuffer;
			////neoBuilding.parseHeader(arrayBuffer, bytesReaded) ;
			arrayBuffer = undefined;
		}
		else 
		{
			neoBuilding.metaData.fileLoadState = 500;
			arrayBuffer = undefined;
		}
	},
	function(status) 
	{
		console.log("xhr status = " + status);
		if (status === 0) { neoBuilding.metaData.fileLoadState = 500; }
		else { neoBuilding.metaData.fileLoadState = status; }
	}).finally(function() 
	{
		magoManager.fileRequestControler.headerFilesRequestedCount -= 1;
		if (magoManager.fileRequestControler.headerFilesRequestedCount < 0) { magoManager.fileRequestControler.headerFilesRequestedCount = 0; }
	});
};


/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param filePath_inServer 변수
 * @param f4dTex 변수
 * @param magoManager 변수
 */
ReaderWriter.prototype.readTexture = function(gl, filePath_inServer, f4dTex, magoManager) 
{
	f4dTex.loadStarted = true;
	//f4dTex.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	f4dTex.texImage = new Image();
	f4dTex.texImage.onload = function() 
	{
		f4dTex.loadFinished = true;
		//f4dTex.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;

		if (magoManager.backGround_fileReadings_count > 0 ) { magoManager.backGround_fileReadings_count -=1; }
	};

	f4dTex.texImage.onerror = function() 
	{
		// doesn't exist or error loading
		f4dTex.loadStarted = false;
		if (magoManager.backGround_fileReadings_count > 0 ) { magoManager.backGround_fileReadings_count -=1; }
		return;
	};

	f4dTex.texImage.src = filePath_inServer;
};

ReaderWriter.prototype.decodeTGA = function(arrayBuffer) 
{
	// code from toji.***
	var content = new Uint8Array(arrayBuffer),
		contentOffset = 18 + content[0],
		imagetype = content[2], // 2 = rgb, only supported format for now
		width = content[12] + (content[13] << 8),
		height = content[14] + (content[15] << 8),
		bpp = content[16], // should be 8,16,24,32
		
		bytesPerPixel = bpp / 8,
		bytesPerRow = width * 4,
		data, i, j, x, y;

	if (!width || !height) 
	{
		console.error("Invalid dimensions");
		return null;
	}

	if (imagetype !== 2) 
	{
		console.error("Unsupported TGA format:", imagetype);
		return null;
	}

	data = new Uint8Array(width * height * 4);
	i = contentOffset;

	// Oy, with the flipping of the rows...
	for (y = height-1; y >= 0; --y) 
	{
		for (x = 0; x < width; ++x, i += bytesPerPixel) 
		{
			j = (x * 4) + (y * bytesPerRow);
			data[j] = content[i+2];
			data[j+1] = content[i+1];
			data[j+2] = content[i+0];
			data[j+3] = (bpp === 32 ? content[i+3] : 255);
		}
	}

	return {
		width  : width,
		height : height,
		data   : data
	};
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param filePath_inServer 변수
 * @param texture 변수
 * @param neoBuilding 변수
 * @param magoManager 변수
 */
ReaderWriter.prototype.readNeoReferenceTexture = function(gl, filePath_inServer, texture, neoBuilding, magoManager) 
{
	// Must know the fileExtension.***
	var extension = filePath_inServer.split('.').pop();
	
	if (extension === "tga" || extension === "TGA" || extension === "Tga")
	{
		texture.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
		loadWithXhr(filePath_inServer).then(function(response) 
		{
			var arrayBuffer = response;
			if (arrayBuffer) 
			{
				// decode tga.***
				// Test with tga decoder from https://github.com/schmittl/tgajs
				var tga = new TGA();
				tga.load(arrayBuffer);
				// End decoding.---------------------------------------------------
				
				//var tga = magoManager.readerWriter.decodeTGA(arrayBuffer); // old code.
				//if(tga) {
				//    gl.bindTexture(gl.TEXTURE_2D, texture.texId);
				//     gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, tga.width, tga.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, tga.data);
				//    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				//	gl.generateMipmap(gl.TEXTURE_2D);
				//	texture.fileLoadState = CODE.fileLoadState.LOADING_FINISHED; // file load finished.***
				//}
				
				// example values of tga.header
				// alphaBits 0
				// bytePerPixel 3
				// colorMapDepth 0
				// colorMapIndex 0
				// colorMapLength 0
				// colorMapType 0
				// flags 32
				// hasColorMap false
				// hasEncoding false
				// height 2048
				// idLength 0
				// imageType 2
				// isGreyColor false
				// offsetX 0
				// offsetY 0
				// origin 2
				// pixelDepth 24
				// width 2048
				
				if (tga) 
				{
					var rgbType;
					if (tga.header.bytePerPixel === 3)
					{
						rgbType = gl.RGB;
						
						// test change rgb to bgr.***
						/*
						var imageDataLength = tga.imageData.length;
						var pixelsCount = imageDataLength/3;
						var r, g, b;
						for(var i=0; i<pixelsCount; i++)
						{
							r = tga.imageData[i*3];
							g = tga.imageData[i*3+1];
							b = tga.imageData[i*3+2];
							
							tga.imageData[i*3] = b;
							tga.imageData[i*3+1] = g;
							tga.imageData[i*3+2] = r;
						}
						*/
					}
					else if (tga.header.bytePerPixel === 4)
					{
						rgbType = gl.RGBA;
						
						// test change rgb to bgr.***
						
						var imageDataLength = tga.imageData.length;
						var pixelsCount = imageDataLength/4;
						var r, g, b, a;
						for (var i=0; i<pixelsCount; i++)
						{
							r = tga.imageData[i*4];
							g = tga.imageData[i*4+1];
							b = tga.imageData[i*4+2];
							a = tga.imageData[i*4+3];
							
							tga.imageData[i*4] = b;
							tga.imageData[i*4+1] = g;
							tga.imageData[i*4+2] = r;
							tga.imageData[i*4+3] = a;
						}
						
					}
					
					
					if (tga.imageData !== undefined && tga.imageData.length > 0 && texture.texId !== undefined)
					{
						gl.bindTexture(gl.TEXTURE_2D, texture.texId);
						gl.texImage2D(gl.TEXTURE_2D, 0, rgbType, tga.header.width, tga.header.height, 0, rgbType, gl.UNSIGNED_BYTE, tga.imageData);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
						gl.generateMipmap(gl.TEXTURE_2D);
						texture.fileLoadState = CODE.fileLoadState.LOADING_FINISHED; // file load finished.***
						gl.bindTexture(gl.TEXTURE_2D, null);
					}
				}
			}
		},
		function(status) 
		{
			if (neoBuilding)
			{
				console.log("xhr status = " + status);
				if (status === 0) { neoBuilding.metaData.fileLoadState = 500; }
				else { neoBuilding.metaData.fileLoadState = status; }
			}
		}).finally(function() 
		{
			magoManager.backGround_fileReadings_count -= 1;
			if (magoManager.backGround_fileReadings_count < 0) { magoManager.backGround_fileReadings_count = 0; }
		});
	}
	else 
	{
		var neoRefImage = new Image();
		texture.fileLoadState = CODE.fileLoadState.LOADING_STARTED; // file load started.***
		
		//magoManager.backGround_fileReadings_count ++;
		neoRefImage.onload = function() 
		{
			// is possible that during loading image the building was deleted. Then return.
			if (texture.texId === undefined)
			{
				return;
			}
			
			// if "texture.texId" exist then bind it.
			handleTextureLoaded(gl, neoRefImage, texture.texId);
			texture.fileLoadState = CODE.fileLoadState.LOADING_FINISHED; // file load finished.***

			if (magoManager.backGround_fileReadings_count > 0 ) 
			{ magoManager.backGround_fileReadings_count -=1; }
		};

		neoRefImage.onerror = function() 
		{
			// doesn't exist or error loading
			return;
		};
		neoRefImage.src = filePath_inServer;
	}	
};

ReaderWriter.loadBinaryData = function(fileName, dataContainer, weatherLayer) 
{
	dataContainer.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	
	loadWithXhr(fileName).then(function(response) 
	{	
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			dataContainer.dataArraybuffer = arrayBuffer;
			dataContainer.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
			arrayBuffer = null;
			
			weatherLayer.parseData(dataContainer);
		}
		else 
		{
			dataContainer.fileLoadState = 500;
		}
	},
	function(status) 
	{
		console.log("Invalid XMLHttpRequest status = " + status);
		if (status === 0) { dataContainer.fileLoadState = 500; }
		else { dataContainer.fileLoadState = status; }
	}).finally(function() 
	{
		
	});
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param filePath_inServer 변수
 * @param texture 변수
 * @param neoBuilding 변수
 * @param magoManager 변수
 */
ReaderWriter.loadImage = function(gl, filePath_inServer, texture) 
{
	// Must know the fileExtension.***
	//var extension = filePath_inServer.split('.').pop();
	
	var image = new Image();
	texture.fileLoadState = CODE.fileLoadState.LOADING_STARTED; // file load started.***
	
	image.onload = function() 
	{
		// is possible that during loading image the building was deleted. Then return.
		if (texture.texId === undefined)
		{
			return;
		}
		
		texture.imageWidth = image.width;
		texture.imageHeight = image.height;
		
		function createTexture(_gl, filter, data, width, height) 
		{
			var textureAux = _gl.createTexture();
			_gl.bindTexture(_gl.TEXTURE_2D, textureAux);
			//_gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
			_gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
			_gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
			_gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, filter);
			_gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, filter);
			if (data instanceof Uint8Array) 
			{
				_gl.texImage2D(_gl.TEXTURE_2D, 0, _gl.RGBA, width, height, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, data);
			}
			else 
			{
				_gl.texImage2D(_gl.TEXTURE_2D, 0, _gl.RGBA, _gl.RGBA, _gl.UNSIGNED_BYTE, data);
			}
			_gl.bindTexture(_gl.TEXTURE_2D, null);
			//gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
			return textureAux;
		}

		texture.texId = createTexture(gl, gl.LINEAR, image);
		texture.fileLoadState = CODE.fileLoadState.BINDING_FINISHED; // file load finished.***
	};

	image.onerror = function() 
	{
		// doesn't exist or error loading
		return;
	};
	image.src = filePath_inServer;
		
};


/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param filePath_inServer 변수
 * @param texture 변수
 * @param neoBuilding 변수
 * @param magoManager 변수
 */
ReaderWriter.prototype.readLegoSimpleBuildingTexture = function(gl, filePath_inServer, texture, magoManager, flip_y_texCoord) 
{
	var neoRefImage = new Image();
	texture.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	magoManager.fileRequestControler.lowLodImagesRequestedCount += 1;

	neoRefImage.onload = function() 
	{
		if (texture.texId === undefined) 
		{ texture.texId = gl.createTexture(); }

		if (flip_y_texCoord === undefined)
		{ flip_y_texCoord = true; }
		
		handleTextureLoaded(gl, neoRefImage, texture.texId, flip_y_texCoord);
		texture.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
		
		magoManager.fileRequestControler.lowLodImagesRequestedCount -= 1;

		if (magoManager.backGround_fileReadings_count > 0 ) { magoManager.backGround_fileReadings_count -=1; }
		if (magoManager.fileRequestControler.lowLodImagesRequestedCount < 0) { magoManager.fileRequestControler.lowLodImagesRequestedCount = 0; }
	};

	neoRefImage.onerror = function() 
	{
		if (texture.texId === undefined) 
		{
			texture.texId = gl.createTexture();
			// Test wait for texture to load.********************************************
			gl.bindTexture(gl.TEXTURE_2D, texture.texId);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([200, 200, 200, 255])); // clear grey
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
		
		texture.fileLoadState = CODE.fileLoadState.READY;
		
		magoManager.fileRequestControler.lowLodImagesRequestedCount -= 1;
		if (magoManager.fileRequestControler.lowLodImagesRequestedCount < 0) { magoManager.fileRequestControler.lowLodImagesRequestedCount = 0; }
	};

	neoRefImage.src = filePath_inServer;
};


/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param fileName 변수
 * @param terranTile 변수
 * @param readerWriter 변수
 * @param magoManager 변수
 */
ReaderWriter.prototype.getTileArrayBuffer = function(gl, fileName, terranTile, readerWriter, magoManager) 
{
	// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data
	terranTile.fileReading_started = true;
	//	magoManager.fileRequestControler.backGround_fileReadings_count += 1;
	//	blocksList.fileLoadState = CODE.fileLoadState.LOADING_STARTED;

	loadWithXhr(fileName).then(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			//var BR_Project = new BRBuildingProject(); // Test.***
			//readerWriter.readF4D_Header(gl, arrayBuffer, BR_Project ); // Test.***
			terranTile.fileArrayBuffer = arrayBuffer;
			terranTile.fileReading_finished = true;

			if (magoManager.backGround_fileReadings_count > 0 ) { magoManager.backGround_fileReadings_count -=1; }
			//			blocksList.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
			arrayBuffer = null;
		}
		else 
		{
			//			blocksList.fileLoadState = 500;
		}
	},
	function(status) 
	{
		console.log("xhr status = " + status);
		//		if(status === 0) blocksList.fileLoadState = 500;
		//		else blocksList.fileLoadState = status;
	}).finally(function() 
	{
		//		magoManager.fileRequestControler.filesRequestedCount -= 1;
		//		if(magoManager.fileRequestControler.filesRequestedCount < 0) magoManager.fileRequestControler.filesRequestedCount = 0;
	});
};

/**
 * 어떤 일을 하고 있습니까?
 * @param filePath_inServer 변수
 * @param pCloud 변수
 * @param readerWriter 변수
 * @param magoManager 변수
 */
ReaderWriter.prototype.loadTINTerrain = function(fileName, tinTerrain, magoManager) 
{
	//magoManager.fileRequestControler.modelRefFilesRequestedCount += 1;
	tinTerrain.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	
	loadWithXhr(fileName).then(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			tinTerrain.dataArrayBuffer = arrayBuffer;
			tinTerrain.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
			//magoManager.parseQueue.putTinTerrainToParse(lowestOctree); // todo.***
			arrayBuffer = undefined;
		}
		else 
		{
			tinTerrain.fileLoadState = 500;
		}
	}, function(status) 
	{
		tinTerrain.fileLoadState = CODE.fileLoadState.LOAD_FAILED;
		//console.log("xhr status = " + status);
		//if (status === 0) { lowestOctree.neoReferencesMotherAndIndices.fileLoadState = 500; }
		//else { lowestOctree.neoReferencesMotherAndIndices.fileLoadState = status; }
	}).finally(function() 
	{
		//magoManager.fileRequestControler.modelRefFilesRequestedCount -= 1;
		//if (magoManager.fileRequestControler.modelRefFilesRequestedCount < 0) { magoManager.fileRequestControler.modelRefFilesRequestedCount = 0; }
	});
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param imageArrayBuffer 변수
 * @param magoManager 변수
 */
ReaderWriter.prototype.imageFromArrayBuffer = function(gl, imageArrayBuffer, texture, magoManager, flip_y_texCoords) 
{
	// example: allowedFileTypes = ["image/png", "image/jpeg", "image/gif"];
	var blob = new Blob( [ imageArrayBuffer ], { type: "image/png" } );
	var urlCreator = window.URL || window.webkitURL;
	var imagenUrl = urlCreator.createObjectURL(blob);
	var imageFromArray = new Image();

	imageFromArray.onload = function () 
	{
		if (flip_y_texCoords === undefined)
		{ flip_y_texCoords = false; }
		
		if (texture.texId === undefined)
		{ texture.texId = gl.createTexture(); }
		handleTextureLoaded(gl, imageFromArray, texture.texId, flip_y_texCoords);
		texture.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
		imageArrayBuffer = null;
	};

	imageFromArray.onerror = function() 
	{
		return;
	};

	imageFromArray.src = imagenUrl;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param filePath_inServer 변수
 * @param texture 변수
 * @param magoManager 변수
 */
ReaderWriter.prototype.loadWMSImage = function(gl, filePath_inServer, texture, magoManager, flip_y_texCoords) 
{
	texture.fileLoadState = CODE.fileLoadState.LOADING_STARTED;
	var readWriter = this;
	loadWithXhr(filePath_inServer).then(function(response) 
	{
		var arrayBuffer = response;
		if (arrayBuffer) 
		{
			if (flip_y_texCoords === undefined)
			{ flip_y_texCoords = false; }
		
			readWriter.imageFromArrayBuffer(gl, arrayBuffer, texture, magoManager, flip_y_texCoords);
			texture.fileLoadState = CODE.fileLoadState.LOADING_FINISHED;
		}
	}, function(status) 
	{
		console.log(status);
		
	}).finally(function() 
	{
		magoManager.backGround_fileReadings_count -= 1;
		if (magoManager.backGround_fileReadings_count < 0) { magoManager.backGround_fileReadings_count = 0; }
	});
		
};

'use strict';

/**
 * This is a skin-type building.
 * @class SkinBuilding
 */
var SkinBuilding = function() 
{
	if (!(this instanceof SkinBuilding)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	// SkinBuildings depends the MultiBuilding class object.***
	this.multiBuildingsOwner;
	
	this.indexRange;
	
	// This class can have lod textures.***
	
};
'use strict';

/**
 * This class is used to render the earth.
 * @class TinTerrain
 */
var TinTerrain = function(owner) 
{
	if (!(this instanceof TinTerrain)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	
	this.owner; // undefined if depth = 0.
	this.depth; 
	if (owner)
	{
		this.owner = owner;
		this.depth = owner.depth + 1;
	}
	else 
	{
		this.depth = 0;
	}
	
	this.childArray; // child array.
	this.childMap; // example: this.childMap["LU"] = tinTerrainChild.
	
	// Data.
	this.X; // tile index X.
	this.Y; // tile index Y.
	
	// CencerPosition.
	this.centerX; // Float64Array.
	this.centerY; // Float64Array.
	this.centerZ; // Float64Array.
	
	// positions(x, y, z), normals, texCoords, colors & indices array.
	this.cartesiansArray;
	this.normalsArray;
	this.texCoordsArray;
	this.colorsArray;
	this.indices;
	
	this.skirtCartesiansArray;
	this.skirtTexCoordsArray;
	
	// Tile extent.
	this.geographicExtent;
	this.sphereExtent;
	this.webMercatorExtent;
	
	// Tile geometry data.
	this.fileLoadState = 0;
	this.dataArrayBuffer;
	this.vboKeyContainer; // class: VBOVertexIdxCacheKeysContainer.
	this.terrainPositionHIGH;
	this.terrainPositionLOW;
	
	this.indexName; // example: "LU".
	this.pathName; // example: "14//4567//516".
	this.texture;
	this.visible;
	
	this.tinTerrainManager;
	
	this.isAdult = false;
	this.birthTime;
	
	/**
	 * Object's current rendering phase. Parameter to avoid duplicated render on scene.
	 * @type {Boolean}
	 * @default false
	 */
	this.renderingFase = false;
};

TinTerrain.prototype.deleteObjects = function(magoManager)
{
	var gl = magoManager.sceneState.gl;
	
	// delete all tree under this tinTerrain. no delete tiles if depth < 2.
	if (this.childMap !== undefined)
	{
		// subTile 0 (Left-Up).
		var subTile_LU = this.childMap.LU;
		if (subTile_LU !== undefined)
		{
			subTile_LU.deleteObjects(magoManager);
			delete this.childMap.LU;
		}
		
		// subTile 1 (Left-Down).
		var subTile_LD = this.childMap.LD;
		if (subTile_LD !== undefined)
		{
			subTile_LD.deleteObjects(magoManager);
			delete this.childMap.LD;
		}
		
		// subTile 2 (Right-Up).
		var subTile_RU = this.childMap.RU;
		if (subTile_RU !== undefined)
		{
			subTile_RU.deleteObjects(magoManager);
			delete this.childMap.RU;
		}
		
		// subTile 3 (Right-Down).
		var subTile_RD = this.childMap.RD;
		if (subTile_RD !== undefined)
		{
			subTile_RD.deleteObjects(magoManager);
			delete this.childMap.RD;
		}
		
		this.childMap = undefined;
	}
	
	// no delete tiles if depth < 2.
	if (this.depth < 2)
	{ return; }
		
	// now delete objects of this tinTerrain.
	this.owner = undefined;
	this.depth = undefined; 
	this.childArray = undefined;
	this.childMap = undefined; 
	
	// Data.
	this.X = undefined; // index X.
	this.Y = undefined; // index Y.
	
	// Tile extent.
	if (this.geographicExtent !== undefined)
	{
		this.geographicExtent.deleteObjects();
		this.geographicExtent = undefined;
	}
	
	if (this.sphereExtent !== undefined)
	{
		this.sphereExtent.deleteObjects();
		this.sphereExtent = undefined;
	}
	
	// Tile geometry data.
	this.fileLoadState = 0;
	this.dataArrayBuffer = undefined;
	
	if (this.vboKeyContainer !== undefined)
	{
		this.vboKeyContainer.deleteGlObjects(gl, magoManager.vboMemoryManager);
		this.vboKeyContainer = undefined; // class: VBOVertexIdxCacheKeysContainer.
		
	}
	this.terrainPositionHIGH = undefined;
	this.terrainPositionLOW = undefined;
	
	this.indexName = undefined;
	this.pathName = undefined; // example: "14//4567//516".
	
	if (this.texture !== undefined)
	{
		this.texture.deleteObjects(gl);
		this.texture = undefined;
	}
	this.visible = undefined;
};

TinTerrain.prototype.getPathName = function()
{
	// this returns a string as: L//X//Y.
	// example: "14//4567//516".
	return this.depth.toString() + "\\" + this.X.toString() + "\\" + this.Y.toString();
};

/**
 * Returns the blending alpha value in current time.
 * 
 * @param {Number} currTime The current time.
 */
TinTerrain.prototype.getBlendAlpha = function(currTime) 
{
	if (!this.isAdult)
	{
		if (this.birthTime === undefined)
		{ this.birthTime = currTime; }
	
		if (this.blendAlpha === undefined)
		{ this.blendAlpha = 0.1; }
		
		var increAlpha = (currTime - this.birthTime)*0.0001;
		this.blendAlpha += increAlpha;
		
		if (this.blendAlpha >= 1.0)
		{
			this.blendAlpha = 1.0;
			this.isAdult = true;
		}
	}
	else
	{ return 1.0; }
	
	return this.blendAlpha;
};

TinTerrain.prototype.setWebMercatorExtent = function(minX, minY, maxX, maxY)
{
	if (this.webMercatorExtent === undefined)
	{ this.webMercatorExtent = new Rectangle2D(); }
	
	this.webMercatorExtent.setExtension(minX, minY, maxX, maxY);
	// Note: the minX & maxX are no util values.
};

TinTerrain.prototype.setGeographicExtent = function(minLon, minLat, minAlt, maxLon, maxLat, maxAlt)
{
	if (this.geographicExtent === undefined)
	{ this.geographicExtent = new GeographicExtent(); }
	
	var geoExtent = this.geographicExtent;
	
	if (geoExtent.minGeographicCoord === undefined)
	{ geoExtent.minGeographicCoord = new GeographicCoord(); }
	
	if (geoExtent.maxGeographicCoord === undefined)
	{ geoExtent.maxGeographicCoord = new GeographicCoord(); }
	
	geoExtent.minGeographicCoord.setLonLatAlt(minLon, minLat, minAlt);
	geoExtent.maxGeographicCoord.setLonLatAlt(maxLon, maxLat, maxAlt);
};

TinTerrain.prototype.isChildrenPrepared = function()
{
	if (this.childMap === undefined)
	{ return false; }
	
	if (this.childMap.length < 4)
	{ return false; }
	
	if (this.childMap.LU.isPrepared() && this.childMap.LD.isPrepared() && this.childMap.RU.isPrepared() &&  this.childMap.RD.isPrepared())
	{ return true; }
	else
	{ return false; }
};

TinTerrain.prototype.isPrepared = function()
{
	// a tinTerrain is prepared if this is parsed and vbo maked and texture binded.
	if (this.fileLoadState !== CODE.fileLoadState.PARSE_FINISHED)
	{ return false; }
	
	if (this.texture === undefined || this.texture.fileLoadState !== CODE.fileLoadState.LOADING_FINISHED)
	{ return false; }

	if (this.texture.texId === undefined)
	{ return false; }
	
	if (this.vboKeyContainer === undefined || 
		this.vboKeyContainer.vboCacheKeysArray === undefined || 
		this.vboKeyContainer.vboCacheKeysArray.length === 0)
	{ return false; }
	
	return true;
};

TinTerrain.prototype.prepareTexture = function(magoManager, tinTerrainManager)
{
	var gl = magoManager.sceneState.gl;
	this.texture = new Texture();
	
	// Provisionally test.******************************************************************************************
	//var imagesDataPath = "\\images\\ko";
	//var textureFilePath = imagesDataPath +  "\\funny" + ".jpg";
	//magoManager.readerWriter.readLegoSimpleBuildingTexture(gl, textureFilePath, this.texture, magoManager);
	//return;
	// End test.----------------------------------------------------------------------------------------------------
			
	var geoServURL = tinTerrainManager.geoServURL;
	var L = this.depth.toString();
	var X = this.X.toString();
	var Y = this.Y.toString();
	
	//var tilePath = L + "&TileRow=" + Y + "&TileCol=" + X;
	//var textureFilePath = geoServURL + "?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&Layer=mago3d:SejongBGM&Format=image/png&TileMatrixSet=EPSG:4326&TileMatrix=EPSG:4326:" + tilePath;
	//https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'


	//https://a.tile.openstreetmap.org/${z}/${x}/${y}.png 
	//https://b.tile.openstreetmap.org/${z}/${x}/${y}.png 
	//https://c.tile.openstreetmap.org/${z}/${x}/${y}.png
		
	var textureFilePath = "https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/" + L + "/" + Y + "/" + X + ".png";
	//var textureFilePath = "https://services.arcgisonline.com/arcgis/rest/services/World_Street_Map/MapServer/tile/" + L + "/" + Y + "/" + X + ".png";
	//var textureFilePath = "https://services.arcgisonline.com/arcgis/rest/services/World_Physical_Map/MapServer/tile/" + L + "/" + Y + "/" + X + ".png"; // low res.
	//var textureFilePath = "https://services.arcgisonline.com/arcgis/rest/services/NatGeo_World_Map/MapServer/tile/" + L + "/" + Y + "/" + X + ".png"; // low res.
	//var textureFilePath = "https://c.tile.openstreetmap.org/" + L + "/" + X + "/" + Y + ".png";
	
	// Provisionally, for debug, save textureFilePath.***
	this.texFilePath__TEST = textureFilePath;
	var flip_y_texCoords = false;
	magoManager.readerWriter.loadWMSImage(gl, textureFilePath, this.texture, magoManager, flip_y_texCoords);
};

TinTerrain.prototype.prepareTinTerrainPlain = function(magoManager, tinTerrainManager)
{
	// Earth considering as an ellipsoid (no elevation data of terrain).***
	// This is a test function.!!!
	// This function 1- loads file & 2- parses file & 3- makes vbo.
	// 1rst, check if the parent is prepared. If parent is not prepared, then prepare the parent.
	
	if (this.owner === undefined || this.owner.isPrepared())
	{
		// 1rst, try to erase from procesQueue_deleting if exist.
		magoManager.processQueue.eraseTinTerrainToDelete(this);
		
		// Prepare this tinTerrain.
		this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED; // Test code.!!!
		if (this.fileLoadState === CODE.fileLoadState.READY)
		{
			//var pathName = this.getPathName();
			//var fileName = "Terrain/" + pathName + ".terrain";
			//magoManager.readerWriter.loadTINTerrain(fileName, this, magoManager);
			
		}
		else if (this.fileLoadState === CODE.fileLoadState.LOADING_FINISHED)
		{
			// put the terrain into parseQueue.
			//magoManager.parseQueue.putTinTerrainToParse(this, 0);
		}
		else if (this.fileLoadState === CODE.fileLoadState.PARSE_FINISHED && this.vboKeyContainer === undefined)
		{
			this.calculateCenterPosition();
			this.makeMeshVirtually(20, 20, undefined, undefined);
			this.makeVbo(magoManager.vboMemoryManager);
		}
		else if (this.texture === undefined)
		{
			this.prepareTexture(magoManager, tinTerrainManager);
		}

		return;
	}
	else
	{
		// Prepare ownerTinTerrain.
		this.owner.prepareTinTerrainPlain(magoManager, tinTerrainManager);
		return;
	}
};

TinTerrain.prototype.prepareTinTerrain = function(magoManager, tinTerrainManager)
{
	// This function 1- loads file & 2- parses file & 3- makes vbo.
	// 1rst, check if the parent is prepared. If parent is not prepared, then prepare the parent.
	if (this.owner === undefined || this.owner.isPrepared())
	{
		// 1rst, try to erase from procesQueue_deleting if exist.
		magoManager.processQueue.eraseTinTerrainToDelete(this);
		
		if (this.depth === 0)
		{
			this.fileLoadState = CODE.fileLoadState.LOAD_FAILED;
		}
		
		// Prepare this tinTerrain.
		if (this.fileLoadState === CODE.fileLoadState.READY)
		{
			var pathName = this.getPathName();
			var geometryDataPath = magoManager.readerWriter.geometryDataPath;
			var fileName = geometryDataPath + "/Terrain/" + pathName + ".terrain";
			magoManager.readerWriter.loadTINTerrain(fileName, this, magoManager);
			
		}
		else if (this.fileLoadState === CODE.fileLoadState.LOADING_FINISHED)
		{
			// put the terrain into parseQueue.
			magoManager.parseQueue.putTinTerrainToParse(this, 0);
		}
		else if (this.fileLoadState === CODE.fileLoadState.PARSE_FINISHED && this.vboKeyContainer === undefined)
		{
			this.decodeData(tinTerrainManager.imageryType);
			this.makeVbo(magoManager.vboMemoryManager);
		}
		else if (this.texture === undefined)
		{
			this.prepareTexture(magoManager, tinTerrainManager);
		}
		else if (this.fileLoadState === CODE.fileLoadState.LOAD_FAILED)
		{
			// Test.***
			this.prepareTinTerrainPlain(magoManager, tinTerrainManager);
			// End test.---
		}

		return;
	}
	else
	{
		// Prepare ownerTinTerrain.
		this.owner.prepareTinTerrain(magoManager, tinTerrainManager);
		return;
	}
};

TinTerrain.prototype.hasChildren = function()
{
	if (this.childMap !== undefined && this.childMap.length > 0)
	{ return true; }
	
	return false;
};

TinTerrain.prototype.deleteTinTerrain = function(magoManager)
{
	// The quadTree must be deleted lowest-quads first.
	// Check if this has child. If this has child, then, 1rst delete child.
	if (this.hasChildren())
	{
		// Delete children 1rst.
		for (var key in this.childMap)
		{
			if (Object.prototype.hasOwnProperty.call(this.childMap, key))
			{
				var child = this.childMap[key];
				child.deleteTinTerrain(magoManager);
			}
		}
		
		return false;
	}
	else
	{
		// 1rst, delete from parse-queue if exist.
		magoManager.parseQueue.eraseTinTerrainToParse(this);
		// put this tinTerrain into deleteQueue.
		magoManager.processQueue.putTinTerrainToDelete(this, 0);
		
		// now, must erase from myOwner-childrenMap.
		delete this.owner.childMap[this.indexName];
		
		if (this.owner.childMap.length === 0)
		{ this.owner.childMap = undefined; }
		
		return true;
	}
};

TinTerrain.prototype.renderBorder = function(currentShader, magoManager)
{
	// TODO:
};

TinTerrain.prototype.render = function(currentShader, magoManager, bDepth, renderType)
{		
	if (this.owner === undefined || (this.owner.isPrepared() && this.owner.isChildrenPrepared()))
	{
		if (this.isPrepared())
		{
			if (this.fileLoadState === CODE.fileLoadState.LOAD_FAILED) // provisional solution.
			{ return false; }
		
			if (this.texture.texId === undefined)
			{ return false; }
		
			var gl = magoManager.getGl();
			
			
		
			if (renderType === 2)
			{
				var colorAux;
				colorAux = magoManager.selectionColor.getAvailableColor(colorAux);
				var idxKey = magoManager.selectionColor.decodeColor3(colorAux.r, colorAux.g, colorAux.b);
				magoManager.selectionManager.setCandidateGeneral(idxKey, this);
				
				gl.uniform1i(currentShader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
				gl.uniform4fv(currentShader.oneColor4_loc, [colorAux.r/255.0, colorAux.g/255.0, colorAux.b/255.0, 1.0]);
			}
			
			// Test.******************************************************************************************
			if (renderType === 1)
			{
				gl.uniform1i(currentShader.colorType_loc, 2); // 0= oneColor, 1= attribColor, 2= texture.
				gl.uniform1f(currentShader.externalAlpha_loc, 1);
				//var currSelObject = magoManager.selectionManager.getSelectedGeneral();
				//if (currSelObject === this)
				//{
				//	gl.uniform1i(currentShader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
				//	gl.uniform4fv(currentShader.oneColor4_loc, [0.8, 0.3, 0.1, 1.0]);
					
			}
			// End test.--------------------------------------------------------------------------------------
			
			// render this tinTerrain.
			var renderWireframe = false;
			
			gl.bindTexture(gl.TEXTURE_2D, this.texture.texId);
			
			gl.uniform3fv(currentShader.buildingPosHIGH_loc, this.terrainPositionHIGH);
			gl.uniform3fv(currentShader.buildingPosLOW_loc, this.terrainPositionLOW);
			
			var vboKey = this.vboKeyContainer.vboCacheKeysArray[0]; // the idx = 0 is the terrain. idx = 1 is the skirt.
			
			// Positions.
			if (!vboKey.bindDataPosition(currentShader, magoManager.vboMemoryManager))
			{ 
				if (this.owner !== undefined)
				{ this.owner.render(currentShader, magoManager, bDepth, renderType); }
				return false; 
			}
		
			// TexCoords (No necessary for depth rendering).
			if (!bDepth)
			{
				if (!vboKey.bindDataTexCoord(currentShader, magoManager.vboMemoryManager))
				{
					if (this.owner !== undefined)
					{ this.owner.render(currentShader, magoManager, bDepth, renderType); }					
					return false; 
				}
			}
			
			// Normals.
			// todo:
			
			// Colors.
			// todo:
			
			// Indices.
			if (!vboKey.bindDataIndice(currentShader, magoManager.vboMemoryManager))
			{ 
				if (this.owner !== undefined)
				{ this.owner.render(currentShader, magoManager, bDepth, renderType); }
				return false; 
			}
			
			var indicesCount = vboKey.indicesCount;
			
			if (renderWireframe)
			{
				var trianglesCount = indicesCount;
				for (var i=0; i<trianglesCount; i++)
				{
					gl.drawElements(gl.LINE_LOOP, 3, gl.UNSIGNED_SHORT, i*3); // Fill.
				}
			}
			else
			{
				gl.drawElements(gl.TRIANGLES, indicesCount, gl.UNSIGNED_SHORT, 0); // Fill.
			}
			
			// Test Render wireframe if selected.*************************************************************
			if (renderType === 1)
			{
				gl.uniform1i(currentShader.colorType_loc, 2); // 0= oneColor, 1= attribColor, 2= texture.
				var currSelObject = magoManager.selectionManager.getSelectedGeneral();
				if (currSelObject === this)
				{
					gl.uniform1i(currentShader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
					gl.uniform4fv(currentShader.oneColor4_loc, [0.0, 0.9, 0.9, 1.0]);
					//gl.drawElements(gl.LINE_LOOP, indicesCount, gl.UNSIGNED_SHORT, 0); // Fill.
					var trianglesCount = indicesCount;
					for (var i=0; i<trianglesCount; i++)
					{
						gl.drawElements(gl.LINE_LOOP, 3, gl.UNSIGNED_SHORT, i*3); // Fill.
					}
					
					this.drawTerrainName(magoManager);
				}
			}
			// End test.--------------------------------------------------------------------------------------
			
			// Render skirt if exist.
			var vboKey = this.vboKeyContainer.vboCacheKeysArray[1]; // the idx = 0 is the terrain. idx = 1 is the skirt.
			if (vboKey === undefined)
			{ return; }
			
			// Positions.
			if (!vboKey.bindDataPosition(currentShader, magoManager.vboMemoryManager))
			{ 
				return false; 
			}
		
			// TexCoords (No necessary for depth rendering).
			if (!bDepth)
			{
				if (!vboKey.bindDataTexCoord(currentShader, magoManager.vboMemoryManager))
				{				
					return false; 
				}
			}
			
			// Normals.
			// todo:
			
			// Colors.
			// todo:
			
			gl.drawArrays(gl.TRIANGLE_STRIP, 0, vboKey.vertexCount); // Fill.

		}
		else 
		{
			// render the owner tinTerrain.
			if (this.owner !== undefined)
			{ this.owner.render(currentShader, magoManager, bDepth, renderType); }
		}
	}
	else 
	{
		// render the owner tinTerrain.
		if (this.owner !== undefined)
		{ this.owner.render(currentShader, magoManager, bDepth, renderType); }
	}
	
	return true;
};

/**
 * Draw terrain names on scene.
 */
TinTerrain.prototype.drawTerrainName = function(magoManager) 
{
	var canvas = magoManager.getObjectLabel();
	var ctx = canvas.getContext("2d");

	var gl = magoManager.getGl();
	var screenCoord;
	
	// Calculate the middle geoLocation.
	var midGeoCoord = this.geographicExtent.getMidPoint();
	var pointWC = ManagerUtils.geographicCoordToWorldPoint(midGeoCoord.longitude, midGeoCoord.latitude, midGeoCoord.altitude, undefined);
	screenCoord = ManagerUtils.calculateWorldPositionToScreenCoord(gl, pointWC.x, pointWC.y, pointWC.z, screenCoord, magoManager);
	
	if (screenCoord.x >= 0 && screenCoord.y >= 0)
	{
		ctx.font = "13px Arial";
		var pathName = this.getPathName();
		ctx.strokeText(pathName, screenCoord.x, screenCoord.y);
		ctx.fillText(pathName, screenCoord.x, screenCoord.y);
		
		magoManager.canvasDirty = true;
	}
	
	ctx.restore(); 
};

TinTerrain.prototype.extractLowestTinTerrains = function(resultLowestTilesArray)
{
	if (hasChildren())
	{
		for (var key in this.childMap)
		{
			if (Object.prototype.hasOwnProperty.call(this.childMap, key))
			{
				var child = this.childMap[key];
				child.visible = false;
				//child.extractLowestTinTerrains(resultLowestTilesArray);
				resultLowestTilesArray.push(child);
			}
		}
	}
	else 
	{
		//resultLowestTilesArray.push(this);
	}
};

TinTerrain.prototype.getFrustumIntersectedTinTerrainsQuadTree = function(frustum, maxDepth, camPos, magoManager, visibleTilesArray, noVisibleTilesArray)
{
	if (this.geographicExtent === undefined || this.geographicExtent.minGeographicCoord === undefined || this.geographicExtent.maxGeographicCoord === undefined)
	{ return; }
	
	var currMinGeographicCoords = this.geographicExtent.minGeographicCoord;
	var currMaxGeographicCoords = this.geographicExtent.maxGeographicCoord;
		
	if (this.sphereExtent === undefined)
	{
		this.sphereExtent = SmartTile.computeSphereExtent(magoManager, currMinGeographicCoords, currMaxGeographicCoords, this.sphereExtent);
	}
	
	var sphereExtentAux = this.sphereExtent;
	/*
	var intersectionType = frustum.intersectionSphere(sphereExtentAux);
	
	if (intersectionType === Constant.INTERSECTION_OUTSIDE)
	{ 
		this.visible = false;
		noVisibleTilesArray.push(this); // collect no visible tiles to delete it.
		return; 
	}
	*/
	//else if (intersectionType === Constant.INTERSECTION_INSIDE)
	//{
	//	// finish the process.
	//	this.visible = true;
	//	visibleTilesArray.push(this);
	//	return;
	//}
	//else if (intersectionType === Constant.INTERSECTION_INTERSECT || intersectionType === Constant.INTERSECTION_INSIDE)
	{
		var currDepth = this.depth;
		
		// check distance to camera.
		this.distToCam = camPos.distToSphere(sphereExtentAux);
		var distLimit = this.tinTerrainManager.distLimitByDepth[currDepth];
		
		if (this.distToCam > distLimit)// && this.depth > 1)
		{
			// finish the process.
			this.visible = true;
			visibleTilesArray.push(this);
			
			// Now, extract all lowest-child and put into "noVisibleTilesArray".***
			if (this.hasChildren())
			{
				//this.extractLowestTinTerrains(noVisibleTilesArray);
				noVisibleTilesArray.push(this.childMap.LU);
				noVisibleTilesArray.push(this.childMap.LD);
				noVisibleTilesArray.push(this.childMap.RU);
				noVisibleTilesArray.push(this.childMap.RD);
			}
			//noVisibleTilesArray.push(this); // collect no visible tiles to delete it.
			return;
		}
		
		if (currDepth < maxDepth)
		{
			// must descend.
			var curX = this.X;
			var curY = this.Y;
			var minLon = currMinGeographicCoords.longitude;
			var minLat = currMinGeographicCoords.latitude;
			var minAlt = currMinGeographicCoords.altitude;
			var maxLon = currMaxGeographicCoords.longitude;
			var maxLat = currMaxGeographicCoords.latitude;
			var maxAlt = currMaxGeographicCoords.altitude;
			var midLon = (minLon + maxLon)/ 2;
			var midLat = (minLat + maxLat)/ 2;
		
			// create children if no exist.
			// +--------------+--------------+
			// | subTile 0(LU)| subTile 2(RU)|
			// | X = curX*2   | X = curX*2+1 |
			// | Y = curY*2   | Y = curY*2   |
			// |              |              |
			// +--------------+--------------+
			// | subTile 1(LD)| subTile 3(RD)|
			// | X = curX*2   | X = curX*2+1 |
			// | Y = curY*2+1 | Y = curY*2+1 |
			// |              |              |
			// +--------------+--------------+
			
			if (this.tinTerrainManager.imageryType === CODE.imageryType.WEB_MERCATOR)
			{
				midLat = this.getMidLatitudeRadWebMercator()*180/Math.PI;
			}
			
			var wmMinX = this.webMercatorExtent.minX;
			var wmMinY = this.webMercatorExtent.minY;
			var wmMaxX = this.webMercatorExtent.maxX;
			var wmMaxY = this.webMercatorExtent.maxY;
			var wmMidX = (wmMaxX + wmMinX)/2.0;
			var wmMidY = (wmMaxY + wmMinY)/2.0;
				
			if (this.childMap === undefined)
			{ this.childMap = {}; }
			
			// subTile 0 (Left-Up).
			var subTile_LU = this.childMap.LU;
			if (subTile_LU === undefined)
			{
				// if no exist -> create it.
				subTile_LU = new TinTerrain(this);
				subTile_LU.X = curX*2;
				subTile_LU.Y = curY*2;
				subTile_LU.setGeographicExtent(minLon, midLat, minAlt,  midLon, maxLat, maxAlt); 
				subTile_LU.indexName = "LU";
				subTile_LU.tinTerrainManager = this.tinTerrainManager;
				this.childMap.LU = subTile_LU;
				
				subTile_LU.setWebMercatorExtent(wmMinX, wmMidY, wmMidX, wmMaxY);
			}
			
			// subTile 1 (Left-Down).
			var subTile_LD = this.childMap.LD;
			if (subTile_LD === undefined)
			{
				// if no exist -> create it.
				subTile_LD = new TinTerrain(this);
				subTile_LD.X = curX*2;
				subTile_LD.Y = curY*2+1;
				subTile_LD.setGeographicExtent(minLon, minLat, minAlt,  midLon, midLat, maxAlt); 
				subTile_LD.indexName = "LD";
				subTile_LD.tinTerrainManager = this.tinTerrainManager;
				this.childMap.LD = subTile_LD;
				
				subTile_LD.setWebMercatorExtent(wmMinX, wmMinY, wmMidX, wmMidY);
			}
			
			// subTile 2 (Right-Up).
			var subTile_RU = this.childMap.RU;
			if (subTile_RU === undefined)
			{
				subTile_RU = new TinTerrain(this);
				subTile_RU.X = curX*2+1;
				subTile_RU.Y = curY*2;
				subTile_RU.setGeographicExtent(midLon, midLat, minAlt,  maxLon, maxLat, maxAlt); 
				subTile_RU.indexName = "RU";
				subTile_RU.tinTerrainManager = this.tinTerrainManager;
				this.childMap.RU = subTile_RU;
				
				subTile_RU.setWebMercatorExtent(wmMidX, wmMidY, wmMaxX, wmMaxY);
			}
			
			// subTile 3 (Right-Down).
			var subTile_RD = this.childMap.RD;
			if (subTile_RD === undefined)
			{
				subTile_RD = new TinTerrain(this);
				subTile_RD.X = curX*2+1;
				subTile_RD.Y = curY*2+1;
				subTile_RD.setGeographicExtent(midLon, minLat, minAlt,  maxLon, midLat, maxAlt);
				subTile_RD.indexName = "RD";
				subTile_RD.tinTerrainManager = this.tinTerrainManager;
				this.childMap.RD = subTile_RD;
				
				subTile_RD.setWebMercatorExtent(wmMidX, wmMinY, wmMaxX, wmMidY);
			}
			
			// now, do frustumCulling for each childTiles.
			subTile_LU.getFrustumIntersectedTinTerrainsQuadTree(frustum, maxDepth, camPos, magoManager, visibleTilesArray, noVisibleTilesArray);
			subTile_LD.getFrustumIntersectedTinTerrainsQuadTree(frustum, maxDepth, camPos, magoManager, visibleTilesArray, noVisibleTilesArray);
			subTile_RU.getFrustumIntersectedTinTerrainsQuadTree(frustum, maxDepth, camPos, magoManager, visibleTilesArray, noVisibleTilesArray);
			subTile_RD.getFrustumIntersectedTinTerrainsQuadTree(frustum, maxDepth, camPos, magoManager, visibleTilesArray, noVisibleTilesArray);
		}
		else 
		{
			// finish the process.
			this.visible = true;
			visibleTilesArray.push(this);
			return;
		}
	}
};

TinTerrain.prototype.calculateCenterPosition = function()
{
	// Note: The centerPosition is Float64Array type.
	// The centerPosition of tiles are calculate with "altitude" = 0;.
	// Note: if the earth is made in only 1 tile, then this calculations is bad.

	var altitude = 0.0;
	var resultGeographicCoord;
	resultGeographicCoord = this.geographicExtent.getMidPoint(resultGeographicCoord);
	
	var centerLon = resultGeographicCoord.longitude;
	var centerLat = resultGeographicCoord.latitude;
	
	var resultCartesian;
	resultCartesian = Globe.geographicToCartesianWgs84(centerLon, centerLat, altitude, resultCartesian);
	
	// Float64Array.
	this.centerX = new Float64Array([resultCartesian[0]]);
	this.centerY = new Float64Array([resultCartesian[1]]);
	this.centerZ = new Float64Array([resultCartesian[2]]);
	
};

TinTerrain.prototype.getMidLatitudeRadWebMercator = function()
{
	if (this.webMercatorExtent === undefined)
	{ return undefined; }
	
	
	var midMercatorY = (this.webMercatorExtent.maxY + this.webMercatorExtent.minY)/2.0;
	var latRad = 2*Math.atan(Math.pow(Math.E, midMercatorY)) - Math.PI/2;
	
	
	if (isNaN(latRad))
	{ var hola = 0; }
	return latRad;
};

TinTerrain.prototype.makeMeshVirtually = function(lonSegments, latSegments, altitude, altitudesSlice)
{
	// WEB_MERCATOR.
	// This function makes an ellipsoidal mesh for tiles that has no elevation data.
	// note: "altitude" & "altitudesSlice" are optionals.
	var degToRadFactor = Math.PI/180.0;
	var minLon = this.geographicExtent.minGeographicCoord.longitude * degToRadFactor;
	var minLat = this.geographicExtent.minGeographicCoord.latitude * degToRadFactor;
	var maxLon = this.geographicExtent.maxGeographicCoord.longitude * degToRadFactor;
	var maxLat = this.geographicExtent.maxGeographicCoord.latitude * degToRadFactor;
	var lonRange = maxLon - minLon;
	var latRange = maxLat - minLat;
	var depth = this.depth;
	
	var lonIncreDeg = lonRange/lonSegments;
	var latIncreDeg = latRange/latSegments;
	
	// calculate total verticesCount.
	var vertexCount = (lonSegments + 1)*(latSegments + 1);
	var lonArray = new Float32Array(vertexCount);
	var latArray = new Float32Array(vertexCount);
	var altArray = new Float32Array(vertexCount);
	this.texCoordsArray = new Float32Array(vertexCount*2);
	
	var currLon = minLon; // init startLon.
	var currLat = minLat; // init startLat.
	var idx = 0;
	var s, t;

	var PI = Math.PI;
	var aConst = (1.0/(2.0*PI))*Math.pow(2.0, depth);
	
	// check if exist altitude.
	var alt = 0;
	if (altitude)
	{ alt = altitude; }
	
	// https://en.wikipedia.org/wiki/Web_Mercator_projection
	var PI_DIV_4 = PI/4;
	var minT = aConst*(PI-Math.log(Math.tan(PI_DIV_4+minLat/2)));
	var maxT = aConst*(PI-Math.log(Math.tan(PI_DIV_4+maxLat/2)));
	var minS = aConst*(minLon+PI);
	var maxS = aConst*(maxLon+PI);
	var floorMinS = Math.floor(minS);
	
	// Flip texCoordY for minT & maxT.***
	minT = 1.0 - minT;
	maxT = 1.0 - maxT;
	
	//var texCorrectionFactor = 0.0005;
	var texCorrectionFactor = 0.003 + (depth * 0.0000001);
	//var texCorrectionFactor = 0.002 + (1/(depth+1) * 0.008);
	
	for (var currLatSeg = 0; currLatSeg<latSegments+1; currLatSeg++)
	{
		currLat = minLat + latIncreDeg * currLatSeg;
		if (currLat > maxLat)
		{ currLat = maxLat; }
	
		t = aConst*(PI-Math.log(Math.tan(PI_DIV_4+currLat/2)));
		t = 1.0 - t;
			
		// Substract minT to "t" to make range [0 to 1].***
		t -= minT; 
		
		// Texture correction in borders.***
		if (currLatSeg === 0)
		{
			t = (texCorrectionFactor);
		}
		else if (currLatSeg === latSegments)
		{
			t = (1-texCorrectionFactor);
		}
		
		for (var currLonSeg = 0; currLonSeg<lonSegments+1; currLonSeg++)
		{
			currLon = minLon + lonIncreDeg * currLonSeg;
			
			if (currLon > maxLon)
			{ currLon = maxLon; }
			
			lonArray[idx] = currLon;
			latArray[idx] = currLat;
			// Now set the altitude.
			if (altitudesSlice)
			{
				altArray[idx] = altitudesSlice.getValue(currLonSeg, currLatSeg);
			}
			else
			{ altArray[idx] = alt; }

			s = aConst*(currLon+PI);
			s -= floorMinS;
			
			// Texture correction in borders.***
			if (currLonSeg === 0)
			{
				s += texCorrectionFactor/2;
			}
			else if (currLonSeg === lonSegments)
			{
				s += -texCorrectionFactor/2;
			}
			
			this.texCoordsArray[idx*2] = s;
			this.texCoordsArray[idx*2+1] = t;
			
			// actualize current values.
			idx++;
		}
	}
	
	
	
	this.cartesiansArray = Globe.geographicRadianArrayToFloat32ArrayWgs84(lonArray, latArray, altArray, this.cartesiansArray);
	
	/*
	// test code.**************************************
	var cartesianAux = [];
	var radToDegFactor = 180.0/Math.PI;
	var coordsCount = lonArray.length;
	for (var i=0; i<coordsCount; i++)
	{
		var lonDeg = lonArray[i] * radToDegFactor;
		var latDeg = latArray[i] * radToDegFactor;
		var alt = altArray[i];
		
		var posWC = ManagerUtils.geographicCoordToWorldPoint(lonDeg, latDeg, alt, undefined);
		cartesianAux.push(posWC.x);
		cartesianAux.push(posWC.y);
		cartesianAux.push(posWC.z);
	}
	
	for (var i=0; i<coordsCount; i++)
	{
		if (Math.abs(cartesianAux[i] - this.cartesiansArray[i]) > 10.0)
		{ var hola = 0; }
	}
	// end test code.----------------------------------
	*/
	
	// Make normals using the cartesians.***
	this.normalsArray = new Int8Array(vertexCount*3);
	var point = new Point3D();
	for (var i=0; i<vertexCount; i++)
	{
		point.set(this.cartesiansArray[i*3], this.cartesiansArray[i*3+1], this.cartesiansArray[i*3+2]);
		point.unitary();
		
		this.normalsArray[i*3] = point.x*126;
		this.normalsArray[i*3+1] = point.y*126;
		this.normalsArray[i*3+2] = point.z*126;
	}
	
	// finally make indicesArray.
	var numCols = lonSegments + 1;
	var numRows = latSegments + 1;
	var options = {
		bCalculateBorderIndices: true
	};
	var resultObject = GeometryUtils.getIndicesTrianglesRegularNet(numCols, numRows, undefined, undefined, undefined, undefined, undefined, options);
	this.indices = resultObject.indicesArray;
	this.southIndices = resultObject.southIndicesArray;
	this.eastIndices = resultObject.eastIndicesArray;
	this.northIndices = resultObject.northIndicesArray;
	this.westIndices = resultObject.westIndicesArray;
	
	this.westVertexCount = this.westIndices.length;
	this.southVertexCount = this.southIndices.length;
	this.eastVertexCount = this.eastIndices.length;
	this.northVertexCount = this.northIndices.length;
	
	// make skirtMesh data.
	var options = {
		skirtDepth          : 50000,
		texCorrectionFactor : texCorrectionFactor
	};
	var skirtResultObject = TinTerrain.getSkirtTrianglesStrip(lonArray, latArray, altArray, this.texCoordsArray, this.southIndices, this.eastIndices, this.northIndices, this.westIndices, options);
	this.skirtCartesiansArray = skirtResultObject.skirtCartesiansArray;
	this.skirtTexCoordsArray = skirtResultObject.skirtTexCoordsArray;
	
	this.calculateCenterPosition();
};

TinTerrain.prototype.makeMeshVirtuallyCRS84 = function(lonSegments, latSegments, altitude, altitudesSlice)
{
	// This function makes an ellipsoidal mesh for tiles that has no elevation data.
	// note: "altitude" & "altitudesSlice" are optionals.
	var degToRadFactor = Math.PI/180.0;
	var minLon = this.geographicExtent.minGeographicCoord.longitude * degToRadFactor;
	var minLat = this.geographicExtent.minGeographicCoord.latitude * degToRadFactor;
	var maxLon = this.geographicExtent.maxGeographicCoord.longitude * degToRadFactor;
	var maxLat = this.geographicExtent.maxGeographicCoord.latitude * degToRadFactor;
	var lonRange = maxLon - minLon;
	var latRange = maxLat - minLat;
	var depth = this.depth;
	
	var lonIncreDeg = lonRange/lonSegments;
	var latIncreDeg = latRange/latSegments;
	
	// calculate total verticesCount.
	var vertexCount = (lonSegments + 1)*(latSegments + 1);
	var lonArray = new Float32Array(vertexCount);
	var latArray = new Float32Array(vertexCount);
	var altArray = new Float32Array(vertexCount);
	this.texCoordsArray = new Float32Array(vertexCount*2);
	
	var currLon = minLon; // init startLon.
	var currLat = minLat; // init startLat.
	var idx = 0;
	var s, t;

	
	// check if exist altitude.
	var alt = 0;
	if (altitude)
	{ alt = altitude; }
	
	for (var currLatSeg = 0; currLatSeg<latSegments+1; currLatSeg++)
	{
		currLat = minLat + latIncreDeg * currLatSeg;
		if (currLat > maxLat)
		{ currLat = maxLat; }
		
		
		for (var currLonSeg = 0; currLonSeg<lonSegments+1; currLonSeg++)
		{
			currLon = minLon + lonIncreDeg * currLonSeg;
			
			if (currLon > maxLon)
			{ currLon = maxLon; }
			
			lonArray[idx] = currLon;
			latArray[idx] = currLat;
			// Now set the altitude.
			if (altitudesSlice)
			{
				altArray[idx] = altitudesSlice.getValue(currLonSeg, currLatSeg);
			}
			else
			{ altArray[idx] = alt; }


			// make texcoords CRS84.***
			s = (currLon - minLon)/lonRange;
			t = (currLat - minLat)/latRange;
			
			this.texCoordsArray[idx*2] = s;
			this.texCoordsArray[idx*2+1] = t;
			
			// actualize current values.
			idx++;
		}
	}
	
	this.cartesiansArray = Globe.geographicRadianArrayToFloat32ArrayWgs84(lonArray, latArray, altArray, this.cartesiansArray);
	
	// Make normals using the cartesians.***
	this.normalsArray = new Int8Array(vertexCount*3);
	var point = new Point3D();
	for (var i=0; i<vertexCount; i++)
	{
		point.set(this.cartesiansArray[i*3], this.cartesiansArray[i*3+1], this.cartesiansArray[i*3+2]);
		point.unitary();
		
		this.normalsArray[i*3] = point.x*126;
		this.normalsArray[i*3+1] = point.y*126;
		this.normalsArray[i*3+2] = point.z*126;
	}
	
	// finally make indicesArray.
	var numCols = lonSegments + 1;
	var numRows = latSegments + 1;
	var options = {
		bCalculateBorderIndices: true
	};
	var resultObject = GeometryUtils.getIndicesTrianglesRegularNet(numCols, numRows, undefined, undefined, undefined, undefined, undefined, options);
	this.indices = resultObject.indicesArray;
	this.southIndices = resultObject.southIndicesArray;
	this.eastIndices = resultObject.eastIndicesArray;
	this.northIndices = resultObject.northIndicesArray;
	this.westIndices = resultObject.westIndicesArray;
	
	this.westVertexCount = this.westIndices.length;
	this.southVertexCount = this.southIndices.length;
	this.eastVertexCount = this.eastIndices.length;
	this.northVertexCount = this.northIndices.length;
	
	this.calculateCenterPosition();
};

TinTerrain.prototype.zigZagDecode = function(value)
{
	return (value >> 1) ^ (-(value & 1));
};

TinTerrain.prototype.makeVbo = function(vboMemManager)
{
	if (this.cartesiansArray === undefined)
	{ return; }

	// rest the CenterPosition to the this.cartesiansArray.
	var coordsCount = this.cartesiansArray.length/3;
	for (var i=0; i<coordsCount; i++)
	{
		this.cartesiansArray[i*3] -= this.centerX[0];
		this.cartesiansArray[i*3+1] -= this.centerY[0];
		this.cartesiansArray[i*3+2] -= this.centerZ[0];
	}
	
	if (this.terrainPositionHIGH === undefined)
	{ this.terrainPositionHIGH = new Float32Array(3); }

	if (this.terrainPositionLOW === undefined)
	{ this.terrainPositionLOW = new Float32Array(3); }
	ManagerUtils.calculateSplited3fv([this.centerX[0], this.centerY[0], this.centerZ[0]], this.terrainPositionHIGH, this.terrainPositionLOW);
	
	if (this.vboKeyContainer === undefined)
	{ this.vboKeyContainer = new VBOVertexIdxCacheKeysContainer(); }
	
	var vboKey = this.vboKeyContainer.newVBOVertexIdxCacheKey();
	
	// Positions.
	vboKey.setDataArrayPos(this.cartesiansArray, vboMemManager);
	
	// Normals.
	if (this.normalsArray)
	{
		vboKey.setDataArrayNor(this.normalsArray, vboMemManager);
	}
	
	// TexCoords.
	if (this.texCoordsArray)
	{
		vboKey.setDataArrayTexCoord(this.texCoordsArray, vboMemManager);
	}
		
	// Indices.
	vboKey.setDataArrayIdx(this.indices, vboMemManager);

	// Make skirt.
	if (this.skirtCartesiansArray === undefined)
	{ return; }

	var skirtCartasiansCount = this.skirtCartesiansArray.length;
	for (var i=0; i<skirtCartasiansCount; i++)
	{
		this.skirtCartesiansArray[i*3] -= this.centerX[0];
		this.skirtCartesiansArray[i*3+1] -= this.centerY[0];
		this.skirtCartesiansArray[i*3+2] -= this.centerZ[0];
	}

	
	var vboKeySkirt = this.vboKeyContainer.newVBOVertexIdxCacheKey();

	// Positions.
	vboKeySkirt.setDataArrayPos(new Float32Array(this.skirtCartesiansArray), vboMemManager);
	
	// TexCoords.
	if (this.skirtTexCoordsArray)
	{
		vboKeySkirt.setDataArrayTexCoord(new Float32Array(this.skirtTexCoordsArray), vboMemManager);
	}
};

TinTerrain.getSkirtTrianglesStrip = function(lonArray, latArray, altArray, texCoordsArray, southIndices, eastIndices, northIndices, westIndices, options)
{
	// Given "lonArray", "latArray" & "altArray", this function makes skirtCartesiansArray & skirtTexCoordsArray.***
	// Note: skirtMesh is trianglesStrip, so, there are no indices.***
	var skirtDepth = 5000.0;
	var texCorrectionFactor = 1.0;
	if (options)
	{
		if (options.skirtDepth !== undefined)
		{ skirtDepth = options.skirtDepth; }
	
		if (options.texCorrectionFactor !== undefined)
		{ texCorrectionFactor = options.texCorrectionFactor; }
	}
	
	// Texture correction in borders & make skirt data.***
	var skirtLonArray = [];
	var skirtLatArray = [];
	var skirtAltArray = [];
	var skirtTexCoordsArray = [];
	
	var westVertexCount = westIndices.length;
	for (var j=0; j<westVertexCount; j++)
	{
		var idx = westIndices[j];
		texCoordsArray[idx*2] += texCorrectionFactor/2;
		
		skirtLonArray.push(lonArray[idx]);
		skirtLatArray.push(latArray[idx]);
		skirtAltArray.push(altArray[idx]);
		
		skirtLonArray.push(lonArray[idx]);
		skirtLatArray.push(latArray[idx]);
		skirtAltArray.push(altArray[idx]-skirtDepth);
		
		// insert texCoords 2 times for the triangles strip.
		skirtTexCoordsArray.push(texCoordsArray[idx*2]);   // s.
		skirtTexCoordsArray.push(texCoordsArray[idx*2+1]); // t.
		skirtTexCoordsArray.push(texCoordsArray[idx*2]);   // s.
		skirtTexCoordsArray.push(texCoordsArray[idx*2+1]); // t.
	}
	
	var southVertexCount = southIndices.length;
	for (var j=0; j<southVertexCount; j++)
	{
		var idx = southIndices[j];
		texCoordsArray[idx*2+1] = (texCorrectionFactor);
		
		skirtLonArray.push(lonArray[idx]);
		skirtLatArray.push(latArray[idx]);
		skirtAltArray.push(altArray[idx]);
		
		skirtLonArray.push(lonArray[idx]);
		skirtLatArray.push(latArray[idx]);
		skirtAltArray.push(altArray[idx]-skirtDepth);
		
		// insert texCoords 2 times for the triangles strip.
		skirtTexCoordsArray.push(texCoordsArray[idx*2]);   // s.
		skirtTexCoordsArray.push(texCoordsArray[idx*2+1]); // t.
		skirtTexCoordsArray.push(texCoordsArray[idx*2]);   // s.
		skirtTexCoordsArray.push(texCoordsArray[idx*2+1]); // t.
	}
	
	var eastVertexCount = eastIndices.length;
	for (var j=0; j<eastVertexCount; j++)
	{
		var idx = eastIndices[j];
		texCoordsArray[idx*2] -= texCorrectionFactor/2;
		
		skirtLonArray.push(lonArray[idx]);
		skirtLatArray.push(latArray[idx]);
		skirtAltArray.push(altArray[idx]);
		
		skirtLonArray.push(lonArray[idx]);
		skirtLatArray.push(latArray[idx]);
		skirtAltArray.push(altArray[idx]-skirtDepth);
		
		// insert texCoords 2 times for the triangles strip.
		skirtTexCoordsArray.push(texCoordsArray[idx*2]);   // s.
		skirtTexCoordsArray.push(texCoordsArray[idx*2+1]); // t.
		skirtTexCoordsArray.push(texCoordsArray[idx*2]);   // s.
		skirtTexCoordsArray.push(texCoordsArray[idx*2+1]); // t.
	}
	var northVertexCount = northIndices.length;
	for (var j=0; j<northVertexCount; j++)
	{
		var idx = northIndices[j];
		texCoordsArray[idx*2+1] = (1-texCorrectionFactor);
		
		skirtLonArray.push(lonArray[idx]);
		skirtLatArray.push(latArray[idx]);
		skirtAltArray.push(altArray[idx]);
		
		skirtLonArray.push(lonArray[idx]);
		skirtLatArray.push(latArray[idx]);
		skirtAltArray.push(altArray[idx]-skirtDepth);
		
		// insert texCoords 2 times for the triangles strip.
		skirtTexCoordsArray.push(texCoordsArray[idx*2]);   // s.
		skirtTexCoordsArray.push(texCoordsArray[idx*2+1]); // t.
		skirtTexCoordsArray.push(texCoordsArray[idx*2]);   // s.
		skirtTexCoordsArray.push(texCoordsArray[idx*2+1]); // t.
	}
	
	var skirtCartesiansArray = Globe.geographicRadianArrayToFloat32ArrayWgs84(skirtLonArray, skirtLatArray, skirtAltArray, undefined);
	
	var resultObject = {
		skirtCartesiansArray : skirtCartesiansArray,
		skirtTexCoordsArray  : skirtTexCoordsArray
	};
	
	return resultObject;
};

TinTerrain.prototype.decodeData = function(imageryType)
{
	if (this.geographicExtent === undefined)
	{ return; }
	
	if (this.vertexArray === undefined)
	{ this.vertexArray = []; }
	
	var degToRadFactor = Math.PI/180.0;
	// latitude & longitude in RADIANS.
	var minLon = this.geographicExtent.minGeographicCoord.longitude * degToRadFactor;
	var minLat = this.geographicExtent.minGeographicCoord.latitude * degToRadFactor;
	var maxLon = this.geographicExtent.maxGeographicCoord.longitude * degToRadFactor;
	var maxLat = this.geographicExtent.maxGeographicCoord.latitude * degToRadFactor;
	var lonRange = maxLon - minLon;
	var latRange = maxLat - minLat;
	
	var minHeight = this.minHeight[0];
	var maxHeight = this.maxHeight[0];
	var heightRange = maxHeight - minHeight;
	
	var vertexCount = this.vertexCount[0];
	this.texCoordsArray = new Float32Array(vertexCount*2);
	var lonArray = new Float32Array(vertexCount);
	var latArray = new Float32Array(vertexCount);
	var altArray = new Float32Array(vertexCount);
	var shortMax = 32767; // 65536
	var lonRangeDivShortMax = lonRange/shortMax;
	var latRangeDivShortMax = latRange/shortMax;
	var heightRangeDivShortMax = heightRange/shortMax;
	var uValues = this.uValues;
	var vValues = this.vValues;
	var hValues = this.hValues;
	
	var exageration = 5.0;
	
	if (this.depth === 0)
	{ var hola = 0; }

	if (this.depth === 1)
	{ var hola = 0; }
	
	if (imageryType === undefined)
	{ imageryType = CODE.imageryType.CRS84; }
	
	if (imageryType === CODE.imageryType.WEB_MERCATOR)
	{
		// web_mercator.
		// https://en.wikipedia.org/wiki/Web_Mercator_projection
		var depth = this.depth;
		var PI = Math.PI;
		var aConst = (1.0/(2.0*PI))*Math.pow(2.0, depth);
		var PI_DIV_4 = PI/4;
		var minT = aConst*(PI-Math.log(Math.tan(PI_DIV_4+minLat/2)));
		var maxT = aConst*(PI-Math.log(Math.tan(PI_DIV_4+maxLat/2)));
		var minS = aConst*(minLon+PI);
		var maxS = aConst*(maxLon+PI);
		var floorMinS = Math.floor(minS);
		var t, s;
		
		// Flip texCoordY for minT & maxT.***
		minT = 1.0 - minT;
		maxT = 1.0 - maxT;
		
		//var texCorrectionFactor = 0.0005;
		var texCorrectionFactor = 0.003 + (depth * 0.0000001);
		//var texCorrectionFactor = 0.002 + (1/(depth+1) * 0.008);
		
		//if (this.depth === 13)
		//{ texCorrectionFactor = 0.0033; }
	
		for (var i=0; i<vertexCount; i++)
		{
			lonArray[i] = minLon + uValues[i]*lonRangeDivShortMax;
			latArray[i] = minLat + vValues[i]*latRangeDivShortMax;
			altArray[i] = minHeight + hValues[i]*heightRangeDivShortMax;
			
			//altArray[i] *= exageration;
			
			var currLon = lonArray[i];
			var currLat = latArray[i];
			
			// make texcoords.
			t = aConst*(PI-Math.log(Math.tan(PI_DIV_4+currLat/2)));
			t = 1.0 - t;
				
			// Substract minT to "t" to make range [0 to 1].***
			t -= minT; 
			
			s = aConst*(currLon+PI);
			s -= floorMinS;
			
			this.texCoordsArray[i*2] = s;
			this.texCoordsArray[i*2+1] = t;
		}
		/*
		// Texture correction in borders & make skirt data.***
		var skirtDepth = 5000.0;
		var skirtLonArray = [];
		var skirtLatArray = [];
		var skirtAltArray = [];
		this.skirtTexCoordsArray = [];
		for (var j=0; j<this.westVertexCount; j++)
		{
			var idx = this.westIndices[j];
			this.texCoordsArray[idx*2] += texCorrectionFactor/2;
			
			skirtLonArray.push(lonArray[idx]);
			skirtLatArray.push(latArray[idx]);
			skirtAltArray.push(altArray[idx]);
			
			skirtLonArray.push(lonArray[idx]);
			skirtLatArray.push(latArray[idx]);
			skirtAltArray.push(altArray[idx]-skirtDepth);
			
			// insert texCoords 2 times for the triangles strip.
			this.skirtTexCoordsArray.push(this.texCoordsArray[idx*2]);   // s.
			this.skirtTexCoordsArray.push(this.texCoordsArray[idx*2+1]); // t.
			this.skirtTexCoordsArray.push(this.texCoordsArray[idx*2]);   // s.
			this.skirtTexCoordsArray.push(this.texCoordsArray[idx*2+1]); // t.
		}
		
		for (var j=0; j<this.southVertexCount; j++)
		{
			var idx = this.southIndices[j];
			this.texCoordsArray[idx*2+1] = (texCorrectionFactor);
			
			skirtLonArray.push(lonArray[idx]);
			skirtLatArray.push(latArray[idx]);
			skirtAltArray.push(altArray[idx]);
			
			skirtLonArray.push(lonArray[idx]);
			skirtLatArray.push(latArray[idx]);
			skirtAltArray.push(altArray[idx]-skirtDepth);
			
			// insert texCoords 2 times for the triangles strip.
			this.skirtTexCoordsArray.push(this.texCoordsArray[idx*2]);   // s.
			this.skirtTexCoordsArray.push(this.texCoordsArray[idx*2+1]); // t.
			this.skirtTexCoordsArray.push(this.texCoordsArray[idx*2]);   // s.
			this.skirtTexCoordsArray.push(this.texCoordsArray[idx*2+1]); // t.
		}
		
		for (var j=0; j<this.eastVertexCount; j++)
		{
			var idx = this.eastIndices[j];
			this.texCoordsArray[idx*2] -= texCorrectionFactor/2;
			
			skirtLonArray.push(lonArray[idx]);
			skirtLatArray.push(latArray[idx]);
			skirtAltArray.push(altArray[idx]);
			
			skirtLonArray.push(lonArray[idx]);
			skirtLatArray.push(latArray[idx]);
			skirtAltArray.push(altArray[idx]-skirtDepth);
			
			// insert texCoords 2 times for the triangles strip.
			this.skirtTexCoordsArray.push(this.texCoordsArray[idx*2]);   // s.
			this.skirtTexCoordsArray.push(this.texCoordsArray[idx*2+1]); // t.
			this.skirtTexCoordsArray.push(this.texCoordsArray[idx*2]);   // s.
			this.skirtTexCoordsArray.push(this.texCoordsArray[idx*2+1]); // t.
		}

		for (var j=0; j<this.northVertexCount; j++)
		{
			var idx = this.northIndices[j];
			this.texCoordsArray[idx*2+1] = (1-texCorrectionFactor);
			
			skirtLonArray.push(lonArray[idx]);
			skirtLatArray.push(latArray[idx]);
			skirtAltArray.push(altArray[idx]);
			
			skirtLonArray.push(lonArray[idx]);
			skirtLatArray.push(latArray[idx]);
			skirtAltArray.push(altArray[idx]-skirtDepth);
			
			// insert texCoords 2 times for the triangles strip.
			this.skirtTexCoordsArray.push(this.texCoordsArray[idx*2]);   // s.
			this.skirtTexCoordsArray.push(this.texCoordsArray[idx*2+1]); // t.
			this.skirtTexCoordsArray.push(this.texCoordsArray[idx*2]);   // s.
			this.skirtTexCoordsArray.push(this.texCoordsArray[idx*2+1]); // t.
		}
		*/
	}
	else
	{
		// crs84.
		for (var i=0; i<vertexCount; i++)
		{
			lonArray[i] = minLon + uValues[i]*lonRangeDivShortMax;
			latArray[i] = minLat + vValues[i]*latRangeDivShortMax;
			altArray[i] = minHeight + hValues[i]*heightRangeDivShortMax;
			
			// make texcoords.
			this.texCoordsArray[i*2] = uValues[i]/shortMax;
			this.texCoordsArray[i*2+1] = vValues[i]/shortMax;
		}
	}
	
	this.cartesiansArray = Globe.geographicRadianArrayToFloat32ArrayWgs84(lonArray, latArray, altArray, this.cartesiansArray);
	
	var options = {
		skirtDepth          : 50000,
		texCorrectionFactor : texCorrectionFactor
	};
	var skirtResultObject = TinTerrain.getSkirtTrianglesStrip(lonArray, latArray, altArray, this.texCoordsArray, this.southIndices, this.eastIndices, this.northIndices, this.westIndices, options);
	this.skirtCartesiansArray = skirtResultObject.skirtCartesiansArray;
	this.skirtTexCoordsArray = skirtResultObject.skirtTexCoordsArray;
	//this.skirtCartesiansArray = Globe.geographicRadianArrayToFloat32ArrayWgs84(skirtLonArray, skirtLatArray, skirtAltArray, this.skirtCartesiansArray);
	
	// free memory.
	this.uValues = undefined;
	this.vValues = undefined;
	this.hValues = undefined;
	
	lonArray = undefined;
	latArray = undefined;
	altArray = undefined;
	
};

TinTerrain.prototype.parseData = function(dataArrayBuffer)
{
	this.fileLoadState = CODE.fileLoadState.PARSE_STARTED;
	var bytes_readed = 0;
	
	// 1. header.
	this.centerX = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	this.centerY = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	this.centerZ = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	
	this.minHeight = new Float32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+4)); bytes_readed+=4;
	this.maxHeight = new Float32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+4)); bytes_readed+=4;
	
	this.boundingSphereCenterX = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	this.boundingSphereCenterY = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	this.boundingSphereCenterZ = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	this.boundingSphereRadius = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	
	this.horizonOcclusionPointX = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	this.horizonOcclusionPointY = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	this.horizonOcclusionPointZ = new Float64Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+8)); bytes_readed+=8;
	
	// 2. vertex data.
	this.vertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed+4)); bytes_readed+=4;
	var vertexCount = this.vertexCount[0];
	this.uValues = new Uint16Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 2 * vertexCount)); bytes_readed += 2 * vertexCount;
	this.vValues = new Uint16Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 2 * vertexCount)); bytes_readed += 2 * vertexCount;
	this.hValues = new Uint16Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 2 * vertexCount)); bytes_readed += 2 * vertexCount;
	
	// decode data.
	var u = 0;
	var v = 0;
	var height = 0;
	for (var i=0; i<vertexCount; i++)
	{
		u += this.zigZagDecode(this.uValues[i]);
		v += this.zigZagDecode(this.vValues[i]);
		height += this.zigZagDecode(this.hValues[i]);
		
		this.uValues[i] = u;
		this.vValues[i] = v;
		this.hValues[i] = height;
	}
	
	// 3. indices.
	this.trianglesCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
	var trianglesCount = this.trianglesCount;
	if (vertexCount > 65536 )
	{
		this.indices = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4 * trianglesCount * 3)); bytes_readed += 4 * trianglesCount * 3;
	}
	else 
	{
		this.indices = new Uint16Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 2 * trianglesCount * 3)); bytes_readed += 2 * trianglesCount * 3;
	}
	
	// decode indices.
	var code;
	var highest = 0;
	var indicesCount = this.indices.length;
	for (var i=0; i<indicesCount; i++)
	{
		code = this.indices[i];
		this.indices[i] = highest - code;
		if (code === 0) 
		{
			++highest;
		}
	}
	
	// 4. edges indices.
	if (vertexCount > 65536 )
	{
		this.westVertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
		this.westIndices = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4 * this.westVertexCount)); bytes_readed += 4 * this.westVertexCount;
		
		this.southVertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
		this.southIndices = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4 * this.southVertexCount)); bytes_readed += 4 * this.southVertexCount;
		
		this.eastVertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
		this.eastIndices = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4 * this.eastVertexCount)); bytes_readed += 4 * this.eastVertexCount;
		
		this.northVertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
		this.northIndices = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4 * this.northVertexCount)); bytes_readed += 4 * this.northVertexCount;
	}
	else
	{
		this.westVertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
		this.westIndices = new Uint16Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 2 * this.westVertexCount)); bytes_readed += 2 * this.westVertexCount;
		
		this.southVertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
		this.southIndices = new Uint16Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 2 * this.southVertexCount)); bytes_readed += 2 * this.southVertexCount;
		
		this.eastVertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
		this.eastIndices = new Uint16Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 2 * this.eastVertexCount)); bytes_readed += 2 * this.eastVertexCount;
		
		this.northVertexCount = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
		this.northIndices = new Uint16Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 2 * this.northVertexCount)); bytes_readed += 2 * this.northVertexCount;
	}
	
	// 5. extension header.
	this.extensionId = new Uint8Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 1)); bytes_readed += 1;
	this.extensionLength = new Uint32Array(dataArrayBuffer.slice(bytes_readed, bytes_readed + 4)); bytes_readed += 4;
	
	this.fileLoadState = CODE.fileLoadState.PARSE_FINISHED;
	
	if (this.extensionId.length === 0)
	{
		dataArrayBuffer = undefined;
		return;
	}
	
	dataArrayBuffer = undefined;
};























































'use strict';

/**
 * @class TinTerrainManager
 */
var TinTerrainManager = function() 
{
	if (!(this instanceof TinTerrainManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	//this.maxDepth = 18;
	this.maxDepth = 12;
	this.currentVisibles_terrName_geoCoords_map = {}; // current visible terrains map[terrainPathName, geographicCoords].
	this.currentTerrainsMap = {}; // current terrains (that was created) map[terrainPathName, tinTerrain].
	
	this.visibleTilesArray = [];
	this.noVisibleTilesArray = [];
	
	// TinTerrainQuadTrees.
	this.tinTerrainsQuadTreeAsia; // Use if this imageryType = CODE.imageryType.CRS84.
	this.tinTerrainsQuadTreeAmerica; // Use if this imageryType = CODE.imageryType.CRS84.
	this.tinTerrainQuadTreeMercator; // Use if this imageryType = CODE.imageryType.WEB_MERCATOR.
	
	this.geoServURL = "http://192.168.10.57:9090/geoserver/gwc/service/wmts";
	
	// Elevation model or plain ellipsoid.
	// terrainType = 0 -> terrainPlainModel.
	// terrainType = 1 -> terrainElevationModel.
	this.terrainType = 1; 
	//CODE.imageryType = {
	//"UNKNOWN"      : 0,
	//"CRS84"        : 1,
	//"WEB_MERCATOR" : 2
	//};
	this.imageryType = CODE.imageryType.WEB_MERCATOR; // Test.***
	//this.imageryType = CODE.imageryType.CRS84; // Test.***
	
	this.init();
	this.makeTinTerrainWithDEMIndex(); // provisional.
	
	//https://www.ngdc.noaa.gov/mgg/global/global.html here there are geotiff of land & ocean 1arc-minute. All earth. size : 21600 x 10800.
};

TinTerrainManager.prototype.init = function()
{
	if (this.imageryType === CODE.imageryType.WEB_MERCATOR)
	{
		this.tinTerrainQuadTreeMercator = new TinTerrain(undefined); // Main object.
		//1.4844222297453322
		//var latDeg = 1.4844222297453322 *180/Math.PI;
		//https://en.wikipedia.org/wiki/Web_Mercator_projection
		//https://en.wikipedia.org/wiki/Mercator_projection
		var webMercatorMaxLatRad = 2*Math.atan(Math.pow(Math.E, Math.PI)) - (Math.PI/2);
		var webMercatorMaxLatDeg = webMercatorMaxLatRad * 180/Math.PI; // = 85.0511287798...
		
		// All earth.
		var minLon = -180;
		var minLat = -90;
		var minAlt = 0;
		var maxLon = 180;
		var maxLat = 90;
		var maxAlt = 0;

		minLat = -webMercatorMaxLatDeg; 
		maxLat = webMercatorMaxLatDeg; 
		
		this.tinTerrainQuadTreeMercator.setGeographicExtent(minLon, minLat, minAlt, maxLon, maxLat, maxAlt);
		this.tinTerrainQuadTreeMercator.setWebMercatorExtent(-1, -Math.PI, 1, Math.PI); // unitary extension.***
		this.tinTerrainQuadTreeMercator.X = 0;
		this.tinTerrainQuadTreeMercator.Y = 0;
		this.tinTerrainQuadTreeMercator.indexName = "RU";
		this.tinTerrainQuadTreeMercator.tinTerrainManager = this;
		
		// do imagery test.
		// set imagery initial geoExtent (in mercator coords).
		
		// Full extent. https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer
	}
	else
	{
		// CRS84.
		this.tinTerrainsQuadTreeAsia = new TinTerrain(undefined); // Main object.
		this.tinTerrainsQuadTreeAmerica = new TinTerrain(undefined); // Main object.
		
		// Asia side.
		var minLon = 0;
		var minLat = -90;
		var minAlt = 0;
		var maxLon = 180;
		var maxLat = 90;
		var maxAlt = 0;
		if (this.imageryType === CODE.imageryType.WEB_MERCATOR)
		{
			minLat = -webMercatorMaxLatDeg; 
			maxLat = webMercatorMaxLatDeg; 
		}
		
		this.tinTerrainsQuadTreeAsia.setGeographicExtent(minLon, minLat, minAlt, maxLon, maxLat, maxAlt);
		this.tinTerrainsQuadTreeAsia.setWebMercatorExtent(0, -Math.PI, 1, Math.PI); // unitary extension.***
		this.tinTerrainsQuadTreeAsia.X = 1;
		this.tinTerrainsQuadTreeAsia.Y = 0;
		this.tinTerrainsQuadTreeAsia.indexName = "RU";
		this.tinTerrainsQuadTreeAsia.tinTerrainManager = this;
		
		// America side.
		minLon = -180;
		minLat = -90;
		minAlt = 0;
		maxLon = 0;
		maxLat = 90;
		maxAlt = 0;
		if (this.imageryType === CODE.imageryType.WEB_MERCATOR)
		{
			minLat = -webMercatorMaxLatDeg; 
			maxLat = webMercatorMaxLatDeg; 
		}
		this.tinTerrainsQuadTreeAmerica.setGeographicExtent(minLon, minLat, minAlt, maxLon, maxLat, maxAlt);
		this.tinTerrainsQuadTreeAmerica.setWebMercatorExtent(-1, -Math.PI, 0, Math.PI); // unitary extension.***
		this.tinTerrainsQuadTreeAmerica.X = 0;
		this.tinTerrainsQuadTreeAmerica.Y = 0;
		this.tinTerrainsQuadTreeAmerica.indexName = "LU";
		this.tinTerrainsQuadTreeAmerica.tinTerrainManager = this;
		
		// do imagery test.
		// set imagery initial geoExtent (in mercator coords).
		
		// Full extent. https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer
	}
	
	this.makeDistanceLimitByDepth();
};

TinTerrainManager.prototype.makeTinTerrainWithDEMIndex = function()
{
	// Provisional.
	// Makes a index of tiles that has DEM data in the server.
	this.tinTerrainWithDEMIndex = [];
	this.tinTerrainWithDEMIndex[0] = { minX: -1, minY: -1, maxX: -1, maxY: -1 };
	this.tinTerrainWithDEMIndex[1] = { minX: -1, minY: -1, maxX: -1, maxY: -1 };
	this.tinTerrainWithDEMIndex[2] = { minX: -1, minY: -1, maxX: -1, maxY: -1 };
	this.tinTerrainWithDEMIndex[3] = { minX: -1, minY: -1, maxX: -1, maxY: -1 };
	this.tinTerrainWithDEMIndex[4] = { minX: -1, minY: -1, maxX: -1, maxY: -1 };
	this.tinTerrainWithDEMIndex[5] = { minX: -1, minY: -1, maxX: -1, maxY: -1 };
	this.tinTerrainWithDEMIndex[6] = { minX: -1, minY: -1, maxX: -1, maxY: -1 };
	this.tinTerrainWithDEMIndex[7] = { minX: -1, minY: -1, maxX: -1, maxY: -1 };
	this.tinTerrainWithDEMIndex[8] = { minX: 213, minY: 94, maxX: 222, maxY: 105 };
	this.tinTerrainWithDEMIndex[9] = { minX: 425, minY: 189, maxX: 443, maxY: 211 };
	this.tinTerrainWithDEMIndex[10] = { minX: 852, minY: 376, maxX: 885, maxY: 423 };
	this.tinTerrainWithDEMIndex[11] = { minX: 1705, minY: 753, maxX: 1770, maxY: 844 };
	this.tinTerrainWithDEMIndex[12] = { minX: 3412, minY: 1506, maxX: 3539, maxY: 1689 };
	this.tinTerrainWithDEMIndex[13] = { minX: -1, minY: -1, maxX: -1, maxY: -1 };
	this.tinTerrainWithDEMIndex[14] = { minX: -1, minY: -1, maxX: -1, maxY: -1 };
	this.tinTerrainWithDEMIndex[15] = { minX: -1, minY: -1, maxX: -1, maxY: -1 };
	this.tinTerrainWithDEMIndex[16] = { minX: -1, minY: -1, maxX: -1, maxY: -1 };
	this.tinTerrainWithDEMIndex[17] = { minX: -1, minY: -1, maxX: -1, maxY: -1 };
	this.tinTerrainWithDEMIndex[18] = { minX: -1, minY: -1, maxX: -1, maxY: -1 };
	this.tinTerrainWithDEMIndex[19] = { minX: -1, minY: -1, maxX: -1, maxY: -1 };
	this.tinTerrainWithDEMIndex[20] = { minX: -1, minY: -1, maxX: -1, maxY: -1 };
};

TinTerrainManager.prototype.makeDistanceLimitByDepth = function()
{
	if (this.distLimitByDepth === undefined)
	{ this.distLimitByDepth = []; }
		
	// For each depth, there are a limit distance.***
	this.distLimitByDepth[0] = 50000000; 
	this.distLimitByDepth[1] = 10000000; 
	this.distLimitByDepth[2] = 5000000; 
	this.distLimitByDepth[3] = 2000000; 
	this.distLimitByDepth[4] = 1000000; 
	this.distLimitByDepth[5] = 500000; 
	this.distLimitByDepth[6] = 100000; 
	this.distLimitByDepth[7] = 50000; 
	this.distLimitByDepth[8] = 20000; 
	this.distLimitByDepth[9] = 10000; 
	this.distLimitByDepth[10] = 9000; 
	this.distLimitByDepth[11] = 8000; 
	this.distLimitByDepth[12] = 7000; 
	this.distLimitByDepth[13] = 6000; 
	this.distLimitByDepth[14] = 5000; 
	this.distLimitByDepth[15] = 4000; 
	this.distLimitByDepth[16] = 3000; 
	this.distLimitByDepth[17] = 2000; 
	this.distLimitByDepth[18] = 1000; 
	this.distLimitByDepth[19] = 800; 
	this.distLimitByDepth[20] = 500; 

	//this.distLimitByDepth[0] = 5; 
};

TinTerrainManager.prototype.doFrustumCulling = function(frustum, camPos, magoManager, maxDepth)
{
	if (maxDepth === undefined)
	{ maxDepth = this.maxDepth; }
	
	this.visibleTilesArray.length = 0;
	this.noVisibleTilesArray.length = 0;
	if (this.imageryType === CODE.imageryType.WEB_MERCATOR)
	{
		this.tinTerrainQuadTreeMercator.getFrustumIntersectedTinTerrainsQuadTree(frustum, maxDepth, camPos, magoManager, this.visibleTilesArray, this.noVisibleTilesArray);
	}
	else 
	{
		this.tinTerrainsQuadTreeAsia.getFrustumIntersectedTinTerrainsQuadTree(frustum, maxDepth, camPos, magoManager, this.visibleTilesArray, this.noVisibleTilesArray);
		this.tinTerrainsQuadTreeAmerica.getFrustumIntersectedTinTerrainsQuadTree(frustum, maxDepth, camPos, magoManager, this.visibleTilesArray, this.noVisibleTilesArray);
	}
};

/**
 * Prepare tinTerrains.
 */
TinTerrainManager.prototype.prepareVisibleTinTerrains = function(magoManager) 
{
	var tinTerrain;
	
	// For the visible tinTerrains prepare its.
	// Preparing rule: First prepare the tinTerrain-owner if the owner is no prepared yet.
	var visiblesTilesCount = this.visibleTilesArray.length;
	if (this.terrainType === 0) // PlainTerrain.
	{
		for (var i=0; i<visiblesTilesCount; i++)
		{
			tinTerrain = this.visibleTilesArray[i];
			tinTerrain.prepareTinTerrainPlain(magoManager, this);
		}
	}
	else if (this.terrainType === 1)// ElevationTerrain.
	{
		for (var i=0; i<visiblesTilesCount; i++)
		{
			tinTerrain = this.visibleTilesArray[i];
			tinTerrain.prepareTinTerrain(magoManager, this);
		}
	}
	
	// 2nd, for all terrains that exist, if there are not in the visiblesMap, then delete its.
	// Deleting rule: If a tinTerrain has children, then delete first the children.
	var deletedCount = 0;
	var noVisiblesTilesCount = this.noVisibleTilesArray.length;
	for (var i=0; i<visiblesTilesCount; i++)
	{
		tinTerrain = this.noVisibleTilesArray[i];
		if (tinTerrain !== undefined)
		{
			if (tinTerrain.depth > 2)
			{
				tinTerrain.deleteTinTerrain(magoManager);
				deletedCount++;
			}
		}
		
		if (deletedCount > 5)
		{ break; }
	}
	
};

TinTerrainManager.prototype.render = function(magoManager, bDepth, renderType, shader) 
{
	var gl = magoManager.sceneState.gl;
	var currentShader;
	if (shader)
	{ currentShader = shader; }
	else
	{ currentShader = magoManager.postFxShadersManager.getShader("tinTerrain"); }
	var shaderProgram = currentShader.program;
	
	gl.useProgram(shaderProgram);
	currentShader.enableVertexAttribArray(currentShader.position3_loc);
	if (bDepth)
	{ currentShader.disableVertexAttribArray(currentShader.texCoord2_loc); }
	else
	{ currentShader.enableVertexAttribArray(currentShader.texCoord2_loc); }
	//gl.disableVertexAttribArray(currentShader.normal3_loc);
	//gl.disableVertexAttribArray(currentShader.color4_loc);
	
	currentShader.bindUniformGenerals();

	var tex = magoManager.texturesStore.getTextureAux1x1(); // provisional.
	gl.activeTexture(gl.TEXTURE2); 
	gl.bindTexture(gl.TEXTURE_2D, tex.texId);

	
	if (this.identityMat === undefined)
	{ this.identityMat = new Matrix4(); }
	
	gl.uniform1i(currentShader.bIsMakingDepth_loc, bDepth); //.
	if (renderType === 1)
	{
		var textureAux1x1 = magoManager.texturesStore.getTextureAux1x1();
		var noiseTexture = magoManager.texturesStore.getNoiseTexture4x4();
		
		gl.uniform1i(currentShader.colorType_loc, 2); // 0= oneColor, 1= attribColor, 2= texture. Initially set as texture color type.***
		gl.uniform4fv(currentShader.oneColor4_loc, [0.5, 0.5, 0.5, 1.0]);
		gl.uniform1i(currentShader.refMatrixType_loc, 0); // init referencesMatrix.
		gl.uniformMatrix4fv(currentShader.buildingRotMatrix_loc, false, this.identityMat._floatArrays);
		
		
		var bApplyShadow = false;
		if (magoManager.sceneState.sunSystem !== undefined && magoManager.sceneState.applySunShadows)
		{ bApplyShadow = true; }
		gl.uniform1i(currentShader.bApplyShadow_loc, bApplyShadow);
		
		if (bApplyShadow)
		{
			// Set sunMatrix uniform.***
			var sunSystem = magoManager.sceneState.sunSystem;
			var sunMatFloat32Array = sunSystem.getLightsMatrixFloat32Array();
			var sunPosLOWFloat32Array = sunSystem.getLightsPosLOWFloat32Array();
			var sunPosHIGHFloat32Array = sunSystem.getLightsPosHIGHFloat32Array();
			var sunDirWC = sunSystem.getSunDirWC();
			var sunLight = sunSystem.getLight(0);
			if (sunLight.tMatrix!== undefined)
			{
				gl.uniformMatrix4fv(currentShader.sunMatrix_loc, false, sunMatFloat32Array);
				gl.uniform3fv(currentShader.sunPosHigh_loc, sunPosHIGHFloat32Array);
				gl.uniform3fv(currentShader.sunPosLow_loc, sunPosLOWFloat32Array);
				gl.uniform1f(currentShader.shadowMapWidth_loc, sunLight.targetTextureWidth);
				gl.uniform1f(currentShader.shadowMapHeight_loc, sunLight.targetTextureHeight);
				gl.uniform3fv(currentShader.sunDirWC_loc, sunDirWC);
				gl.uniform1i(currentShader.sunIdx_loc, 1);
			}
			
			//var sunTexLoc = gl.getUniformLocation(currentShader.program, 'shadowMapTex');
			//gl.uniform1i(sunTexLoc, 3);
			
			//var sunTex2Loc = gl.getUniformLocation(currentShader.program, 'shadowMapTex2');
			//gl.uniform1i(sunTex2Loc, 4);
			
			gl.activeTexture(gl.TEXTURE3); 
			if (bApplyShadow && sunLight.depthFbo)
			{
				var sunLight = sunSystem.getLight(0);
				gl.bindTexture(gl.TEXTURE_2D, sunLight.depthFbo.colorBuffer);
			}
			else 
			{
				gl.bindTexture(gl.TEXTURE_2D, textureAux1x1);
			}
			
			gl.activeTexture(gl.TEXTURE4); 
			if (bApplyShadow && sunLight.depthFbo)
			{
				var sunLight = sunSystem.getLight(1);
				gl.bindTexture(gl.TEXTURE_2D, sunLight.depthFbo.colorBuffer);
			}
			else 
			{
				gl.bindTexture(gl.TEXTURE_2D, textureAux1x1);
			}
		}

		
		var flipTexCoordY = true;
		if (magoManager.isCesiumGlobe())
		{ flipTexCoordY = false; }
		gl.uniform1i(currentShader.textureFlipYAxis_loc, flipTexCoordY); // false for cesium, true for magoWorld.
		gl.uniform1f(currentShader.externalAlpha_loc, 1.0);
		
		//gl.enable(gl.POLYGON_OFFSET_FILL);
		//gl.polygonOffset(1, 3);
		
		gl.activeTexture(gl.TEXTURE2); // difusseTex.
	}
	
	var sceneState = magoManager.sceneState;
	var bApplyShadow = sceneState.applySunShadows;
	var renderWireframe = false;
	var tinTerrain;
	var visiblesTilesCount = this.visibleTilesArray.length;
	
	// check if apply sun shadow.
	var light0 = sceneState.sunSystem.getLight(0);
	var light0MaxDistToCam = light0.maxDistToCam;
	var light0BSphere = light0.bSphere;
	if (light0BSphere === undefined)
	{ bApplyShadow = false; } // cant apply shadow anyway.
	
	if (bApplyShadow)
	{
		var light0Radius = light0BSphere.getRadius();
		var light0CenterPoint = light0BSphere.getCenterPoint();
		for (var i=0; i<visiblesTilesCount; i++)
		{
			tinTerrain = this.visibleTilesArray[i];
			
			if (tinTerrain === undefined)
			{ continue; }
		
			var sphereExtent = tinTerrain.sphereExtent;
			var distToLight0 = light0CenterPoint.distToPoint(sphereExtent.centerPoint)+sphereExtent.r;
			if (distToLight0 < light0Radius*5.0)
			{
				gl.uniform1i(currentShader.sunIdx_loc, 0);
			}
			else
			{
				gl.uniform1i(currentShader.sunIdx_loc, 1);
			}
			tinTerrain.render(currentShader, magoManager, bDepth, renderType);
		}
	}
	else
	{
		for (var i=0; i<visiblesTilesCount; i++)
		{
			tinTerrain = this.visibleTilesArray[i];
			
			if (tinTerrain === undefined)
			{ continue; }
		
			tinTerrain.render(currentShader, magoManager, bDepth, renderType);
		}
	}
	
	
	

	currentShader.disableVertexAttribArray(currentShader.texCoord2_loc); 
	currentShader.disableVertexAttribArray(currentShader.position3_loc); 
	currentShader.disableVertexAttribArray(currentShader.normal3_loc); 
	currentShader.disableVertexAttribArray(currentShader.color4_loc); 
	gl.useProgram(null);
};







































'use strict';

/**
 * This represent Arc feature in 2D
 * @class Arc2D
 */
var Arc2D = function() 
{
	if (!(this instanceof Arc2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	
	this.centerPoint; // Point2D.
	this.radius;
	this.startAngleDeg; // zero startAngle is in "X" axis positive.
	this.sweepAngleDeg; // sweeping in CounterClockWise is positive.
	this.numPointsFor360Deg; // interpolation param.
	
	// Alternative vars.
	this.startPoint; // if no exist radius, then startPoint define the radius.
	this.endPoint;
	this.sweepSense; // 1=CCW, -1=CW.
};

/**
 * Set the center position of Arc2D.
 * @class Arc2D
 */
Arc2D.prototype.deleteObjects = function()
{
	if (this.centerPoint !== undefined)
	{ this.centerPoint.deleteObjects(); } // Point3D.
	this.centerPoint = undefined;
	this.radius = undefined;
	this.startAngleDeg = undefined;
	this.sweepAngleDeg = undefined;
	this.numPointsFor360Deg = undefined;
	
	if (this.startPoint !== undefined)
	{ this.startPoint.deleteObjects(); } 
	
	this.startPoint = undefined;
	
	if (this.endPoint !== undefined)
	{ this.endPoint.deleteObjects(); } 
	
	this.endPoint = undefined;
	this.sweepSense = undefined; // 1=CCW, -1=CW.
};

/**
 * Set the center position of Arc
 * @param {Number} cx the x coordi of the center
 * @param {Number} cy the y coordi of the center
 */
Arc2D.prototype.setCenterPosition = function(cx, cy)
{
	if (this.centerPoint === undefined)
	{ this.centerPoint = new Point2D(); }
	
	this.centerPoint.set(cx, cy);
};

/**
 * Set the radius value
 * @param {Number} radius
 */
Arc2D.prototype.setRadius = function(radius)
{
	this.radius = radius;
};

/**
 * Set the start angle of the arc.
 * @param startAngleDegree 
 */
Arc2D.prototype.setStartAngleDegree = function(startAngleDegree)
{
	this.startAngleDeg = startAngleDegree;
};

/**
 * Set the start point of the arc.
 * @param {Number} x
 * @param {NUmber} y
 */
Arc2D.prototype.setStartPoint = function(x, y)
{
	// If no exist startAngle, then use this to calculate startAngle.
	if (this.startPoint === undefined)
	{ this.startPoint = new Point2D(); }
	
	this.startPoint.set(x, y);
};

/**
 * Set the start angle of the arc.
 * @class Arc2D
 */
Arc2D.prototype.setEndPoint = function(x, y)
{
	// If no exist sweepAngle, then use this to calculate sweepAngle.
	if (this.endPoint === undefined)
	{ this.endPoint = new Point2D(); }
	
	this.endPoint.set(x, y);
};

/**
 * Set the sweep direction sense of the arc.
 * @param sense
 */
Arc2D.prototype.setSense = function(sense)
{
	this.sweepSense = sense; // 1=CCW, -1=CW.
};

/**
 * Set the sweep angle of the arc.
 * @param sweepAngleDegree 
 */
Arc2D.prototype.setSweepAngleDegree = function(sweepAngleDegree)
{
	this.sweepAngleDeg = sweepAngleDegree;
};

/**
 * Returns the points of the arc.
 * @param resultPointsArray the array which saves the result of the points
 * @param pointsCountFor360Deg the value used for interpolation way
 */
Arc2D.prototype.getPoints = function(resultPointsArray, pointsCountFor360Deg)
{
	if (this.centerPoint === undefined)
	{ return resultPointsArray; }
	
	if (pointsCountFor360Deg)
	{ this.numPointsFor360Deg = pointsCountFor360Deg; }

	if (this.numPointsFor360Deg === undefined)
	{ this.numPointsFor360Deg = 36; }

	// Check if exist strAng.
	var strVector, endVector;
	var strVectorModul;
	if (this.startAngleDeg === undefined)
	{
		if (this.startPoint === undefined)
		{ return resultPointsArray; }
		
		strVector = new Point2D();
		strVector.set(this.startPoint.x - this.centerPoint.x, this.startPoint.y - this.centerPoint.y);
		strVectorModul = strVector.getModul();
		
		var angRad = Math.acos(x/strVectorModul);
		if (this.startPoint.y < 0)
		{
			angRad *= -1;
		}
		
		this.startAngleDeg = angRad * 180.0/Math.PI;
	}
	
	// Check if exist radius.
	if (this.radius === undefined)
	{
		// calculate by startPoint.
		if (this.startPoint === undefined)
		{ return resultPointsArray; }
		
		if (strVectorModul === undefined)
		{
			if (strVector === undefined)
			{
				strVector = new Point2D();
				strVector.set(this.startPoint.x - this.centerPoint.x, this.startPoint.y - this.centerPoint.y);
			}
			strVectorModul = strVector.getModul();
		}
		
		this.radius = strVectorModul;
	}
	
	// check if exist sweepAng.
	if (this.sweepAngleDeg === undefined)
	{
		if (this.endPoint === undefined || this.sweepSense === undefined)
		{ return resultPointsArray; }
		
		endVector = new Point2D();
		endVector.set(this.endPoint.x - this.centerPoint.x, this.endPoint.y - this.endPoint.y);
		var endVectorModul = endPoint.getModul();
		
		var angRad = Math.acos(x/strVectorModul);
		if (this.endPoint.y < 0)
		{
			angRad *= -1;
		}
		
		this.sweepAngleDeg = angRad * 180.0/Math.PI;
		
		if (this.sweepSense < 0)
		{ this.sweepAngleDeg = 360 - this.sweepAngleDeg; }
	}
	
	if (resultPointsArray === undefined)
	{ resultPointsArray = []; }
	
	var pointsArray = [];
	
	var increAngRad = 2.0 * Math.PI / this.numPointsFor360Deg;
	var cx = this.centerPoint.x;
	var cy = this.centerPoint.y;
	var x, y;
	var startAngRad = Math.PI/180.0 * this.startAngleDeg;
	var sweepAngRad = Math.PI/180.0 * this.sweepAngleDeg;
	var point;
	var segmentsCount = Math.ceil(sweepAngRad/increAngRad);
	var currAngRad = 0.0;
	if (sweepAngRad >=0)
	{
		//for (var currAngRad = 0.0; currAngRad<sweepAngRad; currAngRad += increAngRad)
		for (var i=0; i<=segmentsCount; i++)
		{
			if (currAngRad > sweepAngRad)
			{ currAngRad = sweepAngRad; }
			
			x = cx + this.radius * Math.cos(currAngRad + startAngRad);
			y = cy + this.radius * Math.sin(currAngRad + startAngRad);
			point = new Point2D(x, y);
			pointsArray.push(point);
			currAngRad += increAngRad;
		}
	}
	else 
	{
		//for (var currAngRad = 0.0; currAngRad>sweepAngRad; currAngRad -= increAngRad)
		for (var i=0; i<=segmentsCount; i++)
		{
			if (currAngRad < sweepAngRad)
			{ currAngRad = sweepAngRad; }
			
			x = cx + this.radius * Math.cos(currAngRad + startAngRad);
			y = cy + this.radius * Math.sin(currAngRad + startAngRad);
			point = new Point2D(x, y);
			pointsArray.push(point);
			currAngRad -= increAngRad;
		}
	}
	
	// once finished, mark the 1rst point and the last point as"important point".
	var pointsCount = pointsArray.length;
	if (pointsCount > 0)
	{
		pointsArray[0].pointType = 1;
		pointsArray[pointsCount-1].pointType = 1;
	}
	
	// now merge points into "resultPointsArray".
	var errorDist = 0.0001; // 0.1mm.
	var resultExistentPointsCount = resultPointsArray.length;
	for (var i=0; i<pointsCount; i++)
	{
		if (i===0)
		{
			if (resultExistentPointsCount > 0)
			{
				// check if the last point of "resultPointsArray" and the 1rst point of "this" is coincident.
				var lastExistentPoint = resultPointsArray[resultExistentPointsCount-1];
				point = pointsArray[i];
				if (!lastExistentPoint.isCoincidentToPoint(point, errorDist))
				{
					resultPointsArray.push(point);
				}
			}
			else
			{
				resultPointsArray.push(pointsArray[i]);
			}
		}
		else
		{
			resultPointsArray.push(pointsArray[i]);
		}
	}
	
	// Last check: finally, in case of sweepAngle = 360 degrees, or is closed pointsArray, then pop the last insertedPoint.
	resultExistentPointsCount = resultPointsArray.length;
	if (resultExistentPointsCount > 0)
	{
		// check if the last point of "resultPointsArray" and the 1rst point of "this" is coincident.
		var lastPoint = resultPointsArray[resultExistentPointsCount-1];
		var firstPoint = resultPointsArray[0];
		if (lastPoint.isCoincidentToPoint(firstPoint, errorDist))
		{
			resultPointsArray.pop();
			lastPoint.deleteObjects();
		}
	}
	
	return resultPointsArray;
};




















'use strict';

/**
 * This show x, y ,z axises of the given feature to visualize them
 * @class AxisXYZ
 * 
 * @param {number} length
 */
var AxisXYZ = function(length) 
{
	if (!(this instanceof AxisXYZ)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	if (length === undefined)
	{ this.length = 60; }
	else { this.length = length; }
	
	/**
	 * Container which holds the VBO Cache Keys
	 * @type {VBOVertexIdxCacheKeysContainer}
	 */
	this.vbo_vicks_container = new VBOVertexIdxCacheKeysContainer();
	//this.vboKey = this.vbo_vicks_container.newVBOVertexIdxCacheKey();
};

/**
 * Set the length of the axises
 * @param {Number} length the length of the axis
 */
AxisXYZ.prototype.setDimension = function(length)
{
	this.length = length;
};

/**
 * Visualize the axises at the feature
 * @param {Number} length the length of the axis to set the length of the axises
 * @returns {Mesh} mesh
 */
AxisXYZ.prototype.makeMesh = function(length)
{
	if (length !== undefined)
	{ this.length = length; }
	
	var pMesh = new ParametricMesh();
		
	pMesh.profile = new Profile2D(); 
	var profileAux = pMesh.profile; 
	
	// create a halfArrow profile.
	var outerRing = profileAux.newOuterRing();
	var arrowLength = this.length;
	var arrowWidth  = this.length*0.1;
	var polyLine = outerRing.newElement("POLYLINE");
	var point3d = polyLine.newPoint2d(0, 0); // 0
	point3d = polyLine.newPoint2d(arrowWidth*0.25, arrowLength*0.25); // 1
	point3d = polyLine.newPoint2d(arrowWidth*0.25, arrowLength*0.75); // 2
	point3d = polyLine.newPoint2d(arrowWidth*0.5, arrowLength*0.75); // 3
	point3d = polyLine.newPoint2d(0, arrowLength); // 3
	//--------------------------------------------------------------------
	
	var bIncludeBottomCap, bIncludeTopCap;
	var revolveAngDeg, revolveSegmentsCount, revolveSegment2d;
	revolveAngDeg = 360.0;
	
	// create a rotation axis by a segment.
	revolveSegment2d = new Segment2D();
	var strPoint2d = new Point2D(0, -10);
	var endPoint2d = new Point2D(0, 10);
	revolveSegment2d.setPoints(strPoint2d, endPoint2d);
	revolveSegmentsCount = 8;
	
	// rotate the profile and create the Y axis.
	pMesh.revolve(profileAux, revolveAngDeg, revolveSegmentsCount, revolveSegment2d);
	
	bIncludeBottomCap = false;
	bIncludeTopCap = false;
	var mesh = pMesh.getSurfaceIndependentMesh(undefined, bIncludeBottomCap, bIncludeTopCap);
	mesh.setColor(0.1, 1.0, 0.1, 1.0); // set the color.
	mesh.reverseSense();
	
	// copy & rotate the mesh and create the X axis.
	var tMatTest = new Matrix4();
	var mesh2 = mesh.getCopy(undefined);
	tMatTest.rotationAxisAngDeg(-90.0, 0, 0, 1);
	mesh2.transformByMatrix4(tMatTest);
	mesh2.setColor(1.0, 0.1, 0.1, 1.0); // set the color.
	
	// copy & rotate the mesh and create the Z axis.
	var mesh3 = mesh.getCopy(undefined);
	tMatTest.rotationAxisAngDeg(90.0, 1, 0, 0);
	mesh3.transformByMatrix4(tMatTest);
	mesh3.setColor(0.1, 0.1, 1.0, 1.0); // set the color.

	// Merge all meshes into a one mesh and make a unique vbo.
	mesh.mergeMesh(mesh2);
	mesh.mergeMesh(mesh3);
	return mesh;
};

/**
 * Get the container which holds the VBO Cache Keys
 * @returns {VBOVertexIdxCacheKeysContainer} vbo_vicks_container
 */
AxisXYZ.prototype.getVboKeysContainer = function()
{
	return this.vbo_vicks_container;
};

'use strict';
/**
* This class represent the bounding box of the other feature in 2D
* @class BoundingRectangle
*/
var BoundingRectangle = function(x, y) 
{
	if (!(this instanceof BoundingRectangle)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.minX = Number.MAX_VALUE;
	this.maxX = Number.MIN_VALUE;
	this.minY = Number.MAX_VALUE;
	this.maxY = Number.MIN_VALUE;
};

BoundingRectangle.prototype.setInit = function(point)
{
	if (point === undefined)
	{ return; }
	
	this.minX = point.x;
	this.minY = point.y;
	this.maxX = point.x;
	this.maxY = point.y;
};
/**
 * Initiation bounding rectangle by the other bounding rectangle
 * @param {BoundingRectangle} bRect The other bounding rectangle	
 */
BoundingRectangle.prototype.setInitByRectangle = function(bRect)
{
	if (bRect === undefined)
	{ return; }
	
	this.minX = bRect.minX;
	this.minY = bRect.minY;
	this.maxX = bRect.maxX;
	this.maxY = bRect.maxY;
};

/**
 * Change the range of this bounding rectangle if a point is added
 * @param {Point2D} point 
 */
BoundingRectangle.prototype.addPoint = function(point)
{
	if (point === undefined)
	{ return; }
	
	if (point.x < this.minX)
	{ this.minX = point.x; }
	else if (point.x > this.maxX)
	{ this.maxX = point.x; }
	
	if (point.y < this.minY)
	{ this.minY = point.y; }
	else if (point.y > this.maxY)
	{ this.maxY = point.y; }
};
/**
 * Change the range of this bounding rectangle if a rectangle is added
 * @param {BoundingRectangle} bRect
 */
BoundingRectangle.prototype.addRectangle = function(bRect)
{
	if (bRect === undefined)
	{ return; }
	
	if (bRect.minX < this.minX)
	{ this.minX = bRect.minX; }
	if (bRect.maxX > this.maxX)
	{ this.maxX = bRect.maxX; }
	
	if (bRect.minY < this.minY)
	{ this.minY = bRect.minY; }
	if (bRect.maxY > this.maxY)
	{ this.maxY = bRect.maxY; }
};
/**
 * Check whether this rectangle is intersected with the given bounding rectangle
 * @param {BoundingRectangle} bRect
 * @returns {Boolean}
 */
BoundingRectangle.prototype.intersectsWithRectangle = function(bRect)
{
	if (bRect === undefined)
	{ return false; }
	
	if (bRect.minX > this.maxX)
	{ return false; }
	else if (bRect.maxX < this.minX)
	{ return false; }
	else if (bRect.minY > this.maxY)
	{ return false; }
	else if (bRect.maxY < this.minY)
	{ return false; }
	
	return true;
};

/**
 * Check whether this rectangle is intersected with the given bounding rectangle
 * @param {BoundingRectangle} bRect
 * @returns {Point2D}
 */
BoundingRectangle.prototype.getCenterPoint = function()
{
	var centerx = (this.minX + this.maxX) / 2;
	var centery = (this.minY + this.maxY) / 2;
	
	return new Point2D(centerx, centery);
};

/**
 * Bounding Rectangle Center point
 * @returns {Point2D}
 */
BoundingRectangle.prototype.getCenterPoint = function()
{
	var centerx = (this.minX + this.maxX) / 2;
	var centery = (this.minY + this.maxY) / 2;
	
	return new Point2D(centerx, centery);
};

/**
 * Bounding Rectangle x length
 * @returns {number}
 */
BoundingRectangle.prototype.getXLength = function()
{
	return this.maxX - this.minX;
};

/**
 * Bounding Rectangle y length
 * @returns {number}
 */
BoundingRectangle.prototype.getYLength = function()
{
	return this.maxY - this.minY;
};
'use strict';

/**
 * This is similar with the 3D version of the Bounding Rectangle but this is slighthly different.
 * 꼭지점을 가지고 한붓 그리기로 3차원 버전의 BB를 그립니다.
 * @class BoxAux
 */
var BoxAux = function() 
{
	if (!(this instanceof BoxAux)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	// vertex indices of the BoxAux.
	//    3----------2        7----------6      
	//    |          |        |          |
	//    |  bottom  |        |   top    |
	//    |          |        |          |
	//    0----------1        4----------5
	
	this.triPolyhedron = new TriPolyhedron();
	this.vbo_vicks_container = new VBOVertexIdxCacheKeysContainer();
	this.vBOVertexIdxCacheKey = this.vbo_vicks_container.newVBOVertexIdxCacheKey();
};

/**
 * get the Vbo keys container of this feature
 */
BoxAux.prototype.getVboKeysContainer = function()
{
	return this.vbo_vicks_container;
};

/**
 * make Axis Aligned Bounding Box(Aux)
 * @param {Number} xLength 
 * @param {Number} yLength
 * @param {Number} zLength
 */
BoxAux.prototype.makeAABB = function(xLength, yLength, zLength)
{
	// this makes a BoxAux centered on the center of the BoxAux.
	var minX = -xLength/2.0;
	var minY = -yLength/2.0;
	var minZ = -zLength/2.0;
	
	var maxX = xLength/2.0;
	var maxY = yLength/2.0;
	var maxZ = zLength/2.0;
	
	// make 8 vertices and 6 triSurfaces.
	var vertexList = this.triPolyhedron.vertexList;
	
	// Bottom.*
	var vertex = vertexList.newVertex(); // 0.
	vertex.setPosition(minX, minY, minZ);
	
	vertex = vertexList.newVertex(); // 1.
	vertex.setPosition(maxX, minY, minZ);
	
	vertex = vertexList.newVertex(); // 2.
	vertex.setPosition(maxX, maxY, minZ);
	
	vertex = vertexList.newVertex(); // 3.
	vertex.setPosition(minX, maxY, minZ);
	
	// Top.
	vertex = vertexList.newVertex(); // 4.
	vertex.setPosition(minX, minY, maxZ);
	
	vertex = vertexList.newVertex(); // 5.
	vertex.setPosition(maxX, minY, maxZ);
	
	vertex = vertexList.newVertex(); // 6.
	vertex.setPosition(maxX, maxY, maxZ);
	
	vertex = vertexList.newVertex(); // 7.
	vertex.setPosition(minX, maxY, maxZ);
	
	
	// now, create triSurfaces and triangles.
	var triSurface;
	var triangle;
	// Bottom surface.
	triSurface = this.triPolyhedron.newTriSurface();
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(0), vertexList.getVertex(2), vertexList.getVertex(1));
	
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(0), vertexList.getVertex(3), vertexList.getVertex(2));
	
	// Top surface.
	triSurface = this.triPolyhedron.newTriSurface();
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(4), vertexList.getVertex(5), vertexList.getVertex(6));
	
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(4), vertexList.getVertex(6), vertexList.getVertex(7));
	
	// Front surface.
	triSurface = this.triPolyhedron.newTriSurface();
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(0), vertexList.getVertex(1), vertexList.getVertex(5));
	
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(0), vertexList.getVertex(5), vertexList.getVertex(4));
	
	// Right surface.
	triSurface = this.triPolyhedron.newTriSurface();
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(1), vertexList.getVertex(2), vertexList.getVertex(6));
	
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(1), vertexList.getVertex(6), vertexList.getVertex(5));
	
	// Rear surface.
	triSurface = this.triPolyhedron.newTriSurface();
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(2), vertexList.getVertex(3), vertexList.getVertex(7));
	
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(2), vertexList.getVertex(7), vertexList.getVertex(6));
	
	// Left surface.
	triSurface = this.triPolyhedron.newTriSurface();
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(3), vertexList.getVertex(0), vertexList.getVertex(4));
	
	triangle = triSurface.newTriangle();
	triangle.setVertices(vertexList.getVertex(3), vertexList.getVertex(4), vertexList.getVertex(7));
	
};
'use strict';

/**
 * BSplineCubic3D represented in 3D
 * @class BSplineCubic3D
 */
var BSplineCubic3D = function(options) 
{
	if (!(this instanceof BSplineCubic3D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	/**
	 * The geographic points that represents the knotPoints.
	 * @type {GeographicCoordsList}
	 * @default undefined
	 */
	this.geoCoordsList; 
	
	/**
	 * GeoLocationDataManager is a class object that contains GeoLocationData objects in an array.
	 * @type {GeoLocationDataManager}
	 * @default undefined
	 */
	this.geoLocDataManager;
	
	
	this.knotPoints3dList;
	this.interpolatedPoints3dList;
	this.controlPoints3dMap; // idxPoint : {prevCPoint, nextCPoint}
	
	this.segmentLengthArray; // Length for each segment (on the interpolated).***
	this.dirty = true;
	
	this.vtxProfilesList;
	this.vboKeysContainer;
	this.vboKeysContainerEdges;
	
	if (options)
	{
		if (options.knotPoints3dArray)
		{
			if (this.knotPoints3dList === undefined)
			{
				this.knotPoints3dList = new Point3DList();
				this.knotPoints3dList.pointsArray = options.knotPoints3dArray;
			}
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
BSplineCubic3D.prototype.getGeographicCoordsList = function() 
{
	if (this.geoCoordsList === undefined)
	{
		this.geoCoordsList = new GeographicCoordsList();
		this.geoCoordsList.owner = this;
	}
	
	return this.geoCoordsList;
};

/**
 * 어떤 일을 하고 있습니까?
 */
BSplineCubic3D.prototype.getGeoLocationDataManager = function(magoManager) 
{
	if (this.geoLocDataManager === undefined)
	{
		// Take the 1rst geoCoord, if exist, and make the geoLocationData.***
		if (this.geoCoordsList !== undefined)
		{
			var geoCoord = this.geoCoordsList.getGeoCoord(0);
			if (geoCoord !== undefined)
			{
				this.geoLocDataManager = new GeoLocationDataManager();
				var geoLoc = this.geoLocDataManager.newGeoLocationData("default");
				var heading, pitch, roll;
				geoLoc = ManagerUtils.calculateGeoLocationData(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude, heading, pitch, roll, geoLoc, magoManager);
			}
		}
	}
	
	return this.geoLocDataManager;
};

/**
 * 어떤 일을 하고 있습니까?
 */
BSplineCubic3D.prototype.renderPoints = function(magoManager, shader, renderType) 
{
	if (this.geoCoordsList === undefined)
	{ return false; }
	
	var bLoop = false, bEnableDepth = false;
	
	this.geoCoordsList.renderPoints(magoManager, shader, renderType, bEnableDepth);
	this.geoCoordsList.renderLines(magoManager, shader, renderType, bLoop, bEnableDepth);
	
	var gl = magoManager.sceneState.gl;
	
	// Render interpolated points.***
	if (this.interpolatedPoints3dList !== undefined)
	{
		var shader = magoManager.postFxShadersManager.getShader("pointsCloud");
		shader.useProgram();
		shader.disableVertexAttribArrayAll();
		shader.resetLastBuffersBinded();
		shader.enableVertexAttribArray(shader.position3_loc);
		shader.bindUniformGenerals();
	
		gl.uniform1i(shader.bPositionCompressed_loc, false);
		if (renderType === 1)
		{
			gl.uniform1i(shader.bUse1Color_loc, true);
			
			if (shader.oneColor4_loc !== undefined && shader.oneColor4_loc !== null)
			{ gl.uniform4fv(shader.oneColor4_loc, [1.0, 0.0, 0.0, 1.0]); } //.
		}
		gl.uniform1f(shader.fixPointSize_loc, 5.0);
		gl.uniform1i(shader.bUseFixPointSize_loc, true);
		this.interpolatedPoints3dList.renderLines(magoManager, shader, renderType, bLoop, bEnableDepth);
	}
	
	// Render controlPoints.***
	if (this.controlPoints3dMap !== undefined)
	{
		// Check if exist control points.***
		//var lineWidthRange = gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE);
		
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
BSplineCubic3D.prototype.makeKnotPointsFromGeoCoordsList = function(magoManager) 
{
	if (this.geoCoordsList.points3dList === undefined)
	{ this.geoCoordsList.makeLines(magoManager); }
	
	this.knotPoints3dList = new Point3DList();
	this.knotPoints3dList.pointsArray = this.geoCoordsList.points3dList.pointsArray;
	
	// Transfer the geoLocationDataManager too.***
	this.knotPoints3dList.geoLocDataManager = this.geoCoordsList.points3dList.geoLocDataManager;
};

/**
 * 어떤 일을 하고 있습니까?
 */
BSplineCubic3D.prototype.makeControlPoints = function(controlPointArmLength, magoManager) 
{
	// This function makes the controlPoints automatically for the geographicsPoints.***
	// There are 2 controlPoints for each point3d : InningControlPoint & OutingControlPoint.***
	
	// 1rst, make knotPoints if no exist.***
	if (this.knotPoints3dList === undefined)
	{
		if (this.geoCoordsList.points3dList === undefined)
		{ this.geoCoordsList.makeLines(magoManager); }
		
		this.knotPoints3dList = new Point3DList();
		this.knotPoints3dList.pointsArray = this.geoCoordsList.points3dList.pointsArray;
		
		// Transfer the geoLocationDataManager too.***
		this.knotPoints3dList.geoLocDataManager = this.geoCoordsList.points3dList.geoLocDataManager;
	}
	
	if (this.knotPoints3dList.pointsArray === undefined)
	{ return; }

	this.controlPoints3dMap = {};
	
	var bLoop = false;
	
	var currPoint;
	var prevPoint;
	var nextPoint;
	var prevSegment;
	var currSegment;
	var inningDist; // the inningControlPoint length.***
	var outingDist; // the outingControlPoint length.***
	
	if (controlPointArmLength === undefined)
	{ controlPointArmLength = 0.1; }
		
	var pointsCount = this.knotPoints3dList.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		currPoint = this.knotPoints3dList.getPoint(i);
		prevSegment;
		currSegment;
		
		if (i === 0)
		{
			// In this case there are no inningControlPoint.***
			nextPoint = this.knotPoints3dList.getPoint(i+1);
			outingDist = controlPointArmLength;
			
			// The outingControlPoint is in the segment, to the 20% of the currentPoint.***
			var outingControlPoint = new Point3D();
			outingControlPoint.set(currPoint.x * (1-outingDist) + nextPoint.x * outingDist, currPoint.y * (1-outingDist) + nextPoint.y * outingDist, currPoint.z * (1-outingDist) + nextPoint.z * outingDist);
			this.controlPoints3dMap[i] = {"inningControlPoint" : undefined, 
										  "outingControlPoint" : outingControlPoint};
		}
		else if ( i === pointsCount-1)
		{
			// In this case there are no outingControlPoint.***
			prevPoint = this.knotPoints3dList.getPoint(i-1);
			inningDist = controlPointArmLength;
			
			var inningControlPoint = new Point3D();
			inningControlPoint.set(currPoint.x * (1-inningDist) + prevPoint.x * inningDist, currPoint.y * (1-inningDist) + prevPoint.y * inningDist, currPoint.z * (1-inningDist) + prevPoint.z * inningDist);
			this.controlPoints3dMap[i] = {"inningControlPoint" : inningControlPoint, 
										  "outingControlPoint" : undefined};
		}
		else 
		{
			prevPoint = this.knotPoints3dList.getPoint(i-1);
			nextPoint = this.knotPoints3dList.getPoint(i+1);
			
			// Find the tangent line3d of the current point.***
			var tangentLine3d = this.knotPoints3dList.getTangentLine3D(i, undefined, bLoop);
			var dir = tangentLine3d.direction;
			
			// InningControlPoint.***
			inningDist = currPoint.distToPoint(prevPoint) * controlPointArmLength;
			var inningControlPoint = new Point3D();
			inningControlPoint.set(currPoint.x - dir.x * inningDist, currPoint.y - dir.y * inningDist, currPoint.z - dir.z * inningDist);
			
			// OutingControlPoint.***
			outingDist = currPoint.distToPoint(nextPoint) * controlPointArmLength;
			var outingControlPoint = new Point3D();
			outingControlPoint.set(currPoint.x + dir.x * outingDist, currPoint.y + dir.y * outingDist, currPoint.z + dir.z * outingDist);
			
			this.controlPoints3dMap[i] = {"inningControlPoint" : inningControlPoint, 
										  "outingControlPoint" : outingControlPoint};
		}
		
		
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
BSplineCubic3D.prototype.makeInterpolatedPoints = function() 
{
	if (this.knotPoints3dList === undefined)
	{ return; }

	if (this.controlPoints3dMap === undefined)
	{ this.makeControlPoints(); }

	if (this.interpolatedPoints3dList === undefined)
	{
		this.interpolatedPoints3dList = new Point3DList();
	}
	
	var interpolationsCount = 10;
	var increT = 1/interpolationsCount;
	var t;
	var interpolatedPointsArray = [];
	
	var bLoop = false;
	
	// For each segment, make the bezier curve interpolated points.***
	var pointsCount = this.knotPoints3dList.getPointsCount();
	for (var i=0; i<pointsCount-1; i++)
	{
		var currSegment = this.knotPoints3dList.getSegment3D(i, undefined, bLoop);
		var strPoint = currSegment.startPoint3d;
		var endPoint = currSegment.endPoint3d;
		
		var strControlPoint = this.controlPoints3dMap[i].outingControlPoint;
		var endControlPoint = this.controlPoints3dMap[i+1].inningControlPoint;
		
		BSplineCubic3D.makeForSegment(strPoint, strControlPoint, endControlPoint, endPoint, interpolationsCount, interpolatedPointsArray);
	}
	
	// Transfer pointsArray.***
	this.interpolatedPoints3dList.pointsArray = interpolatedPointsArray;
	
	// Transfer geoLocationDataManager.***
	this.interpolatedPoints3dList.geoLocDataManager = this.knotPoints3dList.geoLocDataManager;
};

/**
 * This function returns the length of the splineSegment at the unitaryPosition.
 */
BSplineCubic3D.getLengthForSegment = function(strPoint, strControlPoint, endControlPoint, endPoint, unitaryPosition, interpolationsCount) 
{
	if (unitaryPosition === undefined)
	{ unitaryPosition = 1; }
	
	if (interpolationsCount === undefined)
	{ interpolationsCount = 10; }
	
	// 1rst, make the interpolated curve.***
	var resultInterpolatedPointsArray = BSplineCubic3D.makeForSegmentPartial(strPoint, strControlPoint, endControlPoint, endPoint, unitaryPosition, interpolationsCount, undefined);
	
	// Now, calculate the total length of "N" segments.***
	var resultLength = 0;
	var pointA, pointB;
	var pointsCount = resultInterpolatedPointsArray.length;
	for (var i=0; i<pointsCount-1; i++)
	{
		pointA = resultInterpolatedPointsArray[i];
		pointB = resultInterpolatedPointsArray[i+1];
		resultLength += pointA.distToPoint(pointB);
	}
	
	return resultLength;
};

/**
 * This function returns the length of the splineSegment at the unitaryPosition.
 */
BSplineCubic3D.getLength = function(bSpline, interpolationsCount) 
{
	if (bSpline === undefined || bSpline.knotPoints3dList === undefined)
	{ return undefined; }
	
	var kNotsCount = bSpline.knotPoints3dList.getPointsCount();
	if (bSpline.segmentLengthArray === undefined)
	{
		// Calculate all segments length of the bSpline.***
		bSpline.segmentLengthArray = [];
		if (interpolationsCount === undefined)
		{ interpolationsCount = 20; }
		var unitaryPosition = 1;
		var bLoop; // undefined.
		for (var i=0; i<kNotsCount-1; i++)
		{
			var currSegment = bSpline.knotPoints3dList.getSegment3D(i, undefined, bLoop);
			var strPoint = currSegment.startPoint3d;
			var endPoint = currSegment.endPoint3d;
			
			var strControlPoint = bSpline.controlPoints3dMap[i].outingControlPoint;
			var endControlPoint = bSpline.controlPoints3dMap[i+1].inningControlPoint;
			
			var length = BSplineCubic3D.getLengthForSegment(strPoint, strControlPoint, endControlPoint, endPoint, unitaryPosition, interpolationsCount);
			bSpline.segmentLengthArray[i] = length;
		}
	}
	
	var totalLength = 0;
	for (var i=0; i<kNotsCount-1; i++)
	{
		totalLength += bSpline.segmentLengthArray[i];
	}
	
	return totalLength;
};

/**
 * This function returns the unitaryPosition of the splineSegment at the linearPosition.
 */
BSplineCubic3D.getUnitaryPositionForSegmentAtLinearPosition = function(strPoint, strControlPoint, endControlPoint, endPoint, linearPosition, interpolationsCount) 
{
	// "linearPosition" is length.***
	var increT = 1/interpolationsCount;
	var t = increT;
	
	var strX = strPoint.x;
	var strY = strPoint.y;
	var strZ = strPoint.z;
	
	var strCpX = strControlPoint.x;
	var strCpY = strControlPoint.y;
	var strCpZ = strControlPoint.z;
	
	var endCpX = endControlPoint.x;
	var endCpY = endControlPoint.y;
	var endCpZ = endControlPoint.z;
	
	var endX = endPoint.x;
	var endY = endPoint.y;
	var endZ = endPoint.z;
	
	var point = new Point3D(0, 0, 0);
	var prevPoint = new Point3D(0, 0, 0);
	var acumLength = 0;
	var resultUnitaryPosition;
	
	// Must find the interpolatedSegment that contains the "linearPosition".***
	for (var i=0; i<interpolationsCount+1; i++)
	{
		t = (i)*increT;
		var oneMinusT = 1-t;
		var oneMinusT2 = Math.pow(oneMinusT, 2);
		var oneMinusT3 = Math.pow(oneMinusT, 3);
		var t2 = t*t;
		var t3 = t2*t;
		var oneMinusT2_t_3 = 3*oneMinusT2*t;
		var oneMinusT_t2_3 = 3*oneMinusT*t2;

		var x = oneMinusT3*strX + oneMinusT2_t_3*strCpX + oneMinusT_t2_3*endCpX + t3*endX;
		var y = oneMinusT3*strY + oneMinusT2_t_3*strCpY + oneMinusT_t2_3*endCpY + t3*endY;
		var z = oneMinusT3*strZ + oneMinusT2_t_3*strCpZ + oneMinusT_t2_3*endCpZ + t3*endZ;
		point.set(x, y, z);
		
		if (i > 0)
		{
			var currLength = prevPoint.distToPoint(point);
			acumLength += currLength;
			
			if (acumLength > linearPosition)
			{
				// Calculate "resultUnitaryPosition" by interpolation.***
				var prevT = (i-1)*increT;
				var currT = t;
				var diffLength = currLength - (acumLength - linearPosition);
				var unitaryDiffLength = diffLength/currLength;
				unitaryDiffLength /= interpolationsCount;
				resultUnitaryPosition = prevT + unitaryDiffLength;
				return resultUnitaryPosition;
			}
		}
		
		prevPoint.set(x, y, z);
	}
	
	if (resultUnitaryPosition === undefined)
	{ resultUnitaryPosition = 1.0; }
	
	return resultUnitaryPosition;
};

/**
 * This function returns the tangent line of the splineSegment at the unitaryPosition.
 */
BSplineCubic3D.getTangent = function(bSpline, linearPosition, resultTangentLine, magoManager) 
{
	if (bSpline.knotPoints3dList === undefined)
	{
		var controlPointArmLength = 0.3;
		bSpline.makeControlPoints(controlPointArmLength, magoManager);
	}
	
	// "linearPosition" is a length measurement.***
	var kNotsCount = bSpline.knotPoints3dList.getPointsCount();
	
	if (bSpline.segmentLengthArray === undefined)
	{
		// Calculate all segments length of the bSpline.***
		bSpline.segmentLengthArray = [];
		var interpolationsCount = 20;
		var unitaryPosition = 1;
		var bLoop; // undefined.
		for (var i=0; i<kNotsCount-1; i++)
		{
			var currSegment = bSpline.knotPoints3dList.getSegment3D(i, undefined, bLoop);
			var strPoint = currSegment.startPoint3d;
			var endPoint = currSegment.endPoint3d;
			
			var strControlPoint = bSpline.controlPoints3dMap[i].outingControlPoint;
			var endControlPoint = bSpline.controlPoints3dMap[i+1].inningControlPoint;
			
			var length = BSplineCubic3D.getLengthForSegment(strPoint, strControlPoint, endControlPoint, endPoint, unitaryPosition, interpolationsCount);
			bSpline.segmentLengthArray[i] = length;
		}
	}
	
	// 1rst, find the segment that contains the "linearPosition".***
	var find = false;
	var i = 0;
	var lengthAux = 0;
	var prevLengthAux = 0;
	var segmentIdx = -1;
	while (!find && i<kNotsCount)
	{
		lengthAux += bSpline.segmentLengthArray[i];
		if (lengthAux >= linearPosition)
		{
			find = true;
			segmentIdx = i;
			
			var localPosition = linearPosition - prevLengthAux;
			var unitaryPosition = localPosition/bSpline.segmentLengthArray[segmentIdx];
			
			// Must find the realUnitaryPosition.******************************************
			var currSegment = bSpline.knotPoints3dList.getSegment3D(segmentIdx, undefined, bLoop);
			var strPoint = currSegment.startPoint3d;
			var endPoint = currSegment.endPoint3d;
			
			var strControlPoint = bSpline.controlPoints3dMap[segmentIdx].outingControlPoint;
			var endControlPoint = bSpline.controlPoints3dMap[segmentIdx+1].inningControlPoint;
			var interpolationsCount = 20;
			var realUnitaryPos = BSplineCubic3D.getUnitaryPositionForSegmentAtLinearPosition(strPoint, strControlPoint, endControlPoint, endPoint, localPosition, interpolationsCount);
			// End find the realUnitaryPosition.---------------------------------------------

			resultTangentLine = BSplineCubic3D.getTangentForSegment(strPoint, strControlPoint, endControlPoint, endPoint, realUnitaryPos, resultTangentLine);
		}
		prevLengthAux = lengthAux;
		i++;
	}
	
	return resultTangentLine;
};

/**
 * This function returns the tangent line of the splineSegment at the unitaryPosition.
 */
BSplineCubic3D.getTangentForSegment = function(strPoint, strControlPoint, endControlPoint, endPoint, unitaryPosition, resultTangentLine) 
{
	//                                 T = (1-t)*P + t*Q
	//                     P = (1-t)*A + t*B             Q = (1-t)*B + t*C  
	//                  T = (1-t)*(1-t)*A + (1-t)*t*B + t*(1-t)*B + t*t*C
	//                A = (1-t)*K + t*L         B = (1-t)*L + t*M          C = (1-t)*M + t*N
	//           T = (1-t)^3*K + (1-t)^2*t*L + 2*(1-t)^2*t*L + 2*(1-t)*t^2*M + (1-t)*t^2*M + t^3*N 
	//           T = (1-t)^3*K + 3*(1-t)^2*t*L + 3*(1-t)*t^2*M + t^3*N 
	
	// "unitaryPosition" range = [0.0, 1.0].***
	var t = unitaryPosition;
	var oneMinusT = 1-t;
	var oneMinusT2 = oneMinusT*oneMinusT;
	var t2 = t*t;
	var oneMinusT_2_t = 2*oneMinusT*t;
	
	// K.***
	var strX = strPoint.x;
	var strY = strPoint.y;
	var strZ = strPoint.z;
	
	// L.***
	var strCpX = strControlPoint.x;
	var strCpY = strControlPoint.y;
	var strCpZ = strControlPoint.z;
	
	// M.***
	var endCpX = endControlPoint.x;
	var endCpY = endControlPoint.y;
	var endCpZ = endControlPoint.z;
	
	// N.***
	var endX = endPoint.x;
	var endY = endPoint.y;
	var endZ = endPoint.z;
	
	// Calculate points P & Q.***
	//                     P = (1-t)*A + t*B             Q = (1-t)*B + t*C  
	//                A = (1-t)*K + t*L         B = (1-t)*L + t*M          C = (1-t)*M + t*N
	// P = (1-t)*((1-t)*K + t*L) + t*((1-t)*L + t*M)
	// P = (1-t)^2*K + (1-t)*t*L + (1-t)*t*L + t^2*M
	// P = (1-t)^2*K + 2*(1-t)*t*L + t^2*M
	//
	// Q = (1-t)*((1-t)*L + t*M) + t*((1-t)*M + t*N)
	// Q = (1-t)^2*L + (1-t)*t*M + (1-t)*t*M + t^2*N
	// Q = (1-t)^2*L + 2*(1-t)*t*M + t^2*N
	
	var Px = oneMinusT2 * strX + oneMinusT_2_t*strCpX + t2*endCpX;
	var Py = oneMinusT2 * strY + oneMinusT_2_t*strCpY + t2*endCpY;
	var Pz = oneMinusT2 * strZ + oneMinusT_2_t*strCpZ + t2*endCpZ;
	
	var Qx = oneMinusT2 * strCpX + oneMinusT_2_t*endCpX + t2*endX;
	var Qy = oneMinusT2 * strCpY + oneMinusT_2_t*endCpY + t2*endY;
	var Qz = oneMinusT2 * strCpZ + oneMinusT_2_t*endCpZ + t2*endZ;
	
	var pointP = new Point3D(Px, Py, Pz);
	var pointQ = new Point3D(Qx, Qy, Qz);
	
	// Calculate T = (1-t)*P + t*Q.***
	// T = (oneMinusT*Px + t*Qx, oneMinusT*Py + t*Qy, oneMinusT*Pz + t*Qz);

	if (resultTangentLine === undefined)
	{ resultTangentLine = new Line(); }
	
	var direction = pointP.getVectorToPoint(pointQ, undefined);
	direction.unitary();
	resultTangentLine.setPointAndDir(oneMinusT*Px + t*Qx, oneMinusT*Py + t*Qy, oneMinusT*Pz + t*Qz, direction.x, direction.y, direction.z);
	
	return resultTangentLine;
};

/**
 * 어떤 일을 하고 있습니까?
 */
BSplineCubic3D.makeForSegment = function(strPoint, strControlPoint, endControlPoint, endPoint, interpolationsCount, resultInterpolatedPointsArray) 
{
	var unitaryPosition = 1;
	return BSplineCubic3D.makeForSegmentPartial(strPoint, strControlPoint, endControlPoint, endPoint, unitaryPosition, interpolationsCount, resultInterpolatedPointsArray);
};

/**
 * 어떤 일을 하고 있습니까?
 */
BSplineCubic3D.makeForSegmentPartial = function(strPoint, strControlPoint, endControlPoint, endPoint, unitaryPosition, interpolationsCount, resultInterpolatedPointsArray) 
{
	// Bezier from del Casteljau.***
	// Bezier curve defined by 2 points (K & N) & 2 control points (L & M).***
	//
	//                             L--------------------------B-------------M
	//                            /                       /     \            \
	//                           /                    /           \           \
	//                          /                 /                  \         \
	//                         /               /                       \        \
	//                        /            /                             \       \
	//                       /          /                                  \      \
	//                      /        P------------T--------------------------Q     \
	//                     /      /      .  ..............     .               \    \
	//                    /   /     .                               .            \   \
	//                   / /     .                                      .          \  \
	//                  A     .                                             .        \ \
	//                 /   .                                                    .       C
	//                / .                                                           .    \
	//               /.                                                               .   \
	//              /.                                                                  .  \
	//             /.                                                                     . \
	//            K                                                                          N
	//
	//                                 T = (1-t)*P + t*Q
	//
	//                     P = (1-t)*A + t*B             Q = (1-t)*B + t*C
	//                   
	//                  T = (1-t)*(1-t)*A + (1-t)*t*B + t*(1-t)*B + t*t*C
	//
	//                A = (1-t)*K + t*L         B = (1-t)*L + t*M          C = (1-t)*M + t*N
	//
	//           T = (1-t)^3*K + (1-t)^2*t*L + 2*(1-t)^2*t*L + 2*(1-t)*t^2*M + (1-t)*t^2*M + t^3*N 
	//
	//           T = (1-t)^3*K + 3*(1-t)^2*t*L + 3*(1-t)*t^2*M + t^3*N 
	
	if (resultInterpolatedPointsArray === undefined)
	{ resultInterpolatedPointsArray = []; }
	
	var increT = unitaryPosition/interpolationsCount;
	var t = increT;
	
	var strX = strPoint.x;
	var strY = strPoint.y;
	var strZ = strPoint.z;
	
	var strCpX = strControlPoint.x;
	var strCpY = strControlPoint.y;
	var strCpZ = strControlPoint.z;
	
	var endCpX = endControlPoint.x;
	var endCpY = endControlPoint.y;
	var endCpZ = endControlPoint.z;
	
	var endX = endPoint.x;
	var endY = endPoint.y;
	var endZ = endPoint.z;
	
	
	for (var i=0; i<interpolationsCount+1; i++)
	{
		t = (i)*increT;
		var oneMinusT = 1-t;
		var oneMinusT2 = Math.pow(oneMinusT, 2);
		var oneMinusT3 = Math.pow(oneMinusT, 3);
		var t2 = t*t;
		var t3 = t2*t;
		var oneMinusT2_t_3 = 3*oneMinusT2*t;
		var oneMinusT_t2_3 = 3*oneMinusT*t2;

		var x = oneMinusT3*strX + oneMinusT2_t_3*strCpX + oneMinusT_t2_3*endCpX + t3*endX;
		var y = oneMinusT3*strY + oneMinusT2_t_3*strCpY + oneMinusT_t2_3*endCpY + t3*endY;
		var z = oneMinusT3*strZ + oneMinusT2_t_3*strCpZ + oneMinusT_t2_3*endCpZ + t3*endZ;
		var point = new Point3D(x, y, z);
		resultInterpolatedPointsArray.push(point);
	}
	
	return resultInterpolatedPointsArray;
};
































'use strict';

/**
 * This represent the circle feature drawn in 2D.
 * @class Circle2D
 */
var Circle2D = function() 
{
	if (!(this instanceof Circle2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	// sweeping in CounterClockWise is positive.
	// zero startAngle is in "X" axis positive.
	this.centerPoint; // Point2D.
	this.radius;
	this.numPointsFor360Deg; // interpolation param.
};

/**
 * Set the center position of Circle.
 * @param {Number} cx the x coordi of the center
 * @param {Number} cy the y coordi of the center
 */
Circle2D.prototype.setCenterPosition = function(cx, cy)
{
	if (this.centerPoint === undefined)
	{ this.centerPoint = new Point2D(); }
	
	this.centerPoint.set(cx, cy);
};

/**
 * Set the radius value
 * @param {Number} radius
 */
Circle2D.prototype.setRadius = function(radius)
{
	this.radius = radius;
};

/**
 * Returns the points of the circle.
 * @param reulstPointsArray the array which saves the result of the points
 * @param pointsCountFor360Deg the value used for interpolation way
 */
Circle2D.prototype.getPoints = function(resultPointsArray, pointsCountFor360Deg)
{
	if (pointsCountFor360Deg)
	{ this.numPointsFor360Deg = pointsCountFor360Deg; }

	if (this.numPointsFor360Deg === undefined)
	{ this.numPointsFor360Deg = 36; }
	
	// use an arc to make points.
	if (this.centerPoint === undefined || this.radius === undefined)
	{ return resultPointsArray; }
	
	var arc = new Arc2D();
	arc.setCenterPosition(this.centerPoint.x, this.centerPoint.y);
	
	arc.setRadius(this.radius);
	arc.setStartAngleDegree(0);
	arc.setSweepAngleDegree(360.0);
	arc.setSense(1);
	
	if (resultPointsArray === undefined)
	{ resultPointsArray = []; }
	
	resultPointsArray = arc.getPoints(resultPointsArray, this.numPointsFor360Deg);
	return resultPointsArray;
};
















































'use strict';
/**
 * point2d 데이터 cluster
 *
 * @param {Point3DList} point2DList 
 * @param {number} depth
 * @param {MagoManager} magoMangaer
 * @param {function} customRenderFunc optional
 */
var Cluster = function(point2DList, depth, magoMangaer, customRenderFunc) 
{
    
	if (!point2DList || !point2DList instanceof Point2DList) 
	{
		throw new Error('point2DList is required');
	}
	this.point2DList = point2DList;
	this.depth = defaultValueCheckLength(depth, 8);

	this.quatTree;
	this.magoMangaer = magoMangaer;

	this.renderFunction = (customRenderFunc && typeof customRenderFunc === 'function') ? customRenderFunc : this.defaultRenderFunc;

	this.initQuatTree();
};

Cluster.prototype.initQuatTree = function() 
{
	var treeOption = this.getTreeOption();
	this.quatTree = new QuatTree(treeOption);
	this.quatTree.data = this.point2DList.pointsArray;

	this.makeTreeByDepth();
};

Cluster.prototype.getTreeOption = function() 
{
	var br = this.point2DList.getBoundingRectangle();

	var xLength = br.getXLength();
	var yLength = br.getYLength();
	var center = br.getCenterPoint();
	
	if (xLength < 0.03) { xLength = 0.03; }
	if (yLength < 0.03) { yLength = 0.03; }
	return {
		halfWidth  : xLength/2,
		halfHeight : yLength/2,
		center     : center
	};
};

Cluster.prototype.addPoint = function(point) 
{
	this.point2DList.addPoint(point);
	this.initQuatTree();
};

Cluster.prototype.deletePointByCondition = function(condition)
{
	this.point2DList.deletePointByCondition(condition);

	if (this.point2DList.getPointsCount() > 0 ) 
	{
		this.initQuatTree();
	}
	else 
	{
		this.quatTree = undefined;

		this.magoMangaer.objMarkerManager.setMarkerByCondition(function(om)
		{
			return !om.tree;
		});
	}
	
};

Cluster.prototype.updatePoint = function(point, findOption)
{
	var findPoint = this.point2DList.findPointArray(findOption)[0];
	findPoint.set(point.getX(), point.getY());
	var keys = Object.keys(findPoint);

	for (var i=0, len=keys.length;i<len;i++) 
	{
		var key = keys[i];
		findPoint[key] = point[key];
	}

	this.initQuatTree();
};

Cluster.prototype.makeTreeByDepth = function() 
{
	this.quatTree.makeTreeByDepth(this.depth);
};

Cluster.prototype.defaultRenderFunc = function(trees, magoManager) 
{
	magoManager.objMarkerManager.loadDefaultImages(magoManager);
	magoManager.objMarkerManager.objectMarkerArray = [];

	var treeLength = trees.length;
	for (var i=0;i<treeLength;i++) 
	{
		var tree = trees[i];
		if (tree.hasChildren()) 
		{
			var points = tree.displayPointsArray;

			var pointLength = points.length;
			for (var j=0;j<pointLength;j++) 
			{
				var point = points[j];
				var mass = point.mass;

				if (mass > 50) { mass=50; }
				if (mass < 15) { mass = 15; }
				var options = {
					positionWC    : point,
					imageFilePath : "defaultRed",
					sizeX         : mass,
					sizeY         : mass
				};
				magoManager.objMarkerManager.newObjectMarker(options, magoManager);
			}
		}
		else 
		{
			var points = tree.data;
			if (points) 
			{
				var pointLength = points.length;
				for (var j=0;j<pointLength;j++) 
				{
					var point = points[j];
					
					var options = {
						positionWC    : ManagerUtils.geographicCoordToWorldPoint(point.x, point.y, 0),
						imageFilePath : "defaultBlue",
						sizeX         : 8,
						sizeY         : 8
					};
					magoManager.objMarkerManager.newObjectMarker(options, magoManager);
				}
			}
		}
	}
};
'use strict';

/**
 * CuttingPlane on 3D space. 
 * @class CuttingPlane
 */
var CuttingPlane = function() 
{
	if (!(this instanceof CuttingPlane)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.plane;
	this.geoLocDataManager;
	
	// geometric representation.
	this.mesh; // use to draw a rectangle.
};
/**
 * Calculate plane.
 * In the transformationMatrix there are the normal of the plane.
 */
CuttingPlane.prototype.getPlane = function()
{
	// Calculate plane.
	if (this.plane === undefined)
	{ this.plane = new Plane(); }
	
	// In the transformationMatrix there are the normal of the plane.
	var geoLoc = this.geoLocDataManager.getCurrentGeoLocationData();
	var tMatrix = geoLoc.tMatrix; 
	var pos = geoLoc.position;
	this.plane.setPointAndNormal(pos.x, pos.y, pos.z, tMatrix._floatArrays[8], tMatrix._floatArrays[9], tMatrix._floatArrays[10]);
	
	return this.plane;
};
/**
 * create mesh to draw cutting plane's rectangle
 * @param {Number} width the width of the cutting plane's rectangle
 * @param {Number} height the height of the cutting plane's rectangle
 */
CuttingPlane.prototype.makeRectangle = function(width, height)
{
	// Provisional function.
	if (this.mesh === undefined)
	{ this.mesh = new Mesh(); }
	
	var vertexList = this.mesh.getVertexList();
	var semiWidth = width/2;
	var semiHeight = height/2;
	var alt = 100;
	
	// 1- left_down vertex.
	var vertex1 = vertexList.newVertex();
	vertex1.setPosition(-semiWidth, -semiHeight, alt);
	
	// 2- right_down vertex.
	var vertex2 = vertexList.newVertex();
	vertex2.setPosition(semiWidth, -semiHeight, alt);
	
	// 3- right_up vertex.
	var vertex3 = vertexList.newVertex();
	vertex3.setPosition(semiWidth, semiHeight, alt);
	
	// 4- left_up vertex.
	var vertex4 = vertexList.newVertex();
	vertex4.setPosition(-semiWidth, semiHeight, alt);
	
	// now, make triangles.
	var surfaces = this.mesh.newSurface();
	var face = surfaces.newFace();
	
	face.addVerticesArray([vertex1, vertex2, vertex3, vertex4]);
	
	
};

/**
 * Render cutting plane
 * @param magoManager
 * @param shader
 * @param renderType
 */
CuttingPlane.prototype.render = function(magoManager, shader, renderType)
{
	var gl = magoManager.sceneState.gl;
	var glPrimitive;
	if (renderType === 2)
	{
		// colorCoding selection.
		var selectionColor = magoManager.selectionColor;
		var selFamilyName = "general";
		var selManager = magoManager.selectionManager;
		var selCandidateNodes = selManager.getSelectionCandidatesFamily(selFamilyName);
		if (selCandidateNodes === undefined)
		{
			selCandidateNodes = selManager.newCandidatesFamily(selFamilyName);
		}
		
		var selColor4 = selectionColor.getAvailableColor(undefined); // new.
		var idxKey = selectionColor.decodeColor3(selColor4.r, selColor4.g, selColor4.b);
		selManager.setCandidateCustom(idxKey, selFamilyName, this);
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
		gl.uniform4fv(shader.oneColor4_loc, [selColor4.r/255.0, selColor4.g/255.0, selColor4.b/255.0, 1.0]);
	}
	else if (renderType === 1)
	{
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
		gl.uniform4fv(shader.oneColor4_loc, [1.0, 1.0, 0.0, 1.0]);
		var refMatrixType = 0; // identity matrix.
		gl.uniform1i(shader.refMatrixType_loc, refMatrixType);
		glPrimitive = gl.LINE_LOOP;
	}
	else if (renderType === 0)
	{
		var refMatrixType = 0; // identity matrix.
		gl.uniform1i(shader.refMatrixType_loc, refMatrixType);
	}
	
	this.mesh.render(magoManager, shader, renderType, glPrimitive);
};













































'use strict';


/**
 * This class draws an excavation on the grown.
 * @class Excavation
 */
var Excavation = function(options) 
{
	if (!(this instanceof Excavation)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	/**
	 * The geographic points that conforms the excavation border.
	 * @type {GeographicCoordsList}
	 * @default undefined
	 */
	this.geoCoordsList; 
	
	this.geoLocDataManager;
	this.excavationDepthInMeters;
	
	this.vtxProfilesList;
	this.vboKeysContainer;
	this.vboKeysContainerEdges;
	
	this.dirty = true;
	this.color4 = new Color(222/255, 184/255, 135/255, 1.0);
	
	if (options !== undefined)
	{
		if (options.geoCoordsArray !== undefined)
		{
			this.geoCoordsList = new GeographicCoordsList(options.geoCoordsArray);
			this.geoCoordsList.owner = this;
			
			// 1rst, set position of this extrude object. Take as position the 1rst geoCoord absolute position.
			// Another possibility is calculate the average point of geoCoords.
			var geoLoc = this.getGeoLocationData();

			// Take the 1rst geographicCoord's geoLocation.
			var geoCoord = this.geoCoordsList.getGeoCoord(0);
			if (geoCoord)
			{
				var geoLocDataManagerFirst = geoCoord.getGeoLocationDataManager();
				var geoLocFirst = geoLocDataManagerFirst.getCurrentGeoLocationData();
				geoLoc.copyFrom(geoLocFirst);
			}
		}

		if (options.excavationDepthInMeters !== undefined)
		{
			this.excavationDepthInMeters = options.excavationDepthInMeters;
		}

		if (options.color && options.color instanceof Color) 
		{
			this.color4 = options.color;
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Excavation.prototype.getGeographicCoordsList = function() 
{
	return this.geoCoordsList;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Excavation.prototype.renderPoints = function(magoManager, shader, renderType) 
{
	if (this.geoCoordsList === undefined)
	{ return false; }
	
	this.geoCoordsList.renderPoints(magoManager, shader, renderType, false);
	//this.geoCoordsList.renderLines(magoManager, shader, renderType, false, false);
};

/**
 * 어떤 일을 하고 있습니까?
 */
Excavation.prototype.render = function(magoManager, shader, renderType, glPrimitive, bIsSelected) 
{
	if (this.dirty)
	{
		this.makeMesh(magoManager);
		return;
	}
	
	if (this.meshPositive === undefined)
	{ return; }

	
	var gl = magoManager.sceneState.gl;
	
	shader.useProgram();
	shader.resetLastBuffersBinded();

	shader.enableVertexAttribArray(shader.position3_loc);
	shader.bindUniformGenerals();

	if (renderType === 1)
	{
		shader.disableVertexAttribArray(shader.color4_loc);
		shader.enableVertexAttribArray(shader.normal3_loc); 
		shader.disableVertexAttribArray(shader.texCoord2_loc); // provisionally has no texCoords.
	
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
		gl.uniform4fv(shader.oneColor4_loc, [1.0, 1.0, 0.1, 0.0]); //.
		gl.uniform1i(shader.bApplySsao_loc, true); // apply ssao.
		gl.uniform1i(shader.colorType_loc, 1); // 0= oneColor, 1= attribColor, 2= texture.
		gl.uniform1i(shader.bApplySpecularLighting_loc, true); // turn on/off specular lighting.
	}
	
	gl.uniform1i(shader.refMatrixType_loc, 0); // in this case, there are not referencesMatrix.
	
	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LEQUAL);
	
	var buildingGeoLocation = this.geoLocDataManager.getCurrentGeoLocationData();
	buildingGeoLocation.bindGeoLocationUniforms(gl, shader); // rotMatrix, positionHIGH, positionLOW.
		
	
	// STENCIL SETTINGS.*
	gl.colorMask(false, false, false, false);
	gl.depthMask(false); // No altere depth buffer.
	gl.enable(gl.CULL_FACE);
	gl.enable(gl.STENCIL_TEST);
	//gl.enable(gl.POLYGON_OFFSET_FILL);
	//gl.polygonOffset(1.0, 2.0); // Original.
	//gl.polygonOffset(0.0, 0.0); 
	
	gl.clearStencil(0);
	var glPrimitive = undefined;
	

	// First pass.*
	gl.cullFace(gl.FRONT); // 1rstPass.
	gl.stencilFunc(gl.ALWAYS, 0x0, 0xff);
	gl.stencilOp(gl.KEEP, gl.INCR, gl.KEEP); // stencilOp(fail, zfail, zpass)
	this.meshPositive.render(magoManager, shader, renderType, glPrimitive);
	

	// Second pass.*
	gl.cullFace(gl.BACK); // 2ndPass.
	gl.stencilFunc(gl.ALWAYS, 0x0, 0xff);
	gl.stencilOp(gl.KEEP, gl.DECR, gl.KEEP); // stencilOp(fail, zfail, zpass)
	this.meshPositive.render(magoManager, shader, renderType, glPrimitive);// Original.
	

	// Render the hole.
	if (renderType === 1)
	{
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
		gl.uniform4fv(shader.oneColor4_loc, [this.color4.r, this.color4.g, this.color4.b, this.color4.a]); //.
	}
	
	gl.colorMask(true, true, true, true);
	gl.depthMask(true);
	gl.stencilMask(0x00);

	//gl.stencilFunc(gl.NOTEQUAL, 0, 0xff);
	gl.stencilFunc(gl.LEQUAL, 1, 0xff);
	gl.stencilOp(gl.REPLACE, gl.REPLACE, gl.REPLACE); // stencilOp(fail, zfail, zpass)

	gl.cullFace(gl.BACK);
	gl.depthFunc(gl.GREATER);
	
	this.meshNegative.render(magoManager, shader, renderType, glPrimitive);

	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LEQUAL);
	gl.disable(gl.STENCIL_TEST);
	gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP); // stencilOp(fail, zfail, zpass)
	gl.disable(gl.POLYGON_OFFSET_FILL);
	
	gl.stencilMask(0xff);
	
};

/**
 * 어떤 일을 하고 있습니까?
 */
Excavation.prototype.getGeoLocationData = function() 
{
	if (this.geoLocDataManager === undefined)
	{ this.geoLocDataManager = new GeoLocationDataManager(); }
	
	var geoLoc = this.geoLocDataManager.getCurrentGeoLocationData();
	if (geoLoc === undefined)
	{
		geoLoc = this.geoLocDataManager.newGeoLocationData("default");
	}
	
	return geoLoc;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Excavation.prototype.makeMesh = function(magoManager) 
{
	if (this.geoCoordsList === undefined)
	{ return false; }
	
	// 1rst, set position of this extrude object. Take as position the 1rst geoCoord absolute position.
	// Another possibility is calculate the average point of geoCoords.
	var geoLoc = this.getGeoLocationData();

	// Take the 1rst geographicCoord's geoLocation.
	var geoCoord = this.geoCoordsList.getGeoCoord(0);
	var geoLocDataManagerFirst = geoCoord.getGeoLocationDataManager();
	var geoLocFirst = geoLocDataManagerFirst.getCurrentGeoLocationData();
	geoLoc.copyFrom(geoLocFirst);
	
	
	// Now, make the down & up profiles.
	if (this.vtxProfilesList === undefined)
	{ this.vtxProfilesList = new VtxProfilesList(); }
	
	// Project the geoCoordList into a plane. Remember that the local coordinate is the 1rst geoCoord.
	// Calculate down & up points of the extrude object.
	var points3dArrayDown = [];
	var points3dArrayUp = [];
	
	if (this.excavationDepthInMeters === undefined)
	{ this.excavationDepthInMeters = 30.0; }
	
	var cartesianAux;
	var geoCoord;
	var geoCoordsCount = this.geoCoordsList.getGeoCoordsCount();
	for (var i=0; i<geoCoordsCount; i++)
	{
		// Current geoCoord.
		geoCoord = this.geoCoordsList.getGeoCoord(i);
		
		// Down & Up absolute points.
		var point3DDown = new Point3D();
		var point3DUp = new Point3D();
		cartesianAux = Globe.geographicToCartesianWgs84(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude - this.excavationDepthInMeters, cartesianAux);
		point3DDown.set(cartesianAux[0], cartesianAux[1], cartesianAux[2]);
		
		cartesianAux = Globe.geographicToCartesianWgs84(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude + 70.0, cartesianAux);
		point3DUp.set(cartesianAux[0], cartesianAux[1], cartesianAux[2]);
		
		// Down & Up relative points.
		var point3DDownRel = new Point3D();
		var point3DUpRel = new Point3D();
		point3DDownRel = geoLoc.getTransformedRelativePosition(point3DDown, point3DDownRel);
		point3DUpRel = geoLoc.getTransformedRelativePosition(point3DUp, point3DUpRel);
		
		point3DDownRel.pointType = 1;
		point3DUpRel.pointType = 1;
		
		points3dArrayDown[i] = point3DDownRel;
		points3dArrayUp[i] = point3DUpRel;
	}
	
	// Now, make vertexProfiles (down_vtxProfile & up_vtxProfile).
	var vertexProfileDown = this.vtxProfilesList.newVtxProfile();
	var vertexProfileUp = this.vtxProfilesList.newVtxProfile();
	
	vertexProfileDown.makeByPoints3DArray(points3dArrayDown, undefined);
	vertexProfileUp.makeByPoints3DArray(points3dArrayUp, undefined);
	
	// Now, make the mesh.
	if (this.meshPositive === undefined)
	{
		//this.meshTest = 
		var bIncludeBottomCap = true;
		var bIncludeTopCap = true;
		this.mesh = this.vtxProfilesList.getMesh(undefined, bIncludeBottomCap, bIncludeTopCap);
		
		// positive mesh.
		this.meshPositive = this.mesh.getCopySurfaceIndependentMesh(this.meshPositive);
		this.meshPositive.calculateVerticesNormals();
	
		this.meshPositive.setColor(0.1, 0.5, 0.5, 1.0);

		this.meshPositive.getVbo(this.vboKeysContainer, magoManager.vboMemoryManager);
		this.meshPositive.getVboEdges(this.vboKeysContainerEdges, magoManager.vboMemoryManager);
		
		// negative mesh.
		this.meshNegative = this.mesh.getCopySurfaceIndependentMesh(this.meshNegative);
		this.meshNegative.reverseSense(); // here calculates vertices normals.
	
		this.meshNegative.setColor(0.1, 0.5, 0.5, 1.0);

		this.meshNegative.getVbo(this.vboKeysContainer, magoManager.vboMemoryManager);
		this.meshNegative.getVboEdges(this.vboKeysContainerEdges, magoManager.vboMemoryManager);
		
	}
	
	this.dirty = false;
};










































'use strict';

/**
 * The minimum elementary object that constitutes the surface.
 * 표면, Surface의 하위 개념.
 * 실린더를 예를 들면
 * 위 아래 뚜껑은 각각 하나의 Surface이자 face.
 * 옆면은 하나의 Surface에 수십개의 face가 모여있는 구조.
 * 
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class Face
 */
var Face = function() 
{
	if (!(this instanceof Face)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * 페이스의 버텍스 리스트
	 * @type {Array.<Vertex>}
	 */
	this.vertexArray;

	/**
	 * 페이스의 임의의 버텍스의 hEdge.
	 * @type {HalfEdge}
	 */
	this.hEdge;

	/**
	 * 페이스의 플레인 노말 포인트.
	 * @type {Point3D}
	 */
	this.planeNormal;

	/**
	 * @deprecated not used
	 */
	this.surfaceOwner;
};

/**
 * delete all member.
 * Note: "Face" is NO-Owner of vertices, so, don't delete vertices. Only set as "undefined".
 * Note: "Face" is NO-Owner of hEdge, so, don't delete hEdge. Only set as "undefined".
 */
Face.prototype.deleteObjects = function()
{
	this.vertexArray = undefined;
	this.hEdge = undefined;
	
	if (this.planeNormal !== undefined)
	{
		this.planeNormal.deleteObjects();
		this.planeNormal = undefined;
	}
	
	this.surfaceOwner = undefined;
};
/**
 * get vertex array length
 * @returns {number} length of this vertexArray.
 */
Face.prototype.getVerticesCount = function()
{
	if (this.vertexArray === undefined)
	{ return 0; }

	return this.vertexArray.length;
};

/**
 * add vertex to this vertexArray
 * @param {Vertex} vertex
 */
Face.prototype.setVertexIdxInList = function()
{
	var verticesCount = this.getVerticesCount();
	for (var i=0; i<verticesCount; i++)
	{
		this.vertexArray[i].setIdxInList(i);
	}
};

/**
 * This function returns the halfEdge that has the "vertex" as startVertex.
 * @param {Vertex} vertex
 */
Face.prototype.getHalfEdgeOutingFromVertex = function(vertex)
{
	var find = false;
	var i=0;
	var currHedge = this.hEdge;
	var targetHedge;
	var vertexCount = this.getVerticesCount();
	while (!find && i<vertexCount)
	{
		if (currHedge.startVertex === vertex)
		{
			find = true;
			targetHedge = currHedge;
			break;
		}
		
		currHedge = currHedge.next;
		i++;
	}
	
	return targetHedge;
};

/**
 * add vertex to this vertexArray
 * @param {Vertex} vertex
 */
Face.prototype.changeVertex = function(idx, newVertex)
{
	var vertexCount = this.getVerticesCount();
	
	if (idx < 0 || idx >= vertexCount)
	{ return false; }
	
	var vertexToChange = this.vertexArray[idx];
	
	// must find the hedge that uses the "vertexToChange".
	var hedge = this.getHalfEdgeOutingFromVertex(vertexToChange);
	hedge.setStartVertex(newVertex);
	
	this.vertexArray[idx] = newVertex;
	
	return true;
};

/**
 * add vertex to this vertexArray
 * @param {Vertex} vertex
 */
Face.prototype.addVertex = function(vertex)
{
	if (this.vertexArray === undefined)
	{ this.vertexArray = []; }
	
	this.vertexArray.push(vertex);
};

/**
 * add vertex array to this vertexArray
 * @param {Array.<Vertex>} vertex
 */
Face.prototype.addVerticesArray = function(verticesArray)
{
	if (this.vertexArray === undefined)
	{ this.vertexArray = []; }
	
	Array.prototype.push.apply(this.vertexArray, verticesArray);
};

/**
 * get vertex
 * @param {number} idx array index.
 * @returns {Vertex|undefined}
 */
Face.prototype.getVertex = function(idx)
{
	if (this.vertexArray === undefined)
	{ return undefined; }

	return this.vertexArray[idx];
};

/**
 * reverse this vertex array.
 */
Face.prototype.reverseSense = function()
{
	this.vertexArray.reverse();
};

/**
 * set color all vertex in vertexArray.
 * @param {number} r
 * @param {number} g
 * @param {number} b
 * @param {number} a
 */
Face.prototype.setColor = function(r, g, b, a)
{
	var vertex;
	var verticesCount = this.getVerticesCount();
	for (var i=0; i<verticesCount; i++)
	{
		vertex = this.getVertex(i);
		vertex.setColorRGBA(r, g, b, a);
	}
};

/**
 * get plane normal point. if this plane normal is undefined or not a number, calculate plane normal.
 * @returns {Point3D} this plane normal point.
 */
Face.prototype.getPlaneNormal = function()
{
	if (this.planeNormal === undefined || this.planeNormal.isNAN())
	{ 
		//this.calculateVerticesNormals(); 
		this.calculatePlaneNormal();
	} 
	
	return this.planeNormal;
};

/**
 * calculate plane normal point using vertex array.
 * @static
 * @param {Array.<Vertex>} vertexArray
 * @param {Point3D} resultPlaneNormal if this is undefined, set new Point3D instance.
 * @returns {Point3D}
 */
Face.calculatePlaneNormal = function(vertexArray, resultPlaneNormal)
{
	// Note: the vertexArray must be planar.
	if (resultPlaneNormal === undefined)
	{ resultPlaneNormal = new Point3D(); }

	resultPlaneNormal.set(0, 0, 0);
	var verticesCount = vertexArray.length;
	for (var i=0; i<verticesCount; i++)
	{
		var prevIdx = VertexList.getPrevIdx(i, vertexArray);
		var startVec = VertexList.getVector(prevIdx, vertexArray, undefined);
		var endVec = VertexList.getVector(i, vertexArray, undefined);
		
		startVec.unitary();
		endVec.unitary();
		
		if (startVec.isNAN() || endVec.isNAN())
		{ continue; }
		
		var crossProd = startVec.crossProduct(endVec, undefined); // Point3D.
		crossProd.unitary(); 
		if (crossProd.isNAN())
		{ continue; }
	
		var scalarProd = startVec.scalarProduct(endVec);
		
		var cosAlfa = scalarProd; // Bcos startVec & endVec are unitaries.
		if (cosAlfa > 1.0)
		{ cosAlfa = 1.0; }
		else if (cosAlfa < -1.0)
		{ cosAlfa = -1.0; }
		var alfa = Math.acos(cosAlfa);
		
		resultPlaneNormal.add(crossProd.x*alfa, crossProd.y*alfa, crossProd.z*alfa);
	}
	resultPlaneNormal.unitary();
	
	return resultPlaneNormal;
};

/**
 * calculate plane normal and set this plane normal.
 * @returns {Point3D} this plane normal point.
 * 
 * @see Face#calculatePlaneNormal
 */
Face.prototype.calculatePlaneNormal = function()
{
	// Note: face must be planar.
	this.planeNormal = Face.calculatePlaneNormal(this.vertexArray, this.planeNormal);
	return this.planeNormal;
};

/**
 * 각 버텍스들의 normal point를 face의 plane normal로 일괄 적용.
 * @param {Boolean} bForceRecalculatePlaneNormal if true, force execute calculatePlaneNormal.
 * 
 * @see Face#calculatePlaneNormal
 */
Face.prototype.calculateVerticesNormals = function(bForceRecalculatePlaneNormal)
{
	// This function calculates normals for concave faces.
	// Provisionally calculate the plane normal and assign to the vertices.
	var verticesCount = this.vertexArray.length;

	if (bForceRecalculatePlaneNormal !== undefined && bForceRecalculatePlaneNormal)
	{ this.calculatePlaneNormal(); }
	
	if (this.planeNormal === undefined)
	{ this.calculatePlaneNormal(); }
	//@TODO: Add dirty-flag not to copy the normal vector twice.
	
	var normal;
	var verticesCount = this.getVerticesCount();
	for (var i=0; i<verticesCount; i++)
	{
		//normal = this.vertexArray[i].getNormal();
		//normal.addPoint(this.planeNormal);
		//normal.unitary();
		this.vertexArray[i].setNormal(this.planeNormal.x, this.planeNormal.y, this.planeNormal.z);
	}
};

/**
 * Get the texture coordinate by box projection
 */
Face.prototype.calculateTexCoordsBox = function(texCoordsBoundingBox)
{
	//CODE.boxFace = { "UNKNOWN" : 0, "LEFT" : 1, "RIGHT" : 2, "FRONT" : 3, "REAR"  : 4, "TOP" : 5, "BOTTOM" : 6 };
	// 1rst, must know the bestBoxFaceToProject of this face.
	var normal = this.getPlaneNormal();
	var bestBoxFaceToProject = Face.getBestCubeFaceToProject(normal);
	
	var minX = texCoordsBoundingBox.minX;
	var maxX = texCoordsBoundingBox.maxX;
	var minY = texCoordsBoundingBox.minY;
	var maxY = texCoordsBoundingBox.maxY;
	var minZ = texCoordsBoundingBox.minZ;
	var maxZ = texCoordsBoundingBox.maxZ;
	
	var xRange = maxX - minX;
	var yRange = maxY - minY;
	var zRange = maxZ - minZ;
	
	var vertexCount = this.getVerticesCount();
	
	if (bestBoxFaceToProject === CODE.boxFace.TOP)
	{
		for (var i=0; i<vertexCount; i++)
		{
			var vertex = this.getVertex(i);
			var position = vertex.getPosition();
			var texCoord = vertex.getTexCoord();
			
			var x = position.x;
			var y = position.y;
			var s = (x - minX) / xRange;
			var t = (y - minY) / yRange;

			texCoord.set(s, t);
		}
	}
	else if (bestBoxFaceToProject === CODE.boxFace.BOTTOM)
	{
		for (var i=0; i<vertexCount; i++)
		{
			var vertex = this.getVertex(i);
			var position = vertex.getPosition();
			var texCoord = vertex.getTexCoord();
			
			var x = position.x;
			var y = position.y;
			var s = (x - minX) / xRange;
			var t = (y - minY) / yRange;
			t = 1.0 - t;

			texCoord.set(s, t);
		}
	}
	else if (bestBoxFaceToProject === CODE.boxFace.FRONT)
	{
		for (var i=0; i<vertexCount; i++)
		{
			var vertex = this.getVertex(i);
			var position = vertex.getPosition();
			var texCoord = vertex.getTexCoord();
			
			var x = position.x;
			var z = position.z;
			var s = (x - minX) / xRange;
			var t = (z - minZ) / zRange;

			texCoord.set(s, t);
		}
	}
	else if (bestBoxFaceToProject === CODE.boxFace.REAR)
	{
		for (var i=0; i<vertexCount; i++)
		{
			var vertex = this.getVertex(i);
			var position = vertex.getPosition();
			var texCoord = vertex.getTexCoord();
			
			var x = position.x;
			var z = position.z;
			var s = (x - minX) / xRange;
			var t = (z - minZ) / zRange;
			t = 1.0 - t;

			texCoord.set(s, t);
		}
	}
	else if (bestBoxFaceToProject === CODE.boxFace.LEFT)
	{
		for (var i=0; i<vertexCount; i++)
		{
			var vertex = this.getVertex(i);
			var position = vertex.getPosition();
			var texCoord = vertex.getTexCoord();
			
			var y = position.y;
			var z = position.z;
			var t = (y - minY) / yRange;
			var s = (z - minZ) / zRange;

			texCoord.set(s, t);
		}
	}
	else if (bestBoxFaceToProject === CODE.boxFace.RIGHT)
	{
		for (var i=0; i<vertexCount; i++)
		{
			var vertex = this.getVertex(i);
			var position = vertex.getPosition();
			var texCoord = vertex.getTexCoord();
			
			var y = position.y;
			var z = position.z;
			var t = (y - minY) / yRange;
			var s = (z - minZ) / zRange;
			s = 1.0 - s;

			texCoord.set(s, t);
		}
	}
};

/**
 * 시작점과 끝점이 매우 가까울 경우 (거의 같은, 0.1mm보다 가까울때.) 끝점을 삭제.
 * "Uroborus" is an archaic motif of a snake biting its own tail.
 * "Uroborus"는 뱀이 자기 꼬리 먹고 있는 모양.
 * This function checks if the 1rst vertex & the last vertex are coincident. If are coincident then remove last one.
 * 
 * @see Point3D#isCoincidentToPoint
 */
Face.prototype.solveUroborus = function()
{
	// "Uroborus" is an archaic motif of a snake biting its own tail.
	// This function checks if the 1rst vertex & the last vertex are coincident. If are coincident then remove last one.
	var verticesCount = this.getVerticesCount();
	if (verticesCount < 3)
	{ return; }
	
	var vertex_str = this.getVertex(0);
	var vertex_end = this.getVertex(verticesCount - 1);
	
	var pos_str = vertex_str.point3d;
	var pos_end = vertex_end.point3d;
	var distError = 0.0001; // 0.1mm of error.
	
	if (pos_str.isCoincidentToPoint(pos_end, distError))
	{
		// remove the last vertex.
		this.vertexArray.pop();
	}
};

/**
 * 전체 Face 배열 중 동일한 Face 가 존재하는지를 알려준다.
 *
 */
Face.setTwinsFacesOfArray = function(facesArray)
{
	var face, face2;
	
	var facesCount = facesArray.length;
	for (var i=0; i<facesCount; i++)
	{
		face = facesArray[i];
		for (var j=i+1; j<facesCount; j++)
		{
			if (i !== j)
			{
				face2 = facesArray[j];
				face.setTwinFace(face2);
			}
		}
	}
};

/**
 * 표출하기 위해 최적의 plane 타입을 반환.
 * @static
 * @param {Point3D} normal
 * @returns {Number} 0 : plane-xy, 1 : plane-yz, 2: plane-xz
 */
Face.getBestFacePlaneToProject = function(normal)
{
	var best_plane = -1; //"unknown";

	var nx = Math.abs(normal.x);
	var ny = Math.abs(normal.y);
	var nz = Math.abs(normal.z);

	if ( nz > nx && nz >= ny )
 	{
 		best_plane = 0; //"xy";
 	}
 	else if ( nx >= ny && nx >= nz )
 	{
 		best_plane = 1; //"yz";
 	}
 	else if ( ny > nx && ny >= nz )
 	{
 		best_plane = 2; //"xz";
	}

	return best_plane;
};

Face.getBestCubeFaceToProject = function(normal)
{
	var cubeface = CODE.boxFace.UNKNOWN;
	var bestFacePlane = Face.getBestFacePlaneToProject(normal);

	if (bestFacePlane === 0) // xy.
	{
		// TOP or BOTTOM.***
		var nz = normal.z;
		if (nz > 0.0){ cubeface = CODE.boxFace.TOP; }
		else { cubeface = CODE.boxFace.BOTTOM; }
	}
	else if (bestFacePlane === 1) // yz.
	{
		// LEFT or RIGHT.***
		var nx = normal.x;
		if (nx > 0.0){ cubeface = CODE.boxFace.RIGHT; }
		else { cubeface = CODE.boxFace.LEFT; }
	}
	else if (bestFacePlane === 2) // xz.
	{
		// FRONT or REAR.***
		var ny = normal.y;
		if (ny > 0.0){ cubeface = CODE.boxFace.REAR; }
		else { cubeface = CODE.boxFace.FRONT; }
	}

	return cubeface;
};


/**
 * 버텍스 배열을 plane normal에 따라 polygon2d 형식으로 변환 후 반환.
 * @static
 * @param {Array.<Vertex>} vertexArray
 * @param {Point3D} normal
 * @param {Polygon2D} resultProjectedPolygon2d
 * @returns {Polygon2D}
 */
Face.getProjectedPolygon2D = function(vertexArray, normal, resultProjectedPolygon2d)
{
	// Create a temp polygon2d.
	if (resultProjectedPolygon2d === undefined)
	{ resultProjectedPolygon2d = new Polygon2D(); }
	
	if (resultProjectedPolygon2d.point2dList === undefined)
	{ resultProjectedPolygon2d.point2dList = new Point2DList(); }

	var point2dList = resultProjectedPolygon2d.point2dList;
	point2dList.pointsArray =  VertexList.getProjectedPoints2DArray(vertexArray, normal, point2dList.pointsArray);

	return resultProjectedPolygon2d;
};

/**
 * 오목 폴리곤들을 볼록 폴리곤들로 분리 후 반환.
 * concave to convex list.
 * @param {Array.<Triangle>} resultTrianglesArray
 * @returns {Array.<Triangle>}
 */
Face.prototype.getTessellatedTriangles = function(resultTrianglesArray)
{
	if (resultTrianglesArray === undefined)
	{ resultTrianglesArray = []; }

	var verticesCount = this.getVerticesCount();
	if (verticesCount <= 3)
	{
		// This is a triangle, so no need to tessellate.
		resultTrianglesArray = this.getTrianglesConvex(resultTrianglesArray);
		return resultTrianglesArray;
	}

	// 1rst, must project the face to a plane and process to tessellate in 2d.
	var normal = this.getPlaneNormal();

	// Create a temp polygon2d.
	var polygon2d = Face.getProjectedPolygon2D(this.vertexArray, normal, undefined);
	
	// Now, tessellate the polygon2D.
	// Before tessellate, we must know if there are concavePoints.
	var resultConcavePointsIdxArray;
	resultConcavePointsIdxArray = polygon2d.calculateNormal(resultConcavePointsIdxArray);
	
	var convexPolygonsArray = [];
	polygon2d.tessellate(resultConcavePointsIdxArray, convexPolygonsArray);
	
	// inside of "convexPolygonsArray" there are 1 or more convexPolygons result of tessellation of the polygon2d.

	this.calculateVerticesNormals();
	var convexPolygonsCount = convexPolygonsArray.length;
	for (var i=0; i<convexPolygonsCount; i++)
	{
		var convexPolygon = convexPolygonsArray[i];
		
		if (convexPolygon.point2dList.getPointsCount() === 0)
		{ continue; }
		
		var vertex0, vertex1, vertex2;
		var triangle;
		var point2d_0, point2d_1, point2d_2;
		var point2d_0 = convexPolygon.point2dList.getPoint(0);
		
		vertex0 = point2d_0.ownerVertex3d;
		var point2dCount = convexPolygon.point2dList.getPointsCount();
		for (var j=1; j<point2dCount-1; j++)
		{
			point2d_1 = convexPolygon.point2dList.getPoint(j);
			point2d_2 = convexPolygon.point2dList.getPoint(j+1);
			vertex1 = point2d_1.ownerVertex3d;
			vertex2 = point2d_2.ownerVertex3d;
			triangle = new Triangle(vertex0, vertex1, vertex2);
			
			resultTrianglesArray.push(triangle);
		}
	}
	//this.calculateVerticesNormals();
	return resultTrianglesArray;
};

/**
 * 버텍스 배열의 첫번째 배열을 기준으로 삼각형 convex(Triangle)을 생성 후 배열에 담아 반환
 * @param {Array.<Triangle>} resultTrianglesArray undefined일 때, 배열로 초기화.
 * @returns {Array.<Triangle>|undefined} 기존 버텍스 배열이 undefined거나 비어있으면 매개변수 resultTrianglesArray 상태 그대로 반환.
 */
Face.prototype.getTrianglesConvex = function(resultTrianglesArray)
{
	// To call this method, the face MUST be convex.
	// To call this method, the face MUST be convex.
	if (this.vertexArray === undefined || this.vertexArray.length === 0)
	{ return resultTrianglesArray; }
	
	if (resultTrianglesArray === undefined)
	{ resultTrianglesArray = []; }
	
	var vertex0, vertex1, vertex2;
	var triangle;
	vertex0 = this.getVertex(0);
	var verticesCount = this.getVerticesCount();
	for (var i=1; i<verticesCount-1; i++)
	{
		vertex1 = this.getVertex(i);
		vertex2 = this.getVertex(i+1);
		triangle = new Triangle(vertex0, vertex1, vertex2);
		resultTrianglesArray.push(triangle);
	}
	
	return resultTrianglesArray;
};

/**
 * Face의 hedge 중 매개변수 hedge와 twin인 것이 있는지 유무 반환.
 * @param {HalfEdge} hedge 
 * @returns {Boolean}
 * 
 * @see HalfEdge#setTwin
 */
Face.prototype.setTwinHalfEdge = function(hedge)
{
	var twined = false;
	var finished = false;
	var startHEdge = this.hEdge;
	var currHEdge = this.hEdge;
	while (!finished)
	{
		if (currHEdge.setTwin(hedge))
		{ return true; }

		currHEdge = currHEdge.next;
		if (currHEdge === startHEdge)
		{ finished = true; }
	}
	return twined;
};

/**
 * Face의 frontier hedge 배열 반환.
 * @param {Array.<HalfEdge>} resultHedgesArray 
 * @returns {Array.<HalfEdge>}
 * 
 * @see HalfEdge#getHalfEdgesLoop
 * @see HalfEdge#isFrontier
 */
Face.prototype.getFrontierHalfEdges = function(resultHedgesArray)
{
	var hedgesArray = this.getHalfEdgesLoop(undefined);
	if (hedgesArray === undefined)
	{ return resultHedgesArray; }
	
	if (resultHedgesArray === undefined)
	{ resultHedgesArray = []; }

	var hedgesCount = hedgesArray.length;
	var hedge;
	for (var i=0; i<hedgesCount; i++)
	{
		hedge = hedgesArray[i];
		if (hedge.isFrontier())
		{
			resultHedgesArray.push(hedge);
		}
	}
	return resultHedgesArray;
};

/**
 * Face의 hedge 배열 반환.
 * @param {Array.<HalfEdge>} resultHedgesArray 
 * @returns {Array.<HalfEdge>}
 * 
 * @see HalfEdge#getHalfEdgesLoop
 */
Face.prototype.getHalfEdgesLoop = function(resultHedgesArray)
{
	if (this.hEdge === undefined)
	{ return resultHedgesArray; }
	
	resultHedgesArray = HalfEdge.getHalfEdgesLoop(this.hEdge, resultHedgesArray);
	return resultHedgesArray;
};

/**
 * 현재 Face와 매개변수 Face의 각각 hedge를 이용하여 twin hedge를 찾아서 twin 유무 반환
 * @param {Face} face Required. Must contain hEdge.
 * @returns {Boolean} is twin face.
 */
Face.prototype.setTwinFace = function(face)
{
	if (face === undefined)
	{ return false; }
	
	if (this.hEdge === undefined || face.hEdge === undefined)
	{ return false; }
	
	var hedgesArray = face.getHalfEdgesLoop(undefined);
	var hedgesCount = hedgesArray.length;
	var hedge;
	var twined = false;
	for (var i=0; i<hedgesCount; i++)
	{
		hedge = hedgesArray[i];
		if (this.setTwinHalfEdge(hedge))
		{ twined = true; }
	}
	
	return twined;
};

/**
 * 버텍스 배열의 각각 버텍스의 hedge를 설정(next hedge도 설정) 후 배열에 담아서 반환. 
 * 반환배열의 첫번째 요소(HalfEdge, resultHalfEdgesArray[0])는 this.hEdge로 설정
 * @param {Array.<HalfEdge>|undefined} resultHalfEdgesArray
 * @returns {Array.<HalfEdge>}
 */
Face.prototype.createHalfEdges = function(resultHalfEdgesArray)
{
	if (this.vertexArray === undefined || this.vertexArray.length === 0)
	{ return resultHalfEdgesArray; }
	
	if (resultHalfEdgesArray === undefined)
	{ resultHalfEdgesArray = []; }
	
	var vertex;
	var hedge;
	var verticesCount = this.getVerticesCount();
	
	// 1rst, create the half edges.
	for (var i=0; i<verticesCount; i++)
	{
		vertex = this.getVertex(i);
		hedge = new HalfEdge();
		hedge.setStartVertex(vertex);
		hedge.setFace(this);
		resultHalfEdgesArray.push(hedge);
	}
	
	// now, for all half edges, set the nextHalfEdge.
	var nextHedge;
	var nextIdx;
	for (var i=0; i<verticesCount; i++)
	{
		hedge = resultHalfEdgesArray[i];
		nextIdx = VertexList.getNextIdx(i, this.vertexArray);
		nextHedge = resultHalfEdgesArray[nextIdx];
		hedge.setNext(nextHedge);
	}
	
	// set a hedge for this face.
	this.hEdge = resultHalfEdgesArray[0];
	
	return resultHalfEdgesArray;
};






















































'use strict';

/**
 * 특정 버텍스로 부터의 방향을 가진 테두리. 
 * 트윈과 넥스트를 함께 가지는 구조로 이뤄져있음.
 * 트윈은 해당 테두리의 반대 방향 테두리.
 * 넥스트는 현재 테두리의 다음 테두리. 방향은 같음.
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class HalfEdge
 */
var HalfEdge = function() 
{
	if (!(this instanceof HalfEdge)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * start vertex of this edge.
	 * @type {Vertex}
	 */
	this.startVertex;

	/**
	 * next edge of this edge.
	 * @type {HalfEdge}
	 */
	this.next;

	/**
	 * opposite direction edge of this edge.
	 * @type {HalfEdge}
	 */
	this.twin;

	/**
	 * the face of include this edge.
	 * @type {Face}
	 */
	this.face;
};

/**
 * delete all member.
 * Note: "HalfEdge" is NO-Owner of the contents, so, don't delete contents. Only set as "undefined".|
 */
HalfEdge.prototype.deleteObjects = function()
{
	this.startVertex = undefined;
	this.next = undefined;
	this.twin = undefined;
	this.face = undefined;
};

/**
 * set start vertex. this vertex's outingHedge set this edge.
 * @param {Vetex}
 */
HalfEdge.prototype.setStartVertex = function(vertex)
{
	this.startVertex = vertex;
	vertex.outingHedge = this;
};

/**
 * set next hedge
 * @param {HalfEdge}
 */
HalfEdge.prototype.setNext = function(hedge)
{
	this.next = hedge;
};

/**
 * if this param hedge is twinable this hedge, set twin hedge.
 * if twinable, param hedge.twin set this hedge.
 * @param {HalfEdge}
 * 
 * @see HalfEdge#areTwinables
 */
HalfEdge.prototype.setTwin = function(hedge)
{
	var isTwinable = HalfEdge.areTwinables(hedge, this);
	if (isTwinable)
	{
		this.twin = hedge;
		hedge.twin = this;
	}
	return isTwinable;
};

/**
 * set Face.
 * @param {Face}
 */
HalfEdge.prototype.setFace = function(face)
{
	this.face = face;
	this.face.hEdge = this;
};

/**
 * get segment3d.
 * @returns {Segment3D} if this next is undefined, can't get end vertex. so return undefined.
 */
HalfEdge.prototype.getSegment3d = function()
{
	if (this.next === undefined)
	{ return undefined; }

	var strPoint3d = this.getStartVertex().getPosition();
	var endPoint3d = this.getEndVertex().getPosition();
	var segment3d = new Segment3D(strPoint3d, endPoint3d);
	return segment3d;
};

/**
 * get start vertex.
 * @returns {Vertex|undefined} .
 */
HalfEdge.prototype.getStartVertex = function()
{
	return this.startVertex;
};

/**
 * get end vertex.
 * @returns {Vertex|undefined} if this next is undefined, can't get end vertex. so return undefined.
 */
HalfEdge.prototype.getEndVertex = function()
{
	if (this.next === undefined)
	{ return undefined; }
	
	return this.next.startVertex;
};

/**
 * is this hedge frontier?
 * @returns {Boolean} if this twin is undefined or null, return true;
 */
HalfEdge.prototype.isFrontier = function()
{
	if (this.twin === undefined || this.twin === null)
	{ return true; }
	
	return false;
};

/**
 * get prev hedge.
 * half edge의 next를 계속 찾아서 현재 edge와 특정 테두리의 next가 일치할때 특정테두리를 반환.
 * @returns {HalfEdge|undefined}  if next is not define, return undefined.
 */
HalfEdge.prototype.getPrev = function()
{
	var currHedge = this;
	var prevHedge;
	var finished = false;
	while (!finished)
	{
		/**
		 * @todo check this compare is possible.
		 */
		if (currHedge.next === this)
		{ return currHedge; }
		
		if (currHedge.next === undefined)
		{ return undefined; }
		
		currHedge = currHedge.next;
	}
	
	return undefined;
};

/**
 * This function returns the outingFrontierHedge of the "endVertex".
 * @returns {HalfEdge|undefined}  next frontier hedge.
 */
HalfEdge.prototype.getNextFrontier = function()
{
	var endVertex = this.getEndVertex();
	return endVertex.getOutingFrontierHEdge();
};

/**
 * 매개변수로 받은 두 edge가 서로 twinable한 상황인지 체크.
 * @static
 * @param {HalfEdge} hedgeA
 * @param {HalfEdge} hedgeB
 * @returns {Boolean}  각각의 시작 vertex와 마지막 vertex가 동일한지 비교하여 둘다 동일 할 경우 true 반환.
 */
HalfEdge.areTwinables = function(hedgeA, hedgeB)
{
	// check if "hedgeA" is twinable with "hedgeB".
	if (hedgeA.startVertex === hedgeB.getEndVertex())
	{
		if (hedgeA.getEndVertex() === hedgeB.startVertex)
		{ return true; }
	}
	
	return false;
};

/**
 * 연결된 테두리들을 찾아 배열로 반환.
 * @static
 * @param {HalfEdge} hedge Required. if undefined, return original resultHedgesArray.
 * @param {Array|undefined} resultHedgesArray
 * @returns {Array.<HalfEdge>}
 */
HalfEdge.getHalfEdgesLoop = function(hedge, resultHedgesArray)
{
	if (hedge === undefined)
	{ return resultHedgesArray; }
	
	if (resultHedgesArray === undefined)
	{ resultHedgesArray = []; }
	
	resultHedgesArray.length = 0; // init the array.
	
	var startHedge = hedge;
	var currHedge = hedge;
	var finished = false;
	while (!finished)
	{
		resultHedgesArray.push(currHedge);
		currHedge = currHedge.next;
		if (currHedge === startHedge || currHedge === undefined)
		{ finished = true; }
	}
	
	return resultHedgesArray;
};

'use strict';

/**
 * HalfEdge객체의 리스트
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class HalfEdgesList
 */
var HalfEdgesList = function() 
{
	if (!(this instanceof HalfEdgesList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * @type {Array.<HalfEdge>}
	 */
	this.hEdgesArray;
};

/**
 * hEdgesArray 초기화
 */
HalfEdgesList.getSegment3dsFromHedgesArray = function(hedgesArray, resultSegments3dArray)
{
	var hedgesCount = hedgesArray.length;
	if (hedgesCount === 0)
	{ return resultSegments3dArray; }
	
	if (resultSegments3dArray === undefined)
	{ resultSegments3dArray = []; }
	
	for (var i=0; i<hedgesCount; i++)
	{
		resultSegments3dArray.push(hedgesArray[i].getSegment3d());
	}
	
	return resultSegments3dArray;
};

/**
 * hEdgesArray 초기화
 */
HalfEdgesList.prototype.deleteObjects = function()
{
	if (this.hEdgesArray !== undefined)
	{
		var hedgesCount = this.hEdgesArray.length;
		for (var i=0; i<hedgesCount; i++)
		{
			this.hEdgesArray[i].deleteObjects();
			this.hEdgesArray[i] = undefined;
		}
		this.hEdgesArray = undefined;
	}
};

/**
 * 새로 HalfEdge 인스턴스를 생성하여 hEdgesArray에 추가한다.
 * @returns {HalfEdge} 새로 생성된 HalfEdge인스턴스를 반환.
 */
HalfEdgesList.prototype.newHalfEdge = function()
{
	if (this.hEdgesArray === undefined)
	{ this.hEdgesArray = []; }
	
	var hedge = new HalfEdge();
	this.hEdgesArray.push(hedge);
	return hedge;
};

/**
 * 기존 멤버 변수 hEdgesArray에 HalfEdge들을 추가.
 * @param {Array.<HalfEdge>} HalfEdge Required. HalfEdge들의 배열
 */
HalfEdgesList.prototype.addHalfEdgesArray = function(hEdgesArray)
{
	if (hEdgesArray === undefined)
	{ return; }
	
	if (this.hEdgesArray === undefined)
	{ this.hEdgesArray = []; }
	
	Array.prototype.push.apply(this.hEdgesArray, hEdgesArray);
};
'use strict';
/**
* 폴리곤을 구성하는 포인트의 인덱스데이터 객체
* Rind2D의 getPolygon 수행 시 인스턴스를 생성하여 각 포인트에 설정함.
* owner는 Ring2D instance로 설정.
*
* @exception {Error} Messages.CONSTRUCT_ERROR
* @class IndexData
*
* @see Ring2D#getPolygon
*/
var IndexData = function() 
{
	if (!(this instanceof IndexData)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * 포인트를 포함하는 Ring2D 객체
	 * @type {Ring2D}
	 */
	this.owner;

	/**
	 * 포인트의 idxInList
	 * @deprecated idx 대신 idxInList로 사용되고 있음. 변경 필요
	 * @type {Number}
	 */
	this.idx;
};

/**
 * delete the value of owner and idx.
 */
IndexData.prototype.deleteObjects = function() 
{
	// Don't delete objects. Only assign as undefined.
	this.owner = undefined;
	this.idx = undefined;
};
'use strict';

/**
 * index range. consist of two vertex index. start and end.
 * 특정 geometry의 시작vertex와 끝vertex의 index를 저장
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class IndexRange
 */
var IndexRange = function() 
{
	if (!(this instanceof IndexRange)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	/**
	 * start index
	 * @type {Number}
	 */
	this.strIdx;

	/**
	 * last index
	 * @type {Number}
	 */
	this.endIdx;
};

/**
 * make indexRange copy from another indexRange.
 * @param {IndexRange} indexRange 
 */
IndexRange.prototype.copyFrom = function(indexRange)
{
	if (indexRange === undefined)
	{ return; }
	
	this.strIdx = indexRange.strIdx;
	this.endIdx = indexRange.endIdx;
};

/**
 * indexRange init.
 * all member set undifined;
 */
IndexRange.prototype.deleteObjects = function()
{
	this.strIdx = undefined;
	this.endIdx = undefined;
};
'use strict';
/**
 * 교차 판단값
 * 한 객체가 다른 한 객체에 완전히 안쪽에 포함된 경우: INSIDE
 * 한 객체가 다른 한 객체에 일부는 안쪽에 포함되고 일부는 바깥쪽에 포함된 경우: INTERSECT
 * 한 객체가 다른 한 객체에 완전히 바깥쪽에 있는 경우: OUTSIDE
 * A 지점에 포함된 경우: POINT_A
 * B 지점에 포함된 경우: POINT_B
 * 
 * @enum
 */
var Intersect = {
	/**
     * 한 객체가 다른 한 객체에 완전히 바깥쪽에 존재함
     * @type {Number}
     * @constant
     */
	OUTSIDE: 0,
    
	/**
     * 한 객체가 다른 한 객체의 일부분만 포함
     * @type {Number}
     * @constant
     */
	INTERSECT: 1,
    
	/**
     * 한 객체가 다른 한 객체를 완전히 포함
     * @type {Number}
     * @constant
     */
	INSIDE: 2,
    
	/**
     * A 지점에 포함
     * @type {Number}
     * @constant
     */
	POINT_A: 3,
    
	/**
     * B 지점에 포함
     * @type {Number}
     * @constant
     */
	POINT_B: 4
};
'use strict';

/**
 * This represents a line which can be shown as linear equation
 * @class Line
 * @param {Point3D} point the point which decides line
 * @param {Point3D} direction the vector of the direction which decides line
 */
var Line = function(point, direction) 
{
	if (!(this instanceof Line)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	// (x,y,z) = (x0,y0,z0) + lambda * (u, v, w);
	if (point !== undefined)
	{ this.point = point; }
	else
	{ this.point = new Point3D(); }
	
	if (direction !== undefined)
	{ this.direction = direction; }
	else
	{ this.direction = new Point3D(); }
};

/**
 * Set a point and a direction of a linear equation
 * @param px 변수 the value of x coordi of the point
 * @param py 변수 the value of y coordi of the point
 * @param pz 변수 the value of z coordi of the point
 * @param dx 변수 the value of x coordi of the point which represents direction
 * @param dy 변수 the value of y coordi of the point which represents direction
 * @param dz 변수 the value of z coordi of the point which represents direction
 */
Line.prototype.setPointAndDir = function(px, py, pz, dx, dy, dz) 
{
	// Note: dx, dy, dz must be unitary.
	this.point.set(px, py, pz);
	this.direction.set(dx, dy, dz);
	this.direction.unitary();
};

/**
 * get the point which is projected as 2d plane(the plane which is represented by using x,y axis)
 * @param point the target point 
 * @param projectedPoint the projected point of the target point
 * @returns projetedPoint
 */
Line.prototype.getProjectedPoint = function(point, projectedPoint) 
{
	if (projectedPoint === undefined)
	{ projectedPoint = new Point3D(); }
	
	var plane = new Plane();
	plane.setPointAndNormal(point.x, point.y, point.z, this.direction.x, this.direction.y, this.direction.z);
	projectedPoint = plane.intersectionLine(this, projectedPoint);
	
	return projectedPoint;
};

/**
 * Check whether the given point is on this line or not
 * @param {Point3D} point the given point
 * @param {Number} error the error rate which can be handdled
 * @returns {Boolean} 
 */
Line.prototype.isCoincidentPoint = function(point, error) 
{
	if (point === undefined)
	{ return false; }
	
	var projectedPoint = this.getProjectedPoint(point);
	
	if (projectedPoint === undefined)
	{ return false; }
	
	if (error === undefined)
	{ error = 10E-8; }
	
	var squaredDist = projectedPoint.squareDistToPoint(point);
	
	if (squaredDist < error*error)
	{ return true; }
	
	return false;
};


















































'use strict';

/**
 * 선
 * @class Line2D
 */
var Line2D = function() 
{
	if (!(this instanceof Line2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	// (x,y) = (x0,y0) + lambda * (u, v);
	this.point = new Point2D();
	this.direction = new Point2D();
};

/**
 * set the needed value of this line with a point and a direction value
 * @param px the value of x coordi of this line
 * @param py the value of y coordi of this line
 * @param dx the value of x direction of this line
 * @param dy the value of y direction of this line
 */
Line2D.prototype.setPointAndDir = function(px, py, dx, dy) 
{
	this.point.set(px, py);
	this.direction.set(dx, dy);
	this.direction.unitary();
};

/**
 * @param point2d 
 */
Line2D.prototype.distToPoint = function(point2d) 
{
	var projectedPoint = this.getProjectedPoint(point2d);
	var dist = point2d.distToPoint(projectedPoint);

	return dist;
};

/** 
 * Get the perpendicular direction of the line in right-handed coordinate system
 * @param {Point2D} point target point
 * @returns {Line2D} perpendicular the perpendicular direction 
 */
Line2D.prototype.getPerpendicularRight = function(point) 
{
	var perpendicular = new Line2D();
	
	if (point)
	{ perpendicular.point.set(point.x, point.y); }
	else
	{ perpendicular.point.set(this.point.x, this.point.y); }
	
	perpendicular.direction.set(this.direction.y, -this.direction.x);
	return perpendicular;
};

/** 
 * Get a parallel line, in the right side, separated a dist.
 * @param {Number} dist Distance 
 * @returns {Line2D} Parallel line.
 */
Line2D.prototype.getParallelRight = function(dist) 
{
	var perpendicularRight = this.getPerpendicularRight();
	var perpendicularDir = perpendicularRight.direction;
	
	var parallelRight = new Line2D();
	var point = parallelRight.point;
	point.set(this.point.x + perpendicularDir.x*dist, this.point.y + perpendicularDir.y*dist);
	parallelRight.direction.copyFrom(this.direction);
	return parallelRight;
};

/** 
 * Get a parallel line, in the left side, separated a dist.
 * @param {Number} dist Distance 
 * @returns {Line2D} Parallel line.
 */
Line2D.prototype.getParallelLeft = function(dist) 
{
	var perpendicularLeft = this.getPerpendicularLeft();
	var perpendicularDir = perpendicularLeft.direction;
	
	var parallelLeft = new Line2D();
	var point = parallelLeft.point;
	point.set(this.point.x + perpendicularDir.x*dist, this.point.y + perpendicularDir.y*dist);
	parallelLeft.direction.copyFrom(this.direction);
	return parallelLeft;
};

/**
 * Get the perpendicular direction of the line in left-handed coordinate system
 * @param {Point2D} pointt target point
 * @returns {Line2D} perpendicular the perpendicular direction 
 */
Line2D.prototype.getPerpendicularLeft = function(point) 
{
	var perpendicular = new Line2D();
	
	if (point)
	{ perpendicular.point.set(point.x, point.y); }
	else
	{ perpendicular.point.set(this.point.x, this.point.y); }
	
	perpendicular.direction.set(-this.direction.y, this.direction.x);
	return perpendicular;
};

/**
 * Get the perpendicular direction of the line in left-handed coordinate system
 * @param {Point2D} point target point
 * @param {number} error 
 * @returns {number} CODE relativePosition2D
 */
Line2D.prototype.getRelativeSideOfPoint = function(point, error) 
{
	if (error === undefined)
	{ error = 10E-8; }

	var projectPoint = this.getProjectedPoint(point);

	var squaredDist = point.squareDistToPoint(projectPoint);
	
	if (squaredDist < error*error)
	{ return CODE.relativePosition2D.COINCIDENT; }

	var vector = new Point2D(point.x - projectPoint.x, point.y - projectPoint.y);
	vector.unitary();

	if ((Math.abs(vector.x-this.direction.y) < error) && (Math.abs(vector.y+this.direction.x) < error)) 
	{
		return CODE.relativePosition2D.RIGHT;
	}
	else 
	{
		return CODE.relativePosition2D.LEFT;
	}

	return CODE.relativePosition2D.UNKNOWN;
};

/**
 * Return the point which is projected as perpendicular way to the line
 * @param {Point2D} point the given point
 * @param {Point2D} projectedPoint the result of the projection to the line
 * @returns {Point2D} projectedPoint
 * 
 */
Line2D.prototype.getProjectedPoint = function(point, projectedPoint) 
{
	if (point === undefined)
	{ return undefined; }
	
	if (projectedPoint === undefined)
	{ projectedPoint = new Point2D(); }
	
	var perpendicular = this.getPerpendicularLeft(point);
	projectedPoint = this.intersectionWithLine(perpendicular, projectedPoint);
	
	return projectedPoint;
};

/**
 * Check whether the given point is on this line or not
 * @param {Point2D} point the given point
 * @param {Number} error the error rate which can be handdled
 * @returns {Boolean} 
 */
Line2D.prototype.isCoincidentPoint = function(point, error) 
{
	if (point === undefined)
	{ return false; }
	
	if (error === undefined)
	{ error = 10E-8; }
	
	var projectedPoint = this.getProjectedPoint(point, projectedPoint);
	var squaredDist = point.squareDistToPoint(projectedPoint);
	
	if (squaredDist < error*error)
	{ return true; }

	return false;
};

/**
 * Check whether the given line is parallel to this line or not
 * @param {Line2D} line
 * @returns {Boolean}
 */
Line2D.prototype.isParallelToLine = function(line) 
{
	if (line === undefined)
	{ return false; }
	
	var zero = 10E-10;
	var angRad = this.direction.angleRadToVector(line.direction);
	
	// if angle is zero or 180 degree, then this is parallel to "line".
	if (angRad < zero || Math.abs(angRad - Math.PI) < zero)
	{ return true; }
	
	return false;
};

/**
 * Get the intersection point with given line
 * @param {Line2D} line
 * @param {Point2D} resultIntersectPoint
 * @returns {Point2D} resultIntersectPoint
 */
Line2D.prototype.intersectionWithLine = function(line, resultIntersectPoint) 
{
	if (line === undefined)
	{ return undefined; }
	
	// 1rst, check that this is not parallel to "line".
	if (this.isParallelToLine(line))
	{ return undefined; }
	
	// now, check if this or "line" are vertical or horizontal.
	var intersectX;
	var intersectY;
	
	var zero = 10E-10;
	if (Math.abs(this.direction.x) < zero)
	{
		// this is a vertical line.
		var slope = line.direction.y / line.direction.x;
		var b = line.point.y - slope * line.point.x;
		
		intersectX = this.point.x;
		intersectY = slope * this.point.x + b;
	}
	else if (Math.abs(this.direction.y) < zero)
	{
		// this is a horizontal line.
		// must check if the "line" is vertical.
		if (Math.abs(line.direction.x) < zero)
		{
			// "line" is vertical.
			intersectX = line.point.x;
			intersectY = this.point.y;
		}
		else 
		{
			var slope = line.direction.y / line.direction.x;
			var b = line.point.y - slope * line.point.x;
			
			intersectX = (this.point.y - b)/slope;
			intersectY = this.point.y;
		}	
	}
	else 
	{
		// this is oblique.
		if (Math.abs(line.direction.x) < zero)
		{
			// "line" is vertical.
			var mySlope = this.direction.y / this.direction.x;
			var myB = this.point.y - mySlope * this.point.x;
			intersectX = line.point.x;
			intersectY = intersectX * mySlope + myB;
		}
		else 
		{
			var mySlope = this.direction.y / this.direction.x;
			var myB = this.point.y - mySlope * this.point.x;
			
			var slope = line.direction.y / line.direction.x;
			var b = line.point.y - slope * line.point.x;
			
			intersectX = (myB - b)/ (slope - mySlope);
			intersectY = slope * intersectX + b;
		}
	}
	
	if (resultIntersectPoint === undefined)
	{ resultIntersectPoint = new Point2D(); }
	
	resultIntersectPoint.set(intersectX, intersectY);
	return resultIntersectPoint;
};















































'use strict';


/**
 * Under implementation
 * @class MagoNativeProject
 */
var MagoNativeProject = function() 
{
	if (!(this instanceof MagoNativeProject)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	// This is a "ParametricMeshes" composition.
	this.meshesArray;
	this.geoLocDataManager;
	this.vboKeysContainer; // class: VBOVertexIdxCacheKeysContainer
};

MagoNativeProject.prototype.newParametricMesh = function()
{
	if (this.meshesArray === undefined)
	{ this.meshesArray = []; }
	
	var parametricMesh = new ParametricMesh();
	this.meshesArray.push(parametricMesh);
	return parametricMesh;
};

MagoNativeProject.prototype.deleteObjects = function()
{
	if (this.meshesArray === undefined)
	{ return; }
	
	var parametricMeshesCount = this.meshesArray.length;
	for (var i=0; i<parametricMeshesCount; i++)
	{
		this.meshesArray[i].deleteObjects();
		this.meshesArray[i] = undefined;
	}
	this.meshesArray = undefined;
	
	if (this.geoLocDataManager)
	{ this.geoLocDataManager.deleteObjects(); }
	
	this.geoLocDataManager = undefined;
};

MagoNativeProject.prototype.getMeshesCount = function()
{
	if (this.meshesArray === undefined)
	{ return 0; }
	
	return this.meshesArray.length;
};

MagoNativeProject.prototype.getMesh = function(idx)
{
	if (this.meshesArray === undefined)
	{ return undefined; }
	
	return this.meshesArray[idx];
};

















































'use strict';

/**
 * Under implementation
 * Top class on Mago3D.
 * Handling mouse event and send it to MouseAction
 * @class MagoWorld
 * @param {MagoManager} magoManager
 */
var MagoWorld = function(magoManager) 
{
	if (!(this instanceof MagoWorld)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.magoManager = magoManager;
	
	// Set the start position of the camera.***
	/*
	var camera = this.magoManager.sceneState.camera;
	var rotMat = new Matrix4();
	var angRad = 45 * Math.PI/180;
	var rotAxis = new Point3D();
	rotAxis.set(1, 0, 1);
	rotAxis.unitary();
	rotMat.rotationAxisAngRad(angRad, rotAxis.x, rotAxis.y, rotAxis.z);
	camera.transformByMatrix4(rotMat);

	this.updateModelViewMatrixByCamera(camera);
	*/
};

/**
 * 시각화 준비 함수
 */
MagoWorld.prototype.prepareVisibles = function()
{
	// 1rst, do terrain frustum culling.
	// TODO:
};

/**
 * 첫 번째 시야를 그릴 준비
 */
MagoWorld.prototype.renderScene = function()
{
	//this.renderTest();
	var gl = this.magoManager.sceneState.gl;
	//gl.clearColor(0, 0, 0, 1);
	gl.enable(gl.DEPTH_TEST);
	gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	
	this.magoManager.start(undefined, true, 0, 1);
};

/**
 * 첫 번째 시야를 그릴 준비
 * @TODO : 리팩토링 필요
 */
MagoWorld.prototype.renderTest = function()
{
	var gl = this.magoManager.sceneState.gl;
	gl.clearColor(0.0, 0.0, 0.0, 1.0);
	gl.enable(gl.DEPTH_TEST);
	gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	
	this.magoManager.start(undefined, true, 0, 1);
	
};

/**
 * 카메라를 지구의 특정 위치에 위치시키는 함수
 * @param {Number} longitude 
 * @param {Number} latitude
 * @param {Number} altitude 
 */
MagoWorld.prototype.goto = function(longitude, latitude, altitude)
{
	var resultCartesian;
	resultCartesian = Globe.geographicToCartesianWgs84(longitude, latitude, altitude, resultCartesian);
	
	var camera = this.magoManager.sceneState.camera;
	var camPos = camera.position;
	
	// Make an animationData.***
	// Make 3 points & then make a bSpline.***
	var bStoreAbsolutePosition = false;
	var currGeoCoord = Globe.CartesianToGeographicWgs84(camPos.x, camPos.y, camPos.z, undefined, bStoreAbsolutePosition);
	var targetGeoCoord = new GeographicCoord(longitude, latitude, altitude);
	var midGeoCoord = GeographicCoord.getMidPoint(currGeoCoord, targetGeoCoord, undefined);
	
	// For the "midGeoCoord", increment the altitude a little, to fly like bouncing.***
	var angleDistDeg = GeographicCoord.getAngleBetweenCoords(currGeoCoord, targetGeoCoord);
	if (midGeoCoord.altitude < 30000.0 * angleDistDeg)
	{ midGeoCoord.altitude = 30000.0 * angleDistDeg; }
	
	var bSpline = new BSplineCubic3D();
	var geoCoordsList = bSpline.getGeographicCoordsList();
	geoCoordsList.addGeoCoordsArray([currGeoCoord, midGeoCoord, targetGeoCoord]);
	
	//var path = new Path3D([currGeoCoord, midGeoCoord, targetGeoCoord]);
	
	var animData = {animationType: CODE.animationType.PATH};
	animData.path = bSpline;
	animData.birthTime = this.magoManager.getCurrentTime();
	animData.linearVelocityInMetersSecond = 500000.0; // m/s.***
	animData.acceleration = 2000.0; // m/s2.***
	animData.durationInSeconds = 2.0;
	camera.animationData = animData;
	
	if (this.magoManager.animationManager === undefined)
	{ this.magoManager.animationManager = new AnimationManager(); }

	this.magoManager.animationManager.putObject(camera);
	/*
	//----------------------------------------------------------------------------------------------
	var camDir = camera.direction;
	var camUp = camera.up;
	
	var matrixAux;
	matrixAux = this.magoManager.globe.transformMatrixAtCartesianPointWgs84(resultCartesian[0], resultCartesian[1], resultCartesian[2], matrixAux);
	
	camPos.set(resultCartesian[0], resultCartesian[1], resultCartesian[2]);
	
	// calculate camDir & camUp.
	camDir.set(-matrixAux[8], -matrixAux[9], -matrixAux[10]);
	camUp.set(matrixAux[4], matrixAux[5], matrixAux[6]); // tangent north direction.
	
	this.updateModelViewMatrixByCamera(camera);
	*/
};

/**
 * 마우스 꾹 누르는 동작을 핸들링
 * @param {type}event 
 */
MagoWorld.prototype.mousedown = function(event)
{
	this.magoManager.sceneState.mouseButton = event.button;
	MagoWorld.updateMouseStartClick(event.clientX, event.clientY, this.magoManager);
	this.magoManager.isCameraMoving = true;
	this.magoManager.mouse_x = event.clientX;
	this.magoManager.mouse_y = event.clientY;
	
};

/**
 * 마우스 클릭 위치를 최신으로 갱신
 * @param {Number} mouseX 최신 마우스 클릭 위치의 x 좌표
 * @param {Number} mouseY 최신 마우스 클릭 위치의 y 좌표
 * @param {MagoManager} magoManager
 * 
 */

MagoWorld.updateMouseClick = function(mouseX, mouseY, magoManager)
{
	var mouseAction = magoManager.sceneState.mouseAction;
	mouseAction.curX = mouseX;
	mouseAction.curY = mouseY;
};

/**
 * 마우스를 드래그하기 시작하는 시점을 저장
 * @param {Number} mouseX the x coordi of the start point 
 * @param {Number} mouseY the y coordi of the start point
 * @param {MagoManager} magoManager
 */
MagoWorld.screenToCamCoord = function(mouseX, mouseY, magoManager, resultPointCamCoord)
{
	var gl = magoManager.sceneState.gl;
	var camera = magoManager.sceneState.camera;
	
	if (resultPointCamCoord === undefined)
	{ resultPointCamCoord = new Point3D(); }
	
	// Must find the frustum on pick(mouseX, mouseY) detected depth value.***
	var currentDepthFbo;
	var currentFrustumFar;
	var currentFrustumNear;
	var currentLinearDepth;
	var depthDetected = false;
	var frustumsCount = magoManager.numFrustums;
	for (var i = 0; i < frustumsCount; i++)
	{
		var frustumVolume = magoManager.frustumVolumeControl.getFrustumVolumeCulling(i); 
		var depthFbo = frustumVolume.depthFbo;

		currentLinearDepth = ManagerUtils.calculatePixelLinearDepth(gl, mouseX, mouseY, depthFbo, magoManager);
		if (currentLinearDepth < 0.996) // maxDepth/255 = 0.99607...
		{ 
			currentDepthFbo = depthFbo;
			var frustum = camera.getFrustum(i);
			currentFrustumFar = frustum.far[0];
			currentFrustumNear = frustum.near[0];
			depthDetected = true;
			break;
		}
	}
	
	if (!magoManager.isCesiumGlobe())
	{ currentFrustumNear = 0.0; }
	
	//currentFrustumFar = 30000.0; // The "far" for depthTextures if fixed in "RenderShowDepthVS" shader.
	//currentDepthFbo = magoManager.depthFboNeo;
	resultPointCamCoord = ManagerUtils.calculatePixelPositionCamCoord(gl, mouseX, mouseY, resultPointCamCoord, currentDepthFbo, currentFrustumNear, currentFrustumFar, magoManager);
	return resultPointCamCoord;
};

/**
 * 마우스를 드래그하기 시작하는 시점을 저장
 * @param {Number} mouseX the x coordi of the start point 
 * @param {Number} mouseY the y coordi of the start point
 * @param {MagoManager} magoManager
 */
MagoWorld.updateMouseStartClick = function(mouseX, mouseY, magoManager)
{
	var sceneState = magoManager.sceneState;
	var gl = sceneState.gl;
	var mouseAction = sceneState.mouseAction;
	
	MagoWorld.updateMouseClick(mouseX, mouseY, magoManager);
	
	var date = new Date();
	mouseAction.strTime = date.getTime();
	
	// if button = 1 (middleButton), then rotate camera.
	mouseAction.strX = mouseX;
	mouseAction.strY = mouseY;
	if (sceneState.mouseButton === 0)
	{
		magoManager.bPicking = true;
	}
	
	var camera = sceneState.camera;
	
	// Must find the frustum on pick(mouseX, mouseY) detected depth value.***
	var maxDepth = 0.996;
	//maxDepth = 0.996094;
	var currentDepthFbo;
	var currentFrustumFar;
	var currentFrustumNear;
	var currentLinearDepth;
	var depthDetected = false;
	var frustumsCount = magoManager.numFrustums;
	for (var i = 0; i < frustumsCount; i++)
	{
		var frustumVolume = magoManager.frustumVolumeControl.getFrustumVolumeCulling(i); 
		var depthFbo = frustumVolume.depthFbo;

		currentLinearDepth = ManagerUtils.calculatePixelLinearDepth(gl, mouseAction.strX, mouseAction.strY, depthFbo, magoManager);
		if (currentLinearDepth < maxDepth) // maxDepth/255 = 0.99607...
		{ 
			currentDepthFbo = depthFbo;
			var frustum = camera.getFrustum(i);
			currentFrustumFar = frustum.far[0];
			currentFrustumNear = frustum.near[0];
			depthDetected = true;
			break;
		}
	}
	

	if (!depthDetected && magoManager.scene !== undefined)
	{
		var scene = magoManager.scene;
		var camera = scene.frameState.camera;
		var ray = camera.getPickRay(new Cesium.Cartesian2(mouseX, mouseY));
		var pointWC = scene.globe.pick(ray, scene);
		mouseAction.strWorldPoint = pointWC;
		return;
	}
	
	// determine world position of the X,Y.
	mouseAction.strLinealDepth = currentLinearDepth;
	//mouseAction.strCamCoordPoint = ManagerUtils.calculatePixelPositionCamCoord(gl, mouseAction.strX, mouseAction.strY, mouseAction.strCamCoordPoint, currentDepthFbo, currentFrustumNear, currentFrustumFar, magoManager);
	mouseAction.strCamCoordPoint = MagoWorld.screenToCamCoord(mouseX, mouseY, magoManager, mouseAction.strCamCoordPoint);
	if (!mouseAction.strCamCoordPoint) 
	{
		return;
	}
	mouseAction.strWorldPoint = ManagerUtils.cameraCoordPositionToWorldCoord(mouseAction.strCamCoordPoint, mouseAction.strWorldPoint, magoManager);
	
	// now, copy camera to curCamera.
	var strCamera = mouseAction.strCamera;
	strCamera.copyPosDirUpFrom(camera);
	
	// copy modelViewMatrix.
	var modelViewMatrix = sceneState.modelViewMatrix;
	var modelViewMatrixInv = sceneState.modelViewMatrixInv;
	mouseAction.strModelViewMatrix._floatArrays = glMatrix.mat4.copy(mouseAction.strModelViewMatrix._floatArrays, modelViewMatrix._floatArrays);
	mouseAction.strModelViewMatrixInv._floatArrays = glMatrix.mat4.copy(mouseAction.strModelViewMatrixInv._floatArrays, modelViewMatrixInv._floatArrays);

	// save the sphere pick.
	/*
	if (magoManager.globe !== undefined)
	{
		var camRay;
		camRay = ManagerUtils.getRayWorldSpace(gl, mouseX, mouseY, camRay, magoManager); // rayWorldSpace.
		mouseAction.strWorldPoint2 = magoManager.globe.intersectionLineWgs84(camRay, mouseAction.strWorldPoint2);
	}
	*/
};

/**
 * 만약 마우스 핸들링으로 화면이 바뀌었을 경우, 다음 함수가 활성화 된다
 * @param {Camera} camera
 */
MagoWorld.prototype.updateModelViewMatrixByCamera = function(camera)
{
	var camera = this.magoManager.sceneState.camera;
	var camPos = camera.position;
	var camDir = camera.direction;
	var camUp = camera.up;
	var far = camera.frustum.far[0];
	
	var tergetX = camPos.x + camDir.x * far;
	var tergetY = camPos.y + camDir.y * far;
	var tergetZ = camPos.z + camDir.z * far;
	
	var modelViewMatrix = this.magoManager.sceneState.modelViewMatrix;																	
	modelViewMatrix._floatArrays = Matrix4.lookAt(modelViewMatrix._floatArrays, [camPos.x, camPos.y, camPos.z], 
		[tergetX, tergetY, tergetZ], 
		[camUp.x, camUp.y, camUp.z]);
};

/**
 * 마우스를 꾹 눌렀다가 땔 때의 동작을 감지
 * @param {type}event 
 * 
 */
MagoWorld.prototype.mouseup = function(event)
{
	var magoManager = this.magoManager;
	magoManager.bPicking = false;
	magoManager.isCameraMoving = false;
	var sceneState = magoManager.sceneState;
	var mouseAction = sceneState.mouseAction;
	
	// Check time to check if is a "click".***
	if (sceneState.mouseButton === 0)
	{
		var date = new Date();
		var currTime = date.getTime();
		var durationTime = currTime - mouseAction.strTime;
		if (durationTime < 200)
		{
			// now, calculate the angle and the rotationAxis.
			var xMoved = event.clientX - mouseAction.strX;
			var yMoved = event.clientY - mouseAction.strY;

			if (Math.abs(xMoved) < 3 && Math.abs(yMoved) < 3)
			{
				// Considere as "click".***
				magoManager.bPicking = true;
				magoManager.managePickingProcess();
			}
		}
	}
	
	sceneState.mouseButton = -1;
	
	// Check if there are camera inertial movement.
	var currTime = new Date().getTime();
	var strTime = mouseAction.strTime;
	var deltaTime = currTime - strTime;
	var camera = sceneState.camera;
	if (deltaTime > 1E-3 && deltaTime < 200)
	{
		// apply inertial movement.
		camera.lastMovement.deltaTime = deltaTime;	
	}
	else 
	{
		camera.lastMovement.movementType = CODE.movementType.NO_MOVEMENT;
	}

			
};

/**
 * 마우스 클릭 동작을 감지
 * @param {type}event 
 */
MagoWorld.prototype.mouseclick = function(event)
{
	if (event.button === 0)
	{
		var mouseX = event.clientX;
		var mouseY = event.clientY;
		this.magoManager.mouseActionLeftClick(mouseX, mouseY);
	}
};

/**
 * 마우스 휠 동작을 감지
 * @param {type}event 
 */
MagoWorld.prototype.mousewheel = function(event)
{
	var delta = event.wheelDelta / 10;
	var magoManager = this.magoManager;
	var mouseAction = magoManager.sceneState.mouseAction;
	
	// move camera.
	var camera = magoManager.sceneState.camera;
	var camPos = camera.position;
	var camDir = camera.direction;
	
	// calculate the direction of the cursor.
	var nowX = event.clientX;
	var nowY = event.clientY;
	var mouseRayWC = ManagerUtils.getRayWorldSpace(undefined, nowX, nowY, undefined, magoManager);
	var mouseDirWC = mouseRayWC.direction;
	
	var camHeght = camera.getCameraElevation();

	if (isNaN(camHeght))
	{ return; }

	// Lineal increment.
	//delta *= camHeght * 0.003;
	
	// Squared increment.
	delta *= (camHeght*camHeght) * 0.00001 + camHeght * 0.001;
	delta += 1;
	
	//var maxDelta = 200000;
	var maxDelta = 0.5*camHeght;
	if (maxDelta > 200000)
	{ maxDelta = 200000; }
	
	if (delta < -maxDelta)
	{ delta = -maxDelta; }
	
	if (delta > maxDelta)
	{ delta = maxDelta; }
	
	var oldCamPos = new Point3D(camPos.x, camPos.y, camPos.z);
	var camNewPos = new Point3D(camPos.x + mouseDirWC.x * delta, camPos.y + mouseDirWC.y * delta, camPos.z + mouseDirWC.z * delta);
	camPos.set(camNewPos.x,  camNewPos.y,  camNewPos.z);
	
	// calculate the camera's global rotation, and then rotate de cam's direction.
	var rotAxis;
	rotAxis = oldCamPos.crossProduct(camNewPos, rotAxis);
	rotAxis.unitary();
	if (rotAxis.isNAN())
	{ return; }
		
	var angRad = oldCamPos.angleRadToVector(camNewPos);
	if (angRad === 0 || isNaN(angRad))
	{ return; }
		
	var rotMat = new Matrix4();
	rotMat.rotationAxisAngRad(angRad, rotAxis.x, rotAxis.y, rotAxis.z);
	camDir = rotMat.transformPoint3D(camDir, camDir);
	
	// now, must check the camera's up.
	var globeNormalCartesian = Globe.normalAtCartesianPointWgs84(camPos.x, camPos.y, camPos.z, undefined);
	var globeNormal = new Point3D(globeNormalCartesian[0], globeNormalCartesian[1], globeNormalCartesian[2]);
	
	var camRight = camDir.crossProduct(globeNormal);
	camRight.unitary();
	camera.up = camRight.crossProduct(camDir, camera.up);
	
	this.updateModelViewMatrixByCamera(camera);
};

/**
 * 어떻게 화면을 변화시키는지를 처리할 수 있다. 마우스 왼쪽 또는 마우스 휠로 회전 가능.
 */
MagoWorld.prototype.mousemove = function(event)
{
	var magoManager = this.magoManager;
	var mouseAction = magoManager.sceneState.mouseAction;
	
	var camera = this.magoManager.sceneState.camera;
		
	if (camera.lastMovement === undefined)
	{ camera.lastMovement = new Movement(); }

	var currTime = magoManager.getCurrentTime();
	var strTime = mouseAction.strTime;
	var deltaTime = currTime - strTime;
	
	if (magoManager.sceneState.mouseButton === 0)
	{
		// left button pressed.
		var nowX = event.clientX;
		var nowY = event.clientY;
		if (nowX === mouseAction.strX && nowY === mouseAction.strY)
		{ return; }

		var difX = mouseAction.strX - nowX;
		var difY = mouseAction.strY - nowY;
		if (Math.abs(difX) < 3 && Math.abs(difY) < 3)
		{
			return; 
		}
			
		var gl = magoManager.sceneState.gl;
		var sceneState = magoManager.sceneState;
		var strCamera = mouseAction.strCamera; // camera of onMouseDown.
		var strWorldPoint = mouseAction.strWorldPoint;
		var strEarthRadius = strWorldPoint.getModul();

		// now, calculate the angle and the rotationAxis.
		var strCamCoordPoint = mouseAction.strCamCoordPoint;
		
		// 1rst, check the strPoint distance to camera. If distance is small -> translate. If distance is big -> rotate.
		var distToCam = strCamCoordPoint.getModul();
		if (distToCam < 30.0)
		{
			var strWorldPoint = mouseAction.strWorldPoint;
			var strCamCoordPoint = mouseAction.strCamCoordPoint;
			
			// create a plane on strWorldPoint.
			var planeWC = Globe.planeAtCartesianPointWgs84(strWorldPoint.x, strWorldPoint.y, strWorldPoint.z, undefined);
			var planeWCNormalCartesian = Globe.normalAtCartesianPointWgs84(strWorldPoint.x, strWorldPoint.y, strWorldPoint.z, undefined);
			var planeWCNormal = new Point3D(planeWCNormalCartesian[0], planeWCNormalCartesian[1], planeWCNormalCartesian[2]);
			
			//var mv = mouseAction.strModelViewMatrix;
			var mv = sceneState.modelViewMatrix;
			var planeCamCoordNormal = mv.rotatePoint3D(planeWCNormal, undefined);
			var planeCamCoord = new Plane();
			planeCamCoord.setPointAndNormal(strCamCoordPoint.x, strCamCoordPoint.y, strCamCoordPoint.z, planeCamCoordNormal.x, planeCamCoordNormal.y, planeCamCoordNormal.z);
			
			// Now calculate rayWorldCoord.*********************************************************************************************************************************
			var camRayCamCoordCartesian = ManagerUtils.getRayCamSpace(nowX, nowY, camRayCamCoord, this.magoManager);
			var camRayCamCoord = new Line();
			camRayCamCoord.setPointAndDir(0.0, 0.0, 0.0,       camRayCamCoordCartesian[0], camRayCamCoordCartesian[1], camRayCamCoordCartesian[2]);// original.
		
			var nowCamCoordPoint = planeCamCoord.intersectionLine(camRayCamCoord, undefined);
			if (nowCamCoordPoint === undefined)
			{ return; }
			
			var moveVectorCC = new Point3D(nowCamCoordPoint.x - strCamCoordPoint.x, nowCamCoordPoint.y - strCamCoordPoint.y, nowCamCoordPoint.z - strCamCoordPoint.z);
			
			//var mv_inv = mouseAction.strModelViewMatrixInv;
			var mv_inv = sceneState.modelViewMatrixInv;
			var moveVectorWC = mv_inv.rotatePoint3D(moveVectorCC, undefined);

			var moveVecModul = moveVectorWC.getModul();
			if (moveVecModul > 100.0 || moveVecModul < 1E-5)// there are error.
			{ return; }
			
			camera.copyPosDirUpFrom(strCamera);
			camera.position.add(-moveVectorWC.x, -moveVectorWC.y, -moveVectorWC.z);
			
			this.updateModelViewMatrixByCamera(camera);
			
			// Register the movement of the camera for the case : exist inertial movement.
			// calculate angular velocity.
			var moveDir = new Point3D();
			moveDir.copyFrom(moveVectorWC);
			moveDir.unitary();
			
			var linearVelocity = (moveVecModul/deltaTime)*0.25;
			
			camera.lastMovement.movementType = CODE.movementType.TRANSLATION;
			camera.lastMovement.currLinearVelocity = linearVelocity;
			camera.lastMovement.translationDir = moveDir;
		}
		else
		{
			var sceneState = this.magoManager.sceneState;
			var strCamera = mouseAction.strCamera; // camera of onMouseDown.
			var camera = this.magoManager.sceneState.camera;
			
			// now, calculate the angle and the rotationAxis.
			var strWorldPoint = mouseAction.strWorldPoint;
			var strEarthRadius = strWorldPoint.getModul();
			

			var nowPoint;
			var camRay, camRayCamCoord;
			
			camRayCamCoord = ManagerUtils.getRayCamSpace(nowX, nowY, camRayCamCoord, this.magoManager);
			
			// Now calculate rayWorldCoord.
			if (this.pointSC === undefined)
			{ this.pointSC = new Point3D(); }
			
			this.pointSC.set(camRayCamCoord[0], camRayCamCoord[1], camRayCamCoord[2]);

			// Now, must transform this posCamCoord to world coord, but with the "mouseAction.strModelViewMatrixInv".
			var mv_inv = mouseAction.strModelViewMatrixInv;
			this.pointSC2 = mv_inv.rotatePoint3D(this.pointSC, this.pointSC2); // rayWorldSpace.
			this.pointSC2.unitary(); // rayWorldSpace.
			camRay = new Line();
			var testScale = 0.0001;
			var strCamPos = strCamera.position;
			camRay.setPointAndDir(strCamPos.x*testScale, strCamPos.y*testScale, strCamPos.z*testScale,       this.pointSC2.x, this.pointSC2.y, this.pointSC2.z);// original.

			var nowWorldPoint;
			nowWorldPoint = this.magoManager.globe.intersectionLineWgs84(camRay, nowWorldPoint, strEarthRadius*testScale);

			if (nowWorldPoint === undefined)
			{ return; }
		
			var strPoint = new Point3D(strWorldPoint.x*testScale, strWorldPoint.y*testScale, strWorldPoint.z*testScale); // copy point3d.
			var nowPoint = new Point3D(nowWorldPoint[0], nowWorldPoint[1], nowWorldPoint[2]);

			var rotAxis;
			rotAxis = strPoint.crossProduct(nowPoint, rotAxis);
			rotAxis.unitary();
			if (rotAxis.isNAN())
			{ return; }
			
			var angRad = strPoint.angleRadToVector(nowPoint);
			if (angRad < 10E-9 || isNaN(angRad))
			{ return; }
			
			// recalculate position and direction of the camera.
			camera.copyPosDirUpFrom(strCamera);
			
			var rotMat = new Matrix4();
			rotMat.rotationAxisAngRad(-angRad, rotAxis.x, rotAxis.y, rotAxis.z);
			camera.transformByMatrix4(rotMat);

			this.updateModelViewMatrixByCamera(camera);
			
			// Register the movement of the camera for the case : exist inertial movement.
			// calculate angular velocity.
			var angRadVelocity = (angRad/deltaTime)*0.25;
			
			camera.lastMovement.movementType = CODE.movementType.ROTATION;
			camera.lastMovement.currAngularVelocity = angRadVelocity;
			camera.lastMovement.rotationAxis = rotAxis;
			camera.lastMovement.rotationPoint = undefined;

		}
	}
	else if (this.magoManager.sceneState.mouseButton === 1)
	{
		// middle button pressed.
		var strCamera = mouseAction.strCamera;
		camera.copyPosDirUpFrom(strCamera);
		
		// 1rst, determine the point of rotation.
		var rotPoint = mouseAction.strWorldPoint;
		
		// now determine the rotation axis.
		// the rotation axis are the camRight & normalToSurface.
		if (this.magoManager.globe === undefined)
		{ this.magoManager.globe = new Globe(); }
		
		var pivotPointNormal;
		pivotPointNormal = Globe.normalAtCartesianPointWgs84(rotPoint.x, rotPoint.y, rotPoint.z, pivotPointNormal);
		
		var xAxis = camera.getCameraRight();
		
		// now determine camZRot & camXRot angles.
		var nowX = event.clientX;
		var nowY = event.clientY;
		var increX = nowX - mouseAction.strX;
		var increY = nowY - mouseAction.strY;
		
		var zRotAngRad = increX * 0.003;
		var xRotAngRad = increY * 0.003;
		
		if (zRotAngRad === 0 && xRotAngRad === 0)
		{ return; }
		
		if (this.rotMat === undefined)
		{ this.rotMat = new Matrix4(); }
	
		// calculate the rotationAxis & angRad.
		var quatZRot = glMatrix.quat.create();
		quatZRot = glMatrix.quat.setAxisAngle(quatZRot, pivotPointNormal, -zRotAngRad);
		
		var quatXRot = glMatrix.quat.create();
		quatXRot = glMatrix.quat.setAxisAngle(quatXRot, [xAxis.x, xAxis.y, xAxis.z], -xRotAngRad);
		
		var quatTotalRot = glMatrix.quat.create();
		quatTotalRot = glMatrix.quat.multiply(quatTotalRot, quatZRot, quatXRot);
		
		this.rotMat._floatArrays = glMatrix.mat4.fromQuat(this.rotMat._floatArrays, quatTotalRot);
		
		// Alternative calculating by matrices.***************************************************************************************
		//this.rotMatX.rotationAxisAngRad(-xRotAngRad, xAxis.x, xAxis.y, xAxis.z);
		//this.rotMatZ.rotationAxisAngRad(-zRotAngRad, pivotPointNormal[0], pivotPointNormal[1], pivotPointNormal[2]);
		//this.rotMat = this.rotMatX.getMultipliedByMatrix(this.rotMatZ, this.rotMat);
		//----------------------------------------------------------------------------------------------------------------------------
		
		var translationVec_1 = new Point3D(-rotPoint.x, -rotPoint.y, -rotPoint.z);
		var translationVec_2 = new Point3D(rotPoint.x, rotPoint.y, rotPoint.z);
		
		camera.translate(translationVec_1);
		camera.transformByMatrix4(this.rotMat);
		camera.translate(translationVec_2);
		
		this.updateModelViewMatrixByCamera(camera);
		
		// Register the movement of the camera for the case : exist inertial movement.
		// calculate angular velocity.
		var angRadVelocity = (angRad/deltaTime)*0.3;
		
		camera.lastMovement.movementType = CODE.movementType.ROTATION_ZX;
		camera.lastMovement.rotationPoint = rotPoint;
		camera.lastMovement.xAngVelocity = (-xRotAngRad/deltaTime)*0.3;
		camera.lastMovement.zAngVelocity = (-zRotAngRad/deltaTime)*0.3;
		
	}
};

/**
 *
 *
 * @param {*} event
 */
MagoWorld.prototype.keydown = function(event)
{
	// TODO: keydown()
	console.log("keydown");
};





























'use strict';

/**
 * This is a material.
 * @class Material
 */
var Material = function(name) 
{
	if (!(this instanceof Material)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	// this is under construction...
	// provisional data structure.
	this.id;
	this.name = name;
	if (this.name === undefined)
	{ this.name = "noName"; }
	
	this.diffuseTexture; // class Texture.
	this.color4;
};
'use strict';

/**
 * Manages materials of the Mago3D.
 * @class MaterialsManager
 */
var MaterialsManager = function(magoManager) 
{
	if (!(this instanceof MaterialsManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.magoManager = magoManager;
	
	/**
	 * Materials loaded/created array.
	 * @type {Array}
	 */
	this.materialsMap = {}; // map<materialName, Material>
	
	this.texturesManager; // to load textures.
	this.imagesPath = "/images/materialImages";
};

MaterialsManager.prototype.getMaterial = function(materialName)
{
	return this.materialsMap[materialName];
};

MaterialsManager.prototype.getOrNewMaterial = function(materialName)
{
	var material = this.getMaterial(materialName);
	
	if (material === undefined)
	{
		// create the material.
		material = new Material(materialName);
		this.materialsMap[materialName] = material;
	}
	
	return material;
};

MaterialsManager.prototype.getOrLoadTexture = function(textureName)
{
	if (this.texturesManager === undefined)
	{ this.texturesManager = new TexturesManager(this.magoManager); }
	
	var texture = this.texturesManager.getTextureByName(textureName);
	
	if (texture === undefined)
	{
		// load the texture.
		
	}
};
'use strict';

/**
 * This draws the outer shell of the feature as triangular mesh
 * @class Mesh
 */
var Mesh = function() 
{
	if (!(this instanceof Mesh)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.name;
	this.id;
	this.vertexList;
	
	//the list of the Surface features
	this.surfacesArray;
	this.color4;

	this.hedgesList;
	this.edgesSegment3dsArray; // to render wireframe.
	
	this.vboKeysContainer;
	this.edgesVboKeysContainer;
	this.bbox;
	this.material;// class Material.
};

/** 
 * Makes & returns a mesh from a vboCacheKey.
 */
Mesh.fromVbo = function(vboCacheKey)
{
	if (vboCacheKey === undefined)
	{ return; }
	
	var resultMesh = new Mesh();
	resultMesh.vertexList = new VertexList();
	var vertexList = resultMesh.vertexList;
	resultMesh.hedgesList = new HalfEdgesList();
	var hedgesList = resultMesh.hedgesList;
	
	var surface = resultMesh.newSurface();
	
	// Note: each triangle is a face.
	
	var pos0, pos1, pos2;
	var vertex0, vertex1, vertex2;
	var hedge0, hedge1, hedge2;
	var face;
	
	// 1rst, check if the vbo is "array" type or "element" type.
	if (vboCacheKey.vboBufferIdx !== undefined)
	{
		// the vbo is elementType.
		
	}
	else
	{
		// the vbo is arrayType.
		var posDataArray = vboCacheKey.vboBufferPos.dataArray;
		
		if (posDataArray === undefined)
		{ return; }
		
		var pointsCount = posDataArray.length/3;
		
		if (pointsCount === 0)
		{ return; }
		
		var trianglesCount = pointsCount/3;
		
		var vertexOctree = new VertexOctree(); // indexing octree.
		vertexOctree.vertexArray = new Array(pointsCount);
		var indexingVertexArray = vertexOctree.vertexArray;
		
		// 1rst, make the vertexList and then make vertexIndexOctree.
		for (var i=0; i<trianglesCount; i++)
		{
			pos0 = new Point3D(posDataArray[i*9], posDataArray[i*9+1], posDataArray[i*9+2]);
			pos1 = new Point3D(posDataArray[i*9+3], posDataArray[i*9+4], posDataArray[i*9+5]);
			pos2 = new Point3D(posDataArray[i*9+6], posDataArray[i*9+7], posDataArray[i*9+8]);
			
			vertex0 = vertexList.newVertex(pos0);
			vertex1 = vertexList.newVertex(pos1);
			vertex2 = vertexList.newVertex(pos2);
			
			face = surface.newFace();
			face.addVerticesArray([vertex0, vertex1, vertex2]);
			hedgesList.addHalfEdgesArray(face.createHalfEdges(undefined));
			
			vertex0.facesOwnerArray = [face]; // array exists only in mesh making process.
			vertex1.facesOwnerArray = [face]; // array exists only in mesh making process.
			vertex2.facesOwnerArray = [face]; // array exists only in mesh making process.
			
			// parallely, make the indexingVertexArray of vertexOctree.
			indexingVertexArray[i*3] = vertex0;
			indexingVertexArray[i*3+1] = vertex1;
			indexingVertexArray[i*3+2] = vertex2;
		}
		
		// make a vertexOctree to indexing.
		var bbox = vertexList.getBoundingBox(undefined);
		var maxLength = bbox.getMaxLength();
		
		// make a cubic mother octree (cubic octree = all edges has the same length).
		vertexOctree.setBoxSize(bbox.minX, bbox.minX+maxLength, bbox.minY, bbox.minY+maxLength, bbox.minZ, bbox.minZ+maxLength);
		var targetMinSize = maxLength/30;
		if (targetMinSize < 0.1)
		{ targetMinSize = 0.1; }
		vertexOctree.makeTreeByMinSize(targetMinSize);
		
		var lowestOctrees = vertexOctree.extractOctreesWithData();
		
		// now, make triangles merging merge-able vertices.
		var errorDist = 1e-4;
		var vertexCount = vertexList.getVertexCount();
		for (var i=0; i<vertexCount; i++)
		{
			var currVertex = vertexList.getVertex(i);
			if (currVertex.getVertexType() === -1)
			{ continue; }
			
			// find all coincident vertices to "currVertex".
			var indexingOctree = currVertex.vertexIndexingOctree;
			var indexingOctreeVertexArray = indexingOctree.vertexArray;
			
			var resultCoincidentVertexArray = Vertex.getCoincidentVertexArray(currVertex, indexingOctreeVertexArray, undefined, errorDist);
			var coincidentVertexCount = resultCoincidentVertexArray.length;
			for (var j=0; j<coincidentVertexCount; j++)
			{
				var coincidentVertex = resultCoincidentVertexArray[j];
				coincidentVertex.setVertexType(-1); // mark the vertex, -1 = meaning that must be deleted.
				var facesOwnerArray = coincidentVertex.facesOwnerArray;
				var facesCount = facesOwnerArray.length;
				for (var k=0; k<facesCount; k++)
				{
					var face = facesOwnerArray[k];
					
					// for the face, change the "coincidentVertex" to "currVertex", & delete "coincidentVertex".
					face.setVertexIdxInList();
					var coincidentVertexIdx = coincidentVertex.getIdxInList();
					face.changeVertex(coincidentVertexIdx, currVertex);
					
					// Add face into the currVertex's facesOwnerArray.
					currVertex.facesOwnerArray.push(face);
				}
			}
			
			// now, set twins between faces of the currVertex.
			Face.setTwinsFacesOfArray(currVertex.facesOwnerArray);
		}
		
		// now, delete all coincident vertex.
		vertexList.deleteVertexByVertexType(-1);
		
	}
	
	return resultMesh;
};

/**
 * Clear the data of this feature
 * @param {VBOMemManager} vboMemManager 
 */
Mesh.prototype.deleteObjects = function(vboMemManager)
{
	if (this.vertexList !== undefined)
	{
		this.vertexList.deleteObjects();
	}
	
	if (this.surfacesArray !== undefined)
	{
		var surfacesCount = this.surfacesArray.length;
		for (var i=0; i<surfacesCount; i++)
		{
			this.surfacesArray[i].deleteObjects();
			this.surfacesArray[i] = undefined;
		}
		this.surfacesArray = undefined;
	}
	
	if (this.hedgesList !== undefined)
	{
		this.hedgesList.deleteGlObjects();
		this.hedgesList = undefined;
	}
	
	if (this.vboKeysContainer !== undefined)
	{
		this.vboKeysContainer.deleteGlObjects(vboMemManager.gl, vboMemManager);
		this.vboKeysContainer = undefined;
	}
	
	// No delete material if exist. This mesh is no owner of the material.
};

/**
 * Delete the VBO cache key of this feature from VBOMemManager
 * @param {VBOMemManager} vboMemManager 
 */
Mesh.prototype.deleteVbos = function(vboMemManager)
{
	if (this.vboKeysContainer !== undefined)
	{
		this.vboKeysContainer.deleteGlObjects(vboMemManager.gl, vboMemManager);
		this.vboKeysContainer = undefined;
	}
};

/**
 * Add new surface at the surface array
 */
Mesh.prototype.newSurface = function(options)
{
	if (this.surfacesArray === undefined)
	{ this.surfacesArray = []; }
	
	var surface = new Surface(options);
	this.surfacesArray.push(surface);
	return surface;
};

/**
 * Get the list of the half edges that this mesh has
 * @returns {HalfEdgesList}
 */
Mesh.prototype.getHalfEdgesList = function()
{
	if (this.hedgesList === undefined)
	{ this.hedgesList = new HalfEdgesList(); }

	return this.hedgesList;
};

/**
 * Get the specific surface of this mesh by index
 * @param {Number} idx 
 * @returns {Surface}
 */
Mesh.prototype.getSurface = function(idx)
{
	if (this.surfacesArray === undefined)
	{ return undefined; }
	
	return this.surfacesArray[idx];
};

/**
 * Add a surface at this mesh
 * @param {Surface} surface
 */
Mesh.prototype.addSurface = function(surface)
{
	if (surface === undefined)
	{ return; }
	
	if (this.surfacesArray === undefined)
	{ this.surfacesArray = []; }
	
	this.surfacesArray.push(surface);
};

/**
 * Merge the other mesh at this feature
 * @param {Mesh} mesh
 */
Mesh.prototype.mergeMesh = function(mesh)
{
	if (mesh === undefined)
	{ return; }
	
	if (this.surfacesArray === undefined)
	{ this.surfacesArray = []; }
	
	var surfacesCount = mesh.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		this.addSurface(mesh.getSurface(i));
	}
	mesh.surfacesArray = undefined;
};

/**
 * Return the number of the surfaces that this feature holds.
 * @returns {Number} 
 */
Mesh.prototype.getSurfacesCount = function()
{
	if (this.surfacesArray === undefined)
	{ return 0; }
	
	return this.surfacesArray.length;
};

/**
 * Copy the mesh.
 * @param {Mesh} resultMesh this will copy this feature 
 * @returns {Mesh} resultMesh
 */

Mesh.prototype.getCopySurfaceIndependentMesh = function(resultMesh)
{
	// In a surfaceIndependentMesh, the surfaces are disconex.
	if (resultMesh === undefined)
	{ resultMesh = new Mesh(); }
	
	var surface, surfaceCopy;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		surfaceCopy = resultMesh.newSurface();
		surfaceCopy = surface.getCopyIndependentSurface(surfaceCopy);
	}
	
	return resultMesh;
};

/**
 * Get the array of the triangles which consist of this mesh
 * @param {TrianglesList} resultTrianglesArray The array which will hold the result of this function
 * @return {TrianglesList}
 */
Mesh.prototype.getTriangles = function(resultTrianglesArray)
{
	if (this.surfacesArray === undefined || this.surfacesArray.length === 0)
	{ return resultTrianglesArray; }
	
	if (resultTrianglesArray === undefined)
	{ resultTrianglesArray = []; }
	
	var surface;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		resultTrianglesArray = surface.getTriangles(resultTrianglesArray);
	}
	
	return resultTrianglesArray;
};


/**
 * To call this method, the faces must be CONVEX.
 * Get the trianlgesArray from the surfaces array which have only convex faces. 
 * @param {TrianglesList} resultTrianglesArray
 * @returns {TrianglesList} resultTrianglesArray
 */
Mesh.prototype.getTrianglesConvex = function(resultTrianglesArray)
{
	
	if (this.surfacesArray === undefined || this.surfacesArray.length === 0)
	{ return resultTrianglesArray; }
	
	if (resultTrianglesArray === undefined)
	{ resultTrianglesArray = []; }
	
	var surface;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		resultTrianglesArray = surface.getTrianglesConvex(resultTrianglesArray);
	}
	
	return resultTrianglesArray;
};

/**
 * Get the vertices of this mesh without any repeatation
 * @param {VertexList} resultVerticesArray the array which will hold all vertices of this mesh
 * @returns {VertexLis}
 */
Mesh.prototype.getNoRepeatedVerticesArray = function(resultVerticesArray) 
{
	if (resultVerticesArray === undefined)
	{ resultVerticesArray = []; }
	
	// 1rst, assign vertex-IdxInList for all used vertices.
	var facesCount;
	var face;
	var surface;
	var idxAux = 0;
	var vtx;
	var verticesCount;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		facesCount = surface.getFacesCount();
		for (var j=0; j<facesCount; j++)
		{
			face = surface.getFace(j);
			verticesCount = face.getVerticesCount();
			for (var k=0; k<verticesCount; k++)
			{
				vtx = face.getVertex(k);
				vtx.setIdxInList(idxAux);
				idxAux++;
			}
		}
	}
	
	// now, make a map of unique vertices map using "idxInList" of vertices.
	var verticesMap = {};
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		facesCount = surface.getFacesCount();
		for (var j=0; j<facesCount; j++)
		{
			face = surface.getFace(j);
			verticesCount = face.getVerticesCount();
			for (var k=0; k<verticesCount; k++)
			{
				vtx = face.getVertex(k);
				verticesMap[vtx.getIdxInList().toString()] = vtx;
			}
		}
	}
	
	// finally make the unique vertices array.
	var vertex;
	for (var key in verticesMap)
	{
		if (Object.prototype.hasOwnProperty.call(verticesMap, key))
		{
			vertex = verticesMap[key];
			resultVerticesArray.push(vertex);
		}
	}
	
	return resultVerticesArray;
};

/**
 *	Get the list of the vertices which consist of this mesh
 *  @return {VertexList}
 */
Mesh.prototype.getVertexList = function()
{
	if (this.vertexList === undefined)
	{
		this.vertexList = new VertexList();
	}
	
	return this.vertexList;
};

/**
 * Returns the bbox.
 */
Mesh.prototype.getBoundingBox = function()
{
	if (this.bbox === undefined)
	{
		this.bbox = new BoundingBox();
		this.bbox = this.vertexList.getBoundingBox(this.bbox);
	}
	
	return this.bbox;
};

/**
 * Rotates this mesh specified angle by "angDeg" in (axisX, axisY, axisZ) axis.
 * @param {Number} angDeg Angle in degrees to rotate this mesh.
 * @param {Number} axisX X component of the rotation axis.
 * @param {Number} axisY Y component of the rotation axis.
 * @param {Number} axisZ Z component of the rotation axis.
 */
Mesh.prototype.rotate = function(angDeg, axisX, axisY, axisZ)
{
	var rotMat = new Matrix4();
	var quaternion = new Quaternion();
	
	// Note: the axisX, axisY, axisZ must be unitary, but to be safe process, force rotationAxis to be unitary.*** 
	var rotAxis = new Point3D(axisX, axisY, axisZ);
	rotAxis.unitary();

	// calculate rotation.
	quaternion.rotationAngDeg(angDeg, rotAxis.x, rotAxis.y, rotAxis.z);
	rotMat.rotationByQuaternion(quaternion);
	
	this.transformByMatrix4(rotMat);
	
};

/**
 * Transformate this mesh by the input 4x4 matrix
 * @param {Matrix4} transformByMatrix4
 */
Mesh.prototype.transformByMatrix4 = function(tMat4)
{
	if (this.vertexList === undefined)
	{
		this.vertexList = new VertexList();
		this.vertexList.vertexArray = this.getNoRepeatedVerticesArray(this.vertexList.vertexArray);
	}
	
	this.vertexList.transformPointsByMatrix4(tMat4);
	
	// If rotate a mesh, must recalculate normals.
	var bForceRecalculatePlaneNormal = true;
	this.calculateVerticesNormals(bForceRecalculatePlaneNormal);
};

/**
 * Translate this mesh to the given location
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 */
Mesh.prototype.translate = function(x, y, z)
{
	if (this.vertexList === undefined)
	{
		this.vertexList = new VertexList();
		this.vertexList.vertexArray = this.getNoRepeatedVerticesArray(this.vertexList.vertexArray);
	}
	
	this.vertexList.translateVertices(x, y, z);
};

/**
 * Calculate the normal vectors of the vertices
 * @param {Boolean} bForceRecalculatePlaneNormal If the mesh is only moved by translating, then it will be false.
 */
Mesh.prototype.calculateVerticesNormals = function(bForceRecalculatePlaneNormal)
{
	// PROVISIONAL.
	var surface;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		surface.calculateVerticesNormals(bForceRecalculatePlaneNormal);
	}
};

/**
 * Get the texture coordinate by box projection
 */
Mesh.prototype.calculateTexCoordsBox = function(texCoordsBoundingBox)
{
	var surface;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		surface.calculateTexCoordsBox(texCoordsBoundingBox);
	}
};

/**
 * Get the texture coordinate by spherical projection
 */
Mesh.prototype.calculateTexCoordsSpherical = function()
{
	var sphericalCoords = new GeographicCoord();
	var verticesCount = this.vertexList.getVertexCount();
	for (var i=0; i<verticesCount; i++)
	{
		var vertex = this.vertexList.getVertex(i);
		var position = vertex.point3d;
		sphericalCoords = position.getSphericalCoords(sphericalCoords);
		
		var u = sphericalCoords.longitude / 360.0;
		var v;
		var lat = sphericalCoords.latitude;
		v = 0.5 * (90.0 + lat) / 90.0;
		
		if (vertex.texCoord === undefined)
		{ vertex.texCoord = new Point2D(u, v); }
	}
};

/**
 * Set the color of the mesh
 * @param {Number} r
 * @param {Number} g
 * @param {Number} b 
 * @param {Number} a
 */
Mesh.prototype.setColor = function(r, g, b, a)
{
	// This function sets vertices colors.***
	var surface;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		surface.setColor(r, g, b, a);
	}
};

/**
 * Set the unique one color of the mesh
 * @param {Number} r
 * @param {Number} g
 * @param {Number} b 
 * @param {Number} a
 */
Mesh.prototype.setOneColor = function(r, g, b, a)
{
	// This function sets the unique one color of the mesh.***
	if (this.color4 === undefined)
	{ this.color4 = new Color(); }
	
	this.color4.setRGBA(r, g, b, a);
};

/**
 * Set the material of the mesh.
 * @param {Material} material
 */
Mesh.prototype.setMaterial = function(material)
{
	this.material = material;
};

/**
 * Reverse the direction of the sense of this mesh
 */
Mesh.prototype.reverseSense = function()
{
	var surface;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		surface.reverseSense();
	}
	
	this.calculateVerticesNormals();
};

/**
 * Get the frontier half edges of half edges
 * @param {HalfEdgesList} resultHalfEdgesArray the list of the half edges which will hold the result of this operation
 * @return {HalfEdgesList}
 */
Mesh.prototype.getFrontierHalfEdges = function(resultHalfEdgesArray)
{
	var surface;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		resultHalfEdgesArray = surface.getFrontierHalfEdges(resultHalfEdgesArray); 
	}
	
	return resultHalfEdgesArray;
};

/**
 * Copy the mesh to the parameter mesh
 * @param {Mesh} resultMeshCopy this will be the copy of this mesh
 * @return {Mesh} return the copied mesh
 */
Mesh.prototype.getCopy = function(resultMeshCopy)
{
	if (this.vertexList === undefined)
	{ this.vertexList = new VertexList(); }
	
	if (this.vertexList.vertexArray === undefined || this.vertexList.vertexArray.length === 0)
	{ this.vertexList.vertexArray = this.getNoRepeatedVerticesArray(this.vertexList.vertexArray); }
	
	if (resultMeshCopy === undefined)
	{ resultMeshCopy = new Mesh(); }
	
	// 1rst copy vertexList.
	if (resultMeshCopy.vertexList === undefined)
	{ resultMeshCopy.vertexList = new VertexList(); }
	
	resultMeshCopy.vertexList.copyFrom(this.vertexList);
	
	// set idxInList both vertexLists.
	this.vertexList.setIdxInList();
	resultMeshCopy.vertexList.setIdxInList();
	
	// now copy surfaces.
	var surface, facesCount, face, verticesCount;
	var vtxIdx;
	var surfaceCopy, faceCopy, vtxCopy;
	var vtx;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		surfaceCopy = resultMeshCopy.newSurface();
		
		// copy id & name.
		surfaceCopy.id = surface.id;
		surfaceCopy.name = surface.name;
	
		facesCount = surface.getFacesCount();
		for (var j=0; j<facesCount; j++)
		{
			face = surface.getFace(j);
			faceCopy = surfaceCopy.newFace();
			verticesCount = face.getVerticesCount();
			for (var k=0; k<verticesCount; k++)
			{
				vtx = face.getVertex(k);
				vtxIdx = vtx.getIdxInList();
				vtxCopy = resultMeshCopy.vertexList.getVertex(vtxIdx);
				faceCopy.addVertex(vtxCopy);
			}
		}
	}
	
	resultMeshCopy.calculateVerticesNormals();
	
	return resultMeshCopy;
};

/**
 * WebGL's array index range is short number. So if the length of the trianglesArray is over short, then rearrange the list.
 * @param {TrianglesList} trianglesArray the target triangle array
 * @param {Array} resultTrianglesListsArray the array of the TrianglesLis divided into WebGL's index range.
 */
Mesh.prototype.getTrianglesListsArrayBy2ByteSize = function(trianglesArray, resultTrianglesListsArray)
{
	if (resultTrianglesListsArray === undefined)
	{ resultTrianglesListsArray = []; }
	
	// This function returns trianglesListsArray. Each trianglesList's vertices count is lower than 65535.
	var shortSize = 65535;
	var trianglesList = new TrianglesList();
	resultTrianglesListsArray.push(trianglesList);
	var trianglesCount = trianglesArray.length;
	if (trianglesCount*3 <shortSize)
	{
		trianglesList.trianglesArray = [];
		Array.prototype.push.apply(trianglesList.trianglesArray, trianglesArray);
		return resultTrianglesListsArray;
	}
	
	// 1rst, make global vertices array.
	var globalVerticesArray = TrianglesList.getNoRepeatedVerticesArray(trianglesArray, undefined);
	var verticesCount = globalVerticesArray.length;
	
	if (verticesCount <shortSize)
	{
		trianglesList.trianglesArray = [];
		Array.prototype.push.apply(trianglesList.trianglesArray, trianglesArray);
		return resultTrianglesListsArray;
	}
	
	VertexList.setIdxInList(globalVerticesArray);
	var rejectedTrianglesArray = [];
	var trianglesCount = trianglesArray.length;
	var triangle;
	
	for (var i=0; i<trianglesCount; i++)
	{
		triangle = trianglesArray[i];
		if (triangle.vertex0.idxInList < shortSize && triangle.vertex1.idxInList< shortSize && triangle.vertex2.idxInList< shortSize)
		{
			trianglesList.addTriangle(triangle);
		}
		else 
		{
			rejectedTrianglesArray.push(triangle);
		}
	};
	
	if (rejectedTrianglesArray.length > 0)
	{
		resultTrianglesListsArray = this.getTrianglesListsArrayBy2ByteSize(rejectedTrianglesArray, resultTrianglesListsArray);
	}
	
	return resultTrianglesListsArray;
};
/**
 * Render the mesh as child. equal render
 * @param {MagoManager}magoManager
 * @param {Shader} shader
 * @param {Number} renderType
 * @param glPrimitive
 * @TODO : 누가 이 gl primitive의 type 정체를 안다면 좀 달아주세요ㅠㅠ 세슘 쪽인거 같은데ㅠㅠ
 */
Mesh.prototype.renderAsChild = function (magoManager, shader, renderType, glPrimitive, isSelected, options, bWireframe) 
{
	var renderShaded = true;
	var renderWireframe = false;
	var depthMask = true;
	
	var gl = magoManager.getGl();

	if (bWireframe)
	{
		if (options)
		{
			if (options.renderWireframe !== undefined)
			{ renderWireframe = options.renderWireframe; }
			
			if (options.depthMask !== undefined)
			{ depthMask = options.depthMask; }
		}
	
		if (renderWireframe)
		{
			this.renderWireframe(magoManager, shader, renderType, glPrimitive, isSelected);
		}
	}
	else
	{
		if (options)
		{
			if (options.renderShaded !== undefined)
			{ renderShaded = options.renderShaded; }

			if (options.depthMask !== undefined)
			{ depthMask = options.depthMask; }
		}
		
		if (renderShaded)
		{
			gl.depthMask(depthMask);
			this.render(magoManager, shader, renderType, glPrimitive, isSelected);
			gl.depthMask(true);
		}
	}
	
	
	
	
};

/**
 * Render the mesh
 * @param {MagoManager}magoManager
 * @param {Shader} shader
 * @param {Number} renderType
 * @param glPrimitive
 * @TODO : 누가 이 gl primitive의 type 정체를 안다면 좀 달아주세요ㅠㅠ 세슘 쪽인거 같은데ㅠㅠ
 */
Mesh.prototype.render = function(magoManager, shader, renderType, glPrimitive, isSelected)
{
	var vboMemManager = magoManager.vboMemoryManager;
	
	if (this.vboKeysContainer === undefined)
	{
		this.vboKeysContainer = this.getVbo(this.vboKeysContainer, vboMemManager);
		return;
	}
	
	var gl = magoManager.sceneState.gl;
	var primitive;
	
	if (renderType === 0)
	{
		// Depth render.***
	}
	else if (renderType === 1)
	{
		if (!isSelected)
		{
			// Color render.***
			if (this.material !== undefined && this.material.diffuseTexture !== undefined && this.material.diffuseTexture.texId !== undefined)
			{
				var texture = this.material.diffuseTexture;
				gl.uniform1i(shader.colorType_loc, 2); // 0= oneColor, 1= attribColor, 2= texture.
				if (shader.last_tex_id !== texture.texId) 
				{
					gl.activeTexture(gl.TEXTURE2);
					gl.bindTexture(gl.TEXTURE_2D, texture.texId);
					shader.last_tex_id = texture.texId;
				}
			}
			else if (this.color4)
			{ 
				gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
				gl.uniform4fv(shader.oneColor4_loc, [this.color4.r, this.color4.g, this.color4.b, this.color4.a]); 
			}
		}
	}
	else if (renderType === 2)
	{
		// Selection render.***
	}
	
	var vboKeysCount = this.vboKeysContainer.vboCacheKeysArray.length;
	for (var i=0; i<vboKeysCount; i++)
	{
		var vboKey = this.vboKeysContainer.vboCacheKeysArray[i];
		if (!vboKey) 
		{
			return false;
		}
		
		// Positions.
		if (!vboKey.bindDataPosition(shader, vboMemManager))
		{ return false; }
	
		if (renderType === 1)
		{
			// Normals.
			if (vboKey.vboBufferNor)
			{
				if (!vboKey.bindDataNormal(shader, vboMemManager))
				{ return false; }
			}
			else 
			{
				shader.disableVertexAttribArray(shader.normal3_loc);
			}
			
			// TexCoords.
			if (vboKey.vboBufferTCoord)
			{
				if (!vboKey.bindDataTexCoord(shader, vboMemManager))
				{ return false; }
			}
			else 
			{
				shader.disableVertexAttribArray(shader.texCoord2_loc);
			}
		}
		
		if (renderType === 1 || renderType === 2)
		{
			// Colors.
			if (vboKey.vboBufferCol)
			{
				if (!vboKey.bindDataColor(shader, vboMemManager))
				{ return false; }
			}
			else 
			{
				shader.disableVertexAttribArray(shader.color4_loc);
			}
		}
		
		
		// Indices.
		if (!vboKey.bindDataIndice(shader, vboMemManager))
		{ return false; }
		
		if (glPrimitive)
		{ primitive = glPrimitive; }
		else
		{ primitive = gl.TRIANGLES; }
		
		gl.drawElements(primitive, vboKey.indicesCount, gl.UNSIGNED_SHORT, 0);
	}
};

/**
 * Render the mesh
 * @param {MagoManager}magoManager
 * @param {Shader} shader
 * @param {Number} renderType
 * @param glPrimitive
 * @TODO : 누가 이 gl primitive의 type 정체를 안다면 좀 달아주세요ㅠㅠ 세슘 쪽인거 같은데ㅠㅠ
 */
Mesh.prototype.renderWireframe = function(magoManager, shader, renderType, glPrimitive, isSelected)
{
	var vboMemManager = magoManager.vboMemoryManager;
	
	if (this.edgesVboKeysContainer === undefined)
	{
		this.edgesVboKeysContainer = this.getVboEdgesThickLines(this.edgesVboKeysContainer, magoManager);
		return;
	}
	
	var gl = magoManager.sceneState.gl;
	var primitive;
	
	if (renderType === 0)
	{
		// Depth render.***
	}
	else if (renderType === 1)
	{
		if (!isSelected)
		{
			// Color render.***
			if (this.material !== undefined && this.material.diffuseTexture !== undefined && this.material.diffuseTexture.texId !== undefined)
			{
				var texture = this.material.diffuseTexture;
				gl.uniform1i(shader.colorType_loc, 2); // 0= oneColor, 1= attribColor, 2= texture.
				if (shader.last_tex_id !== texture.texId) 
				{
					gl.activeTexture(gl.TEXTURE2);
					gl.bindTexture(gl.TEXTURE_2D, texture.texId);
					shader.last_tex_id = texture.texId;
				}
			}
			else if (this.color4)
			{ 
				gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
				gl.uniform4fv(shader.oneColor4_loc, [this.color4.r, this.color4.g, this.color4.b, this.color4.a]); 
			}
		}
	}
	else if (renderType === 2)
	{
		// Selection render.***
	}
	
	var vbo = this.edgesVboKeysContainer.getVboKey(0);
	
	// based on https://weekly-geekly.github.io/articles/331164/index.html
	/*
	var shader = magoManager.postFxShadersManager.getShader("thickLine");
	shader.useProgram();
	shader.bindUniformGenerals();
	var gl = magoManager.getGl();

	gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
	gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
	gl.disable(gl.CULL_FACE);
	
	gl.enableVertexAttribArray(shader.prev_loc);
	gl.enableVertexAttribArray(shader.current_loc);
	gl.enableVertexAttribArray(shader.next_loc);
	
	var geoLocData = this.geoLocDataManager.getCurrentGeoLocationData();
	geoLocData.bindGeoLocationUniforms(gl, shader);

	var sceneState = magoManager.sceneState;
	var drawingBufferWidth = sceneState.drawingBufferWidth;
	var drawingBufferHeight = sceneState.drawingBufferHeight;

	gl.uniform4fv(shader.color_loc, [0.5, 0.7, 0.9, 1.0]);
	gl.uniform2fv(shader.viewport_loc, [drawingBufferWidth[0], drawingBufferHeight[0]]);
	*/
	
	this.thickness = 2.0;
	gl.uniform1f(shader.thickness_loc, this.thickness);

	var vboPos = vbo.vboBufferPos;
	var dim = vboPos.dataDimensions; // in this case dimensions = 4.
	if (!vboPos.isReady(gl, magoManager.vboMemoryManager))
	{
		return;
	}

	gl.bindBuffer(gl.ARRAY_BUFFER, vboPos.key);
	gl.vertexAttribPointer(shader.prev_loc, dim, gl.FLOAT, false, 16, 0);
	gl.vertexAttribPointer(shader.current_loc, dim, gl.FLOAT, false, 16, 64-32);
	gl.vertexAttribPointer(shader.next_loc, dim, gl.FLOAT, false, 16, 128-32);

	gl.drawArrays(gl.TRIANGLE_STRIP, 0, vbo.vertexCount-(4));

	gl.enable(gl.CULL_FACE);
	
};

/**
 * Get the VBO keys of this mesh
 * @param {VBOVertexIdxCacheKeysContainer} resultVboContainer 
 * @param {VBOMemManager} vboMemManager
 * @return {VBOVertexIdxCacheKeysContainer}
 */
Mesh.prototype.getVbo = function(resultVboContainer, vboMemManager)
{
	if (resultVboContainer === undefined)
	{ resultVboContainer = new VBOVertexIdxCacheKeysContainer(); }

	// make global triangles array.
	var trianglesArray = this.getTriangles(undefined);
	var trianglesCount = trianglesArray.length;
	
	// If vertices count > shortSize(65535), then must split the mesh.
	var trianglesListsArray = this.getTrianglesListsArrayBy2ByteSize(trianglesArray, undefined);
	var trianglesList;
	var verticesArray;
	var trianglesListsCount = trianglesListsArray.length;
	for (var i=0; i<trianglesListsCount; i++)
	{
		trianglesList = trianglesListsArray[i];
		verticesArray = trianglesList.getNoRepeatedVerticesArray(undefined);
		var vbo = resultVboContainer.newVBOVertexIdxCacheKey();
		VertexList.setIdxInList(verticesArray);
		VertexList.getVboDataArrays(verticesArray, vbo, vboMemManager);
		trianglesList.assignVerticesIdx();
		TrianglesList.getVboFaceDataArray(trianglesList.trianglesArray, vbo, vboMemManager);
		
	}

	return resultVboContainer;
};

/**
 * Get the VBO keys of the convex triangles
 * @param {VBOVertexIdxCacheKeysContainer} resultVboContainer 
 * @param {VBOMemManager} vboMemManager
 * @return {VBOVertexIdxCacheKeysContainer} 
 */
Mesh.prototype.getVboTrianglesConvex = function(resultVboContainer, vboMemManager)
{
	if (resultVboContainer === undefined)
	{ resultVboContainer = new VBOVertexIdxCacheKeysContainer(); }

	// make global triangles array.
	var trianglesArray = this.getTrianglesConvex(undefined); // for convex faces (faster).
	var trianglesCount = trianglesArray.length;
	
	// If vertices count > shortSize(65535), then must split the mesh.
	var trianglesListsArray = this.getTrianglesListsArrayBy2ByteSize(trianglesArray, undefined);
	var trianglesList;
	var verticesArray;
	var trianglesListsCount = trianglesListsArray.length;
	for (var i=0; i<trianglesListsCount; i++)
	{
		trianglesList = trianglesListsArray[i];
		verticesArray = trianglesList.getNoRepeatedVerticesArray(undefined);
		var vbo = resultVboContainer.newVBOVertexIdxCacheKey();
		VertexList.setIdxInList(verticesArray);
		VertexList.getVboDataArrays(verticesArray, vbo, vboMemManager);
		trianglesList.assignVerticesIdx();
		TrianglesList.getVboFaceDataArray(trianglesList.trianglesArray, vbo, vboMemManager);
		
	}

	return resultVboContainer;
};

Mesh.prototype.getEdgeSegment3ds = function(resultSegment3dsArray)
{
	var frontierHedgesArray = [];
	var surface;
	var surfacesCount = this.getSurfacesCount();
	for (var i=0; i<surfacesCount; i++)
	{
		surface = this.getSurface(i);
		if (surface.name === "outerLateral")
		{ frontierHedgesArray = surface.getFrontierHalfEdges(frontierHedgesArray); }
	}

	var hedgesCount = frontierHedgesArray.length;
	
	if (hedgesCount === 0)
	{ return resultSegment3dsArray; }
	
	if (!resultSegment3dsArray)
	{ resultSegment3dsArray = []; }
	
	var hedge;
	var segment3d;
	var strVertex, endVertex;
	var strPoint3d, endPoint3d;
	var index = 0;
	for (var i=0; i<hedgesCount; i++)
	{
		hedge = frontierHedgesArray[i];
		strVertex = hedge.startVertex;
		endVertex = hedge.getEndVertex();
		
		strPoint3d = strVertex.getPosition();
		endPoint3d = endVertex.getPosition();
		
		segment3d = new Segment3D(strPoint3d, endPoint3d);
		resultSegment3dsArray.push(segment3d);
	}
	
	return resultSegment3dsArray;
};

/**
 * Register the VBO cache keys of the half edges of this mesh to VBOMemManager.
 * @param {VBOVertexIdxCacheKeysContainer} resultVboContainer 
 * @param {VBOMemManager} vboMemManager
 * @TODO : Need to change name! Not Getter!
 */
Mesh.prototype.getVboEdgesThickLines = function(resultVboContainer, magoManager)
{
	// Make edges if need render wireframe. 
	this.edgesSegment3dsArray = []; // init.
	this.edgesSegment3dsArray = this.getEdgeSegment3ds(this.edgesSegment3dsArray);
	resultVboContainer = Segment3D.getVboThickLines(magoManager, this.edgesSegment3dsArray, resultVboContainer);
	return resultVboContainer;
};

/**
 * Register the VBO cache keys of the half edges of this mesh to VBOMemManager.
 * @param {VBOVertexIdxCacheKeysContainer} resultVboContainer 
 * @param {VBOMemManager} vboMemManager
 * @TODO : Need to change name! Not Getter!
 */
Mesh.prototype.getVboEdges = function(resultVboContainer, vboMemManager)
{
	// Old. deprecated.
	if (resultVboContainer === undefined)
	{ return; }
	
	// provisionally make edges by this.
	var frontierHedgesArray = this.getFrontierHalfEdges(undefined);
	var hedgesCount = frontierHedgesArray.length;
	var hedge;
	var verticesCount = hedgesCount * 2;
	var vertexArray = new Float32Array(verticesCount*3);
	var indicesArray = new Uint16Array(verticesCount);
	var strVertex, endVertex;
	var index = 0;
	for (var i=0; i<hedgesCount; i++)
	{
		hedge = frontierHedgesArray[i];
		strVertex = hedge.startVertex;
		endVertex = hedge.getEndVertex();
		vertexArray[i*6] = strVertex.point3d.x;
		vertexArray[i*6+1] = strVertex.point3d.y;
		vertexArray[i*6+2] = strVertex.point3d.z;
		vertexArray[i*6+3] = endVertex.point3d.x;
		vertexArray[i*6+4] = endVertex.point3d.y;
		vertexArray[i*6+5] = endVertex.point3d.z;
		
		indicesArray[i*2] = index; index++;
		indicesArray[i*2+1] = index; index++;
	}
	
	var resultVbo = resultVboContainer.newVBOVertexIdxCacheKey();
	resultVbo.setDataArrayPos(vertexArray, vboMemManager);
	resultVbo.setDataArrayIdx(indicesArray, vboMemManager);
	
	return resultVboContainer;
};





















































'use strict';


/**
 * Now under implementation
 * @class Modeler
 */
var Modeler = function(magoManager) 
{
	if (!(this instanceof Modeler)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.magoManager = magoManager;
	
	/**
	 * Current modeler's mode. 
	 * @type {Enumeration}
	 * @default CODE.modelerMode.INACTIVE
	 */
	this.mode = CODE.modelerMode.INACTIVE; // test for the moment.
	this.drawingState = CODE.modelerDrawingState.NO_STARTED; // test for the moment.
	this.drawingElement = CODE.modelerDrawingElement.NOTHING; // test for the moment.
	
	// Test objects.***
	this.planeGrid; // sketch plane.
	this.polyLine2d; // current polyline2D to sketch.
	this.geoCoordsList; // class: GeographicCoordsList. geographic polyline.
	this.excavation; // class : Excavation.
	this.tunnel; // class : Tunnel.
	this.bSplineCubic3d;
	this.sphere; // class : Sphere.
	this.clippingBox;
	
	this.testObjectsArray;
	
	this.objectsArray; // put here all objects.***
	this.vectorsArray; // put here vector objects (lines, polylines, etc.).***
	this.currentVisibleObjectsArray;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Modeler.prototype.extractObjectsByClassName = function(className, resultObjectsArray) 
{
	if (this.objectsArray === undefined)
	{ return resultObjectsArray; }
	
	if (resultObjectsArray === undefined)
	{ resultObjectsArray = []; }
	
	var objectsCount = this.objectsArray.length;
	for (var i=0; i<objectsCount; i++)
	{
		var object = this.objectsArray[i];
		if (object.constructor.name === className)
		{
			resultObjectsArray.push(object);
		}
	}
	
	return resultObjectsArray;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Modeler.prototype.newPipe = function(options) 
{
	var interiorRadius = options.interiorRadius;
	var exteriorRadius = options.exteriorRadius;
	var height = options.height;
	
	var pipe = new Pipe(interiorRadius, exteriorRadius, height, options);
	
	if (this.objectsArray === undefined)
	{ this.objectsArray = []; }
	
	this.objectsArray.push(pipe);
	return pipe;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Modeler.prototype.newTube = function(options) 
{
	var interiorRadius = options.interiorRadius;
	var exteriorRadius = options.exteriorRadius;
	var height = options.height;
	
	var tube = new Tube(interiorRadius, exteriorRadius, height, options);
	
	if (this.objectsArray === undefined)
	{ this.objectsArray = []; }
	
	this.objectsArray.push(tube);
	return tube;
};

/**
 * 모델러에 콘센트릭튜브 추가
 * @param {Object}
 * @param {number}} depth Optional. 설정 시 해당 depth로 targetDepth 설정
 */
Modeler.prototype.addObject = function(object, depth) 
{
	if (this.objectsArray === undefined)
	{ this.objectsArray = []; }

	this.objectsArray.push(object);
	
	var smartTileManager = this.magoManager.smartTileManager;
	// Note: the targetDepth must be calculated by the objects bbox size.
	var targetDepth = depth ? depth : 16;
	smartTileManager.putObject(targetDepth, object, this.magoManager);
};

/**
 * 모델러에 콘센트릭튜브 추가
 * @param {Object}
 * @param {number}} depth Optional. 설정 시 해당 depth로 targetDepth 설정
 */
Modeler.prototype.addBoundingSpheres__TEST = function(boundingSpheresArray, depth) 
{
	if (boundingSpheresArray === undefined || boundingSpheresArray.length === 0)
	{ return; }
	
	var bSpheresCount = boundingSpheresArray.length;
	for (var i=0; i<bSpheresCount; i++)
	{
		var bSphere = boundingSpheresArray[i];
		var geoCoord = ManagerUtils.pointToGeographicCoord(bSphere.centerPoint, undefined, this.magoManager);
		var geoLocDataManager = new GeoLocationDataManager();
		
		var geoLocData = geoLocDataManager.newGeoLocationData("noName");
		geoLocData = ManagerUtils.calculateGeoLocationData(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude, undefined, undefined, undefined, geoLocData, this);
		
		var options = {};
		var color = new Color();
		color.setRGB(0.99, 0.1, 0.1);
		options.color = color;
		var sphere = new Sphere(options);
		sphere.geoLocDataManager = geoLocDataManager;
		sphere.setRadius(bSphere.r * 2);
		this.addObject(sphere, depth);
	}
};

/**
 * 모델러에 콘센트릭튜브 추가
 * @param {Object}
 */
Modeler.prototype.removeObject = function(object) 
{
	if (object === undefined)
	{ return false; }
	
	// todo:
};

/**
 * 어떤 일을 하고 있습니까?
 */
Modeler.prototype.newPerson = function(options) 
{
	if (this.testObjectsArray === undefined)
	{ this.testObjectsArray = []; }
	
	var person = new AnimatedPerson();
	this.testObjectsArray.push(person);
	return person;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Modeler.prototype.newBasicFactory = function(factoryWidth, factoryLength, factoryHeight, options) 
{
	// set material for the roof of the factory.
	var magoManager = this.magoManager;
	var materialsManager = magoManager.materialsManager;
	var materialName = "basicFactoryRoof";
	var material = materialsManager.getOrNewMaterial(materialName);
	if (material.diffuseTexture === undefined)
	{ 
		material.diffuseTexture = new Texture(); 
		material.diffuseTexture.textureTypeName = "diffuse";
		material.diffuseTexture.textureImageFileName = "factoryRoof.jpg"; // Gaia3dLogo.png
		var imagesPath = materialsManager.imagesPath + "//" + material.diffuseTexture.textureImageFileName;
		var flipYTexCoord = true;
		TexturesManager.loadTexture(imagesPath, material.diffuseTexture, magoManager, flipYTexCoord);
	}
	
	// add options.
	if (options === undefined)
	{ options = {}; }
	
	options.roof = {
		"material": material
	};
	
	
	var basicFactory = new BasicFactory(factoryWidth, factoryLength, factoryHeight, options);
	basicFactory.bHasGround = true;
	
	if (this.objectsArray === undefined)
	{ this.objectsArray = []; }
	
	this.objectsArray.push(basicFactory);
	
	return basicFactory;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Modeler.getExtrudedSolidMesh = function(profile2d, extrusionDist, extrudeSegmentsCount, extrusionVector, bIncludeBottomCap, bIncludeTopCap, resultMesh) 
{
	if (profile2d === undefined || extrusionDist === undefined)
	{ return undefined; }
	
	var vtxProfilesList = new VtxProfilesList();
	
	// if want caps in the extruded mesh, must calculate "ConvexFacesIndicesData" of the profile2d before creating vtxProfiles.
	vtxProfilesList.convexFacesIndicesData = profile2d.getConvexFacesIndicesData(undefined);
	
	// create vtxProfiles.
	// make the base-vtxProfile.
	var baseVtxProfile = vtxProfilesList.newVtxProfile();
	baseVtxProfile.makeByProfile2D(profile2d);
	
	if (extrusionVector === undefined)
	{ extrusionVector = new Point3D(0, 0, 1); }
	
	var increDist = extrusionDist/extrudeSegmentsCount;
	for (var i=0; i<extrudeSegmentsCount; i++)
	{
		// test with a 1 segment extrusion.
		var nextVtxProfile = vtxProfilesList.newVtxProfile();
		nextVtxProfile.copyFrom(baseVtxProfile);
		nextVtxProfile.translate(0, 0, increDist*(i+1));
	}
	
	// must separate vbo groups by surfaces.
	resultMesh = vtxProfilesList.getMesh(resultMesh, bIncludeBottomCap, bIncludeTopCap);
	resultMesh.calculateVerticesNormals();
	
	return resultMesh;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Modeler.getExtrudedMesh = function(profile2d, extrusionDist, extrudeSegmentsCount, extrusionVector, bIncludeBottomCap, bIncludeTopCap, resultMesh) 
{
	if (profile2d === undefined || extrusionDist === undefined)
	{ return undefined; }

	var solidMesh = Modeler.getExtrudedSolidMesh(profile2d, extrusionDist, extrudeSegmentsCount, extrusionVector, undefined);
	resultMesh = solidMesh.getCopySurfaceIndependentMesh(resultMesh);
	resultMesh.calculateVerticesNormals();
	
	return resultMesh;
};

Modeler.getRevolvedSolidMesh = function(profile2d, revolveAngDeg, revolveSegmentsCount, revolveSegment2d, bIncludeBottomCap, bIncludeTopCap, resultMesh) 
{
	// Note: move this function into "VtxProfilesList" class.
	if (profile2d === undefined)
	{ return undefined; }

	var vtxProfilesList = new VtxProfilesList(); 
	
	// if want caps in the extruded mesh, must calculate "ConvexFacesIndicesData" of the profile2d before creating vtxProfiles.
	vtxProfilesList.convexFacesIndicesData = profile2d.getConvexFacesIndicesData(undefined);
	//profile2d.checkNormals();
	// create vtxProfiles.
	// make the base-vtxProfile.
	var baseVtxProfile = vtxProfilesList.newVtxProfile();
	baseVtxProfile.makeByProfile2D(profile2d);
	
	var increAngDeg = revolveAngDeg/revolveSegmentsCount;
	
	// calculate the translation.
	var line2d = revolveSegment2d.getLine();
	var origin2d = new Point2D(0, 0);
	var translationVector = line2d.getProjectedPoint(origin2d);
	translationVector.inverse();
	
	var rotMat = new Matrix4();
	var quaternion = new Quaternion();
	var rotAxis2d = revolveSegment2d.getDirection();
	var rotAxis = new Point3D(rotAxis2d.x, rotAxis2d.y, 0);
	rotAxis.unitary();
	
	for (var i=0; i<revolveSegmentsCount; i++)
	{
		// calculate rotation.
		quaternion.rotationAngDeg(increAngDeg*(i+1), rotAxis.x, rotAxis.y, rotAxis.z);
		rotMat.rotationByQuaternion(quaternion);
		
		// test top profile.
		var nextVtxProfile = vtxProfilesList.newVtxProfile();
		nextVtxProfile.copyFrom(baseVtxProfile);
		nextVtxProfile.translate(translationVector.x, translationVector.y, 0);
		nextVtxProfile.transformPointsByMatrix4(rotMat);
		nextVtxProfile.translate(-translationVector.x, -translationVector.y, 0);
	}
	
	resultMesh = vtxProfilesList.getMesh(resultMesh, bIncludeBottomCap, bIncludeTopCap);
	resultMesh.calculateVerticesNormals();
	
	return resultMesh;
};

Modeler.getPoints3DList_fromPoints3dArray = function(points3dArray, resultPoints3dList, options) 
{
	// 1rst, calculate the center point of the array.
	var bbox = new BoundingBox();
	bbox.init(points3dArray[0]);
	bbox.addPointsArray(points3dArray);
	
	// calculate the centerPos.
	var centerPos = bbox.getCenterPoint();
	
	// calculate geoLocationData.
	var geoLocData;
	
	// check options.
	if (options !== undefined && options.geoLocationData !== undefined)
	{
		// use the existent geoLocationData.
		geoLocData = options.geoLocationData;
	}
	else
	{
		// calculate geoLocationData by the centerPos of bbox.
		var geoCoord = ManagerUtils.pointToGeographicCoord(centerPos, undefined);
		geoLocData = ManagerUtils.calculateGeoLocationData(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude, 0, 0, 0, undefined);
	}
	
	// calculate points3d relatives to the geoLocData.
	var relPoitsArray = geoLocData.getTransformedRelativePositionsArray(points3dArray, undefined);
	
	if (resultPoints3dList === undefined)
	{ resultPoints3dList = new Point3DList(); }
	
	resultPoints3dList.pointsArray = relPoitsArray;
	
	if (resultPoints3dList.geoLocDataManager === undefined)
	{ resultPoints3dList.geoLocDataManager = new GeoLocationDataManager(); }
	
	resultPoints3dList.geoLocDataManager.addGeoLocationData(geoLocData);
	return resultPoints3dList;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Modeler.prototype.getGeographicCoordsList = function() 
{
	if (this.geoCoordsList === undefined)
	{ this.geoCoordsList = new GeographicCoordsList(); }
	
	return this.geoCoordsList;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Modeler.prototype.getExcavation = function() 
{
	//if (this.excavation === undefined)
	//{ this.excavation = new Excavation(); }
	
	return this.excavation;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Modeler.prototype.getTunnel = function() 
{
	//if (this.tunnel === undefined)
	//{ this.tunnel = new Tunnel(); }
	
	return this.tunnel;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Modeler.prototype.addPointToPolyline = function(point2d) 
{
	if (this.polyLine2d === undefined)
	{ this.polyLine2d = new PolyLine2D(); }
	
	this.polyLine2d.newPoint2d(point2d.x, point2d.y);
};


/**
 * 어떤 일을 하고 있습니까?
 */
Modeler.prototype.render = function(magoManager, shader, renderType, glPrimitive) 
{
	// Generic objects.***
	// The generic objects are into smartTiles, so is rendered when smartTile is visible on camera.
	
	// Render test objects.
	if (this.testObjectsArray !== undefined)
	{
		var testObjectsCount = this.testObjectsArray.length;
		for (var i=0; i<testObjectsCount; i++)
		{
			var testObject = this.testObjectsArray[i];
			testObject.render(magoManager);
		}
	}
	
	// 1rst, render the planeGrid if exist.
	if (this.planeGrid !== undefined)
	{
		this.planeGrid.render(magoManager, shader);
	}
	
	if (this.geoCoordsList !== undefined && renderType === 1)
	{
		// Provisionally render geographicPoints.
		if (this.geoCoordsList.points3dList !== undefined && this.geoCoordsList.points3dList.vboKeysContainer !== undefined)
		{
			//magoManager.clearCanvas2D();
			
			var bEnableDepth = true;
			var options = {};
			var thickLineShader = magoManager.postFxShadersManager.getShader("thickLine"); 
			thickLineShader.useProgram();
			
			// bind building geoLocationData.
			
			
			var gl = this.magoManager.getGl();
			var sceneState = this.magoManager.sceneState;
			gl.uniform4fv(thickLineShader.oneColor4_loc, [0.9, 0.5, 0.3, 1.0]);
			gl.uniform2fv(thickLineShader.viewport_loc, [sceneState.drawingBufferWidth, sceneState.drawingBufferHeight]);
			gl.uniform1f(thickLineShader.thickness_loc, 5.0);
			this.geoCoordsList.points3dList.renderThickLines(magoManager, thickLineShader, renderType, bEnableDepth, options);
			
			shader.useProgram();
		}
		this.geoCoordsList.renderPoints(magoManager, shader, renderType);
	}
	
	if (this.excavation !== undefined)
	{
		this.excavation.renderPoints(magoManager, shader, renderType);
	}
	
	if (this.tunnel !== undefined)
	{
		this.tunnel.renderPoints(magoManager, shader, renderType);
	}
		
	if (renderType === 1 || renderType === 2)
	{
		
		
		if (this.clippingBox !== undefined)
		{
			var glPrimitive = undefined;
			var bIsSelected = false;
			this.clippingBox.render(magoManager, shader, renderType, glPrimitive, bIsSelected);
		}
	}
	
	if (this.bSplineCubic3d !== undefined)
	{
		this.bSplineCubic3d.renderPoints(magoManager, shader, renderType);
	}
	
	if (this.sphere !== undefined)
	{
		this.sphere.render(magoManager, shader, renderType);
	}
	
	
	
};

/**
 * 어떤 일을 하고 있습니까?
 */
Modeler.prototype.createPlaneGrid = function(width, height, numCols, numRows) 
{
	// Test function.
	if (width === undefined)
	{ width = 500.0; }
	
	if (height === undefined)
	{ height = 500.0; }
	
	if (numCols === undefined)
	{ numCols = 50; }
	
	if (numRows === undefined)
	{ numRows = 50; }
	
	if (this.planeGrid === undefined)
	{
		this.planeGrid = new PlaneGrid(width, height, numCols, numRows);
	}
	
	
};













































'use strict';
// TEST OBJECT. NO USE THIS CLASS.***
// TEST OBJECT. NO USE THIS CLASS.***
// TEST OBJECT. NO USE THIS CLASS.***
// TEST OBJECT. NO USE THIS CLASS.***
// TEST OBJECT. NO USE THIS CLASS.***
/**
 * 어떤 일을 하고 있습니까?
 * @class ParametricMesh
 */
var ParametricMesh = function() 
{
	// TEST OBJECT. NO USE THIS CLASS.***
	
	if (!(this instanceof ParametricMesh)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.vtxProfilesList; // class: VtxProfilesList.
	this.profile; // class: Profile. is a 2d object.
	this.vboKeyContainer; // class: VBOVertexIdxCacheKeyContainer.
	this.vboKeyContainerEdges; // class: VBOVertexIdxCacheKeyContainer.
};

/**
 * Delete the data of this.profile
 */
ParametricMesh.prototype.deleteObjects = function() 
{
	// TEST OBJECT. NO USE THIS CLASS.***
	if (this.profile)
	{ this.profile.deleteObjects(); }
	
	this.profile = undefined;
};

/**
 * Get the vbo key container of this feature
 * @returns {VBOVertexIdxCacheKeysContaier}	
 */
ParametricMesh.prototype.getVboKeysContainer = function()
{
	// TEST OBJECT. NO USE THIS CLASS.***
	return this.vboKeyContainer;
};

/**
 * Get mesh of this instance
 * @param {Mesh} resultMesh
 * @param {Boolean} bIncludeBottomCap Check whether include the bottom of this revolved mesh ex) pipeline doesn't have bottom and top cap
 * @param {Boolean} bIncludeTopCap Check whether include the top of this revolved mesh ex) pipeline doesn't have bottom and top cap
 * @returns {Mesh}
 */
ParametricMesh.prototype.getMesh = function(resultMesh, bIncludeBottomCap, bIncludeTopCap)
{
	if (resultMesh === undefined)
	{ resultMesh = new Mesh(); }

	// must separate vbo groups by surfaces.
	resultMesh = this.vtxProfilesList.getMesh(resultMesh, bIncludeBottomCap, bIncludeTopCap);
	resultMesh.calculateVerticesNormals();
	
	return resultMesh;
};

/**
 * Change the unified mesh to the group of surfaces for drawing the mesh with WebGL
 * @param {Mesh} resultMesh
 * @param {Boolean} bIncludeBottomCap Check whether include the bottom of this revolved mesh ex) pipeline doesn't have bottom and top cap
 * @param {Boolean} bIncludeTopCap Check whether include the top of this revolved mesh ex) pipeline doesn't have bottom and top cap
 * 
 */
ParametricMesh.prototype.getSurfaceIndependentMesh = function(resultMesh, bIncludeBottomCap, bIncludeTopCap)
{
	if (resultMesh === undefined)
	{ resultMesh = new Mesh(); }

	// must separate vbo groups by surfaces.
	this.mesh = this.vtxProfilesList.getMesh(undefined, bIncludeBottomCap, bIncludeTopCap);
	resultMesh = this.mesh.getCopySurfaceIndependentMesh(resultMesh);
	resultMesh.calculateVerticesNormals();
	
	return resultMesh;
};

/**
 * Extrude the profile with curved direction
 * @param profile2d the profile which will be extruede
 * @param revolveAngDeg the angle of the vector used for extruding
 * @param revolveSegmentsCount the number of the segements which constitue of the extruded feature
 * @param revolveSegment2d rotating shaft
 * 
 */
ParametricMesh.prototype.revolve = function(profile2d, revolveAngDeg, revolveSegmentsCount, revolveSegment2d) 
{
	// TEST OBJECT. NO USE THIS CLASS.***
	// Note: move this function into "VtxProfilesList" class.
	if (profile2d === undefined)
	{ return undefined; }
	
	if (this.vtxProfilesList === undefined)
	{ this.vtxProfilesList = new VtxProfilesList(); }
	
	// if want caps in the extruded mesh, must calculate "ConvexFacesIndicesData" of the profile2d before creating vtxProfiles.
	this.vtxProfilesList.convexFacesIndicesData = profile2d.getConvexFacesIndicesData(undefined);
	//profile2d.checkNormals();
	// create vtxProfiles.
	// make the base-vtxProfile.
	var baseVtxProfile = this.vtxProfilesList.newVtxProfile();
	baseVtxProfile.makeByProfile2D(profile2d);
	
	var increAngDeg = revolveAngDeg/revolveSegmentsCount;
	
	// calculate the translation.
	var line2d = revolveSegment2d.getLine();
	var origin2d = new Point2D(0, 0);
	var translationVector = line2d.getProjectedPoint(origin2d);
	translationVector.inverse();
	
	var rotMat = new Matrix4();
	var quaternion = new Quaternion();
	var rotAxis2d = revolveSegment2d.getDirection();
	var rotAxis = new Point3D(rotAxis2d.x, rotAxis2d.y, 0);
	rotAxis.unitary();
	
	for (var i=0; i<revolveSegmentsCount; i++)
	{
		// calculate rotation.
		quaternion.rotationAngDeg(increAngDeg*(i+1), rotAxis.x, rotAxis.y, rotAxis.z);
		rotMat.rotationByQuaternion(quaternion);
		
		// test top profile.
		var nextVtxProfile = this.vtxProfilesList.newVtxProfile();
		nextVtxProfile.copyFrom(baseVtxProfile);
		nextVtxProfile.translate(translationVector.x, translationVector.y, 0);
		nextVtxProfile.transformPointsByMatrix4(rotMat);
		nextVtxProfile.translate(-translationVector.x, -translationVector.y, 0);
	}
};

/**
 * Make new instance which consist of the part of the extruded segment(The number of the segments is extrudeSegmentsCount) by extruding profile2D
 * @param {profile2D} profile2d the feature which will be extruded
 * @param {Number} extrusionDist the height of extruded feature
 * @param {Number} extrudeSegmentsCount the number of the segment which consist of extruded feature
 * @param {Point3D} extrusionVector the direction of extrusion
 */
ParametricMesh.prototype.extrude = function(profile2d, extrusionDist, extrudeSegmentsCount, extrusionVector) 
{
	// TEST OBJECT. NO USE THIS CLASS.***
	// Note: move this function into "VtxProfilesList" class.
	if (profile2d === undefined || extrusionDist === undefined)
	{ return undefined; }
	
	if (this.vtxProfilesList === undefined)
	{ this.vtxProfilesList = new VtxProfilesList(); }
	

	// if want caps in the extruded mesh, must calculate "ConvexFacesIndicesData" of the profile2d before creating vtxProfiles.
	this.vtxProfilesList.convexFacesIndicesData = profile2d.getConvexFacesIndicesData(undefined);
	
	// create vtxProfiles.
	// make the base-vtxProfile.
	var baseVtxProfile = this.vtxProfilesList.newVtxProfile();
	baseVtxProfile.makeByProfile2D(profile2d);
	
	if (extrusionVector === undefined)
	{ extrusionVector = new Point3D(0, 0, 1); }
	
	var increDist = extrusionDist/extrudeSegmentsCount;
	for (var i=0; i<extrudeSegmentsCount; i++)
	{
		// test with a 1 segment extrusion.
		var nextVtxProfile = this.vtxProfilesList.newVtxProfile();
		nextVtxProfile.copyFrom(baseVtxProfile);
		nextVtxProfile.translate(0, 0, increDist*(i+1));
	}
};




































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Path3D
 */
var Path3D = function(geographicCoordsArray) 
{
	if (!(this instanceof Path3D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.geoCoordsList;
	
	if (geographicCoordsArray !== undefined)
	{
		this.geoCoordsList = new GeographicCoordsList(geographicCoordsArray);
	}
	
	this.controlPointArmLength = 0.2;
	this.curvesArray;
	this.dirty = true;
	
};

/**
 * Returns the tangent line at "linearPosition" of the path. 
 */
Path3D.prototype.getTangent = function(linearPosition, resultTangentLine, magoManager)
{
	if (this.dirty)
	{
		if (this.curvesArray === undefined)
		{ this.curvesArray = []; }
	
		// Check segments length.***
		var maxLengthDegree = 0.001;
		Path3D.insertPointsOnLargeSegments(this.geoCoordsList.geographicCoordsArray, maxLengthDegree, magoManager);
		
		var coordsCount = this.geoCoordsList.geographicCoordsArray.length;
		for (var i=0; i<coordsCount; i++)
		{
			var geoCoord = this.geoCoordsList.geographicCoordsArray[i];
			var geoLocDataManager = geoCoord.getGeoLocationDataManager();
			var geoLocData = geoLocDataManager.newGeoLocationData("noName");
			geoLocData = ManagerUtils.calculateGeoLocationData(geoCoord.longitude, geoCoord.latitude, geoCoord.altitude, undefined, undefined, undefined, geoLocData, magoManager);
		}
		
		// Make bSpline.***
		var bSplineCubic3d = new BSplineCubic3D();
		this.curvesArray.push(bSplineCubic3d);
		
		bSplineCubic3d.geoCoordsList = this.geoCoordsList;
		bSplineCubic3d.geoCoordsList.makeLines(magoManager);
		
		// Make control points automatically.***
		var controlPointArmLength = this.controlPointArmLength; 
		bSplineCubic3d.makeControlPoints(controlPointArmLength, magoManager);
		
		this.dirty = false;
	}
	
	var bSplineCubic3d = this.curvesArray[0];
	var resultTangentLine = BSplineCubic3D.getTangent(bSplineCubic3d, linearPosition, resultTangentLine, magoManager);
	return resultTangentLine;
};


/**
 * Returns the geoLocDataManager 
 */
Path3D.prototype.getGeoLocationDataManager = function() 
{
	// Provisionally return the "geoLocDataManager" on the 1rst curve, that is a bSpline.***
	if (this.curvesArray === undefined || this.curvesArray.length === 0)
	{ return; }
	
	var bSplineCubic3d = this.curvesArray[0];
	if (bSplineCubic3d === undefined)
	{ return; }
	
	return bSplineCubic3d.knotPoints3dList.geoLocDataManager; // provisional.***
};

/**
 * Inserts points in large segments.
 */
Path3D.insertPointsOnLargeSegments = function(geographicCoordsArray, maxLengthDegree, magoManager)
{
	if (geographicCoordsArray === undefined)
	{ return; }
	
	var geoCoordsCount = geographicCoordsArray.length;
	for (var i=0; i<geoCoordsCount-1; i++)
	{
		var geoCoordA = geographicCoordsArray[i];
		var geoCoordB = geographicCoordsArray[i+1];
		var ang = GeographicCoord.getAngleBetweenCoords(geoCoordA, geoCoordB);
		if (ang > maxLengthDegree)
		{
			var midGeoCoord = GeographicCoord.getMidPoint(geoCoordA, geoCoordB, undefined);
			
			geographicCoordsArray.splice(i+1, 0, midGeoCoord);
			geoCoordsCount = geographicCoordsArray.length;
			i--;
		}
	}
	
};






















































'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class PipeKnot
 */
var PipeKnot = function() 
{
	if (!(this instanceof PipeKnot)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	// Position & curvatureRadius.***
	this.position;
	this.radius;
	
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class PipePath
 */
var PipePath = function(points3dArray) 
{
	if (!(this instanceof PipePath)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.pipeKnotsArray;
	this.dirty = true;
	
};

PipePath.make = function()
{
	
};
'use strict';

/**
 * PlaneGrid on 3D space. (Draw on the ground or plane in 3D space)
 * Now under implementation 
 * @class PlaneGrid
 */
var PlaneGrid = function(width, height, numCols, numRows) 
{
	if (!(this instanceof PlaneGrid)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	//this.plane; // plane 3d.
	this.geoLocDataManager;
	this.width;
	this.height;
	this.altitude = 0.0;
	this.numCols;
	this.numRows;
	this.vboKeysContainer;
	
	this.setSize(width, height, numCols, numRows);
};

/**
 * 어떤 일을 하고 있습니까?
 */
PlaneGrid.prototype.setSize = function(width, height, numCols, numRows) 
{
	if (width !== undefined)
	{ this.width = width; }
	
	if (height !== undefined)
	{ this.height = height; }
	
	if (numCols !== undefined)
	{ this.numCols = numCols; }
	
	if (numRows !== undefined)
	{ this.numRows = numRows; }
};

/**
 * 어떤 일을 하고 있습니까?
 */
PlaneGrid.prototype.render = function(magoManager, shader) 
{
	if (this.vboKeysContainer === undefined)
	{ return; }
	
	var gl = magoManager.sceneState.gl;
	var vboMemManager = magoManager.vboMemoryManager;
	
	// Set uniforms.
	var geoLoc = this.geoLocDataManager.getCurrentGeoLocationData();
	gl.uniformMatrix4fv(shader.buildingRotMatrix_loc, false, geoLoc.rotMatrix._floatArrays);
	gl.uniform3fv(shader.buildingPosHIGH_loc, geoLoc.positionHIGH);
	gl.uniform3fv(shader.buildingPosLOW_loc, geoLoc.positionLOW);
	
	gl.uniform1i(shader.refMatrixType_loc, 0); // in this case, there are not referencesMatrix.
	gl.uniform1i(shader.hasAditionalMov_loc, false);
	shader.disableVertexAttribArray(shader.texCoord2_loc); // Grid has no texCoords.
	
	gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
	gl.uniform4fv(shader.oneColor4_loc, [1.0, 1.0, 1.0, 1.0]);
	
	gl.uniform1i(shader.bApplySpecularLighting_loc, false); // turn off specular lighting.
	
	// disable All AttribPointer.
	shader.disableVertexAttribArrayAll(); // init.
	
	var vboKeysCount = this.vboKeysContainer.vboCacheKeysArray.length;
	for (var i=0; i<vboKeysCount; i++)
	{
		var vboKey = this.vboKeysContainer.vboCacheKeysArray[i];

		// Positions.
		if (vboKey.vboBufferPos!== undefined && !vboKey.bindDataPosition(shader, magoManager.vboMemoryManager))
		{ return false; }

		// Normals.
		if (vboKey.vboBufferNor!== undefined)
		{
			if (!vbo_vicky.bindDataNormal(shader, magoManager.vboMemoryManager))
			{ return false; }
		}
		else 
		{
			shader.disableVertexAttribArray(shader.normal3_loc);
		}

		// Colors.
		if (vboKey.vboBufferCol!== undefined)
		{
			if (!vbo_vicky.bindDataColor(shader, magoManager.vboMemoryManager))
			{ return false; }
		}
		else 
		{
			shader.disableVertexAttribArray(shader.color4_loc);
		}
		
		// TexCoords.
		if (vboKey.vboBufferTCoord!== undefined)
		{
			if (!vbo_vicky.bindDataTexCoord(shader, magoManager.vboMemoryManager))
			{ return false; }
		}
		else 
		{
			shader.disableVertexAttribArray(shader.texCoord2_loc);
		}
		
		//gl.drawElements(primitive, vboKey.indicesCount, gl.UNSIGNED_SHORT, 0);
		gl.drawArrays(gl.LINES, 0, vboKey.vertexCount);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
PlaneGrid.prototype.makeVbo = function(vboMemManager) 
{
	// Calculate positions.
	var halfWidth = this.width/2;
	var halfHeight = this.height/2;
	var alt = this.altitude;
	
	var leftDownPoint = new Point3D(-halfWidth, -halfHeight, alt);
	var rightDownPoint = new Point3D(halfWidth, -halfHeight, alt);
	var rightUpPoint = new Point3D(halfWidth, halfHeight, alt);
	var leftUpPoint = new Point3D(-halfWidth, halfHeight, alt);
	
	var increX = this.width/(this.numCols - 1);
	var increY = this.height/(this.numRows - 1);
	
	var pointsCount = this.numCols * 2 + this.numRows * 2;
	var positionsArray = new Float32Array(pointsCount*3);
	
	// Now, calculate all lines points.
	var x1, y1, z1;
	var x2, y2, z2;
	var idx = 0;
	
	// Vertical lines. "y" are constant.
	y1 = leftDownPoint.y; // down.
	y2 = leftUpPoint.y; // up.
	for (var col = 0; col < this.numCols; col++)
	{
		x1 = leftDownPoint.x + col * increX;
		x2 = x1;
		positionsArray[idx] = x1; idx++;
		positionsArray[idx] = y1; idx++;
		positionsArray[idx] = alt; idx++;
		positionsArray[idx] = x2; idx++;
		positionsArray[idx] = y2; idx++;
		positionsArray[idx] = alt; idx++;
	}
	
	// Horizontal lines.
	x1 = leftDownPoint.x; // left.
	x2 = rightDownPoint.x; // right.
	for (var row = 0; row < this.numRows; row++)
	{
		y1 = leftDownPoint.y + row * increY;
		y2 = y1;
		positionsArray[idx] = x1; idx++;
		positionsArray[idx] = y1; idx++;
		positionsArray[idx] = alt; idx++;
		positionsArray[idx] = x2; idx++;
		positionsArray[idx] = y2; idx++;
		positionsArray[idx] = alt; idx++;
	}
	
	if (this.vboKeysContainer === undefined)
	{ this.vboKeysContainer = new VBOVertexIdxCacheKeysContainer(); }
	
	var vbo = this.vboKeysContainer.newVBOVertexIdxCacheKey();
	vbo.setDataArrayPos(positionsArray, vboMemManager);
	
	
};


























































'use strict';
/**
* 어떤 일을 하고 있습니까?
* @class Point2D
*/
var Point2D = function(x, y) 
{
	if (!(this instanceof Point2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	if (x) { this.x = x; }
	else { this.x = 0.0; }
	if (y) { this.y = y; }
	else { this.y = 0.0; }
	
	this.ownerVertex3d; // Aux var. This will be used for this : this Point2D is the projected ownerVertex3d into 2D
	
	/**associated this property will be used to save topologic information */
	this.associated;
};

/**
 * delete the value of x and y coordi
 */
Point2D.prototype.deleteObjects = function() 
{
	this.x = undefined;
	this.y = undefined;
};

/**
 * set the value of the property 'associated'
 * @param {Point2D} associated
 */
Point2D.prototype.setAssociated = function(associated) 
{
	// aux test.
	this.associated.x = associated.x;
	this.associated.y = associated.y;
};

/**
 * get the value of the property 'associated'
 * @returns {Point2D} this.associated
 */
Point2D.prototype.getAssociated = function() 
{
	// aux test.
	return this.associated;	
};

/**
 * copy the value of other point
 * @param {Point2D} point2d
 */
Point2D.prototype.copyFrom = function(point2d) 
{
	this.x = point2d.x;
	this.y = point2d.y;
};

/**
 * change the sign of the values of point inversely
 */
Point2D.prototype.inverse = function() 
{
	this.x = -this.x;
	this.y = -this.y;
};

/**
 * set the value of x,y coordi of the point
 * @param {Number} x
 * @param {Number} y
 */
Point2D.prototype.set = function(x, y) 
{
	this.x = x;
	this.y = y;
};

Point2D.prototype.getX = function()
{
	return this.x;
};
Point2D.prototype.getY = function()
{
	return this.y;
};

/**
 * return the result of calculating (this.x*this.x + this.y*this.y) 
 * @returns this.x*this.x + this.y*this.y;
 */
Point2D.prototype.getSquaredModul = function() 
{
	return this.x*this.x + this.y*this.y;
};

/**
 * return the result of calculating Math.sqrt(this.x*this.x + this.y*this.y);
 * @returns Math.sqrt(this.x*this.x + this.y*this.y);
 */
Point2D.prototype.getModul = function() 
{
	return Math.sqrt(this.getSquaredModul());
};

/**
 * 
 * make unitary of the point
 */
Point2D.prototype.unitary = function() 
{
	var modul = this.getModul();
	this.x /= modul;
	this.y /= modul;
};

/**
 * Check whether the given line is parallel to this line or not
 * @param {Point2D} point
 * @returns {Boolean}
 */
Point2D.prototype.isParallelToPoint = function(point, err) 
{
	if (point === undefined)
	{ return false; }
	var zero = defaultValue(err, 10E-10);
	var angRad = this.angleRadToVector(point);
	
	// if angle is zero or 180 degree, then this is parallel to "line".
	if (angRad < zero || Math.abs(angRad - Math.PI) < zero)
	{ return true; }
	
	return false;
};

/**
 * prepare to calculate the Euclidean distance between this point and the other point.
 * @param {Number} point
 * @returns dx*dx + dy*dy
 */
Point2D.prototype.squareDistToPoint = function(point) 
{
	var dx = this.x - point.x;
	var dy = this.y - point.y;

	return dx*dx + dy*dy;
};

/**
 * calculate the Euclidean distance between this point and the other point.
 * @param {Point2D} point the target
 * @returns the calculated Euclidan distance
 */
Point2D.prototype.distToPoint = function(point) 
{
	return Math.sqrt(this.squareDistToPoint(point));
};

/**
 * returns a perpendicular vector to left
 * @param {Point2D} resultPoint
 * @returns {Point2D} resultPoint
 */
Point2D.prototype.getLeft = function(resultPoint) 
{
	if (resultPoint === undefined)
	{ resultPoint = new Point2D(); }
	
	resultPoint.set(-this.y, this.x);
	return resultPoint;
};

/**
 * returns a perpendicular vector to right
 * @param {Point2D} resultPoint
 * @returns {Point2D} resultPoint
 */
Point2D.prototype.getRight = function(resultPoint) 
{
	if (resultPoint === undefined)
	{ resultPoint = new Point2D(); }
	
	resultPoint.set(this.y, -this.x);
	return resultPoint;
};

/**
 * Check whether this point and the other point are overlapped(coincident) or not 
 * @param {Point2D} point the point which will be checked whether the two points are coincident or not
 * @param {Number} errorDist allowed error range value of calculating distance. It can be from 0.1mm to 10E-8
 * @returns {Boolean} the flag which let us know whether they are coincident or not 
 */
Point2D.prototype.isCoincidentToPoint = function(point, errorDist) 
{
	var squareDist = this.distToPoint(point);
	var coincident = false;
	if (squareDist < errorDist*errorDist)
	{
		coincident = true;
	}

	return coincident;
};

/**
 * @param {Point2D} targetPoint this returns a vector that points to "targetPoint" from "this" 
 * @param {Point3D} resultVector the "resultVector" has the direction from "this" to "targetPoint", but is NOT normalized.
 * @returns {Point3D} resultVector
 */
Point2D.prototype.getVectorToPoint = function(targetPoint, resultVector) 
{
	if (targetPoint === undefined)
	{ return undefined; }
	
	if (resultVector === undefined)
	{ resultVector = new Point2D(); }
	
	resultVector.set(targetPoint.x - this.x, targetPoint.y - this.y);
	
	return resultVector;
};

/**
 * Calculate vector product
 * @param {Point2D} point the point which will be used at this calculate.
 * @returns {Number} calculated result
 */
Point2D.prototype.crossProduct = function(point) 
{
	return this.x * point.y - point.x * this.y;
};

/**
 * Calculate scalar production of vector
 * @param {Point2D} point the point which will be used at this calculate.
 * @returns {Number} calculated result
 */
Point2D.prototype.scalarProduct = function(point) 
{
	var scalarProd = this.x*point.x + this.y*point.y;
	return scalarProd;
};

/**
 * Calculate the radian value of the angle of the two vectors
 * @param vector the target vector
 * @returns the angle of two vector
 */
Point2D.prototype.angleRadToVector = function(vector) 
{
	if (vector === undefined)
	{ return undefined; }
	
	//
	//var scalarProd = this.scalarProduct(vector);
	var myModul = this.getModul();
	var vecModul = vector.getModul();
	
	// calcule by cos.
	//var cosAlfa = scalarProd / (myModul * vecModul); 
	//var angRad = Math.acos(cosAlfa);
	//var angDeg = alfa * 180.0/Math.PI;
	//------------------------------------------------------
	var error = 10E-10;
	if (myModul < error || vecModul < error)
	{ return undefined; }
	
	return Math.acos(this.scalarProduct(vector) / (myModul * vecModul));
};

/**
 * Calculate the degree value of the angle of the two vectors
 * @param point 변수
 * @param resultPoint 변수
 * @returns resultPoint
 */
Point2D.prototype.angleDegToVector = function(vector) 
{
	if (vector === undefined)
	{ return undefined; }
	
	var angRad = this.angleRadToVector(vector);
	
	if (angRad === undefined)
	{ return undefined; }
		
	return angRad * 180.0/Math.PI;
};

















































'use strict';
/**
* Contain the list of the features of Point2D
* @class Point2DList
*/
var Point2DList = function() 
{
	if (!(this instanceof Point2DList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.pointsArray;
};

/**
 * Clear this.pointsArray of this feature
 */
Point2DList.prototype.deleteObjects = function()
{
	if (this.pointsArray === undefined)
	{ return; }
	
	var pointsCount = this.pointsArray.length;
	for (var i=0; i<pointsCount; i++)
	{
		this.pointsArray[i].deleteObjects();
		this.pointsArray[i] = undefined;
	}
	this.pointsArray = undefined;
};

/**
 * Add a feature of Point2D at the last of this.pointsArray
 * @param {Point2D} point2d the point that will be pushed at this.pointsArray
 */
Point2DList.prototype.addPoint = function(point2d)
{
	if (point2d === undefined)
	{ return; }
	
	if (this.pointsArray === undefined)
	{ this.pointsArray = []; }

	this.pointsArray.push(point2d);
};

/**
 * Create a new feature of Point2D
 * @param {Number} x the x coordi of the point
 * @param {Number} y the y coordi of the point
 * @returns {Point2D} return the created point
 */
Point2DList.prototype.newPoint = function(x, y)
{
	if (this.pointsArray === undefined)
	{ this.pointsArray = []; }
	
	var point = new Point2D(x, y);
	this.pointsArray.push(point);
	return point;
};

/**
 * delete Point2D by condition
 * @param {function} condition must return boolean type
 */
Point2DList.prototype.deletePointByCondition = function(condition)
{	
	this.pointsArray = this.findPointArray(condition);;
};

/**
 * find Point2D by condition
 * @param {function} condition must return boolean type
 * @return {Point2DList} return the find point
 */
Point2DList.prototype.findPointArray = function(condition)
{
	var that = this;
	var arr = that.pointsArray.filter(function(point)
	{
		return condition.call(that, point);
	});

	return arr;
};
/**
 * Search and return the specific feature of Point2D with the index that has at this.pointArray
 * @param {Number} idx the index of the target point at this.pointArray
 * 
 */
Point2DList.prototype.getPoint = function(idx)
{
	return this.pointsArray[idx];
};

/**
 * Return the length of this.pointArray
 * @returns {Number}
 */
Point2DList.prototype.getPointsCount = function()
{
	if (this.pointsArray === undefined)
	{ return 0; }
	
	return this.pointsArray.length;
};

/**
 * This function is used when this feature is a point2DRing.
 * Return the previous index of the given index.
 * @param {Number} idx the target index
 * @param {Number} prevIdx
 */
Point2DList.prototype.getPrevIdx = function(idx)
{
	var pointsCount = this.pointsArray.length;
	var prevIdx;
	
	if (idx === 0)
	{ prevIdx = pointsCount - 1; }
	else
	{ prevIdx = idx - 1; }

	return prevIdx;
};

/**
 * This function is used when this feature is a point2DRing.
 * Return the next index of the given index
 * @param {Number} idx the target index
 * @param {Number} nexIndx
 */
Point2DList.prototype.getNextIdx = function(idx)
{
	var pointsCount = this.pointsArray.length;
	var nextIdx;
	
	if (idx === pointsCount - 1)
	{ nextIdx = 0; }
	else
	{ nextIdx = idx + 1; }

	return nextIdx;
};

/**
 * Get the index of the given point
 * @param {Point2D} point
 * @returns {Number} idx the index of the target point at this.pointArray
 */
Point2DList.prototype.getIdxOfPoint = function(point)
{
	var pointsCount = this.pointsArray.length;
	var i=0;
	var idx = -1;
	var found = false;
	while (!found && i<pointsCount)
	{
		if (this.pointsArray[i] === point)
		{
			found = true;
			idx = i;
		}
		i++;
	}
	
	return idx;
};

/**
 * get the segement with the index of the segment
 * @param {Number} idx the index of start point of segment
 * @param {Segment2D} resultSegment the segement which will store the result segment
 * @returns {Segment2D} resultSegment 
 * 
 */
Point2DList.prototype.getSegment = function(idx, resultSegment)
{
	var currPoint = this.getPoint(idx);
	var nextIdx = this.getNextIdx(idx);
	var nextPoint = this.getPoint(nextIdx);
	
	if (resultSegment === undefined)
	{ resultSegment = new Segment2D(currPoint, nextPoint); }
	else 
	{
		resultSegment.setPoints(currPoint, nextPoint);
	}

	return resultSegment;
};

/**
 * 
 */
Point2DList.prototype.setIdxInList = function()
{
	var pointsCount = this.pointsArray.length;
	for (var i=0; i<pointsCount; i++)
	{
		this.pointsArray[i].idxInList = i;
	}
};

/**
 * Copy the target Point2dList from this.arrayList
 */
Point2DList.prototype.getCopy = function(resultPoint2dList) 
{
	if (resultPoint2dList === undefined)
	{ resultPoint2dList = new Point2DList(); }
	else
	{ resultPoint2dList.deleteObjects(); }
	
	var myPoint, copyPoint;
	var pointsCount = this.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		myPoint = this.getPoint(i);
		copyPoint = resultPoint2dList.newPoint(myPoint.x, myPoint.y);
	}
	
	return resultPoint2dList;
};

/**
 * Calculate the bounding box of this point2DList
 * @param {BoundingRectangle} resultBoundingRectangle the BoundingRectangle which will be calculated
 * @returns {BoundingRectanble} resultPoint
 */
Point2DList.prototype.getBoundingRectangle = function(resultBoundingRectangle) 
{
	var pointsCount = this.getPointsCount();
	if (pointsCount === 0)
	{ return resultBoundingRectangle; }
	
	if (resultBoundingRectangle === undefined)
	{ resultBoundingRectangle = new BoundingRectangle(); }
	
	var point;
	for (var i=0; i<pointsCount; i++)
	{
		if (i === 0)
		{ resultBoundingRectangle.setInit(this.getPoint(i)); }
		else
		{ resultBoundingRectangle.addPoint(this.getPoint(i)); }
	}
	
	return resultBoundingRectangle;
};

/**
 * Calculate and return the point in this.pointArray which is the nearest point of the target point
 * @param point the target point
 * @param resultPoint the nearest point from the target point
 * @returns {Point2D} resultPoint
 */
Point2DList.prototype.getNearestPointIdxToPoint = function(point) 
{
	if (point === undefined)
	{ return undefined; }
	
	var currPoint, candidatePointIdx;
	var currSquaredDist, candidateSquaredDist;
	var pointsCount = this.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		currPoint = this.getPoint(i);
		currSquaredDist = currPoint.squareDistToPoint(point);
		if (candidatePointIdx === undefined)
		{
			candidatePointIdx = i;
			candidateSquaredDist = currSquaredDist;
		}
		else 
		{
			if (currSquaredDist < candidateSquaredDist)
			{
				candidatePointIdx = i;
				candidateSquaredDist = currSquaredDist;
			}
		}
	}
	
	return candidatePointIdx;
};

/**
 * Reverse the order of this.pointArray
 */
Point2DList.prototype.reverse = function() 
{
	if (this.pointsArray !== undefined)
	{ this.pointsArray.reverse(); }
};

/**
 * Sort the points in this.pointArray as the distance from thePoint
 * @param {Point2D} thePoint the target point
 * @param resultSortedPointsIndxArray the target pointArray
 * @TODO : need to change the name of this function. So confused.
 * @result resultSortedPointsIdexArray sorted array
 */
Point2DList.prototype.getPointsIdxSortedByDistToPoint = function(thePoint, resultSortedPointsIdxArray)
{
	if (this.pointsArray === undefined)
	{ return resultSortedPointsIdxArray; }
	
	// Static function.
	// Sorting minDist to maxDist.
	if (resultSortedPointsIdxArray === undefined)
	{ resultSortedPointsIdxArray = []; }
	
	var pointsArray = this.pointsArray;
	
	var objectAux;
	var objectsAuxArray = [];
	var point;
	var squaredDist;
	var startIdx, endIdx, insertIdx;
	var pointsCount = pointsArray.length;
	for (var i=0; i<pointsCount; i++)
	{
		point = pointsArray[i];
		if (point === thePoint)
		{ continue; }
		
		squaredDist = thePoint.squareDistToPoint(point);
		objectAux = {};
		objectAux.pointIdx = i;
		objectAux.squaredDist = squaredDist;
		startIdx = 0;
		endIdx = objectsAuxArray.length - 1;
		
		insertIdx = this.getIndexToInsertBySquaredDist(objectsAuxArray, objectAux, startIdx, endIdx);
		objectsAuxArray.splice(insertIdx, 0, objectAux);
	}
	
	resultSortedPointsIdxArray.length = 0;
	var objectsCount = objectsAuxArray.length;
	for (var i=0; i<objectsCount; i++)
	{
		resultSortedPointsIdxArray.push(objectsAuxArray[i].pointIdx);
	}
	
	return resultSortedPointsIdxArray;
};

/**
 * this do a dicotomic search of idx in a ordered table.
 * @param objectsArray 
 * @param {Point2D} object the target point
 * @param {Number} startIdx the start index of objectsArray
 * @param {Number} endIdx the end index of objectsArray
 * @returns {Number} result_idx the index of object in objectsArray
 * 
 */
Point2DList.prototype.getIndexToInsertBySquaredDist = function(objectsArray, object, startIdx, endIdx) 
{
	// 
	// 1rst, check the range.
	
	var range = endIdx - startIdx;
	
	if (objectsArray.length === 0)
	{ return 0; }
	
	if (range < 6)
	{
		// in this case do a lineal search.
		var finished = false;
		var i = startIdx;
		var idx;
		//var objectsCount = objectsArray.length;
		while (!finished && i<=endIdx)
		{
			if (object.squaredDist < objectsArray[i].squaredDist)
			{
				idx = i;
				finished = true;
			}
			i++;
		}
		
		if (finished)
		{
			return idx;
		}
		else 
		{
			return endIdx+1;
		}
	}
	else // in this case do the dicotomic search. (Binary search)
	{		
		var middleIdx = startIdx + Math.floor(range/2);
		var newStartIdx;
		var newEndIdx;
		if (objectsArray[middleIdx].squaredDist > object.squaredDist)
		{
			newStartIdx = startIdx;
			newEndIdx = middleIdx;
		}
		else 
		{
			newStartIdx = middleIdx;
			newEndIdx = endIdx;
		}
		return this.getIndexToInsertBySquaredDist(objectsArray, object, newStartIdx, newEndIdx);
	}
};

/**
 * This function expands a point2dString or point2dRing.
 * @param {Array} originalPoints2dArray The points2d array that want to expand.
 * @param {Array} resultPoints2dArray The result points2d array.
 * @param {Number} leftExpandDist The expansion distance in the left side.
 * @param {Number} rightExpandDist The expansion distance in the right side.
 * @param {Boolean} bLoop If true, the points2dArray is a ring, else is a string.
 * 
 */
Point2DList.getExpandedPoints = function(originalPoints2dArray, resultPoints2dArray, leftExpandDist, rightExpandDist, bLoop) 
{
	// Function used by basicFactory to make roof profile, for example.
	
	//                                                                        
	//                                                                        
	//                                                           4            
	//                                                         /    \                        
	//                                                       /        \                      
	//                                                     /            \               
	//                                                   /                \            
	//                  1               ==>            /         1          \                       
	//                /   \                          /         /   \          \             
	//              /       \                      /         /       \          \           
	//            /           \                  5         /           \          3
	//          /               \                \       /               \      /
	//        /                   \                \   /                   \  /
	//      2                       0                0                       2
	//
	
	if (originalPoints2dArray === undefined)
	{ return; }

	if (resultPoints2dArray === undefined)
	{ resultPoints2dArray = []; }
	
	var leftSidePointsArray = [];
	var rightSidePointsArray = [];
	
	var pointsCount = originalPoints2dArray.length;
	var prevSegment = new Segment2D(undefined, undefined);
	var currSegment = new Segment2D(undefined, undefined);

	var currIdx;
	var nextIdx;
	var prevIdx;
	
	var currPoint;
	var nextPoint;
	var prevPoint;
	
	var currLine;
	var prevLine;
	
	var currLeftLine;
	var prevLeftLine;
	
	var currRightLine;
	var prevRightLine;
	
	var perpendicularLeftLine;
	
	if (bLoop === undefined)
	{ bLoop = false; }
	
	if (bLoop)
	{
		for (var i=0; i<pointsCount; i++)
		{
			// TODO:
		}
	}
	else 
	{
		for (var i=0; i<pointsCount; i++)
		{
			currPoint = originalPoints2dArray[i];
			currIdx = i;
			
			if (currIdx === 0)
			{
				// In this case, translate perpendicularly the original point to left & right side.***
				nextIdx = GeometryUtils.getNextIdx(currIdx, pointsCount);
				nextPoint = originalPoints2dArray[nextIdx];

				currSegment.setPoints(currPoint, nextPoint);
				currLine = currSegment.getLine(currLine);
				perpendicularLeftLine = currLine.getPerpendicularLeft(); // Must be perpendicular.***
				
				// Left side point.***
				var leftPoint = new Point2D(currPoint.x + perpendicularLeftLine.direction.x*leftExpandDist, currPoint.y + perpendicularLeftLine.direction.y*leftExpandDist);
				leftSidePointsArray.push(leftPoint);
				
				// Right side point.***
				var rightPoint = new Point2D(currPoint.x - perpendicularLeftLine.direction.x*rightExpandDist, currPoint.y - perpendicularLeftLine.direction.y*rightExpandDist);
				rightSidePointsArray.push(rightPoint);
			}
			else if (currIdx === pointsCount-1)
			{
				// In this case, translate perpendicularly the original point to left & right side.***
				prevIdx = GeometryUtils.getPrevIdx(currIdx, pointsCount);
				prevPoint = originalPoints2dArray[prevIdx];
				
				currSegment.setPoints(prevPoint, currPoint);
				currLine = currSegment.getLine(currLine);
				perpendicularLeftLine = currLine.getPerpendicularLeft(); // Must be perpendicular.***
				
				// Left side point.***
				var leftPoint = new Point2D(currPoint.x + perpendicularLeftLine.direction.x*leftExpandDist, currPoint.y + perpendicularLeftLine.direction.y*leftExpandDist);
				leftSidePointsArray.push(leftPoint);
				
				// Right side point.***
				var rightPoint = new Point2D(currPoint.x - perpendicularLeftLine.direction.x*rightExpandDist, currPoint.y - perpendicularLeftLine.direction.y*rightExpandDist);
				rightSidePointsArray.push(rightPoint);
			}
			else 
			{
				nextIdx = GeometryUtils.getNextIdx(currIdx, pointsCount);
				prevIdx = GeometryUtils.getPrevIdx(currIdx, pointsCount);
				
				nextPoint = originalPoints2dArray[nextIdx];
				prevPoint = originalPoints2dArray[prevIdx];
				
				prevSegment.setPoints(prevPoint, currPoint);
				currSegment.setPoints(currPoint, nextPoint);
				
				prevLine = prevSegment.getLine(prevLine);
				currLine = currSegment.getLine(currLine);
				
				// Left side point.***
				prevLeftLine = prevLine.getParallelLeft(leftExpandDist);
				currLeftLine = currLine.getParallelLeft(leftExpandDist);
				
				var leftPoint = prevLeftLine.intersectionWithLine(currLeftLine, undefined);
				leftSidePointsArray.push(leftPoint);
				
				// Right side point.***
				prevRightLine = prevLine.getParallelRight(rightExpandDist);
				currRightLine = currLine.getParallelRight(rightExpandDist);
				
				var rightPoint = prevRightLine.intersectionWithLine(currRightLine, undefined);
				rightSidePointsArray.push(rightPoint);
			}
			
		}
		
		// Now, reverse leftSidePointsArray.***
		leftSidePointsArray.reverse();
		resultPoints2dArray = leftSidePointsArray.concat(rightSidePointsArray);
	}
	
	return resultPoints2dArray;
};
















































'use strict';

/**
 * a point feature which will be used at three degree world
 * @class Point3D 
 * @param {Number} x 
 * @param {Number} y 
 * @param {Number} z 
 */

var Point3D = function(x, y, z) 
{
	if (!(this instanceof Point3D)) 
	{
		// throw new Error(Messages.CONSTRUCT_ERROR);
		throw new Error(i18next.t('error.construct.create'));
	}

	if (x !== undefined)
	{ this.x = x; }
	else
	{ this.x = 0.0; }
	
	if (y !== undefined)
	{ this.y = y; }
	else
	{ this.y = 0.0; }
	
	if (z !== undefined)
	{ this.z = z; }
	else
	{ this.z = 0.0; }
	
	this.pointType; // 1 = important point.
};

/**
 * delete the value of x,y,z coordi
 */
Point3D.prototype.deleteObjects = function() 
{
	this.x = undefined;
	this.y = undefined;
	this.z = undefined;
};

/**
 * copy the value of other point
 * @param {Point3D} point3d
 */
Point3D.prototype.copyFrom = function(point3d) 
{
	this.x = point3d.x;
	this.y = point3d.y;
	this.z = point3d.z;
};

/**
 * Calculate [this.x*this.x + this.y*this.y + this.z*this.z] to prepare squared module 
 * @returns {Number}
 */
Point3D.prototype.getSquaredModul = function() 
{
	return this.x*this.x + this.y*this.y + this.z*this.z;
};

/**
 * Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z );
 * @returns {Number}
 */
Point3D.prototype.getModul = function() 
{
	return Math.sqrt(this.getSquaredModul());
};

/**
 * 
 * get the unitary value
 */
Point3D.prototype.unitary = function() 
{
	var modul = this.getModul();
	this.x /= modul;
	this.y /= modul;
	this.z /= modul;
};

/**
 * 
 * check whether each value of the coordi is null or not
 * @returns {Boolean}
 */
Point3D.prototype.isNAN = function() 
{
	if (isNaN(this.x) || isNaN(this.y) || isNaN(this.z) )
	{ return true; }
	else
	{ return false; }
};

/**
 * Calculate vector product
 * @param {Point3D} point the point which will be used at this calculate.
 * @param {Point3D} resultPoint the point which will save the calculated value.
 * @returns {Number} calculated result
 */
Point3D.prototype.crossProduct = function(point, resultPoint) 
{
	if (resultPoint === undefined) { resultPoint = new Point3D(); }

	resultPoint.x = this.y * point.z - point.y * this.z;
	resultPoint.y = point.x * this.z - this.x * point.z;
	resultPoint.z = this.x * point.y - point.x * this.y;

	return resultPoint;
};

/**
 * Calculate scalar production of vector
 * @param {Point3D} point the point which will be used at this calculate.
 * @returns {Number} calculated result
 */
Point3D.prototype.scalarProduct = function(point) 
{
	var scalarProd = this.x*point.x + this.y*point.y + this.z*point.z;
	return scalarProd;
};

/**
 * get the spherical coordinates
 * @param {GeographicCoord}resultGeographicCoords the target that will be canged
 * @returns {GeographicCoord} resultGeographicCoords
 */
Point3D.prototype.getSphericalCoords = function(resultGeographicCoords) 
{
	if (resultGeographicCoords === undefined)
	{ resultGeographicCoords = new GeographicCoord(); }
	
	// heading.
	var xyProjectedPoint = new Point2D(this.x, this.y);
	var longitudeVectorRef = new Point2D(1.0, 0.0);
	var headingDeg = xyProjectedPoint.angleDegToVector(longitudeVectorRef);
	
	if (this.y < 0.0)
	{
		headingDeg = 360.0 - headingDeg;
	}
	
	// azimutal.meridian angle
	var projectedModul = xyProjectedPoint.getModul();
	var azimutRad = Math.atan(this.z/projectedModul);
	var azimutDeg = azimutRad * 180.0 / Math.PI;
	
	if (this.z < 0.0)
	{
		azimutDeg *= -1.0;
	}
	
	resultGeographicCoords.longitude = headingDeg;
	resultGeographicCoords.latitude = azimutDeg;
	
	return resultGeographicCoords;
};

/**
 * Check whether those of two vectors are parallel or not
 * If parallel then check whether the direction sense is same or not 
 */
Point3D.prototype.getRelativeOrientationToVector = function(vector, radError) 
{
	var angRad = this.angleRadToVector(vector);
	if (angRad < radError)
	{ return 0; } // there are parallel & the same direction sense.
	else if (Math.abs(Math.PI - angRad) < radError)
	{ return 1; } // there are parallel & opposite direction sense.
	else
	{ return 2; } // there are NO parallels.
};

/**
 * Calculate the radian value of the angle of the two vectors
 * @param vector the target vector
 * @returns the angle of two vector
 */
Point3D.prototype.angleRadToVector = function(vector) 
{
	if (vector === undefined)
	{ return undefined; }
	
	//
	//var scalarProd = this.scalarProd(vector);
	var myModul = this.getModul();
	var vecModul = vector.getModul();
	
	// calculate by cos.
	//var cosAlfa = scalarProd / (myModul * vecModul); 
	//var angRad = Math.acos(cosAlfa);
	//var angDeg = alfa * 180.0/Math.PI;
	//------------------------------------------------------
	var error = 10E-10;
	if (myModul < error || vecModul < error)
	{ return undefined; }
	
	return Math.acos(this.scalarProduct(vector) / (myModul * vecModul));
};

/**
 * Calculate the degree value of the angle of the two vectors
 * @param point 변수
 * @param resultPoint 변수
 * @returns resultPoint
 */
Point3D.prototype.angleDegToVector = function(vector) 
{
	if (vector === undefined)
	{ return undefined; }
	
	var angRad = this.angleRadToVector(vector);
	
	if (angRad === undefined)
	{ return undefined; }
		
	return angRad * 180.0/Math.PI;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @returns dx*dx + dy*dy + dz*dz
 */
Point3D.prototype.squareDistToPoint = function(point) 
{
	var dx = this.x - point.x;
	var dy = this.y - point.y;
	var dz = this.z - point.z;

	return dx*dx + dy*dy + dz*dz;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 * @returns dx*dx + dy*dy + dz*dz
 */
Point3D.prototype.isCoincidentToPoint = function(point, errorDist) 
{
	var squareDist = this.distToPoint(point);
	var coincident = false;
	if (squareDist < errorDist*errorDist)
	{
		coincident = true;
	}

	return coincident;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 * @returns dx*dx + dy*dy + dz*dz
 */
Point3D.prototype.isCoincidentToPointCHEAP = function(point, errorDist) 
{
	if (Math.abs(this.x - point.x) > errorDist)
	{ return false; }
	
	if (Math.abs(this.y - point.y) > errorDist)
	{ return false; }
	
	if (Math.abs(this.z - point.z) > errorDist)
	{ return false; }
	
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 * @returns dx*dx + dy*dy + dz*dz
 */
Point3D.prototype.squareDistTo = function(x, y, z) 
{
	var dx = this.x - x;
	var dy = this.y - y;
	var dz = this.z - z;

	return dx*dx + dy*dy + dz*dz;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 * @returns dx*dx + dy*dy + dz*dz
 */
Point3D.prototype.distTo = function(x, y, z) 
{
	return Math.sqrt(this.squareDistTo(x, y, z));
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 * @returns dx*dx + dy*dy + dz*dz
 */
Point3D.prototype.distToPoint = function(point) 
{
	return Math.sqrt(this.squareDistToPoint(point));
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 * @returns dx*dx + dy*dy + dz*dz
 */
Point3D.prototype.distToSphere = function(sphere) 
{
	return Math.sqrt(this.squareDistToPoint(sphere.centerPoint)) - sphere.r;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param px 변수
 * @param py 변수
 * @param pz 변수
 * @returns dx*dx + dy*dy + dz*dz
 */
Point3D.prototype.aproxDistTo = function(pointB, sqrtTable) 
{
	var difX = Math.abs(this.x - pointB.x);
	var difY = Math.abs(this.y - pointB.y);
	var difZ = Math.abs(this.z - pointB.z);
	
	// find the big value.
	var maxValue, value1, value2;
	var value1Idx, value2Idx;
	
	if (difX > difY)
	{
		if (difX > difZ)
		{
			maxValue = difX;
			value1 = difY/maxValue;
			value1Idx = Math.floor(value1*10);
			var middleDist = maxValue * sqrtTable[value1Idx];
			value2 = difZ/middleDist;
			value2Idx = Math.floor(value2*10);
			return (middleDist * sqrtTable[value2Idx]);
		}
		else 
		{
			maxValue = difZ;
			value1 = difX/maxValue;
			value1Idx = Math.floor(value1*10);
			var middleDist = maxValue * sqrtTable[value1Idx];
			value2 = difY/middleDist;
			value2Idx = Math.floor(value2*10);
			return (middleDist * sqrtTable[value2Idx]);
		}
	}
	else 
	{
		if (difY > difZ)
		{
			maxValue = difY;
			value1 = difX/maxValue;
			value1Idx = Math.floor(value1*10);
			var middleDist = maxValue * sqrtTable[value1Idx];
			value2 = difZ/middleDist;
			value2Idx = Math.floor(value2*10);
			return (middleDist * sqrtTable[value2Idx]);
		}
		else 
		{
			maxValue = difZ;
			value1 = difX/maxValue;
			value1Idx = Math.floor(value1*10);
			var middleDist = maxValue * sqrtTable[value1Idx];
			value2 = difY/middleDist;
			value2Idx = Math.floor(value2*10);
			return (middleDist * sqrtTable[value2Idx]);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 */
Point3D.prototype.getVectorToPoint = function(targetPoint, resultVector) 
{
	// this returns a vector that points to "targetPoint" from "this".
	// the "resultVector" has the direction from "this" to "targetPoint", but is NOT normalized.
	if (targetPoint === undefined)
	{ return undefined; }
	
	if (resultVector === undefined)
	{ resultVector = new Point3D(); }
	
	resultVector.set(targetPoint.x - this.x, targetPoint.y - this.y, targetPoint.z - this.z);
	
	return resultVector;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 */
Point3D.prototype.set = function(x, y, z) 
{
	this.x = x; this.y = y; this.z = z;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 */
Point3D.prototype.readDataFromBuffer = function(dataArrayBuffer, bytesReaded) 
{
	this.x = (new Float32Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	this.y = (new Float32Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	this.z = (new Float32Array(dataArrayBuffer.slice(bytesReaded, bytesReaded+4)))[0]; bytesReaded += 4;
	return bytesReaded;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 */
Point3D.prototype.add = function(x, y, z) 
{
	this.x += x; this.y += y; this.z += z;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 */
Point3D.prototype.addPoint = function(point) 
{
	this.x += point.x; this.y += point.y; this.z += point.z;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param x 변수
 * @param y 변수
 * @param z 변수
 */
Point3D.prototype.scale = function(scaleFactor) 
{
	this.x *= scaleFactor; this.y *= scaleFactor; this.z *= scaleFactor;
};































'use strict';
/**
* Contain the list of the features of Point3D
* @class Point3DList
*/
var Point3DList = function(points3dArray) 
{
	if (!(this instanceof Point3DList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.pointsArray;
	if (points3dArray !== undefined)
	{ this.pointsArray = points3dArray; }
	
	this.bLoop; //check whether this Point3DList represents just LineString or Ring
	
	this.geoLocDataManager;//This contains the information to change this point to Absolute CRS
	this.vboKeysContainer;//This saves the key which GPU returns to VBO
};
/**
 * Clear the properties of this feature
 */
Point3DList.prototype.deleteObjects = function(magoManager)
{
	this.deletePoints3d();
	this.deleteVboKeysContainer(magoManager);
	
	if (this.geoLocDataManager !== undefined)
	{
		this.geoLocDataManager.deleteObjects();
		this.geoLocDataManager = undefined;
	}
};

/**
 * Clear vboKeysContainer
*/
Point3DList.prototype.deleteVboKeysContainer = function(magoManager)
{
	if (this.vboKeysContainer !== undefined)
	{
		var gl = magoManager.sceneState.gl;
		this.vboKeysContainer.deleteGlObjects(gl, magoManager.vboMemoryManager);
		this.vboKeysContainer = undefined;
	}
};
/**
 * Clear this.pointsArray of this feature
 * 
 */
Point3DList.prototype.deletePoints3d = function()
{
	if (this.pointsArray === undefined)
	{ return; }
	
	var pointsCount = this.pointsArray.length;
	for (var i=0; i<pointsCount; i++)
	{
		this.pointsArray[i].deleteObjects();
		this.pointsArray[i] = undefined;
	}
	this.pointsArray = undefined;
};
/**
 * Add a feature of Point3D at the last of this.pointsArray
 * @param {Point3D} point3d the point that will be pushed at this.pointsArray
 */
Point3DList.prototype.addPoint = function(point3d)
{
	if (point3d === undefined)
	{ return; }
	
	if (this.pointsArray === undefined)
	{ this.pointsArray = []; }

	this.pointsArray.push(point3d);
};

/**
 * Return the coordinate contained at geoLocDataManager
 * @returns geoLoc
 */
Point3DList.prototype.getGeographicLocation = function()
{
	if (this.geoLocDataManager === undefined)
	{ this.geoLocDataManager = new GeoLocationDataManager(); }
	
	var geoLoc = this.geoLocDataManager.getCurrentGeoLocationData();
	if (geoLoc === undefined)
	{
		geoLoc = this.geoLocDataManager.newGeoLocationData("default");
	}
	
	return geoLoc;
};
/**
 * Add a list of Point3D at the last of this.pointsArray
 * @param point3dArray the point that will be pushed at this.pointsArray
 */
Point3DList.prototype.addPoint3dArray = function(points3dArray)
{
	if (this.pointsArray === undefined)
	{ this.pointsArray = []; }

	this.pointsArray.push.apply(this.pointsArray, points3dArray);
};
/**
 * Create a new feature of Point3D
 * @param {Number} x the x coordi of the point
 * @param {Number} y the y coordi of the point
 * @param {Number} z the z coordi of the point
 * @returns {Point3D} return the created point
 */
Point3DList.prototype.newPoint = function(x, y, z)
{
	if (this.pointsArray === undefined)
	{ this.pointsArray = []; }
	
	var point = new Point3D(x, y, z);
	this.pointsArray.push(point);
	return point;
};
/**
 * Search and return the specific feature of Point2D with the index that has at this.pointArray
 * @param {Number} idx the index of the target point at this.pointArray
 * 
 */
Point3DList.prototype.getPoint = function(idx)
{
	return this.pointsArray[idx];
};
/**
 * Return the length of this.pointArray
 * @returns {Number}
 */
Point3DList.prototype.getPointsCount = function()
{
	if (this.pointsArray === undefined)
	{ return 0; }
	
	return this.pointsArray.length;
};

/**
 * This function is used when this feature is a point3DRing.
 * Return the previous index of the given index.
 * @param {Number} idx the target index
 * @returns {Number} prevIdx
 */
Point3DList.prototype.getPrevIdx = function(idx)
{
	// Note: This function is used when this is a point3dLoop.
	var pointsCount = this.pointsArray.length;
	var prevIdx;
	
	if (idx === 0)
	{ prevIdx = pointsCount - 1; }
	else
	{ prevIdx = idx - 1; }

	return prevIdx;
};
/**
 * This function is used when this is a point3dLoop.
 * @param {Number} idx the index of the target point at this.pointArray
  * @returns {Number} prevIdx
 */
Point3DList.prototype.getNextIdx = function(idx)
{
	
	var pointsCount = this.pointsArray.length;
	var nextIdx;
	
	if (idx === pointsCount - 1)
	{ nextIdx = 0; }
	else
	{ nextIdx = idx + 1; }

	return nextIdx;
};

/**
 * get the segement with the index of the segment
 * @param {Number} idx the index of start point of segment
 * @param {Segment3D} resultSegment the segement which will store the result segment
 * @returns {Segment3D} resultSegment 
 * 
 */
Point3DList.prototype.getSegment3D = function(idx, resultSegment3d, bLoop)
{
	// If "bLoop" = true, then this points3dList is a loop.
	// If "bLoop" = false, then this points3dList is a string.
	if (bLoop === undefined)
	{ bLoop = false; }
	
	var pointsCount = this.getPointsCount();
	
	if (!bLoop && idx === pointsCount-1)
	{ return undefined; }
	
	var currPoint = this.getPoint(idx);
	var nextIdx = this.getNextIdx(idx);
	var nextPoint = this.getPoint(nextIdx);
	
	if (resultSegment3d === undefined)
	{ resultSegment3d = new Segment3D(currPoint, nextPoint); }
	else 
	{
		resultSegment3d.setPoints(currPoint, nextPoint);
	}
	
	return resultSegment3d;
};

/**
 * This function returns a line3d that is tangent of a point(idx). 
 * The tangentLine has the same angle with prevSegment & currSegment.
 * The tangentLine is coincident with the plane defined by prevSegment & currSegment.
 * If "bLoop" = true, then this points3dList is a loop.
 * If "bLoop" = false, then this points3dList is a string.
 * @param {Number} idx index of the point3D which will define the tangentLine3d
 * @param {Line} resultTangentLine3d
 * @param {Boolean} bLoop save the information whether this point3DList is ring or not
 * @result {Line} resultTangentLine3d a line3d that is tangent of a point(idx).
 */
Point3DList.prototype.getTangentLine3D = function(idx, resultTangentLine3d, bLoop)
{
	// The tangentLine has the same direction that the normal of the BisectionPlane.***
	if (resultTangentLine3d === undefined)
	{ resultTangentLine3d = new Line(); }
	
	var point3d = this.getPoint(idx);
	var bisectionPlane = this.getBisectionPlane(idx, undefined, bLoop);
	var direction = bisectionPlane.getNormal();
	resultTangentLine3d.setPointAndDir( point3d.x, point3d.y, point3d.z, direction.x, direction.y, direction.z );
	
	return resultTangentLine3d;
};

/**
 * This function returns a plane that has the same angle with the 2 segments of a point(idx).
 * If "bLoop" = true, then this points3dList is a loop.
 * If "bLoop" = false, then this points3dList is a string.
 * @param {Number} idx index of the point3D which will define bisection plane
 * @param {Plane} resultBisectionPlane
 * @param {Boolean} bLoop save the information whether this point3DList is ring or not
 * @result {Plane} resultBisectionPlane a plane that has the same angle with the 2 segments of a point
 */
Point3DList.prototype.getBisectionPlane = function(idx, resultBisectionPlane, bLoop)
{
	if (bLoop === undefined)
	{ bLoop = false; }
	
	var pointsCount = this.getPointsCount();
	
	if (pointsCount < 1)
	{ return resultBisectionPlane; }
	
	if (resultBisectionPlane === undefined)
	{ resultBisectionPlane = new Plane(); }
	
	var point3d = this.getPoint(idx);
	var segment3d_A, segment3d_B;
	
	if (!bLoop)
	{
		if (idx === pointsCount-1)
		{
			// The last point is an exception in string mode.
			// Take the previous segment.
			var idxPrev = idx-1;
			segment3d_A = this.getSegment3D(idxPrev, undefined, bLoop);	
			segment3d_B = this.getSegment3D(idxPrev, undefined, bLoop);	
		}
		else if (idx === 0)
		{
			segment3d_A = this.getSegment3D(idx, undefined, bLoop);	
			segment3d_B = this.getSegment3D(idx, undefined, bLoop);
		}
		else
		{
			var idxPrev = idx-1;
			segment3d_A = this.getSegment3D(idx, undefined, bLoop);	
			segment3d_B = this.getSegment3D(idxPrev, undefined, bLoop);	
		}
	}
	else 
	{
		var idxPrev = this.getPrevIdx(idx);
		segment3d_A = this.getSegment3D(idx, undefined, bLoop);
		segment3d_B = this.getSegment3D(idxPrev, undefined, bLoop);	
	}
	
	var dirA = segment3d_A.getDirection();
	var dirB = segment3d_B.getDirection();
	dirA.addPoint(dirB);
	dirA.unitary;
	
	// Now, with "point3d" & "dir" make the plane.
	resultBisectionPlane.setPointAndNormal(point3d.x, point3d.y, point3d.z, dirA.x, dirA.y, dirA.z);
	
	return resultBisectionPlane;
};

/**
 * Make the vbo of this point3DList
 * @param magoManager
 */
Point3DList.getVbo = function(magoManager, point3dArray, resultVboKeysContainer)
{
	if (!point3dArray || point3dArray.length === 0) 
	{
		return;
	}
	if (resultVboKeysContainer === undefined)
	{ resultVboKeysContainer = new VBOVertexIdxCacheKeysContainer(); }
	
	var pointsCount = point3dArray.length;
	var posByteSize = pointsCount * 3;
	var posVboDataArray = new Float32Array(posByteSize);
	var point3d;
	for (var i=0; i<pointsCount; i++)
	{
		point3d = point3dArray[i];
		posVboDataArray[i*3] = point3d.x;
		posVboDataArray[i*3+1] = point3d.y;
		posVboDataArray[i*3+2] = point3d.z;
	}
	
	var vbo = resultVboKeysContainer.newVBOVertexIdxCacheKey();
	vbo.setDataArrayPos(posVboDataArray, magoManager.vboMemoryManager);
	return resultVboKeysContainer;
};

/**
 * Make the vbo of this point3DList
 * @param magoManager
 */
Point3DList.getVboThickLines = function(magoManager, point3dArray, resultVboKeysContainer, options)
{
	if (point3dArray === undefined || point3dArray.length < 2)
	{ return resultVboKeysContainer; }

	if (resultVboKeysContainer === undefined)
	{ resultVboKeysContainer = new VBOVertexIdxCacheKeysContainer(); }

	var pointsCount = point3dArray.length;

	// in this case make point4d (x, y, z, w). In "w" save the sign (1 or -1) for the offset in the shader to draw triangles strip.
	var repeats = 4;
	var pointDimension = 4;
	var posByteSize = pointsCount * pointDimension * repeats;
	var posVboDataArray = new Float32Array(posByteSize);
	
	var point3d;

	for (var i=0; i<pointsCount; i++)
	{
		point3d = point3dArray[i];
		posVboDataArray[i*16] = point3d.x;
		posVboDataArray[i*16+1] = point3d.y;
		posVboDataArray[i*16+2] = point3d.z;
		posVboDataArray[i*16+3] = 1; // order.
		
		posVboDataArray[i*16+4] = point3d.x;
		posVboDataArray[i*16+5] = point3d.y;
		posVboDataArray[i*16+6] = point3d.z;
		posVboDataArray[i*16+7] = -1; // order.
		
		posVboDataArray[i*16+8] = point3d.x;
		posVboDataArray[i*16+9] = point3d.y;
		posVboDataArray[i*16+10] = point3d.z;
		posVboDataArray[i*16+11] = 2; // order.
		
		posVboDataArray[i*16+12] = point3d.x;
		posVboDataArray[i*16+13] = point3d.y;
		posVboDataArray[i*16+14] = point3d.z;
		posVboDataArray[i*16+15] = -2; // order.
	}
	
	// Check if must make color vbo.
	var strColor4 = new Color(0.6, 0.9, 0.99, 1.0);
	var endColor4 = new Color(0.6, 0.9, 0.99, 1.0);
	
	var colVboDataArray;
	var makeColorVbo = false;
	if (options)
	{
		if (options.color)
		{
			strColor4.setRGBA(options.color.r, options.color.g, options.color.b, options.color.a);
			endColor4.setRGBA(options.color.r, options.color.g, options.color.b, options.color.a);
		}
		
		if (options.startColor)
		{
			strColor4.setRGBA(options.startColor.r, options.startColor.g, options.startColor.b, options.startColor.a);
			makeColorVbo = true;
		}
		
		if (options.endColor)
		{
			endColor4.setRGBA(options.endColor.r, options.endColor.g, options.endColor.b, options.endColor.a);
			makeColorVbo = true;
		}
	}
	
	// Make the color vbo if necessary.
	if (makeColorVbo)
	{
		colVboDataArray = new Uint8Array(pointsCount * 4 * repeats);
		
		var currColor4 = new Color(0.6, 0.9, 0.99, 1.0);
		currColor4.copyFrom(strColor4);
		var w = 1.0; // weight.***
		var r, g, b, a;
		for (var i=0; i<pointsCount; i++)
		{
			w = 1.0 - (i/(pointsCount-1));
			currColor4 = Color.mix(strColor4, endColor4, w);
			
			colVboDataArray[i*16] = Math.floor(currColor4.r*255);
			colVboDataArray[i*16+1] = Math.floor(currColor4.g*255);
			colVboDataArray[i*16+2] = Math.floor(currColor4.b*255);
			colVboDataArray[i*16+3] = Math.floor(currColor4.a*255);
			
			colVboDataArray[i*16+4] = Math.floor(currColor4.r*255);
			colVboDataArray[i*16+5] = Math.floor(currColor4.g*255);
			colVboDataArray[i*16+6] = Math.floor(currColor4.b*255);
			colVboDataArray[i*16+7] = Math.floor(currColor4.a*255);
			
			colVboDataArray[i*16+8] = Math.floor(currColor4.r*255);
			colVboDataArray[i*16+9] = Math.floor(currColor4.g*255);
			colVboDataArray[i*16+10] = Math.floor(currColor4.b*255);
			colVboDataArray[i*16+11] = Math.floor(currColor4.a*255);
			
			colVboDataArray[i*16+12] = Math.floor(currColor4.r*255);
			colVboDataArray[i*16+13] = Math.floor(currColor4.g*255);
			colVboDataArray[i*16+14] = Math.floor(currColor4.b*255);
			colVboDataArray[i*16+15] = Math.floor(currColor4.a*255);
		}
	}
	var vbo = resultVboKeysContainer.newVBOVertexIdxCacheKey();
	vbo.setDataArrayPos(posVboDataArray, magoManager.vboMemoryManager, pointDimension);
	
	if (colVboDataArray)
	{
		vbo.setDataArrayCol(colVboDataArray, magoManager.vboMemoryManager);
	}
	
	return resultVboKeysContainer;
};

/**
 * Make the vbo of this point3DList
 * @param magoManager
 */
Point3DList.prototype.makeVbo = function(magoManager)
{
	if (!this.pointsArray || this.pointsArray.length === 0) 
	{
		return;
	}
	
	this.vboKeysContainer = Point3DList.getVbo(magoManager, this.pointsArray, this.vboKeysContainer);
};

/**
 * Render this point3dlist using vbo of this list. 
 * @param magoManager
 * @param shader 
 * @param renderType
 * @param bLoop 
 * @param bEnableDepth if this is turned off, then the last-drawing feature will be shown at the top
 */
Point3DList.prototype.render = function(magoManager, shader, renderType, glPrimitive, options)
{
	if (this.vboKeysContainer === undefined)
	{ 
		this.makeVbo(magoManager); 
		return;
	}
	var gl = magoManager.getGl();
	shader.enableVertexAttribArray(shader.position3_loc);
	var bEnableDepth;
	if (bEnableDepth === undefined)
	{ bEnableDepth = true; }
	
	if (bEnableDepth)
	{ gl.enable(gl.DEPTH_TEST); }
	else
	{ gl.disable(gl.DEPTH_TEST); }

	var refMatrixType = 0;
	gl.uniform1i(shader.hasAditionalMov_loc, false);
	gl.uniform1i(shader.refMatrixType_loc, refMatrixType);
	gl.uniform4fv(shader.oneColor4_loc, [1.0, 0.0, 0.0, 0.7]);
	gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.

	// Render the line.
	var buildingGeoLocation = this.geoLocDataManager.getCurrentGeoLocationData();
	buildingGeoLocation.bindGeoLocationUniforms(gl, shader);
	
	if (renderType === 2)
	{
		var selectionManager = magoManager.selectionManager;
		var selectionColor = magoManager.selectionColor;

		var selColor = selectionColor.getAvailableColor(undefined); 
		var idxKey = selectionColor.decodeColor3(selColor.r, selColor.g, selColor.b);

		selectionManager.setCandidateGeneral(idxKey, this);
		gl.uniform4fv(shader.oneColor4_loc, [selColor.r/255.0, selColor.g/255.0, selColor.b/255.0, 1.0]);
	}
	
	var vbo_vicky = this.vboKeysContainer.vboCacheKeysArray[0]; // there are only one.
	if (!vbo_vicky.bindDataPosition(shader, magoManager.vboMemoryManager))
	{ return false; }

	gl.drawArrays(gl.POINTS, 0, vbo_vicky.vertexCount);
	
	// Check if exist selectedGeoCoord.
	/*
	var currSelected = magoManager.selectionManager.getSelectedGeneral();
	if(currSelected !== undefined && currSelected.constructor.name === "GeographicCoord")
	{
		gl.uniform4fv(shader.oneColor4_loc, [1.0, 0.1, 0.1, 1.0]); //.
		gl.uniform1f(shader.fixPointSize_loc, 10.0);
		currSelected.renderPoint(magoManager, shader, gl, renderType);
	}
	*/
	
	gl.enable(gl.DEPTH_TEST);
};

/**
 * Render this point3dlist using vbo of this list. 
 * @param magoManager
 * @param shader 
 * @param renderType
 * @param bLoop 
 * @param bEnableDepth if this is turned off, then the last-drawing feature will be shown at the top
 */
Point3DList.prototype.renderAsChild = function(magoManager, shader, renderType, glPrimitive, options)
{
	if (this.vboKeysContainer === undefined)
	{ 
		this.makeVbo(magoManager); 
		return;
	}
	var gl = magoManager.getGl();
	shader.enableVertexAttribArray(shader.position3_loc);
	shader.disableVertexAttribArray(shader.normal3_loc);
	var bEnableDepth;
	if (bEnableDepth === undefined)
	{ bEnableDepth = true; }
	
	if (bEnableDepth)
	{ gl.enable(gl.DEPTH_TEST); }
	else
	{ gl.disable(gl.DEPTH_TEST); }

	var refMatrixType = 0;
	gl.uniform1i(shader.hasAditionalMov_loc, false);
	gl.uniform1i(shader.refMatrixType_loc, refMatrixType);
	gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
	
	if (renderType === 2)
	{
		var selectionManager = magoManager.selectionManager;
		var selectionColor = magoManager.selectionColor;

		var selColor = selectionColor.getAvailableColor(undefined); 
		var idxKey = selectionColor.decodeColor3(selColor.r, selColor.g, selColor.b);

		selectionManager.setCandidateGeneral(idxKey, this);
		gl.uniform4fv(shader.oneColor4_loc, [selColor.r/255.0, selColor.g/255.0, selColor.b/255.0, 1.0]);
	}
	
	var vbo_vicky = this.vboKeysContainer.vboCacheKeysArray[0]; // there are only one.
	if (!vbo_vicky.bindDataPosition(shader, magoManager.vboMemoryManager))
	{ return false; }

	gl.drawArrays(gl.POINTS, 0, vbo_vicky.vertexCount);
	
	// Check if exist selectedGeoCoord.
	/*
	var currSelected = magoManager.selectionManager.getSelectedGeneral();
	if(currSelected !== undefined && currSelected.constructor.name === "GeographicCoord")
	{
		gl.uniform4fv(shader.oneColor4_loc, [1.0, 0.1, 0.1, 1.0]); //.
		gl.uniform1f(shader.fixPointSize_loc, 10.0);
		currSelected.renderPoint(magoManager, shader, gl, renderType);
	}
	*/
	
	gl.enable(gl.DEPTH_TEST);
};

/**
 * Render this point3dlist using vbo of this list. 
 * @param magoManager
 * @param shader 
 * @param renderType
 * @param bEnableDepth if this is turned off, then the last-drawing feature will be shown at the top
 */
Point3DList.prototype.renderThickLines__element = function(magoManager, shader, renderType, bEnableDepth, options)
{
	if (this.vboKeysContainer === undefined)
	{ return; }

	if (this.geoLocDataManager === undefined)
	{ return; }
	
	var vbo = this.vboKeysContainer.getVboKey(0);
	
	// based on https://weekly-geekly.github.io/articles/331164/index.html
	var shader = magoManager.postFxShadersManager.getShader("thickLine");
	shader.useProgram();
	shader.bindUniformGenerals();
	var gl = magoManager.getGl();
	gl.enable(gl.BLEND);
	gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
	gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
	gl.disable(gl.CULL_FACE);
	
	gl.enableVertexAttribArray(shader.prev_loc);
	gl.enableVertexAttribArray(shader.current_loc);
	gl.enableVertexAttribArray(shader.next_loc);
	gl.enableVertexAttribArray(shader.order_loc);
	
	var orderLoc = gl.getAttribLocation(shader.program, "order");
	
	var geoLocData = this.geoLocDataManager.getCurrentGeoLocationData();
	geoLocData.bindGeoLocationUniforms(gl, shader);

	var sceneState = magoManager.sceneState;
	var projMat = sceneState.projectionMatrix;
	var viewMat = sceneState.modelViewMatrix;
	var drawingBufferWidth = sceneState.drawingBufferWidth;
	var drawingBufferHeight = sceneState.drawingBufferHeight;
	
	this.thickness = 10.0;
	
	gl.uniform4fv(shader.color_loc, [0.5, 0.7, 0.9, 1.0]);
	gl.uniform2fv(shader.viewport_loc, [drawingBufferWidth[0], drawingBufferHeight[0]]);
	gl.uniform1f(shader.thickness_loc, this.thickness);

	var vboPos = vbo.vboBufferPos;
	var dim = vboPos.dataDimensions; // in this case dimensions = 4.
	if (!vboPos.isReady(gl, magoManager.vboMemoryManager))
	{
		return;
	}
	
	// New.**********************
	
	gl.bindBuffer(gl.ARRAY_BUFFER, vboPos.key);
	gl.vertexAttribPointer(shader.prev_loc, dim, gl.FLOAT, false, 0, 0);
	gl.vertexAttribPointer(shader.current_loc, dim, gl.FLOAT, false, 0, 12);
	gl.vertexAttribPointer(shader.next_loc, dim, gl.FLOAT, false, 0, 24);

	var vboOrder = vbo.getVboCustom("thickLineOrder");
	if (!vboOrder.isReady(gl, magoManager.vboMemoryManager))
	{
		return;
	}
	gl.bindBuffer(gl.ARRAY_BUFFER, vboOrder.key);
	gl.vertexAttribPointer(shader.order_loc, vboOrder.dataDimensions, gl.FLOAT, false, 0, 0);

	var indicesCount = vbo.indicesCount;
	if (!vbo.bindDataIndice(shader, magoManager.vboMemoryManager))
	{ return false; }

	gl.disable(gl.DEPTH_TEST);
	//gl.drawElements(gl.TRIANGLE_STRIP, indicesCount, gl.UNSIGNED_SHORT, 0); // Fill.
	gl.drawElements(gl.LINE_STRIP, indicesCount, gl.UNSIGNED_SHORT, 0); // Fill.
	//gl.drawArrays(gl.TRIANGLE_STRIP, 0, vbo.vertexCount-4);
	gl.enable(gl.DEPTH_TEST);
	
	
	// old.**********************************************************************************************
	//gl.bindBuffer(gl.ARRAY_BUFFER, vboPos.key);
	//gl.vertexAttribPointer(shader.prev_loc, dim, gl.FLOAT, false, 16, 0);
	//gl.vertexAttribPointer(shader.current_loc, dim, gl.FLOAT, false, 16, 64-32);
	//gl.vertexAttribPointer(shader.next_loc, dim, gl.FLOAT, false, 16, 128-32);
	
	//gl.drawArrays(gl.TRIANGLE_STRIP, 0, vbo.vertexCount-4);

	// End old.-------------------------------------------------------------------------------------------
	

	gl.enable(gl.CULL_FACE);
	gl.disable(gl.BLEND);
};

/**
 * Render this point3dlist using vbo of this list. 
 * @param magoManager
 * @param shader 
 * @param renderType
 * @param bEnableDepth if this is turned off, then the last-drawing feature will be shown at the top
 */
Point3DList.prototype.renderThickLines = function(magoManager, shader, renderType, bEnableDepth, options)
{
	if (this.vboKeysContainer === undefined)
	{ return; }

	if (this.geoLocDataManager === undefined)
	{ return; }
	
	var vbo = this.vboKeysContainer.getVboKey(0);
	
	// based on https://weekly-geekly.github.io/articles/331164/index.html
	var shader = magoManager.postFxShadersManager.getShader("thickLine");
	shader.useProgram();
	shader.bindUniformGenerals();
	var gl = magoManager.getGl();

	gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
	gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
	gl.disable(gl.CULL_FACE);
	
	gl.enableVertexAttribArray(shader.prev_loc);
	gl.enableVertexAttribArray(shader.current_loc);
	gl.enableVertexAttribArray(shader.next_loc);
	
	var geoLocData = this.geoLocDataManager.getCurrentGeoLocationData();
	geoLocData.bindGeoLocationUniforms(gl, shader);

	var sceneState = magoManager.sceneState;
	var projMat = sceneState.projectionMatrix;
	var viewMat = sceneState.modelViewMatrix;
	var drawingBufferWidth = sceneState.drawingBufferWidth;
	var drawingBufferHeight = sceneState.drawingBufferHeight;
	
	this.thickness = 3.0;
	
	gl.uniform4fv(shader.color_loc, [0.5, 0.7, 0.9, 1.0]);
	gl.uniform2fv(shader.viewport_loc, [drawingBufferWidth[0], drawingBufferHeight[0]]);
	gl.uniform1f(shader.thickness_loc, this.thickness);

	var vboPos = vbo.vboBufferPos;
	var dim = vboPos.dataDimensions; // in this case dimensions = 4.
	if (!vboPos.isReady(gl, magoManager.vboMemoryManager))
	{
		return;
	}

	gl.bindBuffer(gl.ARRAY_BUFFER, vboPos.key);
	gl.vertexAttribPointer(shader.prev_loc, dim, gl.FLOAT, false, 16, 0);
	gl.vertexAttribPointer(shader.current_loc, dim, gl.FLOAT, false, 16, 64-32);
	gl.vertexAttribPointer(shader.next_loc, dim, gl.FLOAT, false, 16, 128-32);

	gl.drawArrays(gl.TRIANGLE_STRIP, 0, vbo.vertexCount-4);

	gl.enable(gl.CULL_FACE);
};

/**
 * Render this point3dlist using vbo of this list. 
 * @param magoManager
 * @param shader 
 * @param renderType
 * @param bLoop 
 * @param bEnableDepth if this is turned off, then the last-drawing feature will be shown at the top
 */
Point3DList.prototype.renderLines = function(magoManager, shader, renderType, bLoop, bEnableDepth)
{
	if (this.pointsArray === undefined)
	{ return false; }

	if (this.geoLocDataManager === undefined)
	{ return false; }
	
	var gl = magoManager.sceneState.gl;
	
	if (this.vboKeysContainer === undefined || this.vboKeysContainer.getVbosCount() === 0)
	{
		this.makeVbo(magoManager);
		return;
	}

	shader.enableVertexAttribArray(shader.position3_loc);
	
	if (bEnableDepth === undefined)
	{ bEnableDepth = true; }
	
	if (bEnableDepth)
	{ gl.enable(gl.DEPTH_TEST); }
	else
	{ gl.disable(gl.DEPTH_TEST); }

	// Render the line.
	var buildingGeoLocation = this.geoLocDataManager.getCurrentGeoLocationData();
	buildingGeoLocation.bindGeoLocationUniforms(gl, shader);
	
	if (renderType === 2)
	{
		var selectionManager = magoManager.selectionManager;
		var selectionColor = magoManager.selectionColor;

		var selColor = selectionColor.getAvailableColor(undefined); 
		var idxKey = selectionColor.decodeColor3(selColor.r, selColor.g, selColor.b);

		selectionManager.setCandidateGeneral(idxKey, this);
		gl.uniform4fv(shader.oneColor4_loc, [selColor.r/255.0, selColor.g/255.0, selColor.b/255.0, 1.0]);
	}
	
	var vbo_vicky = this.vboKeysContainer.vboCacheKeysArray[0]; // there are only one.
	if (!vbo_vicky.bindDataPosition(shader, magoManager.vboMemoryManager))
	{ return false; }

	gl.drawArrays(gl.LINE_STRIP, 0, vbo_vicky.vertexCount);
	
	// Check if exist selectedGeoCoord.
	/*
	var currSelected = magoManager.selectionManager.getSelectedGeneral();
	if(currSelected !== undefined && currSelected.constructor.name === "GeographicCoord")
	{
		gl.uniform4fv(shader.oneColor4_loc, [1.0, 0.1, 0.1, 1.0]); //.
		gl.uniform1f(shader.fixPointSize_loc, 10.0);
		currSelected.renderPoint(magoManager, shader, gl, renderType);
	}
	*/
	
	gl.enable(gl.DEPTH_TEST);
};

Point3DList.prototype.renderPoints = function(magoManager)
{
	
};











































'use strict';

/**
 * 4차원 정보
 * @class Point4D
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @param {Number} w
 */
var Point4D = function(x, y, z, w) 
{
	if (!(this instanceof Point4D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	if (x !== undefined)
	{ this.x = x; }
	else
	{ this.x = 0.0; }
	
	if (y !== undefined)
	{ this.y = y; }
	else
	{ this.y = 0.0; }
	
	if (z !== undefined)
	{ this.z = z; }
	else
	{ this.z = 0.0; }
	
	if (w !== undefined)
	{ this.w = w; }
	else
	{ this.w = 0.0; }
	
	this.pointType; // 1 = important point.
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Polygon2D
 */
var Polygon2D = function() 
{
	if (!(this instanceof Polygon2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	// This is a 2D polygon.
	this.point2dList; // the border of this feature
	this.normal; // Polygon2D sense. (normal = 1) -> CCW. (normal = -1) -> CW.
	this.convexPolygonsArray; // tessellation result.
	this.bRect; // boundary rectangle.
};

Polygon2D.prototype.deleteObjects = function()
{
	if (this.point2dList !== undefined)
	{
		this.point2dList.deleteObjects();
		this.point2dList = undefined;
	}
	
	this.normal = undefined;
};

Polygon2D.prototype.getBoundingRectangle = function(resultBRect)
{
	if (this.point2dList === undefined)
	{ return resultBRect; }
	
	resultBRect = this.point2dList.getBoundingRectangle(resultBRect);
	return resultBRect;
};
/**
 * get the direction of the specific line segment of the edge
 * @param {Number} idx the index of the specific line segment
 * @returns {Point2D} direction	
 */
Polygon2D.prototype.getEdgeDirection = function(idx)
{
	// the direction is unitary vector.
	var segment = this.point2dList.getSegment(idx);
	var direction = segment.getDirection(undefined);
	return direction;
};

/**
 * get the vector of the specigic line segement of the edge
 * @param {Number} index the index of the specific line segment
 * @returns vector
 */
Polygon2D.prototype.getEdgeVector = function(idx)
{
	var segment = this.point2dList.getSegment(idx);
	var vector = segment.getVector(undefined);
	return vector;
};

/**
 * reverse the direction sense of this polygon
 */
Polygon2D.prototype.reverseSense = function()
{
	if (this.point2dList !== undefined)
	{ this.point2dList.reverse(); }
};

/**
 * copy the information of the other polygon to this polygon
 * @param {Polygon2D} resultCopyPolygon
 * @returns {Polygon2D} resultCopyPolygon
 */
Polygon2D.prototype.getCopy = function(resultCopyPolygon)
{
	if (this.point2dList === undefined)
	{ return resultCopyPolygon; }
	
	if (resultCopyPolygon === undefined)
	{ resultCopyPolygon = new Polygon2D(); }
	
	// copy the point2dList and the normal.
	if (resultCopyPolygon.point2dList === undefined)
	{ resultCopyPolygon.point2dList = new Point2DList(); }
	
	resultCopyPolygon.point2dList = this.point2dList.getCopy(resultCopyPolygon.point2dList);
	
	if (this.normal)
	{ resultCopyPolygon.normal = this.normal; }
	
	return resultCopyPolygon;
};

/**
 * Calculate the normal vector of this polygon
 * @param resultConcavePointsIdxArray save the index of the points which make concave at the border
 * @returns resultFConcavePointsIdxArray the list of the index which make concave at the border
 */
Polygon2D.prototype.calculateNormal = function(resultConcavePointsIdxArray)
{
	// must check if the verticesCount is 3. Then is a convex polygon.
	
	// A & B are vectors.
	// A*B is scalarProduct.
	// A*B = |A|*|B|*cos(alfa)
	var point;
	var crossProd;
	
	if (resultConcavePointsIdxArray === undefined)
	{ resultConcavePointsIdxArray = []; }
	
	//var candidate_1 = {}; // normal candidate 1.
	//var candidate_2 = {}; // normal candidate 2.
	
	this.normal = 0; // unknown sense.
	var pointsCount = this.point2dList.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		point = this.point2dList.getPoint(i);
		var prevIdx = this.point2dList.getPrevIdx(i);
		
		// get unitari directions of the vertex.
		var startVec = this.getEdgeDirection(prevIdx); // Point2D.
		var endVec = this.getEdgeDirection(i); // Point2D.
		
		// calculate the cross product.
		var crossProd = startVec.crossProduct(endVec, crossProd); // Point2D.
		var scalarProd = startVec.scalarProduct(endVec);
		
		if (crossProd < 0.0) 
		{
			crossProd = -1;
			resultConcavePointsIdxArray.push(i);
		}
		else if (crossProd > 0.0) 
		{
			crossProd = 1;
		}
		else
		{ continue; }
		// calcule by cos.
		// cosAlfa = scalarProd / (strModul * endModul); (but strVecModul = 1 & endVecModul = 1), so:
		var cosAlfa = scalarProd;
		var alfa = Math.acos(cosAlfa);
		this.normal += (crossProd * alfa);
	}
	
	if (this.normal > 0 )
	{ this.normal = 1; }
	else
	{ this.normal = -1; }
	
	return resultConcavePointsIdxArray;
};

/**
 * Make the tessellate of the triangles which originally make up single Polygon2D feature (like a patchwork with triangle)
 * To call this function, before must call "calculateNormal" that returns "concaveVerticesIndices"
 * In 2D, "normal" is -1=(cw) or 1=(ccw).
 * @param concaveVerticesIndices the index of the points which make concave
 * @param convexPolygonsArray the index of the points which make convex
 */
Polygon2D.prototype.tessellate = function(concaveVerticesIndices, convexPolygonsArray)
{
	var concaveVerticesCount = concaveVerticesIndices.length;
	
	if (concaveVerticesCount === 0)
	{
		convexPolygonsArray.push(this);
		return convexPolygonsArray;
	}
	
	// now, for any concave vertex, find the closest vertex to split the polygon.
	var find = false;
	var idx_B;
	var i=0;
	
	while (!find && i<concaveVerticesCount)
	{
		var idx = concaveVerticesIndices[i];
		var point = this.point2dList.getPoint(idx);
		var resultSortedPointsIdxArray = [];
		
		// get vertices indices sorted by distance to "point".
		this.getPointsIdxSortedByDistToPoint(point, resultSortedPointsIdxArray);
		
		var sortedVerticesCount = resultSortedPointsIdxArray.length;
		var j=0;
		while (!find && j<sortedVerticesCount)
		{
			idx_B = resultSortedPointsIdxArray[j];
			
			// skip adjacent vertices.
			if (this.point2dList.getPrevIdx(idx) === idx_B || this.point2dList.getNextIdx(idx) === idx_B)
			{
				j++;
				continue;
			}
			
			// check if is splittable by idx-idx_B.
			var segment = new Segment2D(this.point2dList.getPoint(idx), this.point2dList.getPoint(idx_B));
			if (this.intersectionWithSegment(segment))
			{
				j++;
				continue;
			}
			
			var resultSplittedPolygons = this.splitPolygon(idx, idx_B);
			
			if (resultSplittedPolygons.length < 2)
			{
				j++;
				continue;
			}
			
			// now, compare splittedPolygon's normals with myNormal.
			var polygon_A = resultSplittedPolygons[0];
			var polygon_B = resultSplittedPolygons[1];
			var concavePoints_A = polygon_A.calculateNormal();
			var concavePoints_B = polygon_B.calculateNormal();
			
			var normal_A = polygon_A.normal;
			var normal_B = polygon_B.normal;
			if (normal_A === this.normal && normal_B === this.normal)
			{
				find = true;
				// polygon_A.
				if (concavePoints_A.length > 0)
				{
					convexPolygonsArray = polygon_A.tessellate(concavePoints_A, convexPolygonsArray);
				}
				else 
				{
					if (convexPolygonsArray === undefined)
					{ convexPolygonsArray = []; }
					
					convexPolygonsArray.push(polygon_A);
				}
				
				// polygon_B.
				if (concavePoints_B.length > 0)
				{
					//TODO : If the tessellation is used later, then please push the result to convexPolygonsArray, not initialized by the result.
					convexPolygonsArray = polygon_B.tessellate(concavePoints_B, convexPolygonsArray);
				}
				else 
				{
					if (convexPolygonsArray === undefined)
					{ convexPolygonsArray = []; }
					
					convexPolygonsArray.push(polygon_B);
				}
			}
			
			j++;
		}
		i++;
	}
	
	return convexPolygonsArray;
};
/**
 * Check whether the given segment cut a polygon edges or is coincident with a polygon's vertex 
 * @param {Segment2D} segment the target segement
 * */
Polygon2D.prototype.intersectionWithSegment = function(segment)
{
	if (this.bRect !== undefined)
	{
		// if exist boundary rectangle, check bRect intersection.
		var segmentsBRect = segment.getBoundaryRectangle(segmentsBRect);
		if (!this.bRect.intersectsWithRectangle(segmentsBRect))
		{ return false; }
	}
	
	// 1rst check if the segment is coincident with any polygons vertex.
	var mySegment;
	var intersectionType;
	var error = 10E-8;
	var pointsCount = this.point2dList.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		mySegment = this.point2dList.getSegment(i, mySegment);
		
		// if segment shares points, then must not cross.
		if (segment.sharesPointsWithSegment(mySegment))
		{
			continue;
		}
		
		var intersectionType = segment.intersectionWithSegment(mySegment, error);
		
		if (intersectionType === Constant.INTERSECTION_INTERSECT)
		{
			return true;
		}
	}
	
	return false; 
};

/**
 * Split single polygon as 2 polygons regarding of points of idx1, idx2
 * @param idx1 the index of the first point
 * @param idx2 the index of the second point
 * @param resultSplittedPolygonsArray the list of the created polygons by splitting
 */
Polygon2D.prototype.splitPolygon = function(idx1, idx2, resultSplittedPolygonsArray)
{
	if (resultSplittedPolygonsArray === undefined)
	{ resultSplittedPolygonsArray = []; }
	
	// polygon A. idx1 -> idx2.
	var polygon_A = new Polygon2D();
	polygon_A.point2dList = new Point2DList();
	polygon_A.point2dList.pointsArray = [];
	
	// 1rst, put vertex1 & vertex2 in to the polygon_A.
	polygon_A.point2dList.pointsArray.push(this.point2dList.getPoint(idx1));
	polygon_A.point2dList.pointsArray.push(this.point2dList.getPoint(idx2));
	
	var finished = false;
	var currIdx = idx2;
	var startIdx = idx1;
	var i=0;
	var totalPointsCount = this.point2dList.getPointsCount();
	while (!finished && i<totalPointsCount)
	{
		var nextIdx = this.point2dList.getNextIdx(currIdx);
		if (nextIdx === startIdx)
		{
			finished = true;
		}
		else 
		{
			polygon_A.point2dList.pointsArray.push(this.point2dList.getPoint(nextIdx));
			currIdx = nextIdx;
		}
		i++;
	}
	
	resultSplittedPolygonsArray.push(polygon_A);
	
	// polygon B. idx2 -> idx1.
	var polygon_B = new Polygon2D();
	polygon_B.point2dList = new Point2DList();
	polygon_B.point2dList.pointsArray = [];
	
	// 1rst, put vertex2 & vertex1 in to the polygon_B.
	polygon_B.point2dList.pointsArray.push(this.point2dList.getPoint(idx2));
	polygon_B.point2dList.pointsArray.push(this.point2dList.getPoint(idx1));
	
	finished = false;
	currIdx = idx1;
	startIdx = idx2;
	i=0;
	while (!finished && i<totalPointsCount)
	{
		var nextIdx = this.point2dList.getNextIdx(currIdx);
		if (nextIdx === startIdx)
		{
			finished = true;
		}
		else 
		{
			polygon_B.point2dList.pointsArray.push(this.point2dList.getPoint(nextIdx));
			currIdx = nextIdx;
		}
		i++;
	}
	
	resultSplittedPolygonsArray.push(polygon_B);
	return resultSplittedPolygonsArray;
};

Polygon2D.prototype.getPointsIdxSortedByDistToPoint = function(thePoint, resultSortedPointsIdxArray)
{
	// Static function.
	// Sorting minDist to maxDist.
	if (resultSortedPointsIdxArray === undefined)
	{ resultSortedPointsIdxArray = []; }
	
	resultSortedPointsIdxArray = this.point2dList.getPointsIdxSortedByDistToPoint(thePoint, resultSortedPointsIdxArray);
	
	return resultSortedPointsIdxArray;
};

/**
 * Make the list of triangles at the convex polygon
 * @param resultTrianglesArray the list of triangles made from the polygon
 * @returns resultTrianglesArray
 */
Polygon2D.prototype.getTrianglesConvexPolygon = function(resultTrianglesArray)
{
	// PROVISIONAL.
	// in this case, consider the polygon is convex.
	if (resultTrianglesArray === undefined)
	{ resultTrianglesArray = []; }

	var pointsCount = this.point2dList.getPointsCount();
	if (pointsCount <3)
	{ return resultTrianglesArray; }
	
	var triangle;
	for (var i=1; i<pointsCount-1; i++)
	{
		triangle = new Triangle();
		
		var point0idx = this.point2dList.getPoint(0).idxInList;
		var point1idx = this.point2dList.getPoint(i).idxInList;
		var point2idx = this.point2dList.getPoint(i+1).idxInList;
		
		triangle.vtxIdx0 = point0idx;
		triangle.vtxIdx1 = point1idx;
		triangle.vtxIdx2 = point2idx;
		
		resultTrianglesArray.push(triangle);
	}
	
	return resultTrianglesArray;
};
/**
 * @TODO : need to refactoring both of this function. 
 * 
 */
Polygon2D.prototype.getVbo = function(resultVbo)
{
	// PROVISIONAL.
	// return positions, normals and indices.
	if (resultVbo === undefined)
	{ resultVbo = new VBOVertexIdxCacheKey(); }
	
	// 1rst, obtain pos, nor.
	var posArray = [];
	var norArray = [];
	var point;
	var normal;
	if (this.normal > 0)
	{ normal = 1; }
	else
	{ normal = -1; }
		
	var pointsCount = this.point2dList.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		point = this.point2dList.getPoint(i);
		
		posArray.push(point.x);
		posArray.push(point.y);
		posArray.push(0.0);
		
		norArray.push(0);
		norArray.push(0);
		norArray.push(normal*255);
	}
	
	resultVbo.posVboDataArray = Float32Array.from(posArray);
	resultVbo.norVboDataArray = Int8Array.from(norArray);
	
	// now calculate triangles indices.
	this.point2dList.setIdxInList(); // use this function instead a map.
	
	var trianglesArray = [];
	var convexPolygonsCount = this.convexPolygonsArray.length;
	for (var i=0; i<convexPolygonsCount; i++)
	{
		var convexPolygon = this.convexPolygonsArray[i];
		trianglesArray = convexPolygon.getTrianglesConvexPolygon(trianglesArray); // provisional.
	}
	TrianglesList.getVboFaceDataArray(trianglesArray, resultVbo);

	return resultVbo;
};
/**
 * @TODO : need to refactoring both of this function. 
 * 
 */
Polygon2D.getVbo = function(concavePolygon, convexPolygonsArray, resultVbo)
{
	// PROVISIONAL.
	// return positions, normals and indices.
	if (resultVbo === undefined)
	{ resultVbo = new VBOVertexIdxCacheKey(); }
	
	// 1rst, obtain pos, nor.
	var posArray = [];
	var norArray = [];
	var point;
	var normal;
	if (concavePolygon.normal > 0)
	{ normal = 1; }
	else
	{ normal = -1; }
		
	var pointsCount = concavePolygon.point2dList.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		point = concavePolygon.point2dList.getPoint(i);
		
		posArray.push(point.x);
		posArray.push(point.y);
		posArray.push(0.0);
		
		norArray.push(0);
		norArray.push(0);
		norArray.push(normal*255);
	}
	
	resultVbo.posVboDataArray = Float32Array.from(posArray);
	resultVbo.norVboDataArray = Int8Array.from(norArray);
	
	// now calculate triangles indices.
	concavePolygon.point2dList.setIdxInList(); // use this function instead a map.
	
	var trianglesArray = [];
	var convexPolygonsCount = convexPolygonsArray.length;
	for (var i=0; i<convexPolygonsCount; i++)
	{
		var convexPolygon = convexPolygonsArray[i];
		trianglesArray = convexPolygon.getTrianglesConvexPolygon(trianglesArray); // provisional.
	}
	TrianglesList.getVboFaceDataArray(trianglesArray, resultVbo);

	return resultVbo;
};
























'use strict';

/**
 * PolyLine represented in 2D
 * This is similar with Point2DList, but this one represents real polyline geometry feature.
 * @class PolyLine2D
 */
var PolyLine2D = function() 
{
	if (!(this instanceof PolyLine2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.point2dArray;
};

/**
 * Creates a new Point2D.
 * @param {Number} x
 * @param {Number} y
 * @returns point2d
 */
PolyLine2D.prototype.newPoint2d = function(x, y)
{
	if (this.point2dArray === undefined)
	{ this.point2dArray = []; }
	
	var point2d = new Point2D(x, y);
	this.point2dArray.push(point2d);
	return point2d;
};

/**
 * Count the number of the point2D in this list
 */
PolyLine2D.prototype.getPointsCount = function()
{
	if (this.point2dArray === undefined)
	{ return 0; }
	
	return this.point2dArray.length;
};

/**
 * Clear all the features in this.point2dArray
 */
PolyLine2D.prototype.deleteObjects = function()
{
	var pointsCount = this.point2dArray.length;
	for (var i=0; i<pointsCount; i++)
	{
		this.point2dArray[i].deleteObjects();
		this.point2dArray[i] = undefined;
	}
	this.point2dArray = undefined;
};

/**
 * Copy the point from this.point2dArray to resultPointsArray
 * @param resultPointsArray
 * @returns resultPointsArray 
 */
PolyLine2D.prototype.getPoints = function(resultPointsArray)
{
	if (resultPointsArray === undefined)
	{ resultPointsArray = []; }
	
	var point;
	var errorDist = 10E-8;
	var resultExistentPointsCount = resultPointsArray.length;
	var pointsCount = this.point2dArray.length;
	for (var i=0; i<pointsCount; i++)
	{
		if (i===0)
		{
			if (resultExistentPointsCount > 0)
			{
				// check if the last point of "resultPointsArray" and the 1rst point of "this" is coincident.
				var lastExistentPoint = resultPointsArray[resultExistentPointsCount-1];
				var point0 = this.point2dArray[i];
				if (!lastExistentPoint.isCoincidentToPoint(point0, errorDist))
				{
					point = new Point2D();
					point.copyFrom(this.point2dArray[i]); 
					point.pointType = 1; // mark as "important point".
					resultPointsArray.push(point);
				}
			}
			else
			{
				point = new Point2D();
				point.copyFrom(this.point2dArray[i]); 
				point.pointType = 1; // mark as "important point".
				resultPointsArray.push(point);
			}
		}
		else
		{
			point = new Point2D();
			point.copyFrom(this.point2dArray[i]); 
			point.pointType = 1; // mark as "important point".
			resultPointsArray.push(point);
		}
	}
	
	return resultPointsArray;
};
'use strict';

/**
 * This is similar with Point23List, but this one represents real polyline geometry feature.
 * @class PolyLine3D
 */
var PolyLine3D = function() 
{
	if (!(this instanceof PolyLine3D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.point3dArray;
	this.geoLocDataManager;
	this.vboKeysContainer;
};

/**
 * Creates a new Point3D.
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @returns point3d
 */
PolyLine3D.prototype.newPoint3d = function(x, y, z)
{
	if (this.point3dArray === undefined)
	{ this.point3dArray = []; }
	
	var point3d = new Point3D(x, y, z);
	this.point3dArray.push(point3d);
	return point3d;
};

/**
 * Add a list of Point3D at the last of this.pointsArray
 * @param point3dArray the point that will be pushed at this.pointsArray
 */
PolyLine3D.prototype.addPoint3dArray = function(points3dArray)
{
	if (points3dArray === undefined)
	{ return; }
	
	if (this.point3dArray === undefined)
	{ this.point3dArray = []; }

	this.point3dArray.push.apply(this.point3dArray, points3dArray);
};

/**
 * Return the coordinate contained at geoLocDataManager
 * @returns geoLoc
 */
PolyLine3D.prototype.getGeographicLocation = function()
{
	if (this.geoLocDataManager === undefined)
	{ this.geoLocDataManager = new GeoLocationDataManager(); }
	
	var geoLoc = this.geoLocDataManager.getCurrentGeoLocationData();
	if (geoLoc === undefined)
	{
		geoLoc = this.geoLocDataManager.newGeoLocationData("default");
	}
	
	return geoLoc;
};

/**
 * Make the vbo of this point3DList
 * @param magoManager
 */
PolyLine3D.prototype.makeVbo = function(magoManager)
{
	if (!this.point3dArray || this.point3dArray.length === 0) 
	{
		return;
	}
	
	this.vboKeysContainer = Point3DList.getVbo(magoManager, this.point3dArray, this.vboKeysContainer);
};

/**
 * Render this point3dlist using vbo of this list. 
 * @param magoManager
 * @param shader 
 * @param renderType
 * @param bLoop 
 * @param bEnableDepth if this is turned off, then the last-drawing feature will be shown at the top
 */
PolyLine3D.prototype.renderLines = function(magoManager, shader, renderType, bLoop, bEnableDepth)
{
	if (this.point3dArray === undefined)
	{ return false; }
	
	var gl = magoManager.sceneState.gl;
	
	if (this.vboKeysContainer === undefined || this.vboKeysContainer.getVbosCount() === 0)
	{ this.makeVbo(magoManager); }

	shader.enableVertexAttribArray(shader.position3_loc);
	
	gl.uniform1i(shader.bPositionCompressed_loc, false);
	gl.uniform1i(shader.bUse1Color_loc, true);
	gl.uniform4fv(shader.oneColor4_loc, [1.0, 1.0, 0.1, 1.0]); //.
	gl.uniform1f(shader.fixPointSize_loc, 5.0);
	gl.uniform1i(shader.bUseFixPointSize_loc, true);
	
	if (bEnableDepth === undefined)
	{ bEnableDepth = true; }
	
	if (bEnableDepth)
	{ gl.enable(gl.DEPTH_TEST); }
	else
	{ gl.disable(gl.DEPTH_TEST); }

	// Render the line.
	var buildingGeoLocation = this.geoLocDataManager.getCurrentGeoLocationData();
	buildingGeoLocation.bindGeoLocationUniforms(gl, shader);
	
	if (renderType === 2)
	{
		var selectionManager = magoManager.selectionManager;
		var selectionColor = magoManager.selectionColor;

		var selColor = selectionColor.getAvailableColor(undefined); 
		var idxKey = selectionColor.decodeColor3(selColor.r, selColor.g, selColor.b);

		selectionManager.setCandidateGeneral(idxKey, this);
		gl.uniform4fv(shader.oneColor4_loc, [selColor.r/255.0, selColor.g/255.0, selColor.b/255.0, 1.0]);
	}
	
	var vbo_vicky = this.vboKeysContainer.vboCacheKeysArray[0]; // there are only one.
	if (!vbo_vicky.bindDataPosition(shader, magoManager.vboMemoryManager))
	{ return false; }

	gl.drawArrays(gl.LINE_STRIP, 0, vbo_vicky.vertexCount);
	
	// Check if exist selectedGeoCoord.
	/*
	var currSelected = magoManager.selectionManager.getSelectedGeneral();
	if(currSelected !== undefined && currSelected.constructor.name === "GeographicCoord")
	{
		gl.uniform4fv(shader.oneColor4_loc, [1.0, 0.1, 0.1, 1.0]); //.
		gl.uniform1f(shader.fixPointSize_loc, 10.0);
		currSelected.renderPoint(magoManager, shader, gl, renderType);
	}
	*/
	
	gl.enable(gl.DEPTH_TEST);
};

/**
 * @class PolyLine3D
 */
PolyLine3D.prototype.renderPoints = function(magoManager)
{
	// todo:
};
'use strict';

/**
 * 
 * @class ProcessCounterManager
 */
var ProcessCounterManager = function() 
{
	if (!(this instanceof ProcessCounterManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.shadowMeshesMadeCount = 0;
};

/**
 * 
 */
ProcessCounterManager.prototype.reset = function()
{
	this.shadowMeshesMadeCount = 0;
};

'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Profile2D
 */
var Profile2D = function() 
{
	if (!(this instanceof Profile2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.outerRing; // one Ring2D. 
	this.innerRingsList; // class: Ring2DList. 
};

/**
 * Set new outer border of this polygon as outerRing
 * @returns {Ring2D} outerRing
 */
Profile2D.prototype.newOuterRing = function() 
{
	if (this.outerRing === undefined)
	{ this.outerRing = new Ring2D(); }
	else 
	{
		this.outerRing.deleteObjects();
	}
	
	return this.outerRing;
};

/**
 * set new inner border of this polygon as innerRing
 * @returns {Ring2D} innerRing
 */
Profile2D.prototype.newInnerRing = function() 
{
	if (this.innerRingsList === undefined)
	{ this.innerRingsList = new Ring2DList(); }
	
	var innerRing = this.innerRingsList.newRing();
	
	return innerRing;
};

/**
 * Get the list of innerRings
 * @returns {}
 */
Profile2D.prototype.getInnerRingsList = function() 
{
	if (this.innerRingsList === undefined)
	{ this.innerRingsList = new Ring2DList(); }

	return this.innerRingsList;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
Profile2D.prototype.deleteObjects = function() 
{
	if (this.outerRing)
	{
		this.outerRing.deleteObjects();
		this.outerRing = undefined;
	}

	if (this.innerRingsList)
	{
		this.innerRingsList.deleteObjects();
		this.innerRingsList = undefined;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */

Profile2D.prototype.hasHoles = function() 
{
	if (this.innerRingsList === undefined || this.innerRingsList.getRingsCount() === 0)
	{ return false; }
	
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
 
Profile2D.prototype.getVBO = function(resultVbo) 
{
	if (this.outerRing === undefined)
	{ return resultVbo; }
	
	var generalPolygon = this.getGeneralPolygon(undefined);
	generalPolygon.getVbo(resultVbo);
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
 
Profile2D.prototype.getConvexFacesIndicesData = function(resultGeneralIndicesData) 
{
	if (this.outerRing === undefined)
	{ return resultVbo; }
	
	var generalPolygon = this.getGeneralPolygon(undefined);
	
	if (resultGeneralIndicesData === undefined)
	{ resultGeneralIndicesData = []; }
	
	// 1rst, set idxInList all points.
	this.outerRing.polygon.point2dList.setIdxInList();
	
	if (this.innerRingsList !== undefined)
	{
		var innerRingsCount = this.innerRingsList.getRingsCount();
		for (var i=0; i<innerRingsCount; i++)
		{
			var innerRing = this.innerRingsList.getRing(i);
			innerRing.polygon.point2dList.setIdxInList();
		}
	}
	
	var convexDatas;
	var convexPolygon;
	var indexData;
	var currRing;
	var ringIdxInList;
	var point;
	var convexPolygonsCount = generalPolygon.convexPolygonsArray.length;
	for (var i=0; i<convexPolygonsCount; i++)
	{
		convexPolygon = generalPolygon.convexPolygonsArray[i];
		convexDatas = [];
		var pointsCount = convexPolygon.point2dList.getPointsCount();
		for (var j=0; j<pointsCount; j++)
		{
			point = convexPolygon.point2dList.getPoint(j);
			indexData = point.indexData;
			currRing = indexData.owner;
			indexData.idxInList = point.idxInList;
			if (currRing === this.outerRing)
			{
				ringIdxInList = -1; // Set idx of outerRing as -1.
			}
			else 
			{
				ringIdxInList = this.innerRingsList.getRingIndex(currRing);
			}
			indexData.ownerIdx = ringIdxInList;
			convexDatas.push(indexData);
		}
		resultGeneralIndicesData.push(convexDatas);
	}
	
	return resultGeneralIndicesData;
};


/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
 
Profile2D.prototype.getGeneralPolygon = function(generalPolygon) 
{
	// this returns a holesTessellatedPolygon, and inside it has convexPolygons.
	this.checkNormals(); // here makes outer & inner's polygons.
	
	if (!this.hasHoles())
	{
		// Simply, put all points of outerPolygon into generalPolygon(computingPolygon).
		if (generalPolygon === undefined)
		{ generalPolygon = new Polygon2D(); }
		
		if (generalPolygon.point2dList === undefined)
		{ generalPolygon.point2dList = new Point2DList(); }
		
		var outerPolygon = this.outerRing.polygon;
		var point;
		var outerPointsCount = outerPolygon.point2dList.getPointsCount();
		for (var i=0; i<outerPointsCount; i++)
		{
			point = outerPolygon.point2dList.getPoint(i);
			generalPolygon.point2dList.addPoint(outerPolygon.point2dList.getPoint(i));
		}
	}
	else 
	{
		// 1rst, check normals congruences.
		generalPolygon = this.tessellateHoles(generalPolygon);
	}
	
	generalPolygon.convexPolygonsArray = [];
	var concavePointsIndices = generalPolygon.calculateNormal(concavePointsIndices);
	generalPolygon.convexPolygonsArray = generalPolygon.tessellate(concavePointsIndices, generalPolygon.convexPolygonsArray);
	
	return generalPolygon;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
Profile2D.prototype.eliminateHolePolygonBySplitPoints = function(outerPolygon, innerPolygon, outerPointIdx, innerPointIdx, resultPolygon) 
{
	if (resultPolygon === undefined)
	{ resultPolygon = new Polygon2D(); }
	
	if (resultPolygon.point2dList === undefined)
	{ resultPolygon.point2dList = new Point2DList(); }
	
	// 1rst, copy in newPolygon the outerPolygon.
	var outerPointsCount = outerPolygon.point2dList.getPointsCount();
	var finished = false;
	var i=0;
	var newPoint;
	var outerPoint;
	var currIdx = outerPointIdx;
	
	while (!finished && i<outerPointsCount)
	{
		outerPoint = outerPolygon.point2dList.getPoint(currIdx);
		resultPolygon.point2dList.addPoint(outerPoint);
		
		currIdx = outerPolygon.point2dList.getNextIdx(currIdx);
		if (currIdx === outerPointIdx)
		{
			finished = true;
			
			// must add the firstPoint point.
			outerPoint = outerPolygon.point2dList.getPoint(currIdx);
			resultPolygon.point2dList.addPoint(outerPoint);
		}
		
		i++;
	}
	// now add innerPolygon's points.
	var innerPointsCount = innerPolygon.point2dList.getPointsCount();
	finished = false;
	i=0;
	newPoint;
	var innerPoint;
	currIdx = innerPointIdx;
	while (!finished && i<innerPointsCount)
	{
		innerPoint = innerPolygon.point2dList.getPoint(currIdx);
		resultPolygon.point2dList.addPoint(innerPoint);
		
		currIdx = innerPolygon.point2dList.getNextIdx(currIdx);
		if (currIdx === innerPointIdx)
		{
			finished = true;
			// must add the firstPoint point.
			innerPoint = innerPolygon.point2dList.getPoint(currIdx);
			resultPolygon.point2dList.addPoint(innerPoint);
		}
		
		i++;
	}
	
	return resultPolygon;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
Profile2D.prototype.eliminateHolePolygon = function(computingPolygon, innerRing, innerPointIdx, resultPolygon) 
{
	// 1rst, make a sorted by dist of points of outer to "innerPoint".
	var resultSortedPointsIdxArray = [];
	var innerPolygon = innerRing.polygon;
	var innerPoint = innerPolygon.point2dList.getPoint(innerPointIdx);
	resultSortedPointsIdxArray = computingPolygon.getPointsIdxSortedByDistToPoint(innerPoint, resultSortedPointsIdxArray);
	
	var outerSortedPointsCount = resultSortedPointsIdxArray.length;
	var splitSegment = new Segment2D();;
	var finished = false;
	var i=0;
	var outPointIdx;
	var outPoint;
	while (!finished && i<outerSortedPointsCount)
	{
		outPointIdx = resultSortedPointsIdxArray[i];
		outPoint = computingPolygon.point2dList.getPoint(outPointIdx);
		splitSegment.setPoints(outPoint, innerPoint);
		
		// check if splitSegment intersects the computingPolygon or any innerPolygons.
		if (computingPolygon.intersectionWithSegment(splitSegment) || innerPolygon.intersectionWithSegment(splitSegment))
		{
			i++;
			continue;
		}
		
		// check if the splitSegment cuts other innerRings.
		//if (this.innerRingsList.intersectionWithSegment(splitSegment))
		//{
		//	i++;
		//	continue;
		//}
		
		resultPolygon = this.eliminateHolePolygonBySplitPoints(computingPolygon, innerPolygon, outPointIdx, innerPointIdx, resultPolygon);
		finished = true;
		
		i++;
	}
	
	if (!finished)
	{ return false; }
	
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
Profile2D.prototype.tessellateHoles = function(resultHolesEliminatedPolygon) 
{
	if (this.outerRing === undefined)
	{ return resultHolesEliminatedPolygon; }
	
	if (!this.hasHoles())
	{ return resultHolesEliminatedPolygon; }
	
	if (resultHolesEliminatedPolygon === undefined)
	{ resultHolesEliminatedPolygon = new Polygon2D(); }
	
	var hole;
	var holeIdx;
	var holePolygon;
	var objectAux;
	var innerPointIdx;
	var innersBRect;
	
	// prepare outerRing if necessary.
	var outerRing = this.outerRing;
	if (outerRing.polygon === undefined)
	{ outerRing.makePolygon(); }
	var outerPolygon = outerRing.polygon;
	var concavePointsIndices = outerPolygon.calculateNormal(concavePointsIndices);
	
	// make a innerRingsArray copy.
	var innerRingsArray = [];
	var innerRingsCount = this.innerRingsList.getRingsCount();
	for (var i=0; i<innerRingsCount; i++)
	{
		innerRingsArray.push(this.innerRingsList.getRing(i));
	}
	
	var resultPolygon = new Polygon2D();
	var computingPolygon = new Polygon2D();
	computingPolygon.point2dList = new Point2DList();
	
	// put all points of outerPolygon into computingPolygon.
	var indexData;
	var point;
	var outerPointsCount = outerPolygon.point2dList.getPointsCount();
	for (var i=0; i<outerPointsCount; i++)
	{
		point = outerPolygon.point2dList.getPoint(i);
		computingPolygon.point2dList.addPoint(outerPolygon.point2dList.getPoint(i));
	}
	
	var innersBRectLeftDownPoint = new Point2D();
	var objectsArray = [];
	
	// now, for each innerRing, try to merge to outerRing by splitSegment.
	var innerRingsCount = innerRingsArray.length;
	var i=0;
	var finished = false;
	while (!finished && i<innerRingsCount)
	{
		// calculate the most left-down innerRing.
		innersBRect = Ring2DList.getBoundingRectangle(innerRingsArray, innersBRect);
		innersBRectLeftDownPoint.set(innersBRect.minX, innersBRect.minY);
		
		objectsArray.length = 0; // init.
		objectsArray = Ring2DList.getSortedRingsByDistToPoint(innersBRectLeftDownPoint, innerRingsArray, objectsArray);
	
		objectAux = objectsArray[0];
		hole = objectAux.ring;
		holeIdx = objectAux.ringIdx;
		holePolygon = hole.polygon;
		innerPointIdx = objectAux.pointIdx;
		holePolygon.calculateNormal();
		
		if (this.eliminateHolePolygon(computingPolygon, hole, innerPointIdx, resultPolygon))
		{
			computingPolygon = resultPolygon;
			
			if (innerRingsArray.length === 1)
			{
				finished = true;
				break;
			}
			// erase the hole from innerRingsArray.
			innerRingsArray.splice(holeIdx, 1);
			resultPolygon = new Polygon2D();
		}
		i++;
	}
	resultHolesEliminatedPolygon = computingPolygon;
	return resultHolesEliminatedPolygon;
};

/**
 * 어떤 일을 하고 있습니까?
 * @returns vertexList
 */
Profile2D.prototype.checkNormals = function() 
{
	if (this.outerRing === undefined)
	{ return; }
	
	// 1rst, calculate the outerNormal.
	var outerRing = this.outerRing;
	if (outerRing.polygon === undefined)
	{ outerRing.makePolygon(); }
	var outerPolygon = outerRing.polygon;
	var concavePointsIndices = outerPolygon.calculateNormal(concavePointsIndices);
	var outerNormal = outerPolygon.normal;
	
	if (this.innerRingsList === undefined)
	{ return; }
	
	// if there are inners, the innerNormals must be inverse of the outerNormal.
	var innerRing;
	var innerPolygon;
	var innerNormal;
	var innersCount = this.innerRingsList.getRingsCount();
	for (var i=0; i<innersCount; i++)
	{
		innerRing = this.innerRingsList.getRing(i);
		if (innerRing.polygon === undefined)
		{ innerRing.makePolygon(); }
		var innerPolygon = innerRing.polygon;
		innerPolygon.calculateNormal();
		var innerNormal = innerPolygon.normal;
		
		if (innerNormal === outerNormal)
		{
			// then reverse innerPolygon.
			innerPolygon.reverseSense();
			innerPolygon.normal = -innerNormal;
		}
		
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Profile2D.prototype.TEST__setFigure_1 = function() 
{
	// complicated polygon with multiple holes.
	var polyLine;
	var arc;
	var circle;
	var rect;
	var point3d;
	var star;
	
	// Outer ring.**
	var outerRing = this.newOuterRing();
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(7, 7); // 0
	point3d = polyLine.newPoint2d(0, 7); // 1
	point3d = polyLine.newPoint2d(0, 0); // 2
	point3d = polyLine.newPoint2d(7, 0); // 3
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(7, 3.5);
	arc.setRadius(3.5);
	arc.setStartAngleDegree(-90.0);
	arc.setSweepAngleDegree(180.0);
	arc.numPointsFor360Deg = 24;
	
	// hole.
	var innerRing = this.newInnerRing();
	rect = innerRing.newElement("RECTANGLE");
	rect.setCenterPosition(3, 3);
	rect.setDimensions(2, 2);
};

/**
 * 어떤 일을 하고 있습니까?
 */
Profile2D.prototype.TEST__setFigure_2holes = function() 
{
	// complicated polygon with multiple holes.
	var polyLine;
	var arc;
	var circle;
	var rect;
	var point3d;
	var star;
	
	// Outer ring.**
	var outerRing = this.newOuterRing();
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(7, 7); // 0
	point3d = polyLine.newPoint2d(0, 7); // 1
	point3d = polyLine.newPoint2d(0, 0); // 2
	point3d = polyLine.newPoint2d(7, 0); // 3
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(7, 3.5);
	arc.setRadius(3.5);
	arc.setStartAngleDegree(-90.0);
	arc.setSweepAngleDegree(180.0);
	arc.numPointsFor360Deg = 24;
	
	// hole 1.
	var innerRing = this.newInnerRing();
	rect = innerRing.newElement("RECTANGLE");
	rect.setCenterPosition(3, 3);
	rect.setDimensions(2, 2);
	
	// hole 2.
	innerRing = this.newInnerRing();
	circle = innerRing.newElement("CIRCLE");
	circle.setCenterPosition(7, 3);
	circle.setRadius(1);
};

/**
 * 어떤 일을 하고 있습니까?
 */
Profile2D.prototype.TEST__setFigureHole_2 = function() 
{
	// complicated polygon with multiple holes.
	var polyLine;
	var arc;
	var circle;
	var rect;
	var point3d;
	var star;
	
	// Outer ring.**
	var outerRing = this.newOuterRing();
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(-13, 3); // 0
	point3d = polyLine.newPoint2d(-13, -11); // 1
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(-8, -11);
	arc.setRadius(5);
	arc.setStartAngleDegree(180.0);
	arc.setSweepAngleDegree(90.0);
	arc.numPointsFor360Deg = 24;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(-8, -16); // 0
	point3d = polyLine.newPoint2d(-5, -16); // 1
	point3d = polyLine.newPoint2d(-3, -15); // 2
	point3d = polyLine.newPoint2d(-3, -14); // 3
	point3d = polyLine.newPoint2d(-5, -12); // 4
	point3d = polyLine.newPoint2d(-3, -11); // 5
	point3d = polyLine.newPoint2d(-2, -9); // 6
	point3d = polyLine.newPoint2d(3, -9); // 7
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(9, -9);
	arc.setRadius(6);
	arc.setStartAngleDegree(180.0);
	arc.setSweepAngleDegree(180.0);
	arc.numPointsFor360Deg = 24;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(15, -9); // 0
	point3d = polyLine.newPoint2d(16, -9); // 1
	point3d = polyLine.newPoint2d(16, 4); // 2
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(11, 4);
	arc.setRadius(5);
	arc.setStartAngleDegree(0.0);
	arc.setSweepAngleDegree(90.0);
	arc.numPointsFor360Deg = 24;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(11, 9); // 0
	point3d = polyLine.newPoint2d(4, 9); // 1
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(4, 11);
	arc.setRadius(2);
	arc.setStartAngleDegree(-90.0);
	arc.setSweepAngleDegree(-180.0);
	arc.numPointsFor360Deg = 24;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(4, 13); // 0
	point3d = polyLine.newPoint2d(9, 13); // 1
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(9, 14.5);
	arc.setRadius(1.5);
	arc.setStartAngleDegree(-90.0);
	arc.setSweepAngleDegree(180.0);
	arc.numPointsFor360Deg = 24;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(9, 16); // 0
	point3d = polyLine.newPoint2d(2, 16); // 1
	point3d = polyLine.newPoint2d(0, 14); // 2
	point3d = polyLine.newPoint2d(-4, 16); // 3
	point3d = polyLine.newPoint2d(-9, 16); // 4
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(-9, 14);
	arc.setRadius(2);
	arc.setStartAngleDegree(90.0);
	arc.setSweepAngleDegree(180.0);
	arc.numPointsFor360Deg = 24;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(-9, 12); // 0
	point3d = polyLine.newPoint2d(-6, 12); // 1
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(-6, 10.5);
	arc.setRadius(1.5);
	arc.setStartAngleDegree(90.0);
	arc.setSweepAngleDegree(-180.0);
	arc.numPointsFor360Deg = 24;
	
	polyLine = outerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(-6, 9); // 0
	point3d = polyLine.newPoint2d(-7, 9); // 1
	
	arc = outerRing.newElement("ARC");
	arc.setCenterPosition(-7, 3);
	arc.setRadius(6);
	arc.setStartAngleDegree(90.0);
	arc.setSweepAngleDegree(90.0);
	arc.numPointsFor360Deg = 24;
	
	// Holes.**
	// Hole 1.*
	var innerRing = this.newInnerRing();
	
	polyLine = innerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(-9, 3); // 0
	point3d = polyLine.newPoint2d(-10, -4); // 1
	point3d = polyLine.newPoint2d(-10, -8); // 2
	point3d = polyLine.newPoint2d(-8, -11); // 3
	point3d = polyLine.newPoint2d(-3, -7); // 4
	point3d = polyLine.newPoint2d(4, -7); // 5
	
	arc = innerRing.newElement("ARC");
	arc.setCenterPosition(8, -7);
	arc.setRadius(4);
	arc.setStartAngleDegree(180.0);
	arc.setSweepAngleDegree(180.0);
	arc.numPointsFor360Deg = 24;
	
	polyLine = innerRing.newElement("POLYLINE");
	point3d = polyLine.newPoint2d(12, -7); // 0
	point3d = polyLine.newPoint2d(12, -4); // 1
	point3d = polyLine.newPoint2d(8, -10); // 2
	point3d = polyLine.newPoint2d(4, -5); // 3
	point3d = polyLine.newPoint2d(-8, -5); // 4
	point3d = polyLine.newPoint2d(-7, 4); // 5
	point3d = polyLine.newPoint2d(9, 4); // 6
	point3d = polyLine.newPoint2d(9, -5); // 7
	point3d = polyLine.newPoint2d(14, 2); // 8
	point3d = polyLine.newPoint2d(13, 2); // 9
	point3d = polyLine.newPoint2d(11, 0); // 10
	point3d = polyLine.newPoint2d(11, 7); // 11
	point3d = polyLine.newPoint2d(13, 8); // 12
	point3d = polyLine.newPoint2d(5, 8); // 13
	point3d = polyLine.newPoint2d(9, 6); // 14
	point3d = polyLine.newPoint2d(-6, 6); // 15
	
	arc = innerRing.newElement("ARC");
	arc.setCenterPosition(-6, 3);
	arc.setRadius(3);
	arc.setStartAngleDegree(90.0);
	arc.setSweepAngleDegree(90.0);
	arc.numPointsFor360Deg = 24;
	
	
		
	// Hole 2.*
	innerRing = this.newInnerRing();
	circle = innerRing.newElement("CIRCLE");
	circle.setCenterPosition(-10, -13);
	circle.setRadius(1);
	
	// Hole 3.*
	innerRing = this.newInnerRing();
	star = innerRing.newElement("STAR");
	star.setCenterPosition(-6.5, -14);
	star.setRadiusCount(5);
	star.setInteriorRadius(0.6);
	star.setExteriorRadius(2);

	// Hole 4.*
	innerRing = this.newInnerRing();
	star = innerRing.newElement("STAR");
	star.setCenterPosition(-9, 14);
	star.setRadiusCount(6);
	star.setInteriorRadius(0.5);
	star.setExteriorRadius(1.5);
	
	// Hole 5.*
	innerRing = this.newInnerRing();
	rect = innerRing.newElement("RECTANGLE");
	rect.setCenterPosition(-4.5, 1.5);
	rect.setDimensions(3, 3);
	
	// Hole 6.*
	innerRing = this.newInnerRing();
	circle = innerRing.newElement("CIRCLE");
	circle.setCenterPosition(-4.5, -2.5);
	circle.setRadius(2);
	
	// Hole 7.*
	innerRing = this.newInnerRing();
	star = innerRing.newElement("STAR");
	star.setCenterPosition(0, 0);
	star.setRadiusCount(5);
	star.setInteriorRadius(1);
	star.setExteriorRadius(2.5);
	
	// Hole 8.*
	innerRing = this.newInnerRing();
	circle = innerRing.newElement("CIRCLE");
	circle.setCenterPosition(-6, 14);
	circle.setRadius(1.5);
	
	// Hole 9.*
	innerRing = this.newInnerRing();
	star = innerRing.newElement("STAR");
	star.setCenterPosition(-1.5, 11);
	star.setRadiusCount(12);
	star.setInteriorRadius(0.6);
	star.setExteriorRadius(2);
	
	// Hole 10.*
	innerRing = this.newInnerRing();
	star = innerRing.newElement("STAR");
	star.setCenterPosition(13.5, 5);
	star.setRadiusCount(25);
	star.setInteriorRadius(0.4);
	star.setExteriorRadius(1.5);
	
	// Hole 11.*
	innerRing = this.newInnerRing();
	star = innerRing.newElement("STAR");
	star.setCenterPosition(9, -13);
	star.setRadiusCount(10);
	star.setInteriorRadius(0.4);
	star.setExteriorRadius(1.5);
	
	// Hole 12.*
	innerRing = this.newInnerRing();
	star = innerRing.newElement("STAR");
	star.setCenterPosition(5.5, 1.5);
	star.setRadiusCount(7);
	star.setInteriorRadius(0.7);
	star.setExteriorRadius(2);
	
};



















'use strict';

/**
 * the list of the features of Profile2D
 * @class Profiles2DList
 */
var Profiles2DList = function() 
{
	// Class no used.
	if (!(this instanceof Profiles2DList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.profilesArray;
	this.auxiliarAxis;
};

/**
 * create new feature of Profile2D and push it at the list
 * @returns {Profile2D} profile
 */
Profiles2DList.prototype.newProfile = function() 
{
	if (this.profilesArray === undefined)
	{ this.profilesArray = []; }
	
	var profile = new Profile2D();
	this.profilesArray.push(profile);
	return profile;
};

/**
 * Clear all the features of this list
 */
Profiles2DList.prototype.deleteObjects = function() 
{
	if (this.profilesArray)
	{
		var profilesCount = this.profilesArray.length;
		for (var i=0; i<profilesCount; i++)
		{
			this.profilesArray[i].deleteObjects();
			this.profilesArray = undefined;
		}
		this.profilesArray = undefined;
	}
};





























'use strict';

var QuatTree = function(options, magoManager) 
{

	//TODO : center width height required
	// QuatTree index
	// +-----+-----+ 
	// |  3  |  2  | 
	// +-----+-----+ 
	// |  0  |  1  | 
	// +-----+-----+ 
	var that = this;
	that.center = options.center || undefined;
	that.halfWidth = options.halfWidth || undefined;
	that.halfHeight = options.halfHeight || undefined;

	that.quatOwner = options.quatOwner || undefined;
	
	that.renderFunc = options.renderFunc || that.defaultRender;

	that.numberName;

	that.depth = 0;
	that.children;
	that.data;
	that.dirty = true;
    
	var camPos;
	var camDir;
	this.magoManager = magoManager;	

	// testtest
	this.displayPointsArray; // provisionally there are only one.
	this.realDatasCount;
	this.numberName;
	if (!this.quatOwner)
	{
		this.numberName = 1;
	}
};
QuatTree.CHILDREN_CNT = 4;
QuatTree.getLimitDistByRadius = function(radius) 
{
	return radius*1.5;
};
QuatTree.prototype.init = function() 
{
	this.children = undefined;
	this.data = undefined;
	this.dirty = true;
	this.displayPointsArray = undefined; // provisionally there are only one.
	this.realDatasCount = undefined;
};

QuatTree.prototype.hasChildren = function() 
{
	return this.children && Array.isArray(this.children) && this.children.length > 0;
};

QuatTree.prototype.hasData = function() 
{
	return this.data && Array.isArray(this.data) && this.data.length > 0;
};

QuatTree.prototype.getDisplayPoints = function(result) 
{
	if (!result) 
	{
		result = [];
	}
	if (!this.displayPointsArray || this.displayPointsArray.length === 0)
	{
		if (this.hasChildren())
		{
			var childCount = this.children.length;
			var displayPoints = [];
			var myDispPoint = new Point3D(0, 0, 0);
			
			for (var i=0; i<childCount; i++)
			{
				displayPoints = this.children[i].getDisplayPoints(displayPoints);
			}
			var displPointsCount = displayPoints.length;
			var totalMass = 0;
			for (var i=0; i<displPointsCount; i++)
			{
				var dataPoint = displayPoints[i];
				var mass = dataPoint.mass;

				var dataPointCopy = new Point3D(dataPoint.x, dataPoint.y, dataPoint.z);
				dataPointCopy.scale(mass);
				myDispPoint.addPoint(dataPointCopy);
				totalMass += mass;
			}
			myDispPoint.scale(1.0/totalMass);
			myDispPoint.mass = totalMass;

			this.displayPointsArray = [];
			this.displayPointsArray.push(myDispPoint);
		}
		else
		{
			// This is leaf quatree.
			// Calculate center of mass.
			if (this.hasData()) 
			{
				var datasCount = this.data.length;
				var displayDataPoint = new Point3D(0, 0, 0);
				for (var i=0; i<datasCount; i++)
				{
					var dataPoint = this.data[i];
					displayDataPoint.addPoint(ManagerUtils.geographicCoordToWorldPoint(dataPoint.x, dataPoint.y, 0));
				}
				displayDataPoint.scale(1.0/datasCount);
				displayDataPoint.mass = datasCount;

				this.displayPointsArray = [];
				this.displayPointsArray.push(displayDataPoint);
			}
		}
		
	}
	if (this.displayPointsArray) 
	{
		result.push.apply(result, this.displayPointsArray);
	}
	
	
	return result;
};

QuatTree.prototype.getQuatTreeByCamDistance = function(result, camPosWc) 
{
	if (!result) 
	{
		result = [];
	}

	if (!this.bSphereWC) 
	{
		this.makeBSphereWC();
	}
	var bSphereWC = this.bSphereWC;
	var distance = camPosWc.distToSphere(bSphereWC);
	
	var limitDist = QuatTree.getLimitDistByRadius(bSphereWC.getRadius());
	
	//find children
	if (distance < limitDist) 
	{
		if (this.children) 
		{
			var childCnt = this.children.length;
			for (var i =0;i<childCnt;i++) 
			{
				var child = this.children[i];
				child.getQuatTreeByCamDistance(result, camPosWc);
			}
		}
		else 
		{
			if (this.data) 
			{
				result.push(this);
			}
		}
	}
	else 
	{
		if (this.displayPointsArray) 
		{
			result.push(this);
		}
	}

	return result;
};
QuatTree.prototype.makeBSphereWC = function() 
{
	//ManagerUtils.geographicCoordToWorldPoint = function(longitude, latitude, altitude
	var pos1 = this.center;
	var pos2x = this.center.x + this.halfWidth;
	var pos2y = this.center.y + this.halfHeight;
	var pos2 = new Point2D(pos2x, pos2y);

	var posWC1 = ManagerUtils.geographicCoordToWorldPoint(pos1.x, pos1.y, 0);
	var posWC2 = ManagerUtils.geographicCoordToWorldPoint(pos2.x, pos2.y, 0);

	var radius = posWC1.distToPoint(posWC2);

	this.bSphereWC = new BoundingSphere(posWC1.x, posWC1.y, posWC1.z, radius);
};
QuatTree.prototype.setData = function(point2DArray)
{
	if (!this.data) 
	{
		this.data = [];
	}
	var length = point2DArray.length;
	for (var i=0;i<length;i++) 
	{
		var point2D = point2DArray[i];
		this.pushData(point2D);
	}
};
QuatTree.prototype.pushData = function(point2D)
{
	var mvm = this.magoManager.sceneState.modelViewProjMatrix;
	var testcc = mvm.transformPoint4D__test([point2D.x, point2D.y, point2D.z, 1.0]);
	var testccw = testcc[3];
	var px = testcc[0]/testccw;
	var py = testcc[1]/testccw;
	
	if (px < 1 && px > -1 && py < 1 && py > -1) 
	{
		var p = new Point2D(px, py);
		p.orgPos = point2D;
		this.data.push(p);
	}
};
QuatTree.prototype.addPoint2DToChild = function(point2D) 
{
	var x = point2D.x;
	var y = point2D.y;
	var center = this.center;
	var idx;
	if (x < center.x) 
	{
		if (y < center.y) 
		{
			idx = 0;
		}
		else 
		{
			idx = 3;
		}
	}
	else 
	{
		if (y < center.y) 
		{
			idx = 1;
		}
		else 
		{
			idx = 2;
		}
	}
    
	if (!this.children) 
	{
		this.createChildren();
	}

	if (!this.children[idx].data) 
	{
		this.children[idx].data = [];
	}
	this.children[idx].data.push(point2D);
};

QuatTree.prototype.createChildren = function() 
{
	this.children = [];
	var opt = {};
	opt.quatOwner = this;

	// +-----+-----+ 
	// |  3  |  2  | 
	// +-----+-----+ 
	// |  0  |  1  | 
	// +-----+-----+

	var minx = this.center.x - this.halfWidth;
	var miny = this.center.y - this.halfHeight;
	var maxx = this.center.x + this.halfWidth;
	var maxy = this.center.y + this.halfHeight;
	var midx = this.center.x;
	var midy = this.center.y;

	var child0 = new QuatTree(opt, this.magoManager);
	child0.depth = this.depth+1;
	child0.numberName = this.numberName*10 +1;
	child0.setSize(minx, miny, midx, midy);
	var child1 = new QuatTree(opt, this.magoManager);
	child1.depth = this.depth+1;
	child1.numberName = this.numberName*10 +2;
	child1.setSize(midx, miny, maxx, midy);
	var child2 = new QuatTree(opt, this.magoManager);
	child2.depth = this.depth+1;
	child2.numberName = this.numberName*10 +3;
	child2.setSize(midx, midy, maxx, maxy);
	var child3 = new QuatTree(opt, this.magoManager);
	child3.depth = this.depth+1;
	child3.numberName = this.numberName*10 +4;
	child3.setSize(minx, midy, midx, maxy);

	this.children.push(child0);
	this.children.push(child1);
	this.children.push(child2);
	this.children.push(child3);
};

QuatTree.prototype.setSize = function(minX, minY, maxX, maxY) 
{
	var centerX = (maxX + minX) / 2;
	var centerY = (maxY + minY) / 2;

	this.center = new Point2D(centerX, centerY);
	this.halfWidth = (maxX - minX)/2;
	this.halfHeight = (maxY - minY)/2;
};

QuatTree.prototype.makeTreeByDepth = function(targetDepth) 
{
	if (this.depth >= targetDepth) 
	{
		return;
	}

	if (this.data) 
	{
		var dataCnt = this.data.length;
		for (var i=0;i<dataCnt;i++) 
		{
			var point = this.data[i];
			this.addPoint2DToChild(point);
		}
		delete this.data;
	}

	
	if (this.children) 
	{
		var childLength = this.children.length;
		for (var i=0;i<childLength;i++) 
		{
			this.children[i].makeTreeByDepth(targetDepth);
		}
	}

	this.dirty = false;
};

QuatTree.prototype.extractLeaf = function(resultArray) 
{
	if (!resultArray || !Array.isArray(resultArray)) 
	{
		resultArray = [];
	}
	if (this.data && this.data.length > 0 ) 
	{
		resultArray.push(this);
	}
	
	if (this.children) 
	{
		var childLength = this.children.length;
		for (var i=0;i<childLength;i++) 
		{
			this.children[i].extractLeaf(resultArray);
		}
	}
	return resultArray;
};


QuatTree.prototype.defaultRender = function(leafArray) 
{
	if (!leafArray) 
	{
		return;
	}
	this.magoManager.objMarkerManager.objectMarkerArray = [];
	var leafArrayLength = leafArray.length;
	for (var i=0;i<leafArrayLength;i++) 
	{
		var leaf = leafArray[i];
		var leafData = leaf.data;
		var bbox = new BoundingBox();
		var cnt = leafData.length;
		for (var j=0;j<cnt;j++ ) 
		{
			var data = leafData[j];
			if (j === 0) 
			{
				bbox.init(data.orgPos);
			}
			else 
			{
				bbox.addPoint(data.orgPos);
			}
		}

		var bbcenter = bbox.getCenterPoint();
		if (cnt > 50) { cnt = 50; }
		var sizeX = cnt;
		var sizeY = cnt;

		if (sizeX < 5.0)
		{ sizeX = 5.0; }
		if (sizeY < 5.0)
		{ sizeY = 5.0; }

		var posWC = new Point3D(bbcenter.x, bbcenter.y, bbcenter.z);
		var options = {
			positionWC            : posWC,
			imageFilePath         : "defaultBlue",
			imageFilePathSelected : "defaultRed",
			sizeX                 : sizeX,
			sizeY                 : sizeY
		};
		this.magoManager.objMarkerManager.newObjectMarker(options, this.magoManager);
	}
};
'use strict';
/**
 * 중심점과 가로, 세로 길이를 가진 클래스
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class Rectangle2D
 */
var Rectangle2D = function() 
{
	if (!(this instanceof Rectangle2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * center point of this rectangle
	 * @type {Point2D}
	 */
	this.centerPoint;

	/**
	 * width of rectangle
	 * @type {Number}
	 */
	this.width;

	/**
	 * height of rectangle
	 * @type {Number}
	 */
	this.height;
	
	/**
	 * minimum x position of rectangle
	 * @type {Number}
	 */
	this.minX;
	
	/**
	 * minimum y position of rectangle
	 * @type {Number}
	 */
	this.minY;
	
	/**
	 * maximum x position of rectangle
	 * @type {Number}
	 */
	this.maxX;
	
	/**
	 * maximum y position of rectangle
	 * @type {Number}
	 */
	this.maxY;
};

/**
 * rectangle의 중심점 설정
 * @param {number} cx
 * @param {number} cy
 */
Rectangle2D.prototype.setCenterPosition = function(cx, cy)
{
	if (this.centerPoint === undefined)
	{ this.centerPoint = new Point2D(); }
	
	this.centerPoint.set(cx, cy);
};

/**
 * rectangle의 가로,세로 길이 설정
 * @param {number} minX
 * @param {number} minY
 * @param {number} maxX
 * @param {number} maxY
 */
Rectangle2D.prototype.setExtension = function(minX, minY, maxX, maxY)
{
	this.minX = minX;
	this.minY = minY;
	this.maxX = maxX;
	this.maxY = maxY;
};

/**
 * rectangle의 가로,세로 길이 설정
 * @param {number} width
 * @param {number} height
 */
Rectangle2D.prototype.setDimensions = function(width, height)
{
	this.width = width;
	this.height = height;
};

Rectangle2D.prototype.getCenterPosition = function()
{
	return this.centerPoint;
};

Rectangle2D.prototype.getWidth = function()
{
	return this.width;
};

Rectangle2D.prototype.getHeight = function()
{
	return this.height;
};

/**
 * Returns the right up point.
 * @param {Point2D|undefined} resultPoint if this undefined, then create new Point2D.
 * @returns {Point2D|undefined} resultPoint
 */
Rectangle2D.prototype.getMaxPoint = function(resultPoint)
{
	if (resultPoint === undefined)
	{ resultPoint = new Point2D(); }
	
	resultPoint.set(this.maxX, this.maxY);
	return resultPoint;
};

/**
 * Returns the left down point.
 * @param {Point2D|undefined} resultPoint if this undefined, then create new Point2D.
 * @returns {Point2D|undefined} resultPoint
 */
Rectangle2D.prototype.getMinPoint = function(resultPoint)
{
	if (resultPoint === undefined)
	{ resultPoint = new Point2D(); }
	
	resultPoint.set(this.minX, this.minY);
	return resultPoint;
};

/**
 * Returns the points of the Rectangle.
 * @param {Array.<Point2D>|undefined} resultPointsArray if this undefined, set new Array. []
 * @returns {Array.<Point2D>} resultPointsArray rectangle의 꼭지점 반환, 중심점으로부터 가로,세로의 절반 만큼 떨어진 4점을 반환
 */
Rectangle2D.prototype.getPoints = function(resultPointsArray)
{
	if (this.centerPoint === undefined || this.width === undefined || this.height === undefined)
	{ return resultPointsArray; }
	
	if (resultPointsArray === undefined)
	{ resultPointsArray = []; }
	
	var point;
	var halfWidth = this.width / 2;
	var halfHeight = this.height / 2;
	
	// starting in left-down corner, go in CCW.
	point = new Point2D(this.centerPoint.x - halfWidth, this.centerPoint.y - halfHeight);
	point.pointType = 1; // mark as "important point".
	resultPointsArray.push(point);
	
	point = new Point2D(this.centerPoint.x + halfWidth, this.centerPoint.y - halfHeight);
	point.pointType = 1; // mark as "important point".
	resultPointsArray.push(point);
	
	point = new Point2D(this.centerPoint.x + halfWidth, this.centerPoint.y + halfHeight);
	point.pointType = 1; // mark as "important point".
	resultPointsArray.push(point);
	
	point = new Point2D(this.centerPoint.x - halfWidth, this.centerPoint.y + halfHeight);
	point.pointType = 1; // mark as "important point".
	resultPointsArray.push(point);
	
	return resultPointsArray;
};



















































'use strict';

/**
 * 링형태의 폴리곤 객체를 생성하기 위한 클래스
 * 
 * @class
 */
var Ring2D = function() 
{
	if (!(this instanceof Ring2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	/**
	 * 다양한 폴리곤을 갖고 있는 배열
	 * @type {Obecjt[]}
	 */
	this.elemsArray = [];

	/**
	 * 폴리곤
	 * @type {Polygon2D}
	 */
	this.polygon = undefined;
	
	this.isOpen; // note: only outer rongs can be open.
};

Ring2D.prototype.getElement = function(index)
{
	if (this.elemsArray.length === 0)
	{
		return null;
	}
	return this.elemsArray[index];
};

/**
 * 생성된 객체가 있다면 삭제하고 초기화 한다.
 */
Ring2D.prototype.deleteObjects = function()
{
	for (var i=0, len = this.elemsArray.length; i<len; i++)
	{
		this.elemsArray[i].deleteObjects();
	}
	this.elemsArray = [];
	
	if (this.polygon !== undefined)
	{
		this.polygon.deleteObjects();
	}
	
	this.polygon = undefined;
};

/**
 * Adds a curve.
 * 
 * @param {Curve} elem Some curve (ARC, CIRCLE, POLYLINE, RECTANGLE, STAR, etc).
 */
Ring2D.prototype.addElement = function(elem)
{
	this.elemsArray.push(elem);
};

/**
 * 폴리곤을 생성하고 elemsArray 에 추가한다.
 * 
 * @param {String} type 폴리곤의 형태
 * @returns {Object} 지정된 형태로 생성한 폴리곤 객체
 */
Ring2D.prototype.newElement = function(type)
{
	var result = undefined;
	
	if (type === "ARC") { result = new Arc2D(); }
	else if (type === "CIRCLE") { result = new Circle2D(); }
	else if (type === "POLYLINE") { result = new PolyLine2D(); }
	else if (type === "RECTANGLE") { result = new Rectangle2D(); }
	else if (type === "STAR") { result = new Star2D(); }
	
	this.elemsArray.push(result);
	
	return result;
};

/**
 * 폴리곤을 생성한다.
 * 
 * @returns {Polygon2D} 폴리곤
 */
Ring2D.prototype.makePolygon = function()
{
	this.polygon = this.getPolygon(this.polygon);
	return this.polygon;
};

/**
 * 폴리곤을 생성한다.
 * 
 * @param {Polygon2D} resultPolygon 결과값을 저장할 폴리곤
 * @returns {Polygon2D} 수정되거나 새로 생성된 폴리곤
 */
Ring2D.prototype.getPolygon = function(resultPolygon)
{
	if (resultPolygon === undefined)
	{
		resultPolygon = new Polygon2D();
	}
	
	if (resultPolygon.point2dList === undefined)
	{
		resultPolygon.point2dList = new Point2DList();
	}
	
	// reset polygon
	resultPolygon.point2dList.deleteObjects();
	// TODO : 폴리곤에서 포인트를 가지고 오도록 변경해야함
	resultPolygon.point2dList.pointsArray = this.getPoints(resultPolygon.point2dList.pointsArray);
	
	// set idxData for all points
	var point;
	var pointsCount = resultPolygon.point2dList.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		point = resultPolygon.point2dList.getPoint(i);
		point.indexData = new IndexData();
		point.indexData.owner = this;
	}
	
	return resultPolygon;
};

/**
 * 다양한 폴리곤 배열에서 포인트를 구한다.
 * 
 * @param {Point2D[]} resultPointsArray 결과값을 저장할 포인트 배열
 * @returns {Point2D[]} 포인트 배열
 */
Ring2D.prototype.getPoints = function(resultPointsArray)
{
	if (resultPointsArray === undefined)
	{
		resultPointsArray = [];
	}
	
	var elem;
	for (var i=0, len = this.elemsArray.length; i<len; i++)
	{
		elem = this.elemsArray[i];
		elem.getPoints(resultPointsArray);
	}

	// finally check if the 1rst point and the last point are coincidents.
	var totalPointsCount = resultPointsArray.length;
	if (totalPointsCount > 1)
	{
		
		var errorDist = 10E-8;
		var firstPoint = resultPointsArray[0];
		var lastPoint = resultPointsArray[totalPointsCount-1];
		
		// mark the last as pointType = 1
		lastPoint.pointType = 1; 

		if (firstPoint.isCoincidentToPoint(lastPoint, errorDist))
		{
			// delete the last point.
			lastPoint = resultPointsArray.pop();
			lastPoint.deleteObjects();
			lastPoint = undefined;
		}
	}
	
	return resultPointsArray;
};








































'use strict';
/**
 * Ring2D 의 리스트 {@link Ring2D}
 */
var Ring2DList = function() 
{
	if (!(this instanceof Ring2DList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * 폴리곤 배열
	 * @type {Ring2D[]}
	 */
	this.ringsArray = [];

	/**
	 * 인덱스 리스트
	 * @type {Number[]}
	 */
	this.idxInList;
};

/**
 * Ring2D 를 생성하고 배열에 추가한다.
 * 
 * @returns {Ring2D} 생성된 Ring2D 의 객체
 */
Ring2DList.prototype.newRing = function() 
{
	var ring = new Ring2D();
	this.ringsArray.push(ring);
	
	return ring;
};

/**
 * 주어진 Ring2D 를 배열에 추가한다.
 * 
 * @param {Ring2D} ring 추가할 Ring2D 객체
 */
Ring2DList.prototype.addRing = function(ring) 
{
	this.ringsArray.push(ring);
};

/**
 * 생성된 객체가 있다면 삭제하고 초기화 한다.
 */
Ring2DList.prototype.deleteObjects = function() 
{
	for (var i=0, len = this.ringsArray.length; i<len; i++)
	{
		this.ringsArray[i].deleteObjects();
		this.ringsArray[i] = undefined;
	}
	this.ringsArray = [];
};

/**
 * Ring2D 배열의 개수를 구한다.
 * 
 * @returns {Number} 배열의 개수
 */
Ring2DList.prototype.getRingsCount = function() 
{
	return this.ringsArray.length;
};

/**
 * 주어진 객체의 인덱스값을 찾는다.
 * 
 * @param {Ring2D} ring Ring2D 객체
 * @returns {Number} 인덱스값
 */
Ring2DList.prototype.getRingIndex = function(ring) 
{
	return this.ringsArray.indexOf(ring);
};

/**
 * 주어진 인덱스에 있는 Ring2D 객체를 가져온다.
 * 
 * @param {Number} index 가져올 Ring2D 객체의 인덱스값.
 * @returns {Ring2D} <code>index</code> 위치의 Ring2D 객체
 * 
 * @see Ring2DList#getRingsCount
 */
Ring2DList.prototype.getRing = function(index) 
{
	return this.ringsArray[index];
};

/**
 * 주어진 Ring2D 배열의 각 폴리곤을 포함하는 경계 사각형을 구한다.
 * 
 * @param {Ring2D[]} ringsArray Ring2D 배열
 * @param {BoundingRectangle} resultBRect 폴리곤들을 포함하는 경계 사각형
 * @returns {BoundingRectangle} 폴리곤들을 포함하는 경계 사각형 결과값
 */
Ring2DList.getBoundingRectangle = function(ringsArray, resultBRect) 
{
	if (resultBRect === undefined)
	{
		resultBRect = new BoundingRectangle();
	}
	
	var ring;
	var currBRect;
	for (var i=0, len = ringsArray.length; i<len; i++)
	{
		ring = ringsArray[i];
		if (ring.polygon !== undefined)
		{
			currBRect = ring.polygon.getBoundingRectangle(currBRect);
			resultBRect.addRectangle(currBRect);
		}
	}

	return resultBRect;
};

/**
 * Ring2D 배열에 대한 인덱스값을 idxInList 속성에 설정한다.
 */
Ring2DList.prototype.setIdxInList = function() 
{
	for (var i=0, len = this.ringsArray.length; i<len; i++)
	{
		this.ringsArray[i].idxInList = i;
	}
};

/**
 * TODO : 확인이 필요함
 */
Ring2DList.prototype.intersectionWithSegment = function(segment) 
{
	// returns true if any ring's polygon intersects with "segment".
	if (segment === undefined)
	{
		return false;
	}
	
	var i=0;
	var intersects = false;
	var ringsCount = this.getRingsCount();
	while (!intersects && i<ringsCount)
	{
		if (this.ringsArray[i].intersectionWithSegment(segment)) // TODO:
		{
			intersects = true;
		}
		i++;
	}
	
	return intersects;
};


/**
 * 주어진 Ponint2D 와 각 Ring2D 의 거리를 기준으로 Ring2D 배열을 정렬한다.
 *
 * @param {Point2D} point 거리를 구하기 위해 주어진 포인트
 * @param {Ring2D[]} ringsArray 정렬을 하기 위한 Ring2D 배열
 * @param {Object[]} resultSortedObjectsArray 거리 기준으로 정렬된 결과값
 * @returns {Object[]} 거리 기준으로 정렬된 결과값
 */
Ring2DList.getSortedRingsByDistToPoint = function(point, ringsArray, resultSortedObjectsArray) 
{
	if (point === undefined)
	{
		return resultSortedObjectsArray;
	}
	
	if (resultSortedObjectsArray === undefined)
	{
		resultSortedObjectsArray = [];
	}
	
	var objectsAuxArray = [];
	var ring;
	var ringPoint;
	var ringPointIdx;
	var squaredDist;
	var objectAux;
	var startIdx, endIdx, insertIdx;
	for (var i=0, len = ringsArray.length; i<len; i++)
	{
		ring = ringsArray[i];
		ringPointIdx = ring.polygon.point2dList.getNearestPointIdxToPoint(point);
		ringPoint = ring.polygon.point2dList.getPoint(ringPointIdx);
		squaredDist = ringPoint.squareDistToPoint(point);

		objectAux = {};
		objectAux.ring = ring;
		objectAux.ringIdx = i;
		objectAux.pointIdx = ringPointIdx;
		objectAux.squaredDist = squaredDist;
		
		startIdx = 0;
		endIdx = objectsAuxArray.length - 1;
		
		// TODO : getIndexToInsertBySquaredDist 함수를 getBinarySearchIndex 를 이용하여 구현하기
		insertIdx = Ring2DList.getIndexToInsertBySquaredDist(objectsAuxArray, objectAux, startIdx, endIdx);
		objectsAuxArray.splice(insertIdx, 0, objectAux);
	}
	
	for (var i=0, len = objectsAuxArray.length; i<len; i++)
	{
		resultSortedObjectsArray.push(objectsAuxArray[i]);
	}
	
	return resultSortedObjectsArray;
};

/**
 * 이진 탐색 방법을 통해 해당 객체가 추가될 인덱스 값을 찾는다.
 * - 탐색의 대상인 배열은 이미 정렬되어있어야 한다.
 * @param {Object[]} objectsArray 탐색하기 위한 배열
 * @param {Object} object 탐색 대상
 * @param {Number} startIdx 시작 인덱스값
 * @param {Number} endIdx 종료 인덱스값
 * @returns {Number} 탐색 결과 인덱스
 */
Ring2DList.getIndexToInsertBySquaredDist = function(objectsArray, object, startIdx, endIdx) 
{
	// this do a dicotomic search of idx in a ordered table.
	// 1rst, check the range.
	
	var range = endIdx - startIdx;
	
	if (objectsArray.length === 0)
	{
		return 0;
	}
	
	if (range < 6)
	{
		// in this case do a lineal search.
		var finished = false;
		var i = startIdx;
		var idx;
		//var objectsCount = objectsArray.length;
		while (!finished && i<=endIdx)
		{
			if (object.squaredDist < objectsArray[i].squaredDist)
			{
				idx = i;
				finished = true;
			}
			i++;
		}
		
		if (finished)
		{
			return idx;
		}
		else 
		{
			return endIdx+1;
		}
	}
	else 
	{
		// in this case do the dicotomic search.
		var middleIdx = startIdx + Math.floor(range/2);
		var newStartIdx;
		var newEndIdx;
		if (objectsArray[middleIdx].squaredDist > object.squaredDist)
		{
			newStartIdx = startIdx;
			newEndIdx = middleIdx;
		}
		else 
		{
			newStartIdx = middleIdx;
			newEndIdx = endIdx;
		}
		return this.getIndexToInsertBySquaredDist(objectsArray, object, newStartIdx, newEndIdx);
	}
};

/**
 * 이진 탐색 방법을 통해 해당 객체가 추가될 인덱스 값을 찾는다.
 * - 탐색의 대상인 배열은 이미 정렬되어있어야 한다.
 *
 * @param {Object[]} arr 탐색하기 위한 배열
 * @param {Object} x 탐색 대상
 * @param {Function} func 탐색 비교값
 * @returns {Number} 탐색 결과 인덱스
 */
Ring2DList.getBinarySearchIndex = function (arr, x, func)
{
	var start = 0;
	var end = arr.length - 1;

	func = func || function (value) { return value; };

	// Iterate while start not meets end 
	while (start <= end)
	{
		// Find the mid index 
		var mid = Math.floor((start + end) / 2);

		if (func(arr[mid]) < func(x))
		{
			start = mid + 1;
		}
		else
		{
			end = mid - 1;
		}
	}

	return start;
};

"use strict";

/**
 * 링폴리곤의 형태를 정의
 */
var RingType = {
	/**
     * 아치형태의 폴리곤 {@link Arc2D}
     * @type {Number}
     * @constant
     */
	ARC: 0,

	/**
     * 원형태의 폴리곤 {@link Circle2D}
     * @type {Number}
     * @constant
     */
	CIRCLE: 1,

	/**
     * 폴리라인형태의 폴리곤 {@link PolyLine2D}
     * @type {Number}
     * @constant
     */
	POLYLINE: 2,

	/**
     * 사각형형태의 폴리곤 {@link Rectangle2D}
     * @type {Number}
     * @constant
     */
	RECTANGLE: 3,

	/**
     * 별형태의 폴리곤 {@link Star2D}
     * @type {Number}
     * @constant
     */
	Star2D: 4,

	/**
     * @private
     */
	NUMBER_OF_RING_TYPE: 5
};
'use strict';

/**
 * This draws a quad with the screen size.
 * @class ScreenQuad
 */
var ScreenQuad = function(vboMemManager) 
{
	if (!(this instanceof ScreenQuad)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.vboCacheKey;
	this.init(vboMemManager);
};

/**
 * 어떤 일을 하고 있습니까?
 */
ScreenQuad.prototype.init = function(vboMemManager) 
{
	var posDataArray = new Float32Array([0, 0,   1, 0,   0, 1,   0, 1,   1, 0,   1, 1]);
	this.vboCacheKey = new VBOVertexIdxCacheKey();
	var dimensions = 2;
	this.vboCacheKey.setDataArrayPos(posDataArray, vboMemManager, dimensions);
};

/**
 * 어떤 일을 하고 있습니까?
 */
ScreenQuad.prototype.render = function(magoManager, shader) 
{
	var gl = magoManager.getGl();
	if (!this.vboCacheKey.bindDataPosition(shader, magoManager.vboMemoryManager))
	{ return; }
	
	gl.drawArrays(gl.TRIANGLES, 0, 6);
};
'use strict';
/**
 * 선분 생성을 위한 클래스
 *
 * @param {Point2D} strPoint2D 시작 포인트
 * @param {Point2D} endPoint2D 종료 포인트
 */
var Segment2D = function(strPoint2D, endPoint2D) 
{
	if (!(this instanceof Segment2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.startPoint2d;
	this.endPoint2d;
	
	if (strPoint2D)
	{
		this.startPoint2d = strPoint2D;
	}
	
	if (endPoint2D)
	{
		this.endPoint2d = endPoint2D;
	}
};


/**
 * 선분에 포인트를 설정한다.
 *
 * @param {Point2D} strPoint2D 시작 포인트
 * @param {Point2D} endPoint2D 종료 포인트
 */
Segment2D.prototype.setPoints = function(strPoint2D, endPoint2D)
{
	if (strPoint2D !== undefined)
	{
		this.startPoint2d = strPoint2D; 
	}
	if (endPoint2D !== undefined)
	{ 
		this.endPoint2d = endPoint2D;
	}
};

/**
 * 시작 포인트에서 종료 포인트까지의 벡터를 구한다.
 *
 * @param {Point2D} result 벡터 결과값
 * @returns {Point2D} 벡터 결과값
 */
Segment2D.prototype.getVector = function(result)
{
	if (this.startPoint2d === undefined || this.endPoint2d === undefined)
	{
		return undefined;
	}
	
	if (result === undefined)
	{
		result = new Point2D();
	}
	
	result = this.startPoint2d.getVectorToPoint(this.endPoint2d, result);
	return result;
};


/**
 * 선분의 방향값을 계산한다.
 *
 * @param {Point2D} result 선분이 나타내는 방향값
 * @returns {Point2D} 선분이 나타내는 방향값
 */
Segment2D.prototype.getDirection = function(result)
{
	if (result === undefined)
	{
		result = new Point2D();
	}
	
	result = this.getVector(result);
	result.unitary();
	
	return result;
};


/**
 * 선분의 경계 사각형을 구한다.
 *
 * @param {BoundaryRectangle} result 선분을 포함하는 경계 사각형
 * @returns {BoundaryRectangle} 선분을 포함하는 경계 사각형
 */
Segment2D.prototype.getBoundaryRectangle = function(result)
{
	if (result === undefined)
	{
		result = new BoundaryRectangle();
	}
	
	result.setInit(this.startPoint2d);
	result.addPoint(this.endPoint2d);
	
	return result;
};


/**
 * 선분을 지나는 직선을 구한다.
 *
 * @param {Line2D} result 주어진 선분을 지나는 직선
 * @returns {Line2D} 주어진 선분을 지나는 직선
 */
Segment2D.prototype.getLine = function(result)
{
	if (result === undefined)
	{
		result = new Line2D();
	}
	// unitary direction.
	var dir = this.getDirection();
	var strPoint = this.startPoint2d;
	result.setPointAndDir(strPoint.x, strPoint.y, dir.x, dir.y);
	return result;
};


/**
 * 선분의 제곱된 길이를 구한다.
 *
 * @returns {Number} 선분의 제곱된 길이
 */
Segment2D.prototype.getSquaredLength = function()
{
	return this.startPoint2d.squareDistToPoint(this.endPoint2d);
};


/**
 * 선분의 길이를 구한다.
 *
 * @returns {Number} 선분의 길이
 */
Segment2D.prototype.getLength = function()
{
	return Math.sqrt(this.getSquaredLength());
};


/**
 * 오차율에 따라 주어진 포인트와 선분의 교차를 판단한다.
 *
 * @param {Point2D} point 포인트
 * @param {Number} error 오차율
 * @returns 교차 판단 결과값
 */
Segment2D.prototype.intersectionWithPointByDistances = function(point, error)
{
	if (point === undefined)
	{
		return undefined;
	}
	
	if (error === undefined)
	{
		error = 10E-8;
	}
	
	// here no check line-point coincidance.
	// now, check if is inside of the segment or if is coincident with any vertex of segment.
	var distA = this.startPoint2d.distToPoint(point);
	var distB = this.endPoint2d.distToPoint(point);
	var distTotal = this.getLength();
	
	if (distA < error)
	{
		return Constant.INTERSECTION_POINT_A;
	}
	
	if (distB < error)
	{
		return Constant.INTERSECTION_POINT_B;
	}
	
	if (distA> distTotal || distB> distTotal)
	{
		return Constant.INTERSECTION_OUTSIDE;
	}
	
	if (Math.abs(distA + distB - distTotal) < error)
	{
		return Constant.INTERSECTION_INSIDE;
	}
};


/**
 * 오차율에 따라 주어진 포인트와 선분의 교차를 판단한다.
 *
 * @param {Point2D} point 포인트
 * @param {Number} error 오차율
 * @returns 교차 판단 결과값
 */
Segment2D.prototype.intersectionWithPoint = function(point, error)
{
	if (point === undefined)
	{
		return undefined;
	}
	
	if (error === undefined)
	{
		error = 10E-8;
	}
	
	var line = this.getLine();
	if (!line.isCoincidentPoint(point, error))
	{
		// no intersection
		return Constant.INTERSECTION_OUTSIDE;
	}
	
	return this.intersectionWithPointByDistances(point, error);
};

/**
 * 오차율에 따라 주어진 선분과 선분의 교차를 판단한다.
 *
 * @param {Segment2D} segment 선분
 * @param {Number} error 오차율
 * @returns 교차 판단 결과값
 */
Segment2D.prototype.intersectionWithSegment = function(segment, error)
{
	if (segment === undefined)
	{
		return undefined;
	}
	
	if (error === undefined)
	{
		error = 10E-8;
	}
	
	var lineA = this.getLine();
	var lineB = segment.getLine();
	var intersectionPoint = lineA.intersectionWithLine(lineB);
	
	// 두 선분이 평행한 경우
	if (intersectionPoint === undefined)
	{
		return undefined;
	}
	
	var intersectionTypeA = this.intersectionWithPointByDistances(intersectionPoint);
	var intersectionTypeB = segment.intersectionWithPointByDistances(intersectionPoint);
	//TODO : change the logic. The return value of intersectionWithPointByDistance has four enum type
	//But the value really used is only one or two. 
	if (intersectionTypeA === Constant.INTERSECTION_OUTSIDE)
	{
		return Constant.INTERSECTION_OUTSIDE;
	}
	if (intersectionTypeB === Constant.INTERSECTION_OUTSIDE)
	{
		return Constant.INTERSECTION_OUTSIDE;
	}
	
	return Constant.INTERSECTION_INTERSECT;
};


/**
 * 주어진 포인트가 시작 포인트 또는 종료 포인트를 갖는지 판단한다.
 * returns if this segment has "point" as startPoint or endPoint.
 *
 * @param {Point2D} point 포인트
 * @returns {Boolean} 시작/종료 포인트 존재 여부
 */
Segment2D.prototype.hasPoint = function(point)
{
	if (point === undefined)
	{
		return false;
	}
	
	if (point === this.startPoint2d || point === this.endPoint2d)
	{
		return true;
	}
	
	return false;
};


/**
 * 주어진 선분이 해당 선분과 공유 포인트를 갖는지 판단한다.
 *
 * @param {Segment2D} segment 선분
 * @returns {Boolean} 공유 포인트 존재 여부
 */
Segment2D.prototype.sharesPointsWithSegment = function(segment)
{
	if (segment === undefined)
	{
		return false;
	}
	
	if (this.hasPoint(segment.startPoint2d) || this.hasPoint(segment.endPoint2d))
	{
		return true;
	}
	
	return false;
};
'use strict';
/**
 * 선분 생성을 위한 클래스
 *
 * @param {Point3D} strPoint2D 시작 포인트
 * @param {Point3D} endPoint2D 종료 포인트
 */
var Segment3D = function(strPoint3D, endPoint3D) 
{
	if (!(this instanceof Segment3D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.startPoint3d;
	this.endPoint3d;
	
	if (strPoint3D)
	{
		this.startPoint3d = strPoint3D;
	}
	
	if (endPoint3D)
	{
		this.endPoint3d = endPoint3D;
	}
};

/**
 * Make the vbo of this
 * @param magoManager
 */
Segment3D.getVboThickLines = function(magoManager, segment3dArray, resultVboKeysContainer)
{
	if (segment3dArray === undefined)
	{ return resultVboKeysContainer; }

	if (resultVboKeysContainer === undefined)
	{ resultVboKeysContainer = new VBOVertexIdxCacheKeysContainer(); }

	var segmentsCount = segment3dArray.length;

	// in this case make point4d (x, y, z, w). In "w" save the sign (1 or -1) for the offset in the shader to draw triangles strip.
	// check if the indexes is bigger than 65536. TODO.
	var repeats = 4;
	var pointDimension = 4;
	var pointsCount = segmentsCount * 2;
	var posVboDataArray = new Float32Array(pointsCount * pointDimension * repeats);
	var segment3d;
	var point_A, point_B;
	for (var i=0; i<segmentsCount; i++)
	{
		segment3d = segment3dArray[i];
		point_A = segment3d.startPoint3d;
		point_B = segment3d.endPoint3d;
		
		// point_A.
		posVboDataArray[i*32] = point_A.x;
		posVboDataArray[i*32+1] = point_A.y;
		posVboDataArray[i*32+2] = point_A.z;
		posVboDataArray[i*32+3] = 1; // order.
		
		posVboDataArray[i*32+4] = point_A.x;
		posVboDataArray[i*32+5] = point_A.y;
		posVboDataArray[i*32+6] = point_A.z;
		posVboDataArray[i*32+7] = -1; // order.
		
		posVboDataArray[i*32+8] = point_A.x;
		posVboDataArray[i*32+9] = point_A.y;
		posVboDataArray[i*32+10] = point_A.z;
		posVboDataArray[i*32+11] = 2; // order.
		
		posVboDataArray[i*32+12] = point_A.x;
		posVboDataArray[i*32+13] = point_A.y;
		posVboDataArray[i*32+14] = point_A.z;
		posVboDataArray[i*32+15] = -2; // order.
		
		// point_B.
		posVboDataArray[i*32+16] = point_B.x;
		posVboDataArray[i*32+17] = point_B.y;
		posVboDataArray[i*32+18] = point_B.z;
		posVboDataArray[i*32+19] = 1; // order.
		
		posVboDataArray[i*32+20] = point_B.x;
		posVboDataArray[i*32+21] = point_B.y;
		posVboDataArray[i*32+22] = point_B.z;
		posVboDataArray[i*32+23] = -1; // order.
		
		posVboDataArray[i*32+24] = point_B.x;
		posVboDataArray[i*32+25] = point_B.y;
		posVboDataArray[i*32+26] = point_B.z;
		posVboDataArray[i*32+27] = 2; // order.
		
		posVboDataArray[i*32+28] = point_B.x;
		posVboDataArray[i*32+29] = point_B.y;
		posVboDataArray[i*32+30] = point_B.z;
		posVboDataArray[i*32+31] = -2; // order.
	}
	
	var vbo = resultVboKeysContainer.newVBOVertexIdxCacheKey();
	vbo.setDataArrayPos(posVboDataArray, magoManager.vboMemoryManager, pointDimension);
	
	return resultVboKeysContainer;
};

/**
 * 선분에 포인트를 설정한다.
 *
 * @param {Point3D} strPoint3D 시작 포인트
 * @param {Point3D} endPoint3D 종료 포인트
 */
Segment3D.prototype.intersectionWithPoint = function(point, error)
{
	if (point === undefined)
	{ return false; }
	
	// calculate the distance.
	if (error === undefined)
	{ error = 10E-8; }
	
	var totalLength = this.getLength();
	var distA = this.startPoint3d.distToPoint(point);
	var distB = this.endPoint3d.distToPoint(point);
	
	var diff = totalLength - distA - distB;
	if (Math.abs(diff) < error)
	{ return true; }
	
	return false;
};

/**
 * 선분에 포인트를 설정한다.
 *
 * @param {Point3D} strPoint3D 시작 포인트
 * @param {Point3D} endPoint3D 종료 포인트
 */
Segment3D.prototype.getLine = function(resultLine)
{
	if (resultLine === undefined)
	{ resultLine = new Line(); }
	
	var direction = this.getDirection();
	resultLine.setPointAndDir(this.startPoint3d.x, this.startPoint3d.y, this.startPoint3d.z, direction.x, direction.y, direction.z);
	
	return resultLine;
};

/**
 * 선분에 포인트를 설정한다.
 *
 * @param {Point3D} strPoint3D 시작 포인트
 * @param {Point3D} endPoint3D 종료 포인트
 */
Segment3D.prototype.setPoints = function(strPoint3D, endPoint3D)
{
	if (strPoint3D)
	{
		this.startPoint3d = strPoint3D;
	}
	
	if (endPoint3D)
	{
		this.endPoint3d = endPoint3D;
	}
};

/**
 * 시작 포인트에서 종료 포인트까지의 벡터를 구한다.
 *
 * @param {Point3D} result 벡터 결과값
 * @returns {Point3D} 벡터 결과값
 */
Segment3D.prototype.getVector = function(result)
{
	if (this.startPoint3d === undefined || this.endPoint3d === undefined)
	{
		return undefined;
	}
	
	if (result === undefined)
	{
		result = new Point3D();
	}
	
	result = this.startPoint3d.getVectorToPoint(this.endPoint3d, result);
	return result;
};

/**
 * 선분의 방향값을 계산한다.
 *
 * @param {Point3D} result 선분이 나타내는 방향값
 * @returns {Point3D} 선분이 나타내는 방향값
 */
Segment3D.prototype.getDirection = function(result)
{
	if (result === undefined)
	{
		result = new Point3D();
	}
	
	result = this.getVector(result);
	result.unitary();
	
	return result;
};

/**
 * 시작 포인트와 종료 포인트를 맞바꾼다.
 * interchange strPoint & endPoint.
 */
Segment3D.prototype.invertSense = function()
{
	var point3dAux = this.startPoint3d;
	this.startPoint3d = this.endPoint3d;
	this.endPoint3d = point3dAux;
};

/**
 * 시작 포인트와 종료 포인트를 맞바꾼다.
 * interchange strPoint & endPoint.
 */
Segment3D.prototype.getLength = function()
{
	return this.startPoint3d.distToPoint(this.endPoint3d);
};























'use strict';

/**
 * This draws the outer shell of the feature as triangular mesh
 * @class ShadowMesh
 */
var ShadowMesh = function() 
{
	if (!(this instanceof ShadowMesh)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.name;
	this.id;
	this.mesh;
};
'use strict';

/**
 * This class is used to render the sky.
 * @class Sky
 */
var Sky = function() 
{
	if (!(this instanceof Sky)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.ellipsoid;
};

/**
 * Render this ellipsoid
 * @param {MagoManager} magoManager
 * @param {Shader} shader
 * @param {Number} renderType
 */
Sky.prototype.render = function(magoManager, shader, renderType, glPrimitive)
{
	// To avoid z-fight, split the sky in 8 regions.***
	if (this.ellipsoid === undefined)
	{ 
		var atmosphereHeight = 200000.0;
		var equatorialRadius = Globe.equatorialRadius() + atmosphereHeight;
		var polarRadius = Globe.polarRadius() + atmosphereHeight;
		
		this.ellipsoid = new Ellipsoid( equatorialRadius, equatorialRadius, polarRadius );
		
		var options = {
			"bLoopColumns"       : false,
			"bTrianglesSenseCCW" : false
		};
	
		this.ellipsoid.makeMesh(options);
		var vboMemoryManager = magoManager.vboMemoryManager;
		this.ellipsoid.makeVbo(vboMemoryManager);
		return; 
	}
	
	var gl = magoManager.getGl();
	gl.uniform3fv(shader.buildingPosHIGH_loc, this.ellipsoid.terrainPositionHIGH);
	gl.uniform3fv(shader.buildingPosLOW_loc, this.ellipsoid.terrainPositionLOW);
	var equatorialRadius = Globe.equatorialRadius();
	var polarRadius = Globe.polarRadius() + atmosphereHeight;
	gl.uniform1f(shader.equatorialRadius_loc, equatorialRadius);
	
	gl.depthRange(1.0, 1.0);
	this.ellipsoid.render(magoManager, shader, renderType, glPrimitive);
	gl.depthRange(0.0, 1.0);
};
'use strict';

/**
 * '별(star)'모양 폴리곤 객체
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class Star2D
 */
var Star2D = function() 
{
	if (!(this instanceof Star2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	// this is a closed element.
	/**
	 * center of star
	 * @type {Point2D}
	 */
	this.centerPoint; // Point3D.

	/**
	 * interior radius
	 * @type {Number}
	 */
	this.interiorRadius;
	/**
	 * exterior radius
	 * @type {Number}
	 */
	this.exteriorRadius;

	/**
	 * 별꼭지점 갯수
	 * @type {Number}
	 */
	this.radiusCount;
};

/**
 * star의 중심점 설정
 * @param {number} cx
 * @param {number} cy
 */
Star2D.prototype.setCenterPosition = function(cx, cy)
{
	if (this.centerPoint === undefined)
	{ this.centerPoint = new Point2D(); }
	
	this.centerPoint.set(cx, cy);
};

/**
 * star의 interior radius 설정
 * @param {number} radius
 */
Star2D.prototype.setInteriorRadius = function(radius)
{
	this.interiorRadius = radius;
};

/**
 * star의 exterior radius 설정
 * @param {number} radius
 */
Star2D.prototype.setExteriorRadius = function(radius)
{
	this.exteriorRadius = radius;
};

/**
 * star의 꼭지점 갯수 설정
 * @param {number} radiusCount
 */
Star2D.prototype.setRadiusCount = function(radiusCount)
{
	this.radiusCount = radiusCount;
};

/**
 * star의 꼭지점 배열 반환
 * @param {Array.<Point2D>} resultPointsArray
 * @returns {Array.<Point2D>} 
 */
Star2D.prototype.getPoints = function(resultPointsArray)
{
	// star has an arrow to up.
	var increAngDeg = 360 / this.radiusCount;
	var increAngRad = increAngDeg * Math.PI/180;
	var halfIncreAngRad = increAngRad / 2;
	var startAngRad = 90 * Math.PI/180;
	var currAngRad = startAngRad;
	var point;
	var x, y;
	
	if (resultPointsArray === undefined)
	{ resultPointsArray = []; }
	
	for (var i=0; i<this.radiusCount; i++)
	{
		// exterior.
		x = this.centerPoint.x + this.exteriorRadius * Math.cos(currAngRad);
		y = this.centerPoint.y + this.exteriorRadius * Math.sin(currAngRad);
		point = new Point2D(x, y);
		point.pointType = 1; // mark as "important point".
		resultPointsArray.push(point);
		
		// interior.
		x = this.centerPoint.x + this.interiorRadius * Math.cos(currAngRad + halfIncreAngRad);
		y = this.centerPoint.y + this.interiorRadius * Math.sin(currAngRad + halfIncreAngRad);
		point = new Point2D(x, y);
		point.pointType = 1; // mark as "important point".
		resultPointsArray.push(point);
		
		currAngRad += increAngRad;
	}
	
	return resultPointsArray;
};


















































'use strict';

/**
 * 정적모델데이터
 * 
 * @class
 */
var StaticModel = function() 
{
	if (!(this instanceof StaticModel)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * 고유 아이디
	 * @type {String}
	 */
	this.guid = "";
	
	/**
	 * 건물 이름
	 * @type {String}
	 */
	this.buildingFolderName = "";

	/**
	 * 프로젝트 이름
	 * @type {String}
	 */
	this.projectFolderName= "";

	/**
	 * 건물 객체
	 * @type {F4D}
	 */
	this.neoBuilding = undefined;
};


/**
 * 정적모델데이터 관리자
 * 
 * @class
 */
var StaticModelsManager = function() 
{
	if (!(this instanceof StaticModelsManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.staticModelsMap = {};
};

/**
 * 고유아이디를 가진 정적모델데이터를 추가한다.
 * 
 * @param {String} guid 고유아이디
 * @param {StaticModel} staticModel 정적모델데이터
 */
StaticModelsManager.prototype.addStaticModel = function(guid, staticModel)
{
	this.staticModelsMap[guid] = staticModel;
};


/**
 * 고유아이디를 가진 정적모델데이터를 가져온다.
 *
 * @param {String} guid 고유아이디
 * @returns {StaticModel} 정적모델데이터
 */
StaticModelsManager.prototype.getStaticModel = function(guid)
{
	var staticModel = this.staticModelsMap[guid];
	if (staticModel === undefined)
	{
		throw new Error('StaticModel is not exist.');
	}
	return staticModel;
};

StaticModelsManager.manageStaticModel = function(node, magoManager)
{
	// Check if the node is a referenceNode.***
	var attributes = node.data.attributes;
	if (attributes === undefined)
	{ return; }

	var neoBuilding = node.data.neoBuilding;
		
	if (attributes.projectId !== undefined && attributes.isReference !== undefined && attributes.isReference === true)
	{
		var projectFolderName;
		var neoBuildingFolderName;
	
		// check if has neoBuilding.***
		if (neoBuilding === undefined)
		{
			var neoBuildingFolderName = attributes.buildingFolderName;
			projectFolderName = attributes.projectFolderName;
			
			// demand to staticModelsManager the neoBuilding.***
			var projectId = attributes.projectId;
			var staticModelsManager = magoManager.hierarchyManager.getStaticModelsManager();
			var staticModel = staticModelsManager.getStaticModel(projectId);
			neoBuilding = staticModel.neoBuilding;
			neoBuildingFolderName = staticModel.buildingFolderName;
			projectFolderName = staticModel.projectFolderName;
			
			//neoBuilding = staticModelsManager.getStaticModel(staticModelDataPath);
			
			// make a buildingSeed.***
			var buildingSeed = new BuildingSeed();
			buildingSeed.fisrtName = neoBuildingFolderName;
			buildingSeed.name = neoBuildingFolderName;
			buildingSeed.buildingId = neoBuildingFolderName;
			buildingSeed.buildingFileName = neoBuildingFolderName;
			buildingSeed.geographicCoord = new GeographicCoord(attributes.longitude, attributes.latitude, attributes.height); // class : GeographicCoord.
			buildingSeed.rotationsDegree = new Point3D(attributes.pitch, attributes.roll, attributes.heading); // class : Point3D. (heading, pitch, roll).
			buildingSeed.bBox = new BoundingBox();           // class : BoundingBox.
			buildingSeed.bBox.init();
			buildingSeed.bBox.expand(10.0); // we dont know the bbox size, provisionally set as 10,10,10.***
			buildingSeed.geographicCoordOfBBox = new GeographicCoord(attributes.longitude, attributes.latitude, attributes.height);  // class : GeographicCoord.
			buildingSeed.smartTileOwner;
			
			// Now, set neoBuildings parameters.***
			neoBuilding.buildingFileName = neoBuildingFolderName;
			neoBuilding.nodeOwner = node;
			node.data.neoBuilding = neoBuilding;
			node.data.buildingSeed = buildingSeed;
			node.data.projectFolderName = projectFolderName;

			if (neoBuilding.metaData === undefined) 
			{ 
				neoBuilding.metaData = new MetaData(); 
				
				if (neoBuilding.metaData.geographicCoord === undefined)
				{ neoBuilding.metaData.geographicCoord = new GeographicCoord(); }

				if (neoBuilding.metaData.bbox === undefined) 
				{ neoBuilding.metaData.bbox = new BoundingBox(); }
			
				neoBuilding.metaData.geographicCoord.setLonLatAlt(buildingSeed.geographicCoord.longitude, buildingSeed.geographicCoord.latitude, buildingSeed.geographicCoord.altitude);
				neoBuilding.metaData.bbox.copyFrom(buildingSeed.bBox);
				neoBuilding.metaData.heading = buildingSeed.rotationsDegree.z;
				neoBuilding.metaData.pitch = buildingSeed.rotationsDegree.x;
				neoBuilding.metaData.roll = buildingSeed.rotationsDegree.y;
			}

			neoBuilding.name = "test_" + neoBuildingFolderName;
			neoBuilding.buildingId = neoBuildingFolderName;
		
			neoBuilding.buildingType = "basicBuilding";
			if (neoBuilding.bbox === undefined)
			{ neoBuilding.bbox = new BoundingBox(); }
			neoBuilding.bbox.copyFrom(buildingSeed.bBox);
			neoBuilding.projectFolderName = node.data.projectFolderName;
		}
	}
};




































'use strict';

/**
 * 서피스
 * 
 * @class
 */
var Surface = function(options)
{
	if (!(this instanceof Surface))
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.id;
	this.name;

	/** 
	 * Surface 가 가진 Face 배열
	 * @type {Face[]}
	 */
	this.facesArray = [];

	/** 
	 * 전체 Face 가 가진 Vertex 배열
	 * - "Surface" is NO-Owner of vertices of "localVertexList".
	 * - so, don't delete "localVertexList". Only set as "undefined".
	 * @type {VertexList}
	 */
	this.localVertexList = undefined;

	/** 
	 * - "Surface" is NO-Owner of hedges of "localHedgesList".
	 * - so, don't delete "localHedgesList". Only set as "undefined".
	 * @type {Object[]}
	 */
	this.localHedgesList = undefined;
	
	if (options !== undefined)
	{
		if (options.id !== undefined)
		{ this.id = options.id; }
		
		if (options.name !== undefined)
		{ this.name = options.name; }
	}
};

/**
 * 생성된 객체가 있다면 삭제하고 초기화 한다.
 */
Surface.prototype.deleteObjects = function()
{
	for (var i=0, len=this.facesArray.length; i<len; i++)
	{
		this.facesArray[i].deleteObjects();
		this.facesArray[i] = undefined;
	}

	this.facesArray = [];
	this.localVertexList = undefined;
	this.localHedgesList = undefined;
};


/**
 * 페이스 객체를 생성하고 배열에 추가한다.
 *
 * @returns {Face} 새로 생성된 Face 객체
 * 
 * @see Face
 */
Surface.prototype.newFace = function()
{
	var face = new Face();
	this.facesArray.push(face);
	return face;
};


/**
 * Surface 가 가지고 있는 Face 의 총 개수를 구한다.
 *
 * @returns {Number} 생성된 Face 의 총 개수
 */
Surface.prototype.getFacesCount = function()
{
	return this.facesArray.length;
};


/**
 * 주어진 인덱스값의 위치에 있는 Face 객체를 가져온다.
 *
 * @param {Number} index 검색하기 위한 인덱스값
 * @returns {Face} 해당 Face
 */
Surface.prototype.getFace = function(index)
{
	return this.facesArray[index];
};

/**
 * 전체 Face 에 대한 색상정보를 주어진 색상값으로 설정한다.
 *
 * @param {Number} r Red 색상정보
 * @param {Number} g green 색상정보
 * @param {Number} b blue 색상정보
 * @param {Number} a alpha 색상정보
 */
Surface.prototype.setColor = function(r, g, b, a)
{
	var face;
	for (var i=0, len=this.getFacesCount(); i<len; i++)
	{
		face = this.getFace(i);
		face.setColor(r, g, b, a);
	}
};

/**
 * 주어진 Face 객체들을 추가한다.
 *
 * @param {Face[]} faces 추가할 Face 배열
 */
Surface.prototype.addFacesArray = function(faces)
{
	if (faces !== undefined)
	{
		Array.prototype.push.apply(this.facesArray, faces);
	}
};

/**
 * 전체 Face 에 대한 Frontier Half Edge 를 구한다.
 *
 * @param {HalfEdge[]} result Frontier Half Edges
 * @returns {HalfEdge[]} Frontier Half Edges
 * 
 * @see HalfEdge
 */
Surface.prototype.getFrontierHalfEdges = function(result)
{
	if (this.facesArray === undefined)
	{ return result; }
	
	result = result || [];

	var face;
	for (var i=0, len=this.getFacesCount(); i<len; i++)
	{
		face = this.getFace(i);
		result = face.getFrontierHalfEdges(result);
	}

	return result;
};

/**
 * 전체 Face 에 대한 Frontier Half Edge 를 구한다.
 *
 * @param {HalfEdge[]} result Frontier Half Edges
 * @returns {HalfEdge[]} Frontier Half Edges
 * 
 * @see HalfEdge
 */
Surface.prototype.getAnyFrontierHalfEdge = function()
{
	if (this.facesArray === undefined)
	{ return undefined; }
	
	var face;
	var hedgesArray = [];
	for (var i=0, len=this.getFacesCount(); i<len; i++)
	{
		face = this.getFace(i);
		hedgesArray = face.getFrontierHalfEdges(hedgesArray);
		
		if (hedgesArray.length > 0)
		{ return hedgesArray[0]; }
	}
};

/**
 * 전체 Face 에 대한 Frontier Half Edge 를 구한다.
 *
 * @param {HalfEdge[]} result Frontier Half Edges
 * @returns {HalfEdge[]} Frontier Half Edges
 * 
 * @see HalfEdge
 */
Surface.prototype.getFrontierPolyline = function(resultPolyline)
{
	// 1rst, find any frontier hedge.
	var frontierHedge = this.getAnyFrontierHalfEdge();
	if (frontierHedge === undefined)
	{ return; }

	if (resultPolyline === undefined)
	{ resultPolyline = new PolyLine3D(); }
	
	// create the 1rst point3d.
	var currPoint3d = frontierHedge.startVertex.point3d;
	var point3d = resultPolyline.newPoint3d(currPoint3d.x, currPoint3d.y, currPoint3d.z);
	
	var nextFrontierHedge = frontierHedge.getNextFrontier();
	var finished = false;
	while (!finished)
	{
		if (nextFrontierHedge === undefined || nextFrontierHedge === frontierHedge)
		{ break; }
		currPoint3d = nextFrontierHedge.startVertex.point3d;
		point3d = resultPolyline.newPoint3d(currPoint3d.x, currPoint3d.y, currPoint3d.z);
		
		nextFrontierHedge = nextFrontierHedge.getNextFrontier();
	}
	
	return resultPolyline;
};


/**
 * 전체 Face 에 대한 Half Edge 를 구한다.
 *
 * @param {HalfEdge[]} result Half Edges
 * @returns {HalfEdge[]} Half Edges
 * 
 * @see HalfEdge
 */
Surface.prototype.getHalfEdges = function(result)
{
	result = result || [];

	var face;
	for (var i=0, len=this.getFacesCount(); i<len; i++)
	{
		face = this.getFace(i);
		result = face.getHalfEdgesLoop(result);
	}

	return result;
};

/**
 * 현재 서피스 정보의 복사본을 제공한다.
 *
 * @param {Surface} result 서피스
 * @returns {Surface}
 */
Surface.prototype.getCopyIndependentSurface = function(result)
{
	if (result === undefined)
	{
		result = new Surface();
	}

	if (result.localVertexList === undefined)
	{
		result.localVertexList = new VertexList();
	}

	var resultLocalvertexList = result.localVertexList;
	result.id = this.id;
	result.name = this.name;

	// copy the localVertexList.
	var vertex;
	var vertexCopy;
	var verticesArray = this.getNoRepeatedVerticesArray();
	var vertexCount = verticesArray.length;
	for (var i=0; i<vertexCount; i++)
	{
		vertex = verticesArray[i];
		vertex.setIdxInList(i);
		vertexCopy = resultLocalvertexList.newVertex();
		vertexCopy.copyFrom(vertex);
	}

	// copy the faces.
	var face;
	var faceCopy;
	var vertexIdxInList;

	var faceCount = this.getFacesCount();
	for (var i=0; i<faceCount; i++)
	{
		face = this.getFace(i);
		faceCopy = result.newFace();
		// TODO : 생성과 관련된 코드는 클래스 외부에서 하지 않도록 변경해야함
		faceCopy.vertexArray = [];

		vertexCount = face.getVerticesCount();
		for (var j=0; j<vertexCount; j++)
		{
			vertex = face.getVertex(j);
			vertexIdxInList = vertex.getIdxInList();
			faceCopy.vertexArray.push(resultLocalvertexList.getVertex(vertexIdxInList));
		}
		var halfEdgesArray = [];
		faceCopy.createHalfEdges(halfEdgesArray);
	}

	result.setTwinsFaces();

	return result;
};

/**
 * 특정 Face 와 Face 배열을 비교하여 동일한 Face 가 존재하는지를 알려준다.
 *
 * @param {Face} face 찾을 Face 대상
 * @param {Face[]} facesArray Face 배열
 * @param {Boolean} bIsRegularQuadGrid 정규쿼드격자 여부
 * @returns {Boolean} 동일한 Face 존재 여부.
 * 					 동일한 Face 가 존재하면 <code>true</code>
 * 					 동일한 Face 가 존재하지 않으면 <code>false</code>
 */
Surface.setTwinsFacesBetweenFaceAndFacesArrays = function(face, facesArray, bIsRegularQuadGrid)
{
	// if the faces pertains a regular-quad-grid,
	// then there are only ONE twin between the "face" & the "facesArray".
	if (facesArray === undefined)
	{
		return false;
	}

	var twined = false;
	for (var i=0, len=facesArray.length; i<len; i++)
	{
		if (facesArray[i].setTwinFace(face))
		{
			twined = true;
			if (bIsRegularQuadGrid)
			{
				// if faces are from a regular quad grid,
				// there are only 1 twin possible.
				return true;
			}
		}
	}

	return twined;
};


/**
 * 두개의 Face 배열 사이에 동일한 Face 가 존재하는지를 알려준다.
 *
 * @param {Face[]} facesA 비교할 Face 배열
 * @param {Face[]} facesB 비교할 Face 배열
 * @returns {Boolean} 동일한 Face 존재 여부.
 * 					 동일한 Face 가 존재하면 <code>true</code>
 * 					 동일한 Face 가 존재하지 않으면 <code>false</code>
 */
Surface.setTwinsFacesBetweenFacesArrays_regularQuadGrid = function(facesA, facesB)
{
	// Faces are rectangles in a rectangle grid.
	if (facesA === undefined || facesB === undefined)
	{
		return false;
	}

	var faceA, faceB;
	for (var i=0, len=facesA.length-1; i<len; i++)
	{
		faceA = facesA[i];
		faceB = facesB[i+1];
		if (!faceA.setTwinFace(faceB))
		{
			faceA = facesA[i+1];
			faceB = facesB[i];
			if (!faceA.setTwinFace(faceB))
			{
				faceA = facesA[i];
				faceB = facesB[i];
				if (!faceA.setTwinFace(faceB))
				{
					faceA = facesA[i+1];
					faceB = facesB[i+1];
					if (!faceA.setTwinFace(faceB))
					{
						// do nothing.
					}
				}
			}
		}
	}
};


/**
 * 전체 Face 배열 중 동일한 Face 가 존재하는지를 알려준다.
 *
 */
Surface.prototype.setTwinsFaces = function()
{
	var face, face2;
	
	var facesCount = this.facesArray.length;
	for (var i=0; i<facesCount; i++)
	{
		face = this.getFace(i);
		for (var j=i+1; j<facesCount; j++)
		{
			if (i !== j)
			{
				face2 = this.getFace(j);
				face.setTwinFace(face2);
			}
		}
	}
};


/**
 * 전체 Face 로부터 반복되지 않는 버텍스 배열을 구한다.
 *
 * @param {Vertex[]} result 버텍스 배열 결과를 저장
 * @returns {Vertex[]} 버텍스 배열
 */
Surface.prototype.getNoRepeatedVerticesArray = function(result)
{
	result = result || [];

	// assign vertex-IdxInList for all used vertices.
	var face;
	var vtx;
	var idxAux = 0;
	var facesCount = this.getFacesCount();
	for (var i=0; i<facesCount; i++)
	{
		face = this.getFace(i);
		for (var j=0, len=face.getVerticesCount(); j<len; j++)
		{
			vtx = face.getVertex(j);
			vtx.setIdxInList(idxAux);
			idxAux++;
		}
	}

	// make a map of unique vertices map using "idxInList" of vertices.
	var verticesMap = {};
	for (var i=0; i<facesCount; i++)
	{
		face = this.getFace(i);
		for (var j=0, len=face.getVerticesCount(); j<len; j++)
		{
			vtx = face.getVertex(j);
			verticesMap[vtx.getIdxInList().toString()] = vtx;
		}
	}

	// finally make the unique vertices array.
	var vertex;
	for (var key in verticesMap)
	{
		if (Object.prototype.hasOwnProperty.call(verticesMap, key))
		{
			vertex = verticesMap[key];
			result.push(vertex);
		}
	}

	return result;
};

/**
 * 전체 Face 에 대해 삼각형을 생성하고 배열로 제공한다.
 * - To call this method, the faces must be convex.
 *
 * @param {Triangle[]} result  Face 배열로부터 생성한 삼각형 배열
 * @returns {Triangle[]} Face 배열로부터 생성한 삼각형 배열
 */
Surface.prototype.getTrianglesConvex = function(result)
{
	result = result || [];

	var face;
	for (var i=0, len=this.getFacesCount(); i<len; i++)
	{
		face = this.getFace(i);
		result = face.getTrianglesConvex(result);
	}

	return result;
};

/**
 * 전체 Face 에 대해 테슬레이트된 삼각형을 생성하고 배열로 제공한다.
 *
 * @param {Triangle[]} result  Face 배열로부터 생성한 삼각형 배열
 * @returns {Triangle[]} Face 배열로부터 생성한 삼각형 배열
 */
Surface.prototype.getTriangles = function(result)
{
	result = result || [];

	var face;
	for (var i=0, len=this.getFacesCount(); i<len; i++)
	{
		face = this.getFace(i);
		result = face.getTessellatedTriangles(result);
	}

	return result;
};

/**
 * 전체 Face 에 대해 버텍스 노말을 계산한다.
 * 
 * @param {Boolean} bForceRecalculatePlaneNormal Plane 노말의 계산 적용 여부
 * 					<code>true</code> Plane 노말을 사용한다.
 *					<code>false</code> Plane 노말을 사용하지 않는다.
 */
Surface.prototype.calculateVerticesNormals = function(bForceRecalculatePlaneNormal)
{
	var face;
	var facesCount = this.getFacesCount();
	for (var i=0; i<facesCount; i++)
	{
		face = this.getFace(i);
		face.calculateVerticesNormals(bForceRecalculatePlaneNormal);
	}
};

/**
 * Get the texture coordinate by box projection
 */
Surface.prototype.calculateTexCoordsBox = function(texCoordsBoundingBox)
{
	var face;
	var facesCount = this.getFacesCount();
	for (var i=0; i<facesCount; i++)
	{
		face = this.getFace(i);
		face.calculateTexCoordsBox(texCoordsBoundingBox);
	}
};

/**
 *
 * 전체 Face 에 대해 각 Face 가 가진 버텍스값을 뒤바꾼다
 */
Surface.prototype.reverseSense = function()
{
	var face;
	var facesCount = this.getFacesCount();
	for (var i=0; i<facesCount; i++)
	{
		face = this.getFace(i);
		face.reverseSense();
	}
};

'use strict';

/**
 * Triangle(삼각형)를 생성하기 위한 클래스
 * 
 * @class Triangle
 *  
 * @param {Vertex} vertex0
 * @param {Vertex} vertex1
 * @param {Vertex} vertex2
 */
var Triangle= function(vertex0, vertex1, vertex2) 
{
	if (!(this instanceof Triangle)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	/**
	 * vertex0
	 * @type {Vertex}
	 * @default vertex0.
	 */
	this.vertex0;
	/**
	 * vertex1
	 * @type {Vertex}
	 * @default vertex1.
	 */
	this.vertex1;
	/**
	 * vertex2
	 * @type {Vertex}
	 * @default vertex2.
	 */
	this.vertex2;
	/**
	 * vtxIdx0
	 * @type {number}
	 * @default undefined.
	 */
	this.vtxIdx0;
	/**
	 * vtxIdx1
	 * @type {number}
	 * @default undefined.
	 */
	this.vtxIdx1;
	/**
	 * vtxIdx2
	 * @type {number}
	 * @default undefined.
	 */
	this.vtxIdx2;
	/**
	 * plainNormal
	 * @type {Point3D}
	 * @default undefined.
	 */	
	this.normal; 
	
	if (vertex0 !== undefined)
	{ this.vertex0 = vertex0; }
	
	if (vertex1 !== undefined)
	{ this.vertex1 = vertex1; }
	
	if (vertex2 !== undefined)
	{ this.vertex2 = vertex2; }
	
	this.hEdge;
};

/**
* 생성된 객체가 있다면 삭제하고 초기화 한다.
*/
Triangle.prototype.deleteObjects = function() 
{
	// the triangle no deletes vertices.
	if (this.vertex0)
	{
		this.vertex0 = undefined;
	}
	if (this.vertex1)
	{
		this.vertex1 = undefined;
	}
	if (this.vertex2)
	{
		this.vertex2 = undefined;
	}
	if (this.normal)
	{
		this.normal.deleteObjects();
		this.normal = undefined;
	}
	
	this.vtxIdx0 = undefined;
	this.vtxIdx1 = undefined;
	this.vtxIdx2 = undefined;
};

/**
 * Triangle의 각각의 Vertex 설정
 * 
 * @param {Vertex} vertex0
 * @param {Vertex} vertex1
 * @param {Vertex} vertex2
 */
Triangle.prototype.setVertices = function(vertex0, vertex1, vertex2) 
{
	this.vertex0 = vertex0;
	this.vertex1 = vertex1;
	this.vertex2 = vertex2;
};

/**
 * Vertex의 vertexList index를 가지고 와서 Vertex index 설정
 */
Triangle.prototype.assignVerticesIdx = function() 
{
	if (this.vertex0 === undefined || this.vertex1 === undefined || this.vertex2 === undefined)
	{ return; }
	
	this.vtxIdx0 = this.vertex0.getIdxInList();
	this.vtxIdx1 = this.vertex1.getIdxInList();
	this.vtxIdx2 = this.vertex2.getIdxInList();
};

/**
 * Triangle의 Vertex index를 인덱스 배열에 추가한다.
 * 
 * @param {indicesArray[]} 인덱스 배열
 * @returns {indicesArray[]} 인덱스 배열 
 */
Triangle.prototype.getIndicesArray = function(indicesArray)
{
	if (indicesArray === undefined)
	{ indicesArray = []; }
	
	if (this.vtxIdx0 !== undefined && this.vtxIdx1 !== undefined && this.vtxIdx2 !== undefined )
	{
		indicesArray.push(this.vtxIdx0);
		indicesArray.push(this.vtxIdx1);
		indicesArray.push(this.vtxIdx2);
	}
	
	return indicesArray;
};

/**
 * invert triangle을 구한다.
 */
Triangle.prototype.invertSense = function() 
{
	var vertexAux = this.vertex1;
	this.vertex1 = this.vertex2;
	this.vertex2 = vertexAux;
	
	this.calculatePlaneNormal();
};

/**
 * PlaneNormal을 계산한다.
 */
Triangle.prototype.calculatePlaneNormal = function() 
{
	if (this.normal === undefined)
	{ this.normal = new Point3D(); }

	this.getCrossProduct(0, this.normal);
	this.normal.unitary();
};

/**
 * PlaneNormal을 계산한다.
 */
Triangle.prototype.getPlaneNormal = function() 
{
	if (this.normal === undefined)
	{ this.calculatePlaneNormal(); }
	
	return this.normal;
};

/**
 * CrossProduct(벡터의 외적)를 계산한다.
 * 
 * @param {Number} idxVertex 
 * @param {Number} resultCrossProduct 
 * @returns {Number} resultCrossProduct
 */
Triangle.prototype.getCrossProduct = function(idxVertex, resultCrossProduct) 
{
	if (resultCrossProduct === undefined)
	{ resultCrossProduct = new Point3D(); }

	var currentPoint, prevPoint, nextPoint;

	if (idxVertex === 0)
	{
		currentPoint = this.vertex0.point3d;
		prevPoint = this.vertex2.point3d;
		nextPoint = this.vertex1.point3d;
	}
	else if (idxVertex === 1)
	{
		currentPoint = this.vertex1.point3d;
		prevPoint = this.vertex0.point3d;
		nextPoint = this.vertex2.point3d;
	}
	else if (idxVertex === 2)
	{
		currentPoint = this.vertex2.point3d;
		prevPoint = this.vertex1.point3d;
		nextPoint = this.vertex0.point3d;
	}

	var v1 = new Point3D();
	var v2 = new Point3D();

	v1.set(currentPoint.x - prevPoint.x,     currentPoint.y - prevPoint.y,     currentPoint.z - prevPoint.z);
	v2.set(nextPoint.x - currentPoint.x,     nextPoint.y - currentPoint.y,     nextPoint.z - currentPoint.z);

	v1.unitary();
	v2.unitary();

	resultCrossProduct = v1.crossProduct(v2, resultCrossProduct);

	return resultCrossProduct;
};

/**
 * 
 */
Triangle.prototype.getBoundingBox = function(resultBbox) 
{
	if (resultBbox === undefined)
	{ resultBbox = new BoundingBox(); }
	
	resultBbox.init(this.vertex0.getPosition());
	resultBbox.addPoint(this.vertex1.getPosition());
	resultBbox.addPoint(this.vertex2.getPosition());
	
	return resultBbox;
};

/**
 * 
 */
Triangle.prototype.getPlane = function(resultPlane) 
{
	if (resultPlane === undefined)
	{ resultPlane = new Plane(); }
	
	// make a plane with the point3d of the vertex0 & the normal.
	var point0 = this.vertex0.getPosition();
	var normal = this.getPlaneNormal();
	resultPlane.setPointAndNormal(point0.x, point0.y, point0.z, normal.x, normal.y, normal.z); 
	
	return resultPlane;
};

/**
 * 
 */
Triangle.prototype.getSegment = function(idx, resultSegment) 
{
	if (idx === undefined)
	{ return; }
	
	if (resultSegment === undefined)
	{ resultSegment = new Segment3D(); }
	
	if (idx === 0)
	{
		resultSegment.setPoints(this.vertex0.getPosition(), this.vertex1.getPosition());
	}
	else if (idx === 1)
	{
		resultSegment.setPoints(this.vertex1.getPosition(), this.vertex2.getPosition());
	}
	else if (idx === 2)
	{
		resultSegment.setPoints(this.vertex2.getPosition(), this.vertex0.getPosition());
	}
	
	return resultSegment;
};































'use strict';

/**
 * Triangle2D(삼각형)를 생성하기 위한 클래스
 * 
 * @class Triangle2D
 *  
 * @param {Point2D} point2d0
 * @param {Point2D} point2d1
 * @param {Point2D} point2d2
 */
var Triangle2D = function(point2d0, point2d1, point2d2) 
{
	if (!(this instanceof Triangle2D)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.point2d0;
	this.point2d1;
	this.point2d2;
	
	if (point2d0 !== undefined)
	{ this.point2d0 = point2d0; }
	
	if (point2d1 !== undefined)
	{ this.point2d1 = point2d1; }
	
	if (point2d2 !== undefined)
	{ this.point2d2 = point2d2; }
};

/**
 * Triangle의 각각의 Vertex 설정
 * 
 * @param {Point2D} point2d0
 * @param {Point2D} point2d1
 * @param {Point2D} point2d2
 */
Triangle2D.prototype.setPoints = function(point2d0, point2d1, point2d2) 
{
	this.point2d0 = point2d0;
	this.point2d1 = point2d1;
	this.point2d2 = point2d2;
};

/**
 * Triangle의 각각의 Vertex 설정
 * 
 * @param {Point2D} p1
 * @param {Point2D} p2
 * @param {Point2D} p3
 */
Triangle2D.sign = function(p1, p2, p3) 
{
	return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
};

/**
 * Triangle의 각각의 Vertex 설정
 * 
 * @param {Point2D} point2d0
 * @param {Point2D} point2d1
 * @param {Point2D} point2d2
 */
Triangle2D.prototype.isPoint2dInside = function(point2d) 
{
	var sign1 = Triangle2D.sign(point2d, this.point2d0, this.point2d1) < 0;
	var sign2 = Triangle2D.sign(point2d, this.point2d1, this.point2d2) < 0;
	var sign3 = Triangle2D.sign(point2d, this.point2d2, this.point2d0) < 0;
	
	var isInside = ((sign1 === sign2) && (sign2 === sign3));
	return isInside;
};






















'use strict';

/**
 * Triangle 객체의 리스트
 * 
 * @class
 */
var TrianglesList = function() 
{
	if (!(this instanceof TrianglesList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	/**
	 * Triangle 객체의 배열
	 * @type {Triangle[]}
	 */
	this.trianglesArray = [];
};

/**
 * Triangle을 생성하고, 배열에 추가한다.
 * 
 * @param {Vertex} vertex0 1번 버텍스
 * @param {Vertex} vertex1 2번 버텍스
 * @param {Vertex} vertex2 3번 버텍스
 * @returns {Triangle} 생성된 Triangle 객체
 */
TrianglesList.prototype.newTriangle = function(vertex0, vertex1, vertex2) 
{
	var triangle = new Triangle(vertex0, vertex1, vertex2);
	this.trianglesArray.push(triangle);

	return triangle;
};

/**
 * 주어진 Triangle을 배열에 추가한다.
 * 
 * @param {Triangle} triangle 추가할 Triangle 객체
 */
TrianglesList.prototype.addTriangle = function(triangle) 
{
	this.trianglesArray.push(triangle);
};

/**
 * 생성된 객체가 있다면 삭제하고, 초기화한다.
 */
TrianglesList.prototype.deleteObjects = function() 
{
	var trianglesCount = this.getTrianglesCount();
	for (var i=0; i<trianglesCount; i++)
	{
		this.trianglesArray[i].deleteObjects();
		this.trianglesArray[i] = undefined;
	}
	this.trianglesArray = [];
};

/**
 * Triangle 배열의 개수를 구한다.
 * 
 * @returns {Number} 배열의 개수
 */
TrianglesList.prototype.getTrianglesCount = function() 
{
	return this.trianglesArray.length;
};

/**
 * 주어진 인덱스에 있는 Triangle 객체를 가져온다.
 * 
 * @param {Number} index 가져올 Triangle 객체의 인덱스 값
 * @returns {Triangle} 주어진 인덱스 위치의 Triangle 객체
 */
TrianglesList.prototype.getTriangle = function(index) 
{
	return this.trianglesArray[index];
};

/**
 * 버텍스 인덱스를 할당한다.
 */
TrianglesList.prototype.assignVerticesIdx = function() 
{
	TrianglesList.assignVerticesIdx(this.trianglesArray);
};

/**
 * 버텍스 인덱스를 할당한다.
 * 
 * @param {Triangle[]} triangles 삼각형 클래스 배열
 */
TrianglesList.assignVerticesIdx = function(triangles) 
{
	if (triangles === undefined)
	{ return; }
	
	var trianglesCount = triangles.length;
	var triangles = triangles;
	for (var i=0; i<trianglesCount; i++)
	{
		triangles[i].assignVerticesIdx();
	}
};

/**
 * 주어진 삼각형 클래스 배열의 버텍스 인덱스를 주어진 인텍스 배열에 설정한다.
 * 
 * @param {Triangle[]} triangles 삼각형 클래스 배열
 * @param {Uint16Array[]}  indices 버텍스 인덱스 배열
 * @returns {Uint16Array[]}  버텍스 인덱스 배열
 */
TrianglesList.getTrianglesIndicesArray = function(triangles, indices) 
{
	var trianglesCount = triangles.length;
	var indicesCount = trianglesCount * 3;
	
	if (indices === undefined)
	{ indices = new Uint16Array(indicesCount); }
	
	for (var i=0; i<trianglesCount; i++)
	{
		indices[i*3] = triangles[i].vtxIdx0;
		indices[i*3+1] = triangles[i].vtxIdx1;
		indices[i*3+2] = triangles[i].vtxIdx2;
	}
	
	return indices;
};

/**
 * 삼각형 클래스 배열의 반복되지 않는 인덱스들을 주어진 인텍스 배열에 설정한다.
 * 
 * @param {Vertex[]} vertices 버텍스 배열
 * @returns {Vertex[]} 버텍스 배열
 */
TrianglesList.prototype.getNoRepeatedVerticesArray = function(vertices) 
{
	vertices = TrianglesList.getNoRepeatedVerticesArray(this.trianglesArray, vertices);
	return vertices;
};

/**
 * 주어진 삼각형 클래스 배열의 반복되지 않는 인덱스들을 주어진 인텍스 배열에 설정한다.
 * 
 * @param {Triangle[]} triangles 
 * @param {Vertex[]} vertices 버텍스 배열
 * @returns {Vertex[]} 버텍스 배열
 */
TrianglesList.getNoRepeatedVerticesArray = function(triangles, vertices) 
{
	if (vertices === undefined)
	{ vertices = []; }
	
	// 1rst, assign vertexIdxInList for all used vertives.
	var triangle;
	var idxAux = 0;
	var vtx_0, vtx_1, vtx_2;

	var trianglesCount = triangles.length;
	for (var i=0; i<trianglesCount; i++)
	{
		triangle = triangles[i];
		vtx_0 = triangle.vertex0;
		vtx_1 = triangle.vertex1;
		vtx_2 = triangle.vertex2;
		
		vtx_0.setIdxInList(idxAux);
		idxAux++;
		vtx_1.setIdxInList(idxAux);
		idxAux++;
		vtx_2.setIdxInList(idxAux);
		idxAux++;
	}
	
	// now, make a map of unique vertices map using "idxInList" of vertices.
	var verticesMap = {};
	for (var i=0; i<trianglesCount; i++)
	{
		triangle = triangles[i];
		vtx_0 = triangle.vertex0;
		vtx_1 = triangle.vertex1;
		vtx_2 = triangle.vertex2;
		
		verticesMap[vtx_0.getIdxInList().toString()] = vtx_0;
		verticesMap[vtx_1.getIdxInList().toString()] = vtx_1;
		verticesMap[vtx_2.getIdxInList().toString()] = vtx_2;
	}
	
	// finally make the unique vertices array.
	var vertex;
	for (var key in verticesMap)
	{
		if (Object.prototype.hasOwnProperty.call(verticesMap, key))
		{
			vertex = verticesMap[key];
			vertices.push(vertex);
		}
	}
	
	return vertices;
};

/**
 * 주어진 trianglesArray을 VBO face 형태의 버텍스 배열로 설정한다.
 * 
 * @param {Triangle[]} triangles 삼각형 클래스 배열
 * @param {VBOVertexIdxCacheKey} result 
 * @param {VboMemoryManager} vboMemManager 
 * @returns {VBOVertexIdxCacheKey}
 */
TrianglesList.getVboFaceDataArray = function(triangles, result, vboMemManager) 
{
	// TODO: 함수기능을 분리해야함.
	if (result === undefined)
	{ result = new VBOVertexIdxCacheKey(); }

	if (triangles === undefined)
	{ return result; }
	
	var trianglesCount = triangles.length;
	if (trianglesCount === 0)
	{ return result; }

	var indicesArray = TrianglesList.getTrianglesIndicesArray(triangles, undefined);
	result.setDataArrayIdx(indicesArray, vboMemManager);
	
	return result;
};

'use strict';

/**
 * Triangle 리스트의 배열
 * 
 * @class
 * 
 * @see TrianglesMatrix
 * @see TrianglesList
 */
var TrianglesMatrix= function() 
{
	if (!(this instanceof TrianglesMatrix)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	/**
	 * Triangle 리스트의 배열
	 * @type {TrianglesList[]}
	 */
	this.trianglesListsArray = [];
};

/**
 * 생성된 객체가 있다면 삭제하고, 초기화한다.
 */
TrianglesMatrix.prototype.deleteObjects = function()
{
	var trianglesListsCount = this.trianglesListsArray.length;
	for (var i=0; i<trianglesListsCount; i++)
	{
		this.trianglesListsArray[i].deleteObjects();
		this.trianglesListsArray[i] = undefined;
	}
	this.trianglesListsArray = [];
};

/**
 * 주어진 인덱스에 있는 TrianglesList를 가져온다.
 * 
 * @param {Number} index 가져올 Triangle 리스트의 인덱스 값
 * @returns {TrianglesList} 주어진 인덱스 위치의 TrianglesList
 */
TrianglesMatrix.prototype.getTrianglesList = function(index)
{
	return this.trianglesListsArray[index];
};

/**
 * TrianglesList 배열의 개수를 구한다.
 * 
 * @returns {Number} 배열의 개수
 */
TrianglesMatrix.prototype.getTrianglesListsCount = function()
{
	return this.trianglesListsArray.length;
};

/**
 * Triangle 객체의 리스트를 추가하고, 배열에 추가한다.
 *
 * @returns {TrianglesList} Triangle 객체의 리스트
 */
TrianglesMatrix.prototype.newTrianglesList = function()
{
	var trianglesList = new TrianglesList();
	this.trianglesListsArray.push(trianglesList);

	return trianglesList;
};

/**
 * 버텍스 인덱스를 할당한다.
 */
TrianglesMatrix.prototype.assignVerticesIdx = function() 
{
	var trianglesListsCount = this.trianglesListsArray.length;
	for (var i=0; i<trianglesListsCount; i++)
	{
		this.trianglesListsArray[i].assignVerticesIdx();
	}
};

/**
 * 주어진 trianglesArray을 VBO face 형태의 버텍스 배열로 설정한다.
 * 
 * @param {} result 
 * @returns vertexArray[idx] VBO face 형태의 버텍스 배열
 */
TrianglesMatrix.prototype.getVboFaceDataArray = function(result)
{
	// TODO: 정확한 입출력 결과 타입을 알 수 없음.
	var indicesArray = [];
	var trianglesListsCount = this.trianglesListsArray.length;
	for (var i=0; i<trianglesListsCount; i++)
	{
		indicesArray = this.trianglesListsArray[i].getTrianglesIndicesArray(indicesArray);
	}
	
	result.idxVboDataArray = Int16Array.from(indicesArray);
	result.indicesCount = result.idxVboDataArray.length;
	
	return result;
};



















































'use strict';


/**
 * 어떤 일을 하고 있습니까?
 * @class Tunnel
 */
var Tunnel = function() 
{
	if (!(this instanceof Tunnel)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	// This is a loft object, so need a path & a profile.
	
	this.geoCoordsListPath; // class : GeographicCoordsList.
	this.geoCoordsListProfile; // class : GeographicCoordsList.
	this.geoLocDataManager;
	
	this.vtxProfilesList;
	this.vboKeysContainer;
	this.vboKeysContainerEdges;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Tunnel.prototype.getGeoLocationData = function() 
{
	if (this.geoLocDataManager === undefined)
	{ this.geoLocDataManager = new GeoLocationDataManager(); }
	
	var geoLoc = this.geoLocDataManager.getCurrentGeoLocationData();
	if (geoLoc === undefined)
	{
		geoLoc = this.geoLocDataManager.newGeoLocationData("default");
	}
	
	return geoLoc;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Tunnel.prototype.getPathGeographicCoordsList = function() 
{
	if (this.geoCoordsListPath === undefined)
	{
		this.geoCoordsListPath = new GeographicCoordsList();
		this.geoCoordsListPath.owner = this;
	}
	return this.geoCoordsListPath;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Tunnel.prototype.getProfileGeographicCoordsList = function() 
{
	if (this.geoCoordsListProfile === undefined)
	{
		this.geoCoordsListProfile = new GeographicCoordsList();
		this.geoCoordsListProfile.owner = this;
	}

	return this.geoCoordsListProfile;
};

/**
 * 어떤 일을 하고 있습니까?
 */
Tunnel.prototype.renderPoints = function(magoManager, shader, renderType) 
{
	if (this.geoCoordsListPath === undefined)
	{ return false; }

	//this.renderMesh(magoManager, shader, renderType);
	this.renderTunnel(magoManager, shader, renderType);

	//if(this.meshPositive !== undefined)
	//{
	//	this.renderExcavation(magoManager, shader, renderType);
	//}
	
	this.geoCoordsListPath.renderPoints(magoManager, shader, renderType, false);
	this.geoCoordsListPath.renderLines(magoManager, shader, renderType, false, false);
};

/**
 * 어떤 일을 하고 있습니까?
 */
Tunnel.prototype.renderMesh = function(magoManager, shader, renderType) 
{
	if (this.meshPositive === undefined)
	{ return; }
	
	var gl = magoManager.sceneState.gl;
	var buildingGeoLocation = this.getGeoLocationData();
	buildingGeoLocation.bindGeoLocationUniforms(gl, shader);
	this.meshPositive.render(magoManager, shader, renderType);
};

/**
 * 어떤 일을 하고 있습니까?
 */
Tunnel.prototype.renderTunnel = function(magoManager, shader, renderType) 
{
	if (this.meshPositive === undefined)
	{ return; }
	
	//if(magoManager.currentFrustumIdx !== 0)
	//	return;
	
	var gl = magoManager.sceneState.gl;
	
	shader.useProgram();
	shader.resetLastBuffersBinded();

	shader.enableVertexAttribArray(shader.position3_loc);
	shader.disableVertexAttribArray(shader.color4_loc);
	shader.enableVertexAttribArray(shader.normal3_loc); 
	shader.disableVertexAttribArray(shader.texCoord2_loc); // provisionally has no texCoords.
	
	shader.bindUniformGenerals();

	
	gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
	gl.uniform4fv(shader.oneColor4_loc, [1.0, 1.0, 0.1, 0.0]); //.
	
	gl.uniform1i(shader.bApplySsao_loc, false); // apply ssao.
	gl.uniform1i(shader.refMatrixType_loc, 0); // in this case, there are not referencesMatrix.
	gl.uniform1i(shader.colorType_loc, 1); // 0= oneColor, 1= attribColor, 2= texture.
	gl.uniform1i(shader.bApplySpecularLighting_loc, true); // turn on/off specular lighting.
	
	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LEQUAL);
	gl.depthRange(0, 1);
	
	var buildingGeoLocation = this.geoLocDataManager.getCurrentGeoLocationData();
	buildingGeoLocation.bindGeoLocationUniforms(gl, shader); // rotMatrix, positionHIGH, positionLOW.
		
	
	// STENCIL SETTINGS.*
	gl.colorMask(false, false, false, false);
	gl.depthMask(false);
	gl.enable(gl.CULL_FACE);
	gl.enable(gl.STENCIL_TEST);
	//gl.enable(gl.POLYGON_OFFSET_FILL);
	//gl.polygonOffset(1.0, 2.0); // Original.
	//gl.polygonOffset(0.0, 0.0); 
	
	gl.clearStencil(0);
	var glPrimitive = undefined;
	
	
	//if(magoManager.currentFrustumIdx !== 5)
	{
		// First pass.*
		gl.cullFace(gl.FRONT); // 1rstPass.
		gl.stencilFunc(gl.ALWAYS, 0x0, 0xff);
		//gl.stencilOp(gl.KEEP, gl.INCR, gl.KEEP); // stencilOp(fail, zfail, zpass)
		gl.stencilOp(gl.KEEP, gl.INCR, gl.KEEP); // stencilOp(fail, zfail, zpass)
		this.meshPositive.render(magoManager, shader, renderType, glPrimitive);
	}
	
	
	//if(magoManager.currentFrustumIdx === 5)
	{
		// Second pass.*
		gl.cullFace(gl.BACK); // 2ndPass.
		gl.stencilFunc(gl.ALWAYS, 0x0, 0xff);
		//gl.stencilOp(gl.KEEP, gl.DECR, gl.KEEP); // stencilOp(fail, zfail, zpass)
		gl.stencilOp(gl.KEEP, gl.DECR, gl.KEEP); // stencilOp(fail, zfail, zpass)
		this.meshPositive.render(magoManager, shader, renderType, glPrimitive);// Original.
	}
	

	// Render the hole.
	//shader.bindUniformGenerals();
	gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
	gl.uniform4fv(shader.oneColor4_loc, [222/255, 184/255, 135/255, 1.0]); //.
	
	//gl.disable(gl.POLYGON_OFFSET_FILL);
	//gl.disable(gl.CULL_FACE);
	gl.colorMask(true, true, true, true);
	//gl.depthMask(false); // original.
	gl.depthMask(true);
	gl.stencilMask(0x00);

	//gl.stencilFunc(gl.NOTEQUAL, 0, 0xff);
	gl.stencilFunc(gl.LEQUAL, 1, 0xff);
	//gl.stencilFunc(gl.LESS, 0, 0xff);
	//gl.stencilFunc(gl.EQUAL, 1, 0xff);
	gl.stencilOp(gl.REPLACE, gl.REPLACE, gl.REPLACE); // stencilOp(fail, zfail, zpass)

	//gl.disable(gl.DEPTH_TEST);

	gl.cullFace(gl.BACK);

	gl.depthFunc(gl.ALWAYS);

	//gl.disable(gl.DEPTH_TEST);
	//gl.disable(gl.STENCIL_TEST);
	
	//if (magoManager.currentFrustumIdx === 0)
	//{
	//	
	//}
	
	this.meshNegative.render(magoManager, shader, renderType, glPrimitive);

	
	//gl.disable(gl.STENCIL_TEST);
	//gl.depthFunc(gl.LEQUAL);
	//this.meshPositive.render(magoManager, shader, renderType, glPrimitive);// Original.


	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LEQUAL);
	//gl.disable(gl.BLEND);
	gl.disable(gl.STENCIL_TEST);
	gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP); // stencilOp(fail, zfail, zpass)
	gl.disable(gl.POLYGON_OFFSET_FILL);
	gl.depthRange(0, 1);// return to the normal value.
	gl.useProgram(null);
	
	gl.depthMask(true); //sets whether writing into the depth buffer is enabled or disabled. Default value: true, meaning that writing is enabled.
	gl.stencilMask(0xff);
};

/**
 * 어떤 일을 하고 있습니까?
 */
Tunnel.prototype.makeMesh = function(magoManager) 
{
	if (this.geoCoordsListPath === undefined || this.geoCoordsListProfile === undefined)
	{ return false; }
	
	// 1rst, set position of this extrude object. Take as position the 1rst geoCoord absolute position.
	// Another possibility is calculate the average point of geoCoords.
	var geoLoc = this.getGeoLocationData();

	// Take the 1rst geographicCoord's geoLocation of the path.
	var geoCoord = this.geoCoordsListPath.getGeoCoord(0);
	var geoLocDataManagerFirst = geoCoord.getGeoLocationDataManager();
	var geoLocFirst = geoLocDataManagerFirst.getCurrentGeoLocationData();
	geoLoc.copyFrom(geoLocFirst);

	// Now, make the profiles ( 1 vtxProfile for each point of the path).
	if (this.vtxProfilesList === undefined)
	{ this.vtxProfilesList = new VtxProfilesList(); }
	
	// Transform pathGeoCoordsList to cartesianPath(points3DList).
	var wgs84Point3DArray = this.geoCoordsListPath.getWgs84Points3D(undefined);
	var relativePoints3dArray = geoLoc.getTransformedRelativePositionsArray(wgs84Point3DArray, undefined);
	
	var pathPoints3dList = new Point3DList(relativePoints3dArray);
	var bLoop = false; // this is a stringTypePath, no loopTypePath.
	
	// Provisionally make an circular profile in the 1rst point3d-plane.
	var bisectionPlane = pathPoints3dList.getBisectionPlane(0, undefined, bLoop);
	// Note: "bisectionPlane" is in local coordinate "geoLoc".
			
	var profile2d = new Profile2D();
	//profile2d.TEST__setFigureHole_2();
	//profile2d.TEST__setFigure_1();
	//profile2d.TEST__setFigure_2holes();
	
	var ring = profile2d.newOuterRing();
	var circle = ring.newElement("CIRCLE");
	circle.setCenterPosition(0, 0);
	circle.setRadius(15);
	var resultPoints2dArray = [];
	var pointsCountFor360Deg = 24;
	ring.getPoints(resultPoints2dArray, pointsCountFor360Deg);

	// Now, calculate the rotMatrix of the bisectionPlane, & calculate points3ds of the circle points2d.
	var rotMat4 = bisectionPlane.getRotationMatrix(undefined);
	var firstPoint3d = pathPoints3dList.getPoint(0);
	rotMat4.setTranslation(firstPoint3d.x, firstPoint3d.y, firstPoint3d.z);

	// Make the loft vtxProfilesList.
	//bLoop = true;
	
	if (this.meshPositive === undefined)
	{
		this.vtxProfilesList.makeLoft(profile2d, pathPoints3dList, bLoop);
		
		// positive mesh.
		var bIncludeBottomCap = true;
		var bIncludeTopCap = true;
		var meshAux = this.vtxProfilesList.getMesh(undefined, bIncludeBottomCap, bIncludeTopCap, bLoop);
		this.meshPositive = meshAux.getCopySurfaceIndependentMesh(this.meshPositive);
		var bForceRecalculatePlaneNormal = false;
		this.meshPositive.calculateVerticesNormals(bForceRecalculatePlaneNormal);
		this.meshPositive.setColor(0.1, 0.5, 0.5, 1.0);
		
		// negative mesh.
		this.meshNegative = meshAux.getCopySurfaceIndependentMesh(this.meshNegative);
		this.meshNegative.reverseSense(); // here calculates vertices normals.
		this.meshNegative.setColor(0.1, 0.5, 0.5, 1.0);
		this.meshNegative.getVbo(this.vboKeysContainer, magoManager.vboMemoryManager);
		this.meshNegative.getVboEdges(this.vboKeysContainerEdges, magoManager.vboMemoryManager);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 */
Tunnel.prototype.remakeMesh = function(magoManager) 
{
	if (this.vtxProfilesList === undefined)
	{ return false; }
	
	// 1rst, set position of this extrude object. Take as position the 1rst geoCoord absolute position.
	// Another possibility is calculate the average point of geoCoords.
	var geoLoc = this.getGeoLocationData();

	// Take the 1rst geographicCoord's geoLocation of the path.
	var geoCoord = this.geoCoordsListPath.getGeoCoord(0);
	var geoLocDataManagerFirst = geoCoord.getGeoLocationDataManager();
	var geoLocFirst = geoLocDataManagerFirst.getCurrentGeoLocationData();
	geoLoc.copyFrom(geoLocFirst);

	// Now, make the profiles ( 1 vtxProfile for each point of the path).
	
	// Transform pathGeoCoordsList to cartesianPath(points3DList).
	var wgs84Point3DArray = this.geoCoordsListPath.getWgs84Points3D(undefined);
	var relativePoints3dArray = geoLoc.getTransformedRelativePositionsArray(wgs84Point3DArray, undefined);
	
	var pathPoints3dList = new Point3DList(relativePoints3dArray);
	var bLoop = false; // this is a stringTypePath, no loopTypePath.
	
	// Provisionally make an circular profile in the 1rst point3d-plane.
	var bisectionPlane = pathPoints3dList.getBisectionPlane(0, undefined, bLoop);
	// Note: "bisectionPlane" is in local coordinate "geoLoc".
			
	var profile2d = new Profile2D();
	//profile2d.TEST__setFigureHole_2();
	//profile2d.TEST__setFigure_1();
	//profile2d.TEST__setFigure_2holes();
	
	var ring = profile2d.newOuterRing();
	var circle = ring.newElement("CIRCLE");
	circle.setCenterPosition(0, 0);
	circle.setRadius(15);
	var resultPoints2dArray = [];
	var pointsCountFor360Deg = 24;
	ring.getPoints(resultPoints2dArray, pointsCountFor360Deg);

	// Now, calculate the rotMatrix of the bisectionPlane, & calculate points3ds of the circle points2d.
	var rotMat4 = bisectionPlane.getRotationMatrix(undefined);
	var firstPoint3d = pathPoints3dList.getPoint(0);
	rotMat4.setTranslation(firstPoint3d.x, firstPoint3d.y, firstPoint3d.z);

	// Make the loft vtxProfilesList.
	//bLoop = true;
	this.meshPositive = undefined;
	this.meshNegative = undefined;
	
	this.vtxProfilesList.deleteObjects();
	this.vtxProfilesList = new VtxProfilesList();
	
	if (this.meshPositive === undefined)
	{
		this.vtxProfilesList.makeLoft(profile2d, pathPoints3dList, bLoop);
		
		// positive mesh.
		var bIncludeBottomCap = true;
		var bIncludeTopCap = true;
		var meshAux = this.vtxProfilesList.getMesh(undefined, bIncludeBottomCap, bIncludeTopCap, bLoop);
		this.meshPositive = meshAux.getCopySurfaceIndependentMesh(this.meshPositive);
		var bForceRecalculatePlaneNormal = false;
		this.meshPositive.calculateVerticesNormals(bForceRecalculatePlaneNormal);
		this.meshPositive.setColor(0.1, 0.5, 0.5, 1.0);
		
		// negative mesh.
		this.meshNegative = meshAux.getCopySurfaceIndependentMesh(this.meshNegative);
		this.meshNegative.reverseSense(); // here calculates vertices normals.
		this.meshNegative.setColor(0.1, 0.5, 0.5, 1.0);
		this.meshNegative.getVbo(this.vboKeysContainer, magoManager.vboMemoryManager);
		this.meshNegative.getVboEdges(this.vboKeysContainerEdges, magoManager.vboMemoryManager);
	}
};















































'use strict';

/**
 * Data structure with vertex information
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class Vertex
 * 
 * @param {Point3D} position vertex postion.
 */
var Vertex = function(position) 
{
	if (!(this instanceof Vertex)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	/**
	 * vertex 3d coordinate.
	 * @type {Point3D}
	 */
	this.point3d;

	/**
	 * vertex noraml.
	 * @type {Point3D}
	 */
	this.normal;

	/**
	 * 2d coordinate
	 * @type {Point2D}
	 */
	this.texCoord;

	/**
	 * vertex color
	 * @type {Color}
	 */
	this.color4; // class: Color.
	
	/**
	 * outingHedge
	 * @type {HalfEdge}
	 */
	this.outingHedge; // class: HalfEdge

	/**
	 * vertex type. 1 is important vertex.
	 * @type {Number}
	 */
	this.vertexType;

	/**
	 *  vertexList index
	 * @type {Number}
	 * 
	 * @see VertexList
	 */
	this.idxInList;
	

	if (position)
	{ this.point3d = position; }
	else
	{
		this.point3d = new Point3D();
	}
};

/**
 * vertex init.
 * all member set undifined;
 */
Vertex.prototype.deleteObjects = function() 
{
	if (this.point3d)
	{ this.point3d.deleteObjects(); }
	if (this.normal)
	{ this.normal.deleteObjects(); }
	if (this.texCoord)
	{ this.texCoord.deleteObjects(); }
	if (this.color4)
	{ this.color4.deleteObjects(); }
	
	this.point3d = undefined;
	this.normal = undefined;
	this.texCoord = undefined;
	this.color4 = undefined;
};

/**
 * get vertexList index
 * @returns {Number}
 */
Vertex.prototype.getIdxInList = function() 
{
	return this.idxInList;
};

/**
 * set vertexList index
 * @param {Number} idx index
 */
Vertex.prototype.setIdxInList = function(idx) 
{
	this.idxInList = idx;
};

/**
 * set this vertex type. vertexType is used in auxiliar process, such as merging vertices in a mesh.
 * @param {Number} vertexType
 */
Vertex.prototype.setVertexType = function(vertexType) 
{
	this.vertexType = vertexType;
};

/**
 * set this vertex type. vertexType is used in auxiliar process, such as merging vertices in a mesh.
 * @param {Number} vertexType
 */
Vertex.prototype.getVertexType = function() 
{
	return this.vertexType;
};

/**
 * make vertex copy from another vertex. like clone.
 * @param {Vertex} vertex 
 */
Vertex.prototype.copyFrom = function(vertex) 
{
	// copy position if exist.
	if (vertex.point3d)
	{
		if (this.point3d === undefined)
		{ this.point3d = new Point3D(); }
		
		this.point3d.copyFrom(vertex.point3d);
	}
	
	// copy normal if exist.
	if (vertex.normal)
	{
		if (this.normal === undefined)
		{ this.normal = new Point3D(); }
		
		this.normal.copyFrom(vertex.normal);
	}
	
	// copy texCoord if exist.
	if (vertex.texCoord)
	{
		if (this.texCoord === undefined)
		{ this.texCoord = new Point2D(); }
		
		this.texCoord.copyFrom(vertex.texCoord);
	}
	
	// copy color4 if exist.
	if (vertex.color4)
	{
		if (this.color4 === undefined)
		{ this.color4 = new Color(); }
		
		this.color4.copyFrom(vertex.color4);
	}
	
	this.vertexType = vertex.vertexType;
};

/**
 * get this vertex point.
 * @returns {Point3D}
 */
Vertex.prototype.getPosition = function() 
{
	return this.point3d;
};

/**
 * set this vertex point. if this point3d undefined, set new Point3D instance.
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 */
Vertex.prototype.setPosition = function(x, y, z) 
{
	if (this.point3d === undefined)
	{ this.point3d = new Point3D(); }
	
	this.point3d.set(x, y, z);
};

/**
 * set this vertex texCoord. if this texCoord undefined, set new Point2D instance.
 * @param {Number} s
 * @param {Number} t
 */
Vertex.prototype.setTexCoord = function(s, t) 
{
	if (this.texCoord === undefined)
	{ this.texCoord = new Point2D(); }
	
	this.texCoord.set(s, t);
};

/**
 * set this vertex color exclude alpha. if this color4 undefined, set new Color instance.
 * @param {Number} r
 * @param {Number} g
 * @param {Number} b
 */
Vertex.prototype.setColorRGB = function(r, g, b) 
{
	if (this.color4 === undefined) { this.color4 = new Color(); }
	
	this.color4.setRGB(r, g, b);
};

/**
 * set this vertex color include alpha. if this color4 undefined, set new Color instance.
 * @param {Number} r
 * @param {Number} g
 * @param {Number} b
 * @param {Number} alpha
 */
Vertex.prototype.setColorRGBA = function(r, g, b, alpha) 
{
	if (this.color4 === undefined) { this.color4 = new Color(); }
	
	this.color4.setRGBA(r, g, b, alpha);
};

/**
 * set this vertex normal. if this normal undefined, set new Point3D instance.
 * @param {Number} nx
 * @param {Number} ny
 * @param {Number} nz
 */
Vertex.prototype.setNormal = function(nx, ny, nz) 
{
	if (this.normal === undefined) { this.normal = new Point3D(); }
	
	this.normal.set(nx, ny, nz);
};

/**
 * get this vertex normal
 * @returns {Point3D} normal
 */
Vertex.prototype.getNormal = function() 
{
	if (this.normal === undefined) { this.normal = new Point3D(); }
	
	return this.normal;
};

/**
 * get this vertex normal
 * @returns {Point2D} normal
 */
Vertex.prototype.getTexCoord = function() 
{
	if (this.texCoord === undefined) { this.texCoord = new Point2D(); }
	
	return this.texCoord;
};

/**
 * vertex point translate. use add method.
 * @param {Number} dx
 * @param {Number} dy
 * @param {Number} dz
 * @see Point3D#add
 */
Vertex.prototype.translate = function(dx, dy, dz) 
{
	this.point3d.add(dx, dy, dz);
};

/**
 * get vertex outinghedges. 
 * @param {Array} resultHedgesArray
 * @returns {Array} resultHedgesArray
 */
Vertex.prototype.getOutingHEdges = function(resultHedgesArray) 
{
	if (resultHedgesArray === undefined)
	{ resultHedgesArray = []; }

	// todo:
	
	return resultHedgesArray;
};

/**
 * get vertex outinghedges. 
 * @returns {HalfEdge} resultHedge
 */
Vertex.prototype.getOutingFrontierHEdge = function() 
{
	// 1rst, check if this.outingHedge is frontier.
	if (this.outingHedge.isFrontier())
	{ return this.outingHedge; }
	
	var finished = false;
	var hedge = this.outingHedge.twin.next;
	while (!finished)
	{
		if (hedge.isFrontier())
		{ return hedge; }
		
		hedge = hedge.twin.next;
		
		if (hedge === undefined || hedge === this.outingHedge)
		{ return undefined; }
	}
};

/**
 * get vertex intersected with plane. 
 * @static
 * @param {Vertex} vertex Required. 
 * @returns {Array} resultCoincidentVertexArray
 */
Vertex.getCoincidentVertexArray = function(vertex, vertexToCompareArray, resultCoincidentVertexArray, errorDist)
{
	if (vertex === undefined || vertexToCompareArray === undefined)
	{ return resultCoincidentVertexArray; }
	
	if (resultCoincidentVertexArray === undefined)
	{ resultCoincidentVertexArray = []; }
	
	if (errorDist === undefined)
	{ errorDist = 1e-4; }
	
	var point3d = vertex.getPosition();
	var vertexCount = vertexToCompareArray.length;
	for (var i=0; i<vertexCount; i++)
	{
		var currVertex = vertexToCompareArray[i];
		if (vertex === currVertex)
		{ continue; }
		
		var currPoint3d = currVertex.getPosition();
		
		if (point3d.isCoincidentToPointCHEAP(currPoint3d, errorDist))
		{
			resultCoincidentVertexArray.push(currVertex);
		}
	}
	
	return resultCoincidentVertexArray;
};

/**
 * get vertex intersected with plane. 
 * @static
 * @param {Vertex} vertex Required. 
 * @param {Plane} plane. 
 * @param {Point3D} projectionDirection projectionDirection must be unitary.
 * @param {Vertex} resultVertex Optional. 
 * @returns {Vertex} resultVertex
 */
Vertex.getProjectedOntoPlane = function(vertex, plane, projectionDirection, resultVertex)
{
	if (vertex === undefined)
	{ return resultVertex; }
	
	var position = vertex.getPosition();
	var line = new Line(position, projectionDirection);

	var intersectionPoint;
	intersectionPoint = plane.intersectionLine(line, intersectionPoint);
	
	if (resultVertex === undefined)
	{ resultVertex = new Vertex(); }
	
	// 1rst, copy from the original vertex.
	resultVertex.copyFrom(vertex);
	
	// Now, change only the position.
	resultVertex.setPosition(intersectionPoint.x, intersectionPoint.y, intersectionPoint.z);
	
	return resultVertex;
};

'use strict';

/**
 * Vertex List (Array of Vetex)
 * @see Vertex
 * 
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class VertexList
 */
var VertexList = function() 
{
	if (!(this instanceof VertexList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * vertex list.
	 * @type {Array.<Vertex>}
	 */
	this.vertexArray = [];
};

/**
 * get previus index of vertexArray
 * @static
 * @param {Number} idx index must bigger than 0, less than vertexArray length.
 * @param {Array.<Vertex>} vertexArray
 * @returns {Number} prevIdx. if idx is 0, return vertexArray.length - 1.
 */
VertexList.getPrevIdx = function(idx, vertexArray)
{
	var verticesCount = vertexArray.length;
	
	if (idx < 0 || idx > verticesCount-1)
	{ return undefined; }
	
	var prevIdx;
	
	if (idx === 0)
	{ prevIdx = verticesCount - 1; }
	else
	{ prevIdx = idx - 1; }

	return prevIdx;
};

/**
 * get next index of vertexArray
 * @static
 * @param {Number} idx index must bigger than 0, less than vertexArray length.
 * @param {Array.<Vertex>} vertexArray
 * @returns {Number} nextIdx. if idx is equal vertexArray.length - 1, return 0.
 */
VertexList.getNextIdx = function(idx, vertexArray)
{
	var verticesCount = vertexArray.length;
	
	if (idx < 0 || idx > verticesCount-1)
	{ return undefined; }
	
	var nextIdx;
	
	if (idx === verticesCount - 1)
	{ nextIdx = 0; }
	else
	{ nextIdx = idx + 1; }

	return nextIdx;
};

/**
 * get vertex segment. This segment is consist of indexed vertex and next vertex
 * @static
 * @param {Number} idx index
 * @param {Array.<Vertex>} vertexArray
 * @param {VtxSegment} resultVtxSegment if resultVtxSegment is undefined, resultVtxSegment set new VtxSegemnt instance.
 * @returns {VtxSegment} resultVtxSegment
 */
VertexList.getVtxSegment = function(idx, vertexArray, resultVtxSegment)
{
	var currVertex = vertexArray[idx];
	var nextIdx = VertexList.getNextIdx(idx, vertexArray);
	var nextVertex = vertexArray[nextIdx];
	
	if (resultVtxSegment === undefined)
	{ resultVtxSegment = new VtxSegment(currVertex, nextVertex); }
	else 
	{
		resultVtxSegment.setVertices(currVertex, nextVertex);
	}

	return resultVtxSegment;
};

/**
 * get vertex vector. This vector is consist of indexed vertex and next vertex
 * @static
 * @param {Number} idx index
 * @param {Array.<Vertex>} vertexArray
 * @param {Point3D} resultVector if resultVector is undefined, resultVector set new Point3D instance.
 * @returns {Point3D} resultVector
 */
VertexList.getVector = function(idx, vertexArray, resultVector)
{
	var currVertex = vertexArray[idx];
	var nextIdx = VertexList.getNextIdx(idx, vertexArray);
	var nextVertex = vertexArray[nextIdx];
	
	var currPoint = currVertex.point3d;
	var nextPoint = nextVertex.point3d;
	
	if (resultVector === undefined)
	{ resultVector = new Point3D(nextPoint.x - currPoint.x, nextPoint.y - currPoint.y, nextPoint.z - currPoint.z); }
	else 
	{
		resultVector.set(nextPoint.x - currPoint.x, nextPoint.y - currPoint.y, nextPoint.z - currPoint.z);
	}

	return resultVector;
};

/**
 * get vertex direction. vertex vector's unitary.
 * @static
 * @param {Number} idx index
 * @param {Array.<Vertex>} vertexArray
 * @param {Point3D} resultDir point3d unitary.
 * @returns {Point3D} 
 */
VertexList.getDirection = function(idx, vertexArray, resultDir)
{
	resultDir = VertexList.getVector(idx, vertexArray, resultDir);
	resultDir.unitary();
	return resultDir;
};

/**
 * get crossproduct. This crossproduct is consist of indexed vertex and prev vertex
 * @deprecated
 * @static
 * @param {Number} idx index
 * @param {Array.<Vertex>} vertexArray
 * @param {Point3D} resultCrossProduct
 * @returns {Point3D} 
 */
VertexList.getCrossProduct = function(idx, vertexArray, resultCrossProduct)
{
	var currVector = VertexList.getVector(idx, vertexArray, undefined);
	var prevIdx = VertexList.getPrevIdx(idx, vertexArray);
	var prevVector = VertexList.getVector(prevIdx, vertexArray, undefined);
	resultCrossProduct = prevVector.crossProduct(currVector, resultCrossProduct);

	return resultCrossProduct;
};

/**
 * get vertex list. this vertex is projected onto plane. 
 * @static
 * @param {Array.<Vertex>} vertexArray if vertexArray is undefined, return resultVertexList
 * @param {Plane} plane. 
 * @param {Point3D} projectionDirection projectionDirection must be unitary.
 * @param {VertexList} resultVertexList if resultVertexList is undefined, resultVector set new VertexList instance.
 * @returns {VertexList} 
 * 
 * @see Vertex#getProjectedOntoPlane
 */
VertexList.getProjectedOntoPlane = function(vertexList, plane, projectionDirection, resultVertexList)
{
	if (vertexList === undefined)
	{ return resultVertexList; }
	
	if (resultVertexList === undefined)
	{ resultVertexList = new VertexList(); }
	
	var vertex, projectedVertex;
	var vertexCount = vertexList.getVertexCount();
	for (var i=0; i<vertexCount; i++)
	{
		vertex = vertexList.getVertex(i);
		projectedVertex = resultVertexList.newVertex();
		projectedVertex = Vertex.getProjectedOntoPlane(vertex, plane, projectionDirection, projectedVertex);
	}
	
	return resultVertexList;
};

/**
 * get projected point(2d) list.
 * @static
 * @param {Array.<Vertex>} vertexArray if vertexArray is undefined, return resultPoints2dArray
 * @param {Point3D} normal. 
 * @param {Array.<Point2D>} resultPoints2dArray array.
 * @returns {Array.<Point2D>} resultPoints2dArray
 */
VertexList.getProjectedPoints2DArray = function(vertexArray, normal, resultPoints2dArray)
{
	// This function projects the vertices on to planes xy, yz or xz.
	if (vertexArray === undefined)
	{ return resultPoints2dArray; }
	
	if (resultPoints2dArray === undefined)
	{ resultPoints2dArray = []; }
	
	var bestPlaneToProject = Face.getBestFacePlaneToProject(normal);
	
	var point2d;
	var verticesCount = vertexArray.length;
	// Project this face into the bestPlane.
	if (bestPlaneToProject === 0) // plane-xy.
	{
		// project this face into a xy plane.
		for (var i=0; i<verticesCount; i++)
		{
			var vertex = vertexArray[i];
			var point3d = vertex.point3d;
			if (normal.z > 0)
			{ point2d = new Point2D(point3d.x, point3d.y); }
			else
			{ point2d = new Point2D(point3d.x, -point3d.y); }
			point2d.ownerVertex3d = vertex; // with this we can reconvert polygon2D to face3D.
			resultPoints2dArray.push(point2d);
		}
	}
	else if (bestPlaneToProject === 1) // plane-yz.
	{
		// project this face into a yz plane.
		for (var i=0; i<verticesCount; i++)
		{
			var vertex = vertexArray[i];
			var point3d = vertex.point3d;
			if (normal.x > 0)
			{ point2d = new Point2D(point3d.y, point3d.z); }
			else
			{ point2d = new Point2D(-point3d.y, point3d.z); }
			point2d.ownerVertex3d = vertex; // with this we can reconvert polygon2D to face3D.
			resultPoints2dArray.push(point2d);
		}
	}
	else if (bestPlaneToProject === 2) // plane-xz.
	{
		// project this face into a xz plane.
		for (var i=0; i<verticesCount; i++)
		{
			var vertex = vertexArray[i];
			var point3d = vertex.point3d;
			if (normal.y > 0)
			{ point2d = new Point2D(-point3d.x, point3d.z); }
			else
			{ point2d = new Point2D(point3d.x, point3d.z); }
			point2d.ownerVertex3d = vertex; // with this we can reconvert polygon2D to face3D.
			resultPoints2dArray.push(point2d);
		}
	}
	
	return resultPoints2dArray;
};

/**
 * delete all vertex.
 */
VertexList.prototype.deleteVertexByVertexType = function(vertexTypeToDelete) 
{
	var vertexToSave = [];
	var vertexCount = this.getVertexCount();
	for (var i=0; i<vertexCount; i++)
	{
		var currVertex = this.getVertex(i);
		if (currVertex.getVertexType() !== vertexTypeToDelete)
		{ 
			vertexToSave.push(currVertex); 
		}
		else
		{
			currVertex.deleteObjects();
		}
	}
	this.vertexArray = vertexToSave;
};

/**
 * delete all vertex.
 */
VertexList.prototype.deleteObjects = function() 
{
	for (var i = 0, vertexCount = this.vertexArray.length; i < vertexCount; i++) 
	{
		this.vertexArray[i].deleteObjects();
		this.vertexArray[i] = undefined;
	}
	this.vertexArray = undefined;
};

/**
 * Copy vertex list from another vertexList.
 * @param {VertexList} vertexList
 */
VertexList.prototype.copyFrom = function(vertexList) 
{
	// first reset vertexArray.
	this.deleteObjects();
	this.vertexArray = [];
	
	var vertex;
	var myVertex;
	var vertexCount = vertexList.getVertexCount();
	for (var i=0; i<vertexCount; i++)
	{
		vertex = vertexList.getVertex(i);
		myVertex = this.newVertex();
		myVertex.copyFrom(vertex);
	}
};

/**
 * Copy vertex list from point3d array
 * @param {Array.<Point3D>} point3dArray Required.
 */
VertexList.prototype.copyFromPoint3DArray = function(point3dArray) 
{
	if (point3dArray === undefined)
	{ return; }
	
	// first reset vertexArray.
	this.deleteObjects();
	this.vertexArray = [];
	
	var point3d;
	var vertex;

	var pointsCount = point3dArray.length;
	for (var i=0; i<pointsCount; i++)
	{
		point3d = point3dArray[i];
		vertex = this.newVertex();
		vertex.point3d = new Point3D();
		vertex.point3d.set(point3d.x, point3d.y, point3d.z);
		vertex.point3d.pointType = point3d.pointType;
		vertex.vertexType = point3d.pointType;
	}
};

/**
 * Copy vertex list from point2d array and z coordinate.
 * @param {Point2DList} point2dArray.
 * @param {Number} z default is 0.
 */
VertexList.prototype.copyFromPoint2DList = function(point2dList, z) 
{
	// first reset vertexArray.
	this.deleteObjects();
	this.vertexArray = [];
	
	var point2d;
	var vertex;
	if (z === undefined)
	{ z = 0; }

	var pointsCount = point2dList.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		point2d = point2dList.getPoint(i);
		vertex = this.newVertex();
		vertex.point3d = new Point3D();
		vertex.point3d.set(point2d.x, point2d.y, z);
		vertex.point3d.pointType = point2d.pointType;
		vertex.vertexType = point2d.pointType;
	}
};

/**
 * set normal
 * @param {Number} nx
 * @param {Number} ny
 * @param {Number} nz
 */
VertexList.prototype.setNormal = function(nx, ny, nz) 
{
	var vertex;
	var vertexCount = this.getVertexCount();
	for (var i=0; i<vertexCount; i++)
	{
		vertex = this.getVertex(i);
		vertex.setNormal(nx, ny, nz);
	}
};

/**
 * add vertex and return.
 * @returns {Vertex}
 */
VertexList.prototype.newVertex = function(point3d) 
{
	var vertex = new Vertex(point3d);
	this.vertexArray.push(vertex);
	return vertex;
};

/**
 * get vertex
 * @param {Number} idx
 * @returns {Vertex}
 */
VertexList.prototype.getVertex = function(idx) 
{
	return this.vertexArray[idx];
};

/**
 * get vertex list lench
 * @returns {Number}
 */
VertexList.prototype.getVertexCount = function() 
{
	return this.vertexArray.length;
};

/**
 * get previus index
 * @param {Number} idx
 * @returns {Number} prev index
 */
VertexList.prototype.getPrevIdx = function(idx)
{
	return VertexList.getPrevIdx(idx, this.vertexArray);
};

/**
 * get next index
 * @param {Number} idx
 * @returns {Number} next index
 */
VertexList.prototype.getNextIdx = function(idx)
{
	return VertexList.getNextIdx(idx, this.vertexArray);
};

/**
 * get index of vertex in list
 * @deprecated not use.
 * @param {Vertex}
 * @returns {Number} index
 */
VertexList.prototype.getIdxOfVertex = function(vertex)
{
	var verticesCount = this.vertexArray.length;
	var i=0;
	var idx = -1;
	var found = false;
	while (!found && i<verticesCount)
	{
		if (this.vertexArray[i] === vertex)
		{
			found = true;
			idx = i;
		}
		i++;
	}
	
	return idx;
};

/**
 * get vertex segment
 * @deprecated not use.
 * @param {Number} idx
 * @param {VtxSegment}
 * @returns {VtxSegment}
 */
VertexList.prototype.getVtxSegment = function(idx, resultVtxSegment)
{
	return VertexList.getVtxSegment(idx, this.vertexArray, resultVtxSegment);
};

/**
 * translate vertex
 * @param {Number} dx
 * @param {Number} dy
 * @param {Number} dz
 */
VertexList.prototype.translateVertices = function(dx, dy, dz) 
{
	for (var i = 0, vertexCount = this.vertexArray.length; i < vertexCount; i++) 
	{
		this.vertexArray[i].translate(dx, dy, dz);
	}
};

/**
 * get bounding box of vertex list.
 * @param {BoundingBox} resultBox if this is undefined, set new BoundingBox instance.
 * @returns {BoundingBox} resultBox
 */
VertexList.prototype.getBoundingBox = function(resultBox) 
{
	if (resultBox === undefined) { resultBox = new BoundingBox(); }

	for (var i = 0, vertexCount = this.vertexArray.length; i < vertexCount; i++) 
	{
		if (i === 0) { resultBox.init(this.vertexArray[i].point3d); }
		else { resultBox.addPoint(this.vertexArray[i].point3d); }
	}
	return resultBox;
};

/**
 * vertex point transform by matrix4
 * @param {Matrix4} transformMatrix
 * @see Matrix4#transformPoint3D
 */
VertexList.prototype.transformPointsByMatrix4 = function(transformMatrix) 
{
	for (var i = 0, vertexCount = this.vertexArray.length; i < vertexCount; i++) 
	{
		var vertex = this.vertexArray[i];
		transformMatrix.transformPoint3D(vertex.point3d, vertex.point3d);
	}
};

/**
 * set vertex idxInList
 */
VertexList.prototype.setIdxInList = function()
{
	VertexList.setIdxInList(this.vertexArray);
	/*
	for (var i = 0, vertexCount = this.vertexArray.length; i < vertexCount; i++) 
	{
		this.vertexArray[i].idxInList = i;
	}
	*/
};

/**
 * set vertex idxInList
 * @static
 * @param {VertexList} Required.
 */
VertexList.setIdxInList = function(vertexArray)
{
	if (vertexArray === undefined)
	{ return; }
	
	for (var i = 0, vertexCount = vertexArray.length; i < vertexCount; i++) 
	{
		vertexArray[i].idxInList = i;
	}
};

/**
 * get vbo vertex index cache key. not use.
 * @deprecated only used static method.
 * @param {VBOVertexIdxCacheKey} resultVbo.
 * @param {VBOMemoryManager} vboMemManager.
 * @returns {VBOVertexIdxCacheKey}
 * 
 * @see VertexList#getVboDataArrays
 */
VertexList.prototype.getVboDataArrays = function(resultVbo, vboMemManager) 
{
	VertexList.getVboDataArrays(this.vertexArray, resultVbo, vboMemManager) ;
	return resultVbo;
};

/**
 * get vbo vertex index cache key. for set VboBuffer data
 * @static
 * @param {VertexList} vertexArray if this length 0, return argument resultVbo.
 * @param {VBOVertexIdxCacheKey} resultVbo. if this is undefined, set new VBOVertexIdxCacheKey Instance.
 * @param {VBOMemoryManager} vboMemManager.
 * @returns {VBOVertexIdxCacheKey}
 * 
 * @see VBOManager
 */
VertexList.getVboDataArrays = function(vertexArray, resultVbo, vboMemManager) 
{
	// returns positions, and if exist, normals, colors, texCoords.
	var verticesCount = vertexArray.length;
	if (verticesCount === 0)
	{ return resultVbo; }
	
	if (resultVbo === undefined)
	{ resultVbo = new VBOVertexIdxCacheKey(); }
	
	var vertex, position, normal, color, texCoord;
	
	// 1rst, check if exist normals, colors & texCoords.
	var hasNormals = false;
	var hasColors = false;
	var hasTexCoords = false;
	
	// Take the 1rst vertex.
	vertex = vertexArray[0];
	if (vertex.point3d === undefined)
	{ return resultVbo; }
	
	if (vertex.normal !== undefined)
	{ hasNormals = true; }
	
	if (vertex.color4 !== undefined)
	{ hasColors = true; }
	
	if (vertex.texCoord !== undefined)
	{ hasTexCoords = true; }
	
	// Make dataArrays. Use vboMemManager to determine classified memorySize( if use memory pool).
	var posVboDataArray, norVboDataArray, colVboDataArray, tcoordVboDataArray;
	
	// Positions.
	var posByteSize = verticesCount * 3;
	posVboDataArray = new Float32Array(posByteSize);
	
	if (hasNormals)
	{ 
		var norByteSize = verticesCount * 3;
		norVboDataArray = new Int8Array(norByteSize);
	}
	
	if (hasColors)
	{ 
		var colByteSize = verticesCount * 4;
		colVboDataArray = new Uint8Array(colByteSize);
	}
	
	if (hasTexCoords)
	{ 
		var texCoordByteSize = verticesCount * 2;
		tcoordVboDataArray = new Float32Array(texCoordByteSize);
	}
	
	for (var i = 0; i < verticesCount; i++) 
	{
		vertex = vertexArray[i];
		if (vertex.point3d === undefined)
		{ continue; }
		
		position = vertex.point3d;

		posVboDataArray[i*3] = position.x;
		posVboDataArray[i*3+1] = position.y;
		posVboDataArray[i*3+2] = position.z;
		
		if (hasNormals)
		{
			normal = vertex.normal;
			norVboDataArray[i*3] = normal.x*127;
			norVboDataArray[i*3+1] = normal.y*127;
			norVboDataArray[i*3+2] = normal.z*127;
		}
		
		if (hasColors)
		{
			color = vertex.color4;
			colVboDataArray[i*4] = color.r*255;
			colVboDataArray[i*4+1] = color.g*255;
			colVboDataArray[i*4+2] = color.b*255;
			colVboDataArray[i*4+3] = color.a*255;
		}
		
		if (hasTexCoords)
		{
			texCoord = vertex.texCoord;
			tcoordVboDataArray[i*2] = texCoord.x;
			tcoordVboDataArray[i*2+1] = texCoord.y;
		}
	}
	
	resultVbo.setDataArrayPos(posVboDataArray, vboMemManager);
	
	if (hasNormals)
	{
		resultVbo.setDataArrayNor(norVboDataArray, vboMemManager);
	}
	
	if (hasColors)
	{
		resultVbo.setDataArrayCol(colVboDataArray, vboMemManager);
	}
	
	if (hasTexCoords)
	{
		resultVbo.setDataArrayTexCoord(tcoordVboDataArray, vboMemManager);
	}

	return resultVbo;
};

'use strict';


/**
 * Vertex Matrix (Array of VertexList)
 * @see Vertex
 * @see VertexList
 * 
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class VertexMatrix
 */
var VertexMatrix = function() 
{
	if (!(this instanceof VertexMatrix)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	/**
	 * VertexList Array
	 * @instance
	 * @type {Array.<VertexList>}
	 */
	this.vertexListsArray = [];
	// SCTRATXH.

	/**
	 * All Vertex array
	 * @instance
	 * @type {Array.<Vertex>}
	 */
	this.totalVertexArraySC = [];
};

/**
 * delete all vertex.
 */
VertexMatrix.prototype.deleteObjects = function() 
{
	for (var i = 0, vertexListsCount = this.vertexListsArray.length; i < vertexListsCount; i++) 
	{
		this.vertexListsArray[i].deleteObjects();
		this.vertexListsArray[i] = undefined;
	}
	this.vertexListsArray = undefined;
};

/**
 * add vertex list and return.
 * @returns {VertexList}}
 */
VertexMatrix.prototype.newVertexList = function() 
{
	var vertexList = new VertexList();
	this.vertexListsArray.push(vertexList);
	return vertexList;
};

/**
 * get vertex list
 * @param {Number }idx
 * @returns {VertextList|undefined} if invalid idx, return undefined
 */
VertexMatrix.prototype.getVertexList = function(idx) 
{
	if (idx >= 0 && idx < this.vertexListsArray.length) 
	{
		return this.vertexListsArray[idx];
	}
	else 
	{
		return undefined;
	}
};

/**
 * copy from another vertex matrix.
 * @param {VertexMatrix} vertexMatrix Required.
 */
VertexMatrix.prototype.copyFrom = function(vertexMatrix) 
{
	if (vertexMatrix === undefined)
	{ return; }
	
	var vertexList, myVertexList;
	var vertexListsCount = vertexMatrix.vertexListsArray.length;
	for (var i=0; i<vertexListsCount; i++)
	{
		vertexList = vertexMatrix.getVertexList(i);
		myVertexList = this.newVertexList();
		myVertexList.copyFrom(vertexList);
	}
};

/**
 * get bounding box this matrix.
 * init totalVertexArraySC and get bounding box
 * @param {BoundingBox} resultBox if this is undefined, set new BoundingBox instance.
 * @returns {BoundingBox}
 */
VertexMatrix.prototype.getBoundingBox = function(resultBox) 
{
	if (resultBox === undefined) { resultBox = new BoundingBox(); }
	
	this.totalVertexArraySC.length = 0;
	this.totalVertexArraySC = this.getTotalVertexArray(this.totalVertexArraySC);
	for (var i = 0, totalVertexCount = this.totalVertexArraySC.length; i < totalVertexCount; i++) 
	{
		if (i === 0) { resultBox.init(this.totalVertexArraySC[i].point3d); }
		else { resultBox.addPoint(this.totalVertexArraySC[i].point3d); }
	}
	return resultBox;
};

/**
 * set vertex index number in list
 * mIdxInList is maybe wrong. 
 * 
 * @see Atmosphere
 */
VertexMatrix.prototype.setVertexIdxInList = function() 
{
	var idxInList = 0;
	for (var i = 0, vertexListsCount = this.vertexListsArray.length; i < vertexListsCount; i++) 
	{
		var vtxList = this.vertexListsArray[i];
		for (var j = 0, vertexCount = vtxList.vertexArray.length; j < vertexCount; j++) 
		{
			var vertex = vtxList.getVertex(j);
			vertex.mIdxInList = idxInList;
			idxInList++;
		}
	}
};

/**
 * get total vertex count
 * @returns {number}}
 */
VertexMatrix.prototype.getVertexCount = function() 
{
	var vertexCount = 0;
	for (var i = 0, vertexListsCount = this.vertexListsArray.length; i < vertexListsCount; i++) 
	{
		vertexCount += this.vertexListsArray[i].getVertexCount();
	}
	
	return vertexCount;
};

/**
 * get total vertex array.
 * @param {Array} resultTotalVertexArray 변수
 * @returns {Array.<Vertex>}
 */
VertexMatrix.prototype.getTotalVertexArray = function(resultTotalVertexArray) 
{
	for (var i = 0, vertexListsCount = this.vertexListsArray.length; i < vertexListsCount; i++) 
	{
		var vtxList = this.vertexListsArray[i];
		for (var j = 0, vertexCount = vtxList.vertexArray.length; j < vertexCount; j++) 
		{
			var vertex = vtxList.getVertex(j);
			resultTotalVertexArray.push(vertex);
		}
	}
	
	return resultTotalVertexArray;
};

/**
 * get vertex color float array.
 * @param {Float32Array} resultFloatArray if this is undefined, set new Float32Array instance. length = this.totalVertexArraySC.length*6
 * @returns {Float32Array}
 */
VertexMatrix.prototype.getVBOVertexColorFloatArray = function(resultFloatArray) 
{
	this.totalVertexArraySC.length = 0;
	this.totalVertexArraySC = this.getTotalVertexArray(this.totalVertexArraySC);
	
	var totalVertexCount = this.totalVertexArraySC.length;
	if (resultFloatArray === undefined) { resultFloatArray = new Float32Array(totalVertexCount * 6); }
	
	for (var i = 0; i < totalVertexCount; i++) 
	{
		var vertex = this.totalVertexArraySC[i];
		resultFloatArray[i*6] = vertex.point3d.x;
		resultFloatArray[i*6+1] = vertex.point3d.y;
		resultFloatArray[i*6+2] = vertex.point3d.z;
		
		resultFloatArray[i*6+3] = vertex.color4.r;
		resultFloatArray[i*6+4] = vertex.color4.g;
		resultFloatArray[i*6+5] = vertex.color4.b;
	}
	
	return resultFloatArray;
};

/**
 * get vertex color with alpha float array.
 * @param {Float32Array} resultFloatArray if this is undefined, set new Float32Array instance. length = this.totalVertexArraySC.length*7
 * @returns {Float32Array}
 */
VertexMatrix.prototype.getVBOVertexColorRGBAFloatArray = function(resultFloatArray) 
{
	this.totalVertexArraySC.length = 0;
	this.totalVertexArraySC = this.getTotalVertexArray(this.totalVertexArraySC);
	
	var totalVertexCount = this.totalVertexArraySC.length;
	if (resultFloatArray === undefined) { resultFloatArray = new Float32Array(totalVertexCount * 7); }
	
	for (var i = 0; i < totalVertexCount; i++) 
	{
		var vertex = this.totalVertexArraySC[i];
		resultFloatArray[i*7] = vertex.point3d.x;
		resultFloatArray[i*7+1] = vertex.point3d.y;
		resultFloatArray[i*7+2] = vertex.point3d.z;
		
		resultFloatArray[i*7+3] = vertex.color4.r;
		resultFloatArray[i*7+4] = vertex.color4.g;
		resultFloatArray[i*7+5] = vertex.color4.b;
		resultFloatArray[i*7+6] = vertex.color4.a;
	}
	
	return resultFloatArray;
};

/**
 * get vertex basic float array.
 * @param {Float32Array} resultFloatArray if this is undefined, set new Float32Array instance. length = this.totalVertexArraySC.length*3
 * @returns {Float32Array}
 */
VertexMatrix.prototype.getVBOVertexFloatArray = function(resultFloatArray) 
{
	this.totalVertexArraySC.length = 0;
	this.totalVertexArraySC = this.getTotalVertexArray(this.totalVertexArraySC);
	
	var totalVertexCount = this.totalVertexArraySC.length;
	if (resultFloatArray === undefined) { resultFloatArray = new Float32Array(totalVertexCount * 3); }
	
	for (var i = 0; i < totalVertexCount; i++) 
	{
		var vertex = this.totalVertexArraySC[i];
		resultFloatArray[i*3] = vertex.point3d.x;
		resultFloatArray[i*3+1] = vertex.point3d.y;
		resultFloatArray[i*3+2] = vertex.point3d.z;
	}
	
	return resultFloatArray;
};

/**
 * translate vertex in vertex matrix
 * @param {Number} dx
 * @param {Number} dy
 * @param {Number} dz
 */
VertexMatrix.prototype.translateVertices = function(dx, dy, dz) 
{
	for (var i = 0, vertexListsCount = this.vertexListsArray.length; i < vertexListsCount; i++) 
	{
		this.vertexListsArray[i].translateVertices(dx, dy, dz);
	}
};

/**
 * set TTrianglesMatrix using vertexMatrix.
 * OLD function. Used for shadow blending cube. OLD.
 * TTriangles provisional is in geometryUtils.	
 * condition: all the vertex lists must have the same number of vertex.
 * @param {TTrianglesMatrix} tTrianglesMatrix
 */
VertexMatrix.prototype.makeTTrianglesLateralSidesLOOP = function(tTrianglesMatrix) 
{
	// 
	var vtxList1;
	var vtxList2;
	var tTrianglesList;
	var tTriangle1;
	var tTriangle2;
	var vertexCount = 0;
	for (var i = 0, vertexListsCount = this.vertexListsArray.length; i < vertexListsCount-1; i++) 
	{
		vtxList1 = this.vertexListsArray[i];
		vtxList2 = this.vertexListsArray[i+1];
		tTrianglesList = tTrianglesMatrix.newTTrianglesList();
		
		vertexCount = vtxList1.vertexArray.length;
		for (var j = 0; j < vertexCount; j++) 
		{
			tTriangle1 = tTrianglesList.newTTriangle();
			tTriangle2 = tTrianglesList.newTTriangle();
			
			if (j === vertexCount-1) 
			{
				tTriangle1.setVertices(vtxList1.getVertex(j), vtxList2.getVertex(j), vtxList2.getVertex(0)); 
				tTriangle2.setVertices(vtxList1.getVertex(j), vtxList2.getVertex(0), vtxList1.getVertex(0)); 
			}
			else 
			{
				tTriangle1.setVertices(vtxList1.getVertex(j), vtxList2.getVertex(j), vtxList2.getVertex(j+1)); 
				tTriangle2.setVertices(vtxList1.getVertex(j), vtxList2.getVertex(j+1), vtxList1.getVertex(j+1)); 
			}
		}
	}
};

/**
 * get vertex matrix. using data array.
 * @deprecated
 * @static
 * @param {Array.<Number>} positions3Array Required.
 * @param {Array.<Number>} normals3Array
 * @param {Array.<Number>} texCoords2Array
 * @param {Array.<Number>} colors4Array
 * @param {Number} numCols
 * @param {Number} numRows
 * @param {VertexMatrix} resultVertexMatrix if undefined, set new VertexMatrix instance.
 * @returns {VertexMatrix} 
 */
VertexMatrix.makeMatrixByDataArray = function(positions3Array, normals3Array, texCoords2Array, colors4Array, numCols, numRows, resultVertexMatrix) 
{
	if (positions3Array === undefined)
	{ return; }
	
	if (resultVertexMatrix === undefined)
	{ resultVertexMatrix = new VertexMatrix(); }
	
	var vertexList;
	var vertex;
	var px, py, pz;
	var nx, ny, nz;
	var tx, ty;
	var r, g, b, a;
	for (var r=0; r<numRows; r++)
	{
		vertexList = resultVertexMatrix.newVertexList();
		for (var c=0; c<numCols; c++)
		{
			vertex = vertexList.newVertex();
			px = positions3Array[c*3];
			py = positions3Array[c*3+1];
			pz = positions3Array[c*3+2];
			
			vertex.setPosition(px, py, pz);
			
			if (normals3Array)
			{
				nx = normals3Array[c*3];
				ny = normals3Array[c*3+1];
				nz = normals3Array[c*3+2];
				vertex.setNormal(nx, ny, nz);
			}
			
			if (texCoords2Array)
			{
				tx = texCoords2Array[c*2];
				ty = texCoords2Array[c*2+1];
				vertex.setTexCoord(tx, ty);
			}
			
			if (colors4Array)
			{
				r = colors4Array[c*4];
				g = colors4Array[c*4+1];
				b = colors4Array[c*4+2];
				a = colors4Array[c*4+3];
				vertex.setColorRGBA(r, g, b, a);
			}
		}
	}
	
	return resultVertexMatrix;
};

/**
 * make face array between two vertex lists.
 * condition: all the vertex lists must have the same number of vertex.
 *	 3   3-------------2  +   +-------------+  +   +-------------+  +   +-------------+
 *	 | \   \           |  | \   \           |  | \   \           |  | \   \           |
 *	 |   \   \  face_B |  |   \   \  face_B |  |   \   \  face_B |  |   \   \  face_B |
 *	 |     \   \       |  |     \   \       |  |     \   \       |  |     \   \       |
 *	 |       \   \     |  |       \   \     |  |       \   \     |  |       \   \     |
 *	 | face_A  \   \   |  | face_A  \   \   |  | face_A  \   \   |  | face_A  \   \   |
 *	 |           \   \ |  |           \   \ |  |           \   \ |  |           \   \ |
 *	 0-------------1   1  +-------------+   +  +-------------+   +  +-------------+   +
 *	
 *	 +   +-------------+  +   +-------------+  +   +-------------+  +   +-------------+
 *	 | \   \           |  | \   \           |  | \   \           |  | \   \           |
 *	 |   \   \  face_B |  |   \   \  face_B |  |   \   \  face_B |  |   \   \  face_B |
 *	 |     \   \       |  |     \   \       |  |     \   \       |  |     \   \       |
 *	 |       \   \     |  |       \   \     |  |       \   \     |  |       \   \     |
 *	 | face_A  \   \   |  | face_A  \   \   |  | face_A  \   \   |  | face_A  \   \   |
 *	 |           \   \ |  |           \   \ |  |           \   \ |  |           \   \ |
 *	 +-------------+   +  +-------------+   +  +-------------+   +  +-------------+   +
 * @static
 * @param {VertexList} vertexListDown Required.
 * @param {VertexList} vertexListUp
 * @param {Array.<Face>} resultFacesArray
 * @param {Boolean} bLoop
 * @param {Boolean} bClockWise
 * @returns {VertexMatrix} 
 */
VertexMatrix.makeFacesBetweenVertexLists = function(vertexListDown, vertexListUp, resultFacesArray, bLoop, bClockWise) 
{
	if (resultFacesArray === undefined)
	{ resultFacesArray = []; }
	
	var face_A, face_B;
	var hedge_A, hedge_B;
	var faceLast_B;
	var vertexCount = vertexListDown.vertexArray.length;
	var vertex_0, vertex_1, vertex_2, vertex_3;
	if (bClockWise === undefined)
	{ bClockWise = false; }
	
	var resultHalfEdgesArray_A = [];
	var resultHalfEdgesArray_B = [];
	var vtx0_idx, vtx1_idx, vtx2_idx, vtx3_idx;
	
	if (bClockWise)
	{
		for (var j = 0; j < vertexCount; j++) 
		{
			resultHalfEdgesArray_A.length = 0;
			resultHalfEdgesArray_B.length = 0;
			if (j < vertexCount-1) 
			{
				vertex_0 = vertexListDown.getVertex(j);
				vertex_1 = vertexListDown.getVertex(j+1);
				vertex_2 = vertexListUp.getVertex(j+1);
				vertex_3 = vertexListUp.getVertex(j);
				
				face_A = new Face();
				face_B = new Face();
				
				face_A.addVerticesArray([vertex_0, vertex_3, vertex_1]);
				//resultHalfEdgesArray_A = face_A.createHalfEdges(resultHalfEdgesArray_A);
				//hedge_A = resultHalfEdgesArray_A[1]; // Diagonal hedge of face_A.
				
				face_B.addVerticesArray([vertex_1, vertex_3, vertex_2]);
				//resultHalfEdgesArray_B = face_B.createHalfEdges(resultHalfEdgesArray_B);
				//hedge_B = resultHalfEdgesArray_B[2]; // Diagonal hedge of face_B.
				
				// Now, set twins between face_A & face_B.
				//hedge_A.setTwin(hedge_B);
				resultFacesArray.push(face_A);
				resultFacesArray.push(face_B);
			}
			else 
			{
				if (bLoop !== undefined && bLoop === true)
				{
					vertex_0 = vertexListDown.getVertex(j);
					vertex_1 = vertexListDown.getVertex(0);
					vertex_2 = vertexListUp.getVertex(0);
					vertex_3 = vertexListUp.getVertex(j);
					
					face_A = new Face();
					face_B = new Face();
					
					face_A.addVerticesArray([vertex_0, vertex_3, vertex_1]);
					//resultHalfEdgesArray_A = face_A.createHalfEdges(resultHalfEdgesArray_A);
					//hedge_A = resultHalfEdgesArray_A[1]; // Diagonal hedge of face_A.
					
					face_B.addVerticesArray([vertex_1, vertex_3, vertex_2]);
					//resultHalfEdgesArray_B = face_B.createHalfEdges(resultHalfEdgesArray_B);
					//hedge_B = resultHalfEdgesArray_B[2]; // Diagonal hedge of face_B.
					
					// Now, set twins between face_A & face_B.
					//hedge_A.setTwin(hedge_B);
					resultFacesArray.push(face_A);
					resultFacesArray.push(face_B);
				}
			}
			
			if (faceLast_B === undefined)
			{ faceLast_B = face_B; }
			else 
			{
				//face_A.setTwinFace(faceLast_B);
				faceLast_B = face_B;
			}
			
			
		}
	}
	else
	{
		for (var j = 0; j < vertexCount; j++) 
		{
			resultHalfEdgesArray_A.length = 0;
			resultHalfEdgesArray_B.length = 0;

			if (j < vertexCount - 1) 
			{
				vertex_0 = vertexListDown.getVertex(j);
				vertex_1 = vertexListDown.getVertex(j+1);
				vertex_2 = vertexListUp.getVertex(j+1);
				vertex_3 = vertexListUp.getVertex(j);
				
				face_A = new Face();
				face_B = new Face();
				
				face_A.addVerticesArray([vertex_0, vertex_1, vertex_3]);
				//resultHalfEdgesArray_A = face_A.createHalfEdges(resultHalfEdgesArray_A);
				//hedge_A = resultHalfEdgesArray_A[1]; // Diagonal hedge of face_A.
				
				face_B.addVerticesArray([vertex_1, vertex_2, vertex_3]);
				//resultHalfEdgesArray_B = face_B.createHalfEdges(resultHalfEdgesArray_B);
				//hedge_B = resultHalfEdgesArray_B[2]; // Diagonal hedge of face_B.
				
				// Now, set twins between face_A & face_B.
				//hedge_A.setTwin(hedge_B);
				
				resultFacesArray.push(face_A);
				resultFacesArray.push(face_B);
			}
			else 
			{
				if (bLoop !== undefined && bLoop === true)
				{
					vertex_0 = vertexListDown.getVertex(j);
					vertex_1 = vertexListDown.getVertex(0);
					vertex_2 = vertexListUp.getVertex(0);
					vertex_3 = vertexListUp.getVertex(j);
					
					face_A = new Face();
					face_B = new Face();
					
					face_A.addVerticesArray([vertex_0, vertex_1, vertex_3]);
					//resultHalfEdgesArray_A = face_A.createHalfEdges(resultHalfEdgesArray_A);
					//hedge_A = resultHalfEdgesArray_A[1]; // Diagonal hedge of face_A.
					
					face_B.addVerticesArray([vertex_1, vertex_2, vertex_3]);
					//resultHalfEdgesArray_B = face_B.createHalfEdges(resultHalfEdgesArray_B);
					//hedge_B = resultHalfEdgesArray_B[2]; // Diagonal hedge of face_B.
					
					// Now, set twins between face_A & face_B.
					//hedge_A.setTwin(hedge_B);
					
					resultFacesArray.push(face_A);
					resultFacesArray.push(face_B);
				}
				
			}
			
			if (faceLast_B === undefined)
			{ faceLast_B = face_B; }
			else 
			{
				//face_A.setTwinFace(faceLast_B);
				faceLast_B = face_B;
			}
			
			
		}
	}
	
	return resultFacesArray;
};

/**
* make Surface
* condition: all the vertex lists must have the same number of vertex.
* @deprecated
* @static
* @param {VertexMatrix} vertexMatrix
* @param {Surface} resultSurface  if undefined, set new Surface instance.
* @param {Boolean} bLoop
* @param {Boolean} bClockWise
* @returns {Surface} 
*/
VertexMatrix.makeSurface = function(vertexMatrix, resultSurface, bLoop, bClockWise) 
{
	if (resultSurface === undefined)
	{ resultSurface = new Surface(); }
	
	var vtxList1;
	var vtxList2;
	var vertexListDown, vertexListUp;
	var resultFacesArray = [];
	var resultFacesArrayLast;
	var vertexCount = 0;
	var vertexListsCount = vertexMatrix.vertexListsArray.length;
	for (var i = 0; i <vertexListsCount-1; i++) 
	{
		vertexListDown = vertexMatrix.vertexListsArray[i];
		vertexListUp = vertexMatrix.vertexListsArray[i+1];
		resultFacesArray = VertexMatrix.makeFacesBetweenVertexLists(vertexListDown, vertexListUp, resultFacesArray, bLoop, bClockWise);
		/*
		if(resultFacesArrayLast === undefined)
			resultFacesArrayLast = resultFacesArray;
		else{
			Surface.setTwinsFacesBetweenFacesArrays_regularQuadGrid(resultFacesArray, resultFacesArrayLast);
			resultFacesArrayLast = resultFacesArray;
		}
		*/
		
		resultSurface.addFacesArray(resultFacesArray);
		
		resultFacesArray.length = 0;
	}
	
	return resultSurface;
};

/**
 * set TTrianglesMatrix using vertexMatrix.
 * OLD function. Used for shadow blending cube. OLD.
 * TTriangles provisional is in geometryUtils.	
 * condition: all the vertex lists must have the same number of vertex.
 * @deprecated
 * @param {TTrianglesMatrix} trianglesMatrix
 * @param {Boolean} bLoop if true, include last vertex triangle
 */
VertexMatrix.prototype.makeTrianglesLateralSides = function(trianglesMatrix, bLoop) 
{
	var vtxList1;
	var vtxList2;
	var trianglesList;
	var triangle1;
	var triangle2;
	var vertexCount = 0;
	for (var i = 0, vertexListsCount = this.vertexListsArray.length; i < vertexListsCount-1; i++) 
	{
		vtxList1 = this.vertexListsArray[i];
		vtxList2 = this.vertexListsArray[i+1];
		trianglesList = trianglesMatrix.newTrianglesList();
		
		vertexCount = vtxList1.vertexArray.length;
		for (var j = 0; j < vertexCount; j++) 
		{
			if (j === vertexCount-1) 
			{
				if (bLoop !== undefined && bLoop === true)
				{
					triangle1 = trianglesList.newTriangle();
					triangle2 = trianglesList.newTriangle();
					triangle1.setVertices(vtxList1.getVertex(j), vtxList2.getVertex(j), vtxList2.getVertex(0)); 
					triangle2.setVertices(vtxList1.getVertex(j), vtxList2.getVertex(0), vtxList1.getVertex(0)); 
				}
			}
			else 
			{
				triangle1 = trianglesList.newTriangle();
				triangle2 = trianglesList.newTriangle();
				triangle1.setVertices(vtxList1.getVertex(j), vtxList2.getVertex(j), vtxList2.getVertex(j+1)); 
				triangle2.setVertices(vtxList1.getVertex(j), vtxList2.getVertex(j+1), vtxList1.getVertex(j+1)); 
			}
		}
	}
};

/**
* get index of array
* return col + row * numCols;
* @static
* @param {Number} numCols
* @param {Number} numRows not used.
* @param {Number} col
* @param {Number} row
* @returns {Number} 
*/
VertexMatrix.getIndexOfArray = function(numCols, numRows, col, row) 
{
	// static function.
	var idx = col + row * numCols;
	return idx;
};

/**
 * vertex point transform by matrix4
 * @param {Matrix4} transformMatrix
 * @see Matrix4#transformPoint3D
 */
VertexMatrix.prototype.transformPointsByMatrix4 = function(transformMatrix) 
{
	for (var i = 0, vertexListsCount = this.vertexListsArray.length; i < vertexListsCount; i++) 
	{
		var vtxList = this.vertexListsArray[i];
		vtxList.transformPointsByMatrix4(transformMatrix);
	}
};



'use strict';

/**
 * VertexOctree
 * @see Vertex
 * 
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class VertexOctree
 */
var VertexOctree = function(octreeOwner) 
{
	if (!(this instanceof VertexOctree)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.octree_owner = octreeOwner;
	this.octree_level = 0;
	this.octree_number_name = 0;
	this.subOctrees_array;
	this.vertexArray;
	
	/**
	 * The center position in local coordinates of the octree.
	 * @type {Point3D}
	 * @default (0,0,0)
	 */
	this.centerPos = new Point3D();
	
	/**
	 * The half width of the octree in x-axis.
	 * @type {Number}
	 * @default 0.0
	 */
	this.half_dx = 0.0; 
	
	/**
	 * The half width of the octree in y-axis.
	 * @type {Number}
	 * @default 0.0
	 */
	this.half_dy = 0.0; 
	
	/**
	 * The half width of the octree in z-axis.
	 * @type {Number}
	 * @default 0.0
	 */
	this.half_dz = 0.0; 
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
VertexOctree.prototype.setBoxSize = function(minX, maxX, minY, maxY, minZ, maxZ) 
{
	this.centerPos.x = (maxX + minX)/2.0;
	this.centerPos.y = (maxY + minY)/2.0;
	this.centerPos.z = (maxZ + minZ)/2.0;

	this.half_dx = (maxX - minX)/2.0; // half width.
	this.half_dy = (maxY - minY)/2.0; // half length.
	this.half_dz = (maxZ - minZ)/2.0; // half height.
};

/**
 * Creates a child octree.
 * @returns {Octree} subOctree Returns the created child octree.
 */
VertexOctree.prototype.new_subOctree = function() 
{
	var subOctree = new VertexOctree(this);
	subOctree.octree_level = this.octree_level + 1;
	this.subOctrees_array.push(subOctree);
	return subOctree;
};

/**
 * 어떤 일을 하고 있습니까?
 */
VertexOctree.prototype.setSizesSubBoxes = function() 
{
	// Octree number name.**
	// Bottom                      Top
	// +-----+-----+     +-----+-----+
	// |  3  |  2  |     |  7  |  6  |       Y
	// +-----+-----+     +-----+-----+       |
	// |  0  |  1  |     |  4  |  5  |       |
	// +-----+-----+     +-----+-----+       +---------> X

	if (this.subOctrees_array && this.subOctrees_array.length > 0) 
	{
		var half_x = this.centerPos.x;
		var half_y = this.centerPos.y;
		var half_z = this.centerPos.z;

		var min_x = this.centerPos.x - this.half_dx;
		var min_y = this.centerPos.y - this.half_dy;
		var min_z = this.centerPos.z - this.half_dz;

		var max_x = this.centerPos.x + this.half_dx;
		var max_y = this.centerPos.y + this.half_dy;
		var max_z = this.centerPos.z + this.half_dz;

		this.subOctrees_array[0].setBoxSize(min_x, half_x, min_y, half_y, min_z, half_z);
		this.subOctrees_array[1].setBoxSize(half_x, max_x, min_y, half_y, min_z, half_z);
		this.subOctrees_array[2].setBoxSize(half_x, max_x, half_y, max_y, min_z, half_z);
		this.subOctrees_array[3].setBoxSize(min_x, half_x, half_y, max_y, min_z, half_z);

		this.subOctrees_array[4].setBoxSize(min_x, half_x, min_y, half_y, half_z, max_z);
		this.subOctrees_array[5].setBoxSize(half_x, max_x, min_y, half_y, half_z, max_z);
		this.subOctrees_array[6].setBoxSize(half_x, max_x, half_y, max_y, half_z, max_z);
		this.subOctrees_array[7].setBoxSize(min_x, half_x, half_y, max_y, half_z, max_z);

		for (var i=0; i<8; i++) 
		{
			this.subOctrees_array[i].setSizesSubBoxes();
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
VertexOctree.prototype.createChildren = function() 
{
	this.subOctrees_array = []; // Init array.
	
	for (var i=0; i<8; i++) 
	{
		var subOctree = this.new_subOctree();
		subOctree.octree_number_name = this.octree_number_name * 10 + (i+1);
	}

	this.setSizesSubBoxes();
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
VertexOctree.prototype.makeTreeByMinSize = function(targetMinSize) 
{
	if (this.vertexArray === undefined || this.vertexArray.length === 0)
	{ return; }
	
	var minSize = Math.min.apply(null, [this.half_dx, this.half_dy, this.half_dz]);
	
	if (minSize*2 > targetMinSize)
	{
		// descend 1 depth.
		this.createChildren();
		
		// now, insert vertices into subOctrees.
		var vertexCount = this.vertexArray.length;
		for (var i=0; i<vertexCount; i++)
		{
			this.insertVertexToChildren(this.vertexArray[i]);
		}
		this.vertexArray.length = 0; // init to save memory.
		
		for (var i=0; i<8; i++)
		{
			this.subOctrees_array[i].makeTreeByMinSize(targetMinSize);
		}
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
VertexOctree.prototype.extractOctreesWithData = function(resultOctreesArray) 
{
	if (resultOctreesArray === undefined)
	{ resultOctreesArray = []; }
	
	if (this.vertexArray !== undefined && this.vertexArray.length > 0)
	{ resultOctreesArray.push(this); }
	
	if (this.subOctrees_array)
	{
		var subOctreesCount = this.subOctrees_array.length; // must be 8 always.
		for (var i=0; i<subOctreesCount; i++)
		{
			this.subOctrees_array[i].extractOctreesWithData(resultOctreesArray);
		}
	}
	
	return resultOctreesArray;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param treeDepth 변수
 */
VertexOctree.prototype.insertVertexToChildren = function(vertex) 
{
	// Octree number name.**
	// Bottom                      Top
	// +-----+-----+     +-----+-----+
	// |  3  |  2  |     |  7  |  6  |       Y
	// +-----+-----+     +-----+-----+       |
	// |  0  |  1  |     |  4  |  5  |       |
	// +-----+-----+     +-----+-----+       +---------> X
	
	var idx = -1;
	var point3d = vertex.getPosition();
	if (point3d.x < this.centerPos.x)
	{
		// idx = 0,3,4,7.
		if (point3d.y < this.centerPos.y)
		{
			// idx = 0,4.
			if (point3d.z < this.centerPos.z)
			{
				idx = 0;
			}
			else
			{
				idx = 4;
			}
		}
		else
		{
			// idx = 3,7.
			if (point3d.z < this.centerPos.z)
			{
				idx = 3;
			}
			else
			{
				idx = 7;
			}
		}
	}
	else
	{
		// idx = 1,2,5,6.
		if (point3d.y < this.centerPos.y)
		{
			// idx = 2,6.
			if (point3d.z < this.centerPos.z)
			{
				idx = 2;
			}
			else
			{
				idx = 6;
			}
		}
		else
		{
			// idx = 1,5.
			if (point3d.z < this.centerPos.z)
			{
				idx = 1;
			}
			else
			{
				idx = 5;
			}
		}
	}
	
	var subOctree = this.subOctrees_array[idx];
	if (subOctree.vertexArray === undefined)
	{ subOctree.vertexArray = []; }
	
	vertex.vertexIndexingOctree = subOctree; // assign provisionally the vertexOctree.
	subOctree.vertexArray.push(vertex);
};




































'use strict';
/**
 * vertex profile. consist of outer Vertex ring and inner Vertex ring list.
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class VtxProfile
 * 
 * @see VtxRing
 */
var VtxProfile = function() 
{
	if (!(this instanceof VtxProfile)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * outer VtxRing
	 * @type {VtxRing}
	 */
	this.outerVtxRing;

	/**
	 * inner VtxRingList
	 * @type {VtxRingList}
	 */
	this.innerVtxRingsList;
};

/**
 * delete all vertex.
 */
VtxProfile.prototype.deleteObjects = function()
{
	if (this.outerVtxRing !== undefined)
	{
		this.outerVtxRing.deleteObjects();
		this.outerVtxRing = undefined;
	}
	
	if (this.innerVtxRingsList !== undefined)
	{
		this.innerVtxRingsList.deleteObjects();
		this.innerVtxRingsList = undefined;
	}
};

/**
 * get inner vertex ring's count
 * @returns {Number} 
 */
VtxProfile.prototype.getInnerVtxRingsCount = function()
{
	if (this.innerVtxRingsList === undefined || this.innerVtxRingsList.getRingsCount === 0)
	{ return 0; }
	
	return this.innerVtxRingsList.getVtxRingsCount();
};

/**
 * get inner vertex ring
 * @param {Number} idx
 * @returns {VtxRing} 
 */
VtxProfile.prototype.getInnerVtxRing = function(idx)
{
	if (this.innerVtxRingsList === undefined || this.innerVtxRingsList.getRingsCount === 0)
	{ return undefined; }
	
	return this.innerVtxRingsList.getVtxRing(idx);
};

/**
 * set vertex index in list
 * 
 * @see VertexList#setIdxInList
 * @see VtxRingList#setVerticesIdxInList maybe error.
 */
VtxProfile.prototype.setVerticesIdxInList = function()
{
	if (this.outerVtxRing && this.outerVtxRing.vertexList)
	{
		this.outerVtxRing.vertexList.setIdxInList();
	}
	
	if (this.innerVtxRingsList)
	{
		this.innerVtxRingsList.setVerticesIdxInList();
	}
};

/**
 * vertex profile copy from another vertex profile.
 * @param {VtxProfile} vtxProfile
 */
VtxProfile.prototype.copyFrom = function(vtxProfile)
{
	if (vtxProfile.outerVtxRing)
	{
		if (this.outerVtxRing === undefined)
		{ this.outerVtxRing = new VtxRing(); }
		
		this.outerVtxRing.copyFrom(vtxProfile.outerVtxRing);
	}
	
	if (vtxProfile.innerVtxRingsList)
	{
		if (this.innerVtxRingsList === undefined)
		{ this.innerVtxRingsList = new VtxRingsList(); }
		
		this.innerVtxRingsList.copyFrom(vtxProfile.innerVtxRingsList);
	}
};

/**
 * vertex point translate.
 * @param {Number} dx
 * @param {Number} dy
 * @param {Number} dz
 * @see Point3D#add
 */
VtxProfile.prototype.translate = function(dx, dy, dz)
{
	if (this.outerVtxRing !== undefined)
	{ this.outerVtxRing.translate(dx, dy, dz); }
	
	if (this.innerVtxRingsList !== undefined)
	{ this.innerVtxRingsList.translate(dx, dy, dz); }
};

/**
 * Rotates this VtxProfile specified angle by "angDeg" in (axisX, axisY, axisZ) axis.
 * @param {Number} angDeg Angle in degrees to rotate this VtxProfile.
 * @param {Number} axisX X component of the rotation axis.
 * @param {Number} axisY Y component of the rotation axis.
 * @param {Number} axisZ Z component of the rotation axis.
 */
VtxProfile.prototype.rotate = function(angDeg, axisX, axisY, axisZ)
{
	var rotMat = new Matrix4();
	var quaternion = new Quaternion();
	
	// Note: the axisX, axisY, axisZ must be unitary, but to be safe process, force rotationAxis to be unitary.*** 
	var rotAxis = new Point3D(axisX, axisY, axisZ);
	rotAxis.unitary();

	// calculate rotation.
	quaternion.rotationAngDeg(angDeg, rotAxis.x, rotAxis.y, rotAxis.z);
	rotMat.rotationByQuaternion(quaternion);
	
	this.transformPointsByMatrix4(rotMat);
};

/**
 * vertex point transform by matrix4
 * @param {Matrix4} tMat4
 * @see Matrix4#transformPoint3D
 */
VtxProfile.prototype.transformPointsByMatrix4 = function(tMat4)
{
	if (this.outerVtxRing !== undefined)
	{ this.outerVtxRing.transformPointsByMatrix4(tMat4); }
	
	if (this.innerVtxRingsList !== undefined)
	{ this.innerVtxRingsList.transformPointsByMatrix4(tMat4); }
};

/**
 * get projected 2d profile.
 * Note: this makes a projected profile2d ONLY conformed by polyLines2D.
 * This function is used when necessary to tessellate this vtxProfile.
 * @param {Profile2D|undefined} resultProfile2d if undefined, set new Profile2D instance.
 * @returns {Profile2D} when this.outerVtxRing is undefined or normal is undefined. return original resultProfile2d.
 * 
 * @see VtxRing#calculatePlaneNormal
 * @see VtxRing#getProjectedPolyLineBasedRing2D
 */
VtxProfile.prototype.getProjectedProfile2D = function(resultProfile2d)
{
	if (this.outerVtxRing === undefined)
	{ return resultProfile2d; }
	
	// 1rst, calculate the normal of this vtxProfile. Use the this.outerVtxRing.
	// The normal is used co calculate the bestFace to project.
	var normal = this.outerVtxRing.calculatePlaneNormal(undefined);

	if (normal === undefined)
	{ return resultProfile2d; }
	
	if (resultProfile2d === undefined)
	{ resultProfile2d = new Profile2D(); }
	
	// OuterVtxRing.
	resultProfile2d.outerRing = this.outerVtxRing.getProjectedPolyLineBasedRing2D(resultProfile2d.outerRing, normal);
	
	// InnerVtxRings.
	if (this.innerVtxRingsList !== undefined)
	{
		var innerVtxRingsCount = this.innerVtxRingsList.getVtxRingsCount();
		var innerRingsList;
		if (innerVtxRingsCount > 0)
		{
			innerRingsList = resultProfile2d.getInnerRingsList();
		}
		
		for (var i=0; i<innerVtxRingsCount; i++)
		{
			var innerVtxRing = this.innerVtxRingsList.getVtxRing(i);
			var innerRing = innerVtxRing.getProjectedPolyLineBasedRing2D(undefined, normal);
			innerRingsList.addRing(innerRing);
		}
	}
	
	return resultProfile2d;
};

/**
 * use point3d array, set outerVtxRing's vertex list and indexrange.
 * @param {Array.<Point3D>} outerPoints3dArray Required.
 * @param {Array.<Array.<Point3D>>} innerPoints3dArrayArray deprecated.
 * 
 * @see VtxRing#makeByPoints3DArray
 */
VtxProfile.prototype.makeByPoints3DArray = function(outerPoints3dArray, innerPoints3dArrayArray)
{
	if (outerPoints3dArray === undefined)
	{ return; }
	
	// outer.
	if (this.outerVtxRing === undefined)
	{ this.outerVtxRing = new VtxRing(); }

	this.outerVtxRing.makeByPoints3DArray(outerPoints3dArray);
	
	// inners.
	// todo:
};

/**
 * use point3d array, update outerVtxRing's vertex list.
 * @param {Array.<Point3D>} point3dArray Required.
 * @param {Array.<Array.<Point3D>>} innerPoints3dArrayArray deprecated.
 * 
 * @see VtxRing#makeByPoints3DArray
 */
VtxProfile.prototype.updateByPoints3DArray = function(outerPoints3dArray, innerPoints3dArrayArray)
{
	if (outerPoints3dArray === undefined)
	{ return; }
	
	// outer.
	if (this.outerVtxRing === undefined)
	{ return; }

	this.outerVtxRing.updateByPoints3DArray(outerPoints3dArray);
	
	// inners.
	// todo:
};

/**
 * use Profile2D, make VtxProfile's outer vertex ring and inner vertex ring list. 
 * z is always 0.
 * @param {Profile2D} profile2d Required.
 * 
 * @see VtxRing#makeByPoint2DList
 */
VtxProfile.prototype.makeByProfile2D = function(profile2d)
{
	if (profile2d === undefined || profile2d.outerRing === undefined)
	{ return undefined; }
	
	var outerRing = profile2d.outerRing;
	if (outerRing.polygon === undefined)
	{ outerRing.makePolygon(); }
	
	// outer.
	if (this.outerVtxRing === undefined)
	{ this.outerVtxRing = new VtxRing(); }
	
	var z = 0;
	var outerPolygon = outerRing.polygon;
	var point2dList = outerPolygon.point2dList;
	this.outerVtxRing.makeByPoint2DList(point2dList, z);

	// inners.
	if (profile2d.innerRingsList === undefined)
	{ return; } 
	
	var innerRingsList = profile2d.innerRingsList;
	var innerRingsCount = innerRingsList.getRingsCount();
	
	if (innerRingsCount === 0)
	{ return; }
	
	if (this.innerVtxRingsList === undefined)
	{ this.innerVtxRingsList = new VtxRingsList(); }
	
	var innerRing;
	var innerPolygon;
	var innerVtxRing;
	
	for (var i=0; i<innerRingsCount; i++)
	{
		innerRing = innerRingsList.getRing(i);
		if (innerRing.polygon === undefined)
		{ innerRing.makePolygon(); }
		innerPolygon = innerRing.polygon;
		point2dList = innerPolygon.point2dList;
		
		innerVtxRing = this.innerVtxRingsList.newVtxRing();
		innerVtxRing.makeByPoint2DList(point2dList, z);
	}
};

/**
 * get all vertex in outer vertex ring and inner vertex ring list. 
 * @param {Array} resultVerticesArray
 * @returns {Array.<Vertex>|undefined}
 */
VtxProfile.prototype.getAllVertices = function(resultVerticesArray)
{
	if (this.outerVtxRing !== undefined)
	{ this.outerVtxRing.getAllVertices(resultVerticesArray); }
	
	if (this.innerVtxRingsList !== undefined)
	{ this.innerVtxRingsList.getAllVertices(resultVerticesArray); }
	
	return resultVerticesArray;
};

/**
 * get vertex intersected with plane. 
 * @static
 * @param {VtxProfile} vtxProfile if vtxProfile.outerVtxRing undefined, return resultvtxProfile.
 * @param {Plane} plane. 
 * @param {Point3D} projectionDirection projectionDirection must be unitary.
 * @param {VtxProfile} resultvtxProfile Optional. if undefined, set new VtxProfile instance.
 * @returns {VtxProfile} resultvtxProfile
 */
VtxProfile.getProjectedOntoPlane = function(vtxProfile, plane, projectionDirection, resultvtxProfile)
{
	if (vtxProfile.outerVtxRing === undefined)
	{ return resultvtxProfile; }
	
	if (resultvtxProfile === undefined)
	{ resultvtxProfile = new VtxProfile(); }
	
	// OuterVtxRing.
	resultvtxProfile.outerVtxRing = VtxRing.getProjectedOntoPlane(vtxProfile.outerVtxRing, plane, projectionDirection, resultvtxProfile.outerVtxRing);
				
	// InnerVtxRings.
	if (vtxProfile.innerVtxRingsList !== undefined)
	{
		resultvtxProfile.innerVtxRingsList = VtxRingsList.getProjectedOntoPlane(vtxProfile.innerVtxRingsList, plane, projectionDirection, resultvtxProfile.innerVtxRingsList);
	}
	
	return resultvtxProfile;
};




















































'use strict';
/**
* Vertex Profile List
* @exception {Error} Messages.CONSTRUCT_ERROR

* @class VtxProfilesList

* @param {number} x not used
* @param {number} y not used
*
* @see VtxProfile
*/
var VtxProfilesList = function(x, y) 
{
	if (!(this instanceof VtxProfilesList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * VtxProfile Array
	 * @type {Array.<VtxProfile>}
	 */
	this.vtxProfilesArray;

	
	/**
	 * convex index data array
	 * @type {Array.<Array.<IndexData>>}
	 */
	this.convexFacesIndicesData;
};


/**
 * delete vertex profile and convex array.
 */
VtxProfilesList.prototype.deleteObjects = function()
{
	if (this.vtxProfilesArray !== undefined)
	{
		var vtxProfilesCount = this.vtxProfilesArray.length;
		for (var i=0; i<vtxProfilesCount; i++)
		{
			this.vtxProfilesArray[i].deleteObjects();
			this.vtxProfilesArray[i] = undefined;
		}
		this.vtxProfilesArray = undefined;
	}
	
	if (this.convexFacesIndicesData !== undefined)
	{
		/*
		var idxDatasCount = this.convexFacesIndicesData.length;
		for(var i=0; i<idxDatasCount; i++)
		{
			for(var key in this.convexFacesIndicesData[i])
			{
				var value = this.convexFacesIndicesData[i][key];
				value.deleteObjects();
				value = undefined;
			}
			this.convexFacesIndicesData[i] = undefined;
		}
		*/
		this.convexFacesIndicesData = undefined;
	}
};

/**
 * 페이스 목록 생성 및 반환. 메쉬의 hedgelist 업데이트
 * 
 * @static
 * @param {VtxRing} bottomVtxRing
 * @param {VtxRing} topVtxRing
 * @param {Array.<Face>} resultFacesArray
 * @param {Mesh} resultMesh
 * @param {IndexRange} elemIndexRange
 * 
 * @see VtxProfilesList#getMesh
 * @see Mesh#getHalfEdgesList
 * @see Face#createHalfEdges
 * @see Face#setTwinFace
 * @see HalfEdgesList#addHalfEdgesArray
 */
VtxProfilesList.getLateralFaces = function(bottomVtxRing, topVtxRing, resultFacesArray, resultMesh, elemIndexRange)
{
	// This returns a lateral surface between "bottomVtxRing" & "topVtxRing" limited by "elemIndexRange".
	if (resultFacesArray === undefined)
	{ resultFacesArray = []; }
	
	var hedgesList = resultMesh.getHalfEdgesList();
	
	var strIdx, currIdx, endIdx, nextIdx;
	var vtx0, vtx1, vtx2, vtx3;
	var face, prevFace;
	var hedgesArray = [];
	currIdx = elemIndexRange.strIdx;
	while (currIdx !== elemIndexRange.endIdx)
	{
		nextIdx = bottomVtxRing.vertexList.getNextIdx(currIdx);
		
		face = new Face();
		resultFacesArray.push(face);
		face.vertexArray = [];
		
		vtx0 = bottomVtxRing.vertexList.getVertex(currIdx);
		vtx1 = bottomVtxRing.vertexList.getVertex(nextIdx);
		vtx2 = topVtxRing.vertexList.getVertex(nextIdx);
		vtx3 = topVtxRing.vertexList.getVertex(currIdx);
		Array.prototype.push.apply(face.vertexArray, [vtx0, vtx1, vtx2, vtx3]);
		
		// now create hedges of the face.
		hedgesArray.length = 0;
		hedgesArray = face.createHalfEdges(hedgesArray);
		hedgesList.addHalfEdgesArray(hedgesArray);
		
		if (prevFace !== undefined)
		{
			// set twins between face and prevFace.
			face.setTwinFace(prevFace);
		}
		prevFace = face;

		currIdx = nextIdx;
	}
	
	return resultFacesArray;
};

/**
 * VtxProfile 추가
 * @param {VtxProfile} vtxProfile
 */
VtxProfilesList.prototype.addVtxProfile = function(vtxProfile)
{
	if (this.vtxProfilesArray === undefined)
	{ this.vtxProfilesArray = []; }
	
	this.vtxProfilesArray.push(vtxProfile);
};

/**
 * VtxProfile 생성하여 vtxProfileArray에 추가 후 반환.
 * @returns {VtxProfile} vtxProfile
 */
VtxProfilesList.prototype.newVtxProfile = function()
{
	if (this.vtxProfilesArray === undefined)
	{ this.vtxProfilesArray = []; }
	
	var vtxProfile = new VtxProfile();
	this.vtxProfilesArray.push(vtxProfile);
	return vtxProfile;
};

/**
 * vtxProfileArray length 반환.
 * @returns {Number}
 */
VtxProfilesList.prototype.getVtxProfilesCount = function()
{
	if (this.vtxProfilesArray === undefined)
	{ return 0; }
	
	return this.vtxProfilesArray.length;
};

/**
 * 인덱스에 해당하는 vtxProfile 반환
 * @returns {VtxProfile}
 */
VtxProfilesList.prototype.getVtxProfile = function(idx)
{
	if (this.vtxProfilesArray === undefined)
	{ return undefined; }
	
	return this.vtxProfilesArray[idx];
};

/**
 * vtxProfileArray에 있는 모든 vertex를 배열에 담아 반환
 * @param {Array.<Vertex>|undefined} resultVerticesArray 비어있을 시 배열 초기화.
 * @returns {Array.<Vertex>}
 */
VtxProfilesList.prototype.getAllVertices = function(resultVerticesArray)
{
	// collect all vertices of all vtxProfiles.
	if (resultVerticesArray === undefined)
	{ resultVerticesArray = []; }
	
	var vtxProfile;
	var vtxProfilesCount = this.getVtxProfilesCount();
	for (var i=0; i<vtxProfilesCount; i++)
	{
		vtxProfile = this.getVtxProfile(i);
		resultVerticesArray = vtxProfile.getAllVertices(resultVerticesArray);
	}
	
	return resultVerticesArray;
};

/**
 * vtxProfileList로 부터 Mesh 생성 후 반환
 * @param {Mesh} resultMesh 비어있을 시 new Mesh 인스턴스 선언.
 * @param {Boolean} bIncludeBottomCap Mesh의 바닥 surface 추가 유무, true 일시 getTransversalSurface
 * @param {Boolean} bIncludeTopCap Mesh의 위쪽(뚜껑) surface 추가 유무, true 일시 getTransversalSurface
 * @param {Boolean} bLoop 기본값은 false. true로 선언 시, bIncludeBottomCap, bIncludeTopCap 는 false로 변경
 * @returns {Mesh}
 * 
 * @see VtxProfilesList#getTransversalSurface
 */
VtxProfilesList.prototype.getMesh = function(resultMesh, bIncludeBottomCap, bIncludeTopCap, bLoop)
{
	// face's vertex order.
	// 3-------2
	// |       |
	// |       |
	// 0-------1
	
	if (this.vtxProfilesArray === undefined)
	{ return resultTriangleMatrix; }

	if (bLoop === undefined)
	{ bLoop = false; }
	
	if (bLoop === true)
	{
		// To make a safe mesh, if loop, then there are no caps in the extrems.
		bIncludeBottomCap = false;
		bIncludeTopCap = false;
	}
	
	
	// outerLateral.
	var vtxProfilesCount = this.getVtxProfilesCount();
	
	if (vtxProfilesCount < 2)
	{ return resultTriangleMatrix; }
	
	if (resultMesh === undefined)
	{ resultMesh = new Mesh(); }
	
	if (resultMesh.vertexList === undefined)
	{ resultMesh.vertexList = new VertexList(); }
	
	// 1rst, get all vertices and put it into the resultMesh.
	resultMesh.vertexList.vertexArray = this.getAllVertices(resultMesh.vertexList.vertexArray);
		
	var bottomVtxProfile, topVtxProfile;

	bottomVtxProfile = this.getVtxProfile(0);
	var outerVtxRing = bottomVtxProfile.outerVtxRing;
	var elemIndexRange;
	var bottomVtxRing, topVtxRing;
	var elemIndicesCount;
	var strIdx, currIdx, endIdx, nextIdx;
	var vtx0, vtx1, vtx2, vtx3;
	var face, surface;
	var k;
	var facesArray = [];
	var prevFacesArray;
	var elemsCount = outerVtxRing.elemsIndexRangesArray.length;
	var options = {};
	options.name = "outerLateral";
	for (var i=0; i<elemsCount; i++)
	{
		surface = resultMesh.newSurface(options);
		prevFacesArray = undefined;
		elemIndexRange = outerVtxRing.getElementIndexRange(i);
		for (var j=0; j<vtxProfilesCount; j++)
		{
			if (j === vtxProfilesCount-1 )
			{
				if (bLoop)
				{
					bottomVtxProfile = this.getVtxProfile(j);
					topVtxProfile = this.getVtxProfile(0);
				}
				else { break; }
			}
			else 
			{
				bottomVtxProfile = this.getVtxProfile(j);
				topVtxProfile = this.getVtxProfile(j+1);
			}
			
			bottomVtxRing = bottomVtxProfile.outerVtxRing;
			topVtxRing = topVtxProfile.outerVtxRing;
			
			facesArray.length = 0;
			facesArray = VtxProfilesList.getLateralFaces(bottomVtxRing, topVtxRing, facesArray, resultMesh, elemIndexRange);
			surface.addFacesArray(facesArray);
			
			if (prevFacesArray !== undefined && prevFacesArray.length > 0)
			{
				// set twins between "prevFacesArray" & "facesArray".
				var currFace, prevFace;
				var facesCount = facesArray.length;
				for (var k=0; k<facesCount; k++)
				{
					currFace = facesArray[k];
					prevFace = prevFacesArray[k];
					currFace.setTwinFace(prevFace);
				}
			}
			
			prevFacesArray = [];
			Array.prototype.push.apply(prevFacesArray, facesArray);
		}
	}
	
	// Inner laterals.
	options.name = "innerLateral";
	var innerVtxRing;
	var innerRinsCount = bottomVtxProfile.getInnerVtxRingsCount();
	for (var k=0; k<innerRinsCount; k++)
	{
		innerVtxRing = bottomVtxProfile.getInnerVtxRing(k);
		elemsCount = innerVtxRing.elemsIndexRangesArray.length;
		for (var i=0; i<elemsCount; i++)
		{
			surface = resultMesh.newSurface(options);
			prevFacesArray = undefined;
			elemIndexRange = innerVtxRing.getElementIndexRange(i);
			for (var j=0; j<vtxProfilesCount; j++)
			{
				if (j === vtxProfilesCount-1 )
				{
					if (bLoop)
					{
						bottomVtxProfile = this.getVtxProfile(j);
						topVtxProfile = this.getVtxProfile(0);
					}
					else { break; }
				}
				else 
				{
					bottomVtxProfile = this.getVtxProfile(j);
					topVtxProfile = this.getVtxProfile(j+1);
				}

				bottomVtxRing = bottomVtxProfile.getInnerVtxRing(k);
				topVtxRing = topVtxProfile.getInnerVtxRing(k);
				
				facesArray.length = 0;
				facesArray = VtxProfilesList.getLateralFaces(bottomVtxRing, topVtxRing, facesArray, resultMesh, elemIndexRange);
				surface.addFacesArray(facesArray);
				
				if (prevFacesArray !== undefined && prevFacesArray.length>0)
				{
					// set twins between "prevFacesArray" & "facesArray".
					var currFace, prevFace;
					var facesCount = facesArray.length;
					for (var a=0; a<facesCount; a++)
					{
						currFace = facesArray[a];
						prevFace = prevFacesArray[a];
						currFace.setTwinFace(prevFace);
					}
				}
				
				prevFacesArray = [];
				Array.prototype.push.apply(prevFacesArray, facesArray);
				
			}
		}
	}
	
	// Caps (bottom and top).
	if (this.convexFacesIndicesData === undefined)
	{ 
		// Calculate the convexFacesIndicesData.
		var vtxProfileFirst = this.getVtxProfile(0);
		var profile2d = vtxProfileFirst.getProjectedProfile2D(profile2d);
		this.convexFacesIndicesData = profile2d.getConvexFacesIndicesData(this.convexFacesIndicesData);
	}
	
	var resultSurface;
	
	// Top profile.**
	// in this case, there are a surface with multiple convex faces.
	if (bIncludeTopCap === undefined || bIncludeTopCap === true)
	{
		options.name = "top";
		topVtxProfile = this.getVtxProfile(vtxProfilesCount-1);
		resultSurface = resultMesh.newSurface(options);
		resultSurface = VtxProfilesList.getTransversalSurface(topVtxProfile, this.convexFacesIndicesData, resultSurface);
	}

	// Bottom profile.**
	if (bIncludeBottomCap === undefined || bIncludeBottomCap === true)
	{
		options.name = "bottom";
		bottomVtxProfile = this.getVtxProfile(0);
		resultSurface = resultMesh.newSurface(options);
		resultSurface = VtxProfilesList.getTransversalSurface(bottomVtxProfile, this.convexFacesIndicesData, resultSurface);
		
		// in bottomSurface inverse sense of faces.
		resultSurface.reverseSense();
	}

	return resultMesh;
};

/**
 * 위쪽이나 아랫쪽 surface 생성.
 * @static
 * @param {VtxProfile} vtxProfile
 * @param {Array.<IndexData>} convexFacesIndicesData
 * @param {Surface} resultSurface 비어있을 시 Surface 인스턴스 선언.
 * @returns {Surface}
 */
VtxProfilesList.getTransversalSurface = function(vtxProfile, convexFacesIndicesData, resultSurface)
{
	if (resultSurface === undefined)
	{ resultSurface = new Surface(); }
	 
	var currRing;
	var currVtxRing;
	var faceIndicesData;
	var indexData;
	var ringIdx, vertexIdx;
	var indicesCount;
	var face;
	var vertex;
	var convexFacesCount = convexFacesIndicesData.length;
	for (var i=0; i<convexFacesCount; i++)
	{
		face = resultSurface.newFace();
		face.vertexArray = [];
			
		faceIndicesData = convexFacesIndicesData[i];
		indicesCount = faceIndicesData.length;
		for (var j=0; j<indicesCount; j++)
		{
			indexData = faceIndicesData[j];
			ringIdx = indexData.ownerIdx;
			vertexIdx = indexData.idxInList;
			
			if (ringIdx === -1)
			{
				// is the outerRing.
				currVtxRing = vtxProfile.outerVtxRing;
			}
			else 
			{
				currVtxRing = vtxProfile.innerVtxRingsList.getVtxRing(ringIdx);
			}
			
			vertex = currVtxRing.vertexList.getVertex(vertexIdx);
			face.vertexArray.push(vertex);
		}
	}
	
	return resultSurface;
};

/**
 * profile2d와 경로 point3d 리스트를 이용하여 vtxProfile 생성 후 vtxProfilesArray에 추가
 * @method VtxProfilesList.makeLoft
 * @param {Profile2D} profile2d
 * @param {Points3DList} pathPoints3dList
 * @param {Boolean} bLoop 기본값은 false.
 * 
 * @see Point3DList#getBisectionPlane
 * @see Point3DList#getSegment3D
 */
VtxProfilesList.prototype.makeLoft = function(profile2d, pathPoints3dList, bLoop)
{
	// 1rst, make the base vtxProfile.
	// if want caps in the extruded mesh, must calculate "ConvexFacesIndicesData" of the profile2d before creating vtxProfiles.
	this.convexFacesIndicesData = profile2d.getConvexFacesIndicesData(undefined);
	
	// create vtxProfiles.
	// make the base-vtxProfile.
	var baseVtxProfile = new VtxProfile();
	baseVtxProfile.makeByProfile2D(profile2d);
	
	// Now, transform the baseVtxProfile to coplanar into the 1rstPlane.
	if (bLoop === undefined) { bLoop = false; } // Is important to set "bLoop" = false to obtain a perpendicular plane respect to the segment.
	var bisectionPlane1rst = pathPoints3dList.getBisectionPlane(0, undefined, bLoop);
	var point3d1rst = pathPoints3dList.getPoint(0);
	var tMatrix = bisectionPlane1rst.getRotationMatrix(undefined);
	tMatrix.setTranslation(point3d1rst.x, point3d1rst.y, point3d1rst.z);
	
	// Now rotate&translate vtxProfile onto the bisectionPlane1rst.
	baseVtxProfile.transformPointsByMatrix4(tMatrix);
	
	// Now, project the vtxProfile onto the bisectionPlanes of each vertex.
	var pathPoint3d;
	var bisectionPlane;
	var segment3d;
	var projectionDirection;
	var pathPointsCount = pathPoints3dList.getPointsCount();
	for (var i=0; i<pathPointsCount; i++)
	{
		pathPoint3d = pathPoints3dList.getPoint(i);
		bisectionPlane = pathPoints3dList.getBisectionPlane(i, undefined, bLoop);
		if (i === 0)
		{
			segment3d = pathPoints3dList.getSegment3D(i, undefined, bLoop);
		}
		else
		{ segment3d = pathPoints3dList.getSegment3D(i-1, undefined, bLoop); }
		
		projectionDirection = segment3d.getDirection(undefined);
		
		var projectedVtxProfile = VtxProfile.getProjectedOntoPlane(baseVtxProfile, bisectionPlane, projectionDirection, undefined);
		this.addVtxProfile(projectedVtxProfile);
		// finally update the baseVtxProfile.
		baseVtxProfile = projectedVtxProfile;
	}
};

























































'use strict';

/**
 * vertex ring.
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class VtxRing
 * 
 */
var VtxRing = function() 
{
	if (!(this instanceof VtxRing)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * vertex list
	 * @type {VertexList}
	 */
	this.vertexList;

	/**
	 * indexRange array
	 * @type {Array.<IndexRange>}
	 */
	this.elemsIndexRangesArray;
	
	this.isOpen;
};

/**
 * delete all vertex and element index ranges.
 */
VtxRing.prototype.deleteObjects = function()
{
	if (this.vertexList !== undefined)
	{
		this.vertexList.deleteObjects();
		this.vertexList = undefined;
	}
	
	if (this.elemsIndexRangesArray !== undefined)
	{
		this.deleteElementIndexRanges();
	}
};

/**
 * delete all element index ranges.
 */
VtxRing.prototype.deleteElementIndexRanges = function()
{
	if (this.elemsIndexRangesArray === undefined)
	{ return; }
	
	var indexRangesCount = this.elemsIndexRangesArray.length;
	for (var i=0; i<indexRangesCount; i++)
	{
		this.elemsIndexRangesArray[i].deleteObjects();
		this.elemsIndexRangesArray[i] = undefined;
	}
	
	this.elemsIndexRangesArray = undefined;
};

/**
 * add new index range and return.
 * @returns {IndexRange}
 */
VtxRing.prototype.newElementIndexRange = function()
{
	if (this.elemsIndexRangesArray === undefined)
	{ this.elemsIndexRangesArray = []; }
	
	var indexRange = new IndexRange();
	this.elemsIndexRangesArray.push(indexRange);
	return indexRange;
};

/**
 * get IndexRange
 * @param {number}
 * @returns {IndexRange|undefined}
 */
VtxRing.prototype.getElementIndexRange = function(idx)
{
	if (this.elemsIndexRangesArray === undefined)
	{ return undefined; }
	
	return this.elemsIndexRangesArray[idx];
};

/**
 * get all vertex. 
 * @param {Array} resultVerticesArray
 * @returns {Array.<Vertex>|undefined} if this.vertexList is undefined or this.vertexList.vertexArray is undefined, return resultVerticesArray.
 */
VtxRing.prototype.getAllVertices = function(resultVerticesArray)
{
	if (this.vertexList === undefined || this.vertexList.vertexArray === undefined)
	{ return resultVerticesArray; }
	
	if (resultVerticesArray === undefined)
	{ resultVerticesArray = []; }
	
	resultVerticesArray.push.apply(resultVerticesArray, this.vertexList.vertexArray);
	
	return resultVerticesArray;
};

/**
 * vertex ring copy from another vertex ring.
 * @param {VtxRing} vtxRing
 */
VtxRing.prototype.copyFrom = function(vtxRing)
{
	if (vtxRing.vertexList !== undefined)
	{
		if (this.vertexList === undefined)
		{ this.vertexList = new VertexList(); }
		
		this.vertexList.copyFrom(vtxRing.vertexList);
	}
	
	if (vtxRing.elemsIndexRangesArray !== undefined)
	{
		if (this.elemsIndexRangesArray === undefined)
		{ this.elemsIndexRangesArray = []; }
		
		var indexRange, myIndexRange;
		var indexRangesCount = vtxRing.elemsIndexRangesArray.length;
		for (var i=0; i<indexRangesCount; i++)
		{
			indexRange = vtxRing.elemsIndexRangesArray[i];
			myIndexRange = this.newElementIndexRange();
			myIndexRange.copyFrom(indexRange);
		}
	}
	
	this.isOpen = vtxRing.isOpen;
};

/**
 * vertex point translate.
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @see Point3D#add
 */
VtxRing.prototype.translate = function(x, y, z)
{
	if (this.vertexList !== undefined)
	{
		this.vertexList.translateVertices(x, y, z);
	}
};

/**
 * vertex point transform by matrix4
 * @param {Matrix4} tMat4
 * @see Matrix4#transformPoint3D
 */
VtxRing.prototype.transformPointsByMatrix4 = function(tMat4)
{
	if (this.vertexList !== undefined)
	{
		this.vertexList.transformPointsByMatrix4(tMat4);
	}
};

/**
 * get projected poly line. this line based ring2d.
 * @param {Ring2D|undefined} resultRing2d if undefined, set new Ring2D instance.
 * @param {Point3D} normal
 * @returns {Ring2D}
 * 
 * @see VertexList#getProjectedPoints2DArray
 */
VtxRing.prototype.getProjectedPolyLineBasedRing2D = function(resultRing2d, normal)
{
	// This function returns a ring2d made by polylines2d.
	if (this.vertexList === undefined)
	{ return resultRing2d; }
	
	if (resultRing2d === undefined)
	{ resultRing2d = new Ring2D(); }
	
	var points2dArray = [];
	points2dArray = VertexList.getProjectedPoints2DArray(this.vertexList.vertexArray, normal, points2dArray);
	
	var polyLine2d = resultRing2d.newElement("POLYLINE");
	polyLine2d.point2dArray = points2dArray;
	
	return resultRing2d;
};

/**
 * use point3d array, set VtxRing's vertex list and indexrange.
 * @param {Array.<Point3D>} point3dArray Required.
 * 
 * @see VertexList#copyFromPoint3DArray
 */
VtxRing.prototype.makeByPoints3DArray = function(point3dArray)
{
	if (point3dArray === undefined)
	{ return; }
	
	if (this.vertexList === undefined)
	{ this.vertexList = new VertexList(); }
	
	this.vertexList.copyFromPoint3DArray(point3dArray);
	
	// Now, in this case, mark all vertex.vertexType = 1 (bcos all elems are lines).
	var vertexCount = this.vertexList.getVertexCount();
	var vertex;
	for (var i=0; i<vertexCount; i++)
	{
		vertex = this.vertexList.getVertex(i);
		vertex.setVertexType(1);
	}
	this.calculateElementsIndicesRange();
};

/**
 * use point3d array, update VtxRing's vertex list.
 * @param {Array.<Point3D>} point3dArray Required.
 * 
 * @see VertexList#copyFromPoint3DArray
 */
VtxRing.prototype.updateByPoints3DArray = function(point3dArray)
{
	// Note: point3dCount must be equal to this.verticesCount.
	if (point3dArray === undefined)
	{ return; }
	
	if (this.vertexList === undefined)
	{ this.vertexList = new VertexList(); }

	var vertex;
	var point3d;
	var position;
	var points3dCount = point3dArray.length;
	for (var i=0; i<points3dCount; i++)
	{
		point3d = point3dArray[i]; // the original point3d.
		vertex = this.vertexList.getVertex(i);
		if (vertex === undefined)
		{ vertex = this.vertexList.newVertex(); }
		
		if (vertex.point3d === undefined)
		{ vertex.point3d = new Point3D(); }
		
		vertex.point3d.set(point3d.x, point3d.y, point3d.z);
	}
	
	this.vertexList.copyFromPoint3DArray(point3dArray);
	
	// Do no modify elementsIndexRanges.
	//this.calculateElementsIndicesRange();
};

/**
 * use point2d array, update VtxRing's vertex list and indexrange.
 * @param {Point2DList} point2dArray Required.
 * @param {number} z altitude. default is zero.
 * @see VertexList#copyFromPoint3DArray
 */
VtxRing.prototype.makeByPoint2DList = function(point2dList, z)
{
	if (point2dList === undefined)
	{ return; }
	
	if (z === undefined)
	{ z = 0; }
	
	if (this.vertexList === undefined)
	{ this.vertexList = new VertexList(); }
	
	this.vertexList.copyFromPoint2DList(point2dList, z);
	this.calculateElementsIndicesRange();
};

/**
 * calculate plane normal.
 * Note: this ring must be planar (or almost planar).
 * @param {Point3D} resultPlaneNormal not use.
 * @returns {Point3D} planeNormal
 * @see Face#calculatePlaneNormal
 */
VtxRing.prototype.calculatePlaneNormal = function(resultPlaneNormal)
{
	var planeNormal = Face.calculatePlaneNormal(this.vertexList.vertexArray, undefined);
	return planeNormal;
};

/**
 * calculate elements indices range.
 */
VtxRing.prototype.calculateElementsIndicesRange = function()
{
	if (this.vertexList === undefined)
	{ return false; }

	// 1rst, delete all existent indexRanges.
	this.deleteElementIndexRanges();
	this.elemsIndexRangesArray = [];
	
	var vertex;
	var idxRange = undefined;
	var vertexType;
	var vertexCount = this.vertexList.getVertexCount();
	for (var i=0; i<vertexCount; i++)
	{
		vertex = this.vertexList.getVertex(i);
		vertexType = vertex.vertexType;
		
		//if(vertexType === undefined && i===0)
		//{
		//	var prevIdx = this.vertexList.getPrevIdx(i);
		//	var prevVertex = this.vertexList.getVertex(prevIdx);
		//	vertexType = prevVertex.vertexType;
		//}
		
		if (vertexType && vertexType === 1)
		{
			if (idxRange !== undefined)
			{
				idxRange.endIdx = i;
			}
			if (i !== vertexCount)
			{
				idxRange = this.newElementIndexRange();
				idxRange.strIdx = i;
			}
		}
	}
	
	if (idxRange !== undefined)
	{ idxRange.endIdx = 0; }
};

/**
 * get vertex intersected with plane. 
 * @static
 * @param {VtxRing} vtxRing if vtxRing's vertexList undefined, return resultVtxRing.
 * @param {Plane} plane. 
 * @param {Point3D} projectionDirection projectionDirection must be unitary.
 * @param {VtxRing} resultVtxRing Optional. if undefined, set new VtxRing instance.
 * @returns {VtxRing} resultVertex
 */
VtxRing.getProjectedOntoPlane = function(vtxRing, plane, projectionDirection, resultVtxRing)
{
	if (vtxRing.vertexList === undefined)
	{ return resultRing2d; }
	
	if (resultVtxRing === undefined)
	{ resultVtxRing = new VtxRing(); }

	resultVtxRing.vertexList = VertexList.getProjectedOntoPlane(vtxRing.vertexList, plane, projectionDirection, resultVtxRing.vertexList);
	resultVtxRing.calculateElementsIndicesRange();
	return resultVtxRing;
};














































'use strict';
/**
 * vertex ring list.
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class VtxRing
 * 
 */
var VtxRingsList = function() 
{
	if (!(this instanceof VtxRingsList)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	/**
	 * vertex list.
	 * @type {Array.<VtxRing>}
	 */
	this.vtxRingsArray;
};

/**
 * delete all vertex and element index ranges.
 */
VtxRingsList.prototype.deleteObjects = function()
{
	if (this.vtxRingsArray !== undefined)
	{
		var vtxRingsCount = this.vtxRingsArray.length;
		for (var i=0; i<vtxRingsCount; i++)
		{
			this.vtxRingsArray[i].deleteObjects();
			this.vtxRingsArray[i] = undefined;
		}
		this.vtxRingsArray = undefined;
	}
};


/**
 * get vtxRing count.
 * @returns {Number} 
 */
VtxRingsList.prototype.getVtxRingsCount = function()
{
	if (this.vtxRingsArray === undefined)
	{ return 0; }
	
	return this.vtxRingsArray.length;
};

/**
 * get vtxRing.
 * @param {Number} idx.
 * @returns {VtxRing|undefined} 
 */
VtxRingsList.prototype.getVtxRing = function(idx)
{
	if (this.vtxRingsArray === undefined)
	{ return undefined; }
	
	return this.vtxRingsArray[idx];
};

/**
 * add new vtxRing and return.
 * @returns {IndexRange}
 */
VtxRingsList.prototype.newVtxRing = function()
{
	if (this.vtxRingsArray === undefined)
	{ this.vtxRingsArray = []; }
	
	var vtxRing = new VtxRing();
	this.vtxRingsArray.push(vtxRing);
	return vtxRing;
};

/**
 * vertex ring list copy from another vertex ring list.
 * @param {VtxRingList} vtxRingList
 */
VtxRingsList.prototype.copyFrom = function(vtxRingsList)
{
	if (vtxRingsList === undefined)
	{ return; }
	
	if (this.vtxRingsArray === undefined)
	{ this.vtxRingsArray = []; }
	
	var vtxRing;
	var vtxRingsCount = vtxRingsList.getVtxRingsCount();
	for (var i=0; i<vtxRingsCount; i++)
	{
		vtxRing = this.newVtxRing();
		vtxRing.copyFrom(vtxRingsList.getVtxRing(i));
	}
};

/**
 * vertex point translate.
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @see Point3D#add
 */
VtxRingsList.prototype.translate = function(x, y, z)
{
	var vtxRingsCount = this.getVtxRingsCount();
	for (var i=0; i<vtxRingsCount; i++)
	{
		this.vtxRingsArray[i].translate(x, y, z);
	}
};

/**
 * vertex point transform by matrix4
 * @param {Matrix4} tMat4
 * @see Matrix4#transformPoint3D
 */
VtxRingsList.prototype.transformPointsByMatrix4 = function(tMat4)
{
	var vtxRingsCount = this.getVtxRingsCount();
	for (var i=0; i<vtxRingsCount; i++)
	{
		this.vtxRingsArray[i].transformPointsByMatrix4(tMat4);
	}
};

/**
 * get all vertex. 
 * @param {Array} resultVerticesArray
 * @returns {Array.<Vertex>|undefined} if this.vtxRingsArray is undefined, return resultVerticesArray.
 */
VtxRingsList.prototype.getAllVertices = function(resultVerticesArray)
{
	if (this.vtxRingsArray === undefined)
	{ return resultVerticesArray; }
	
	var vtxRingsCount = this.getVtxRingsCount();
	for (var i=0; i<vtxRingsCount; i++)
	{
		this.vtxRingsArray[i].getAllVertices(resultVerticesArray);
	}
	
	return resultVerticesArray;
};

/**
 * set vertex idx in list.
 * @deprecated Must no use. and VtxRing has no setVerticesIdxInList method.
 */
VtxRingsList.prototype.setVerticesIdxInList = function()
{
	if (this.vtxRingsArray === undefined)
	{ return; }
	
	var vtxRingsCount = this.getVtxRingsCount();
	for (var i=0; i<vtxRingsCount; i++)
	{
		this.vtxRingsArray[i].setVerticesIdxInList();
	}
};

/**
 * get vertex intersected with plane. 
 * @static
 * @param {VtxRingList} vtxRingList if vtxRingList undefined, return resultVtxRingList.
 * @param {Plane} plane. 
 * @param {Point3D} projectionDirection projectionDirection must be unitary.
 * @param {VtxRingList} resultVtxRingList Optional. if undefined, set new VtxRingList instance.
 * @returns {VtxRingList} resultVtxRingList
 */
VtxRingsList.getProjectedOntoPlane = function(vtxRingList, plane, projectionDirection, resultVtxRingList)
{
	if (vtxRingList === undefined)
	{ return resultVtxRingList; }
	
	if (resultVtxRingList === undefined)
	{ resultVtxRingList = new VtxRingsList(); }
	
	var vtxRing, projectedVtxRing;;
	var vtxRingsCount = vtxRingList.getVtxRingsCount();
	for (var i=0; i<vtxRingsCount; i++)
	{
		vtxRing = vtxRingList.getVtxRing(i);
		projectedVtxRing = resultVtxRingList.newVtxRing();
		projectedVtxRing = VtxRing.getProjectedOntoPlane(vtxRing, plane, projectionDirection, projectedVtxRing);
	}
	
	return resultVtxRingList;
};



















































'use strict';

/**
 * Vertex segment.
 * @exception {Error} Messages.CONSTRUCT_ERROR
 * 
 * @class VtxSegment
 * 
 * @param {Vertex} startVertex Optional. start vertex.
 * @param {Vertex} endVertex Optional. end vertex.
 */
var VtxSegment = function(startVertex, endVertex) 
{
	if (!(this instanceof VtxSegment)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	/**
	 * start vertex.
	 * @type {Vertex}
	 */
	this.startVertex;

	/**
	 * end vertex.
	 * @type {Vertex}
	 */
	this.endVertex;
	
	if (startVertex)
	{ this.startVertex = startVertex; }
	
	if (endVertex)
	{ this.endVertex = endVertex; }
};

/**
 * set start, end vertex.
 * @param {Vertex} startVertex 
 * @param {Vertex} endVertex
 */
VtxSegment.prototype.setVertices = function(startVertex, endVertex)
{
	this.startVertex = startVertex;
	this.endVertex = endVertex;
};

/**
 * get direction between start vertex and end vertex.
 * @param {Point3d} resultDirection if undefined , set new Point3D instance.
 * @returns {Point3d} resultDirection
 */
VtxSegment.prototype.getDirection = function(resultDirection)
{
	// the direction is an unitary vector.
	var resultDirection = this.getVector();
	
	if (resultDirection === undefined)
	{ return undefined; }
	
	resultDirection.unitary();
	return resultDirection;
};

/**
 * get vector point between start vertex and end vertex.
 * @param {Point3d} resultVector if undefined , set new Point3D instance.
 * @returns {Point3d} resultVector
 */
VtxSegment.prototype.getVector = function(resultVector)
{
	if (this.startVertex === undefined || this.endVertex === undefined)
	{ return undefined; }
	
	var startPoint = this.startVertex.point3d;
	var endPoint = this.endVertex.point3d;
	
	if (startPoint === undefined || endPoint === undefined)
	{ return undefined; }
	
	resultVector = startPoint.getVectorToPoint(endPoint, resultVector);
	return resultVector;
};

/**
 * get line between start vertex and end vertex.
 * @param {Line} resultLine if undefined , set new Line instance.
 * @returns {Line} resultLine
 */
VtxSegment.prototype.getLine = function(resultLine)
{
	if (resultLine === undefined)
	{ resultLine = new Line(); }
	
	var dir = this.getDirection(); // unitary direction.
	var strPoint = this.startVertex.point3d;
	resultLine.setPointAndDir(strPoint.x, strPoint.y, strPoint.z, dir.x, dir.y, dir.z);
	return resultLine;
};

/**
 * get squared length.
 * @returns {Number} squared length
 * 
 * @see Point3D#squareDistToPoint
 */
VtxSegment.prototype.getSquaredLength = function()
{
	return this.startVertex.point3d.squareDistToPoint(this.endVertex.point3d);
};

/**
 * get length. 
 * @returns {Number} square root of squared length
 */
VtxSegment.prototype.getLength = function()
{
	return Math.sqrt(this.getSquaredLength());
};

/**
 * get intersection info with point. 
 * @param {Point3D} point
 * @param {Number} error default is 10E-8.
 * @returns {Number} Constant.INTERSECTION_*
 * Constant.INTERSECTION_OUTSIDE = 0
 * Constant.INTERSECTION_INTERSECT= 1
 * Constant.INTERSECTION_INSIDE = 2
 * Constant.INTERSECTION_POINT_A = 3
 * Constant.INTERSECTION_POINT_B = 4
 * 
 * @see Constant
 * @see Line#isCoincidentPoint
 * @see Point3D#distToPoint
 */
VtxSegment.prototype.intersectionWithPoint = function(point, error)
{
	// check if the point intersects the vtxSegment's line.
	var line = this.getLine();
	
	if (error === undefined)
	{ error = 10E-8; }
	
	if (!line.isCoincidentPoint(point, error))
	{ return Constant.INTERSECTION_OUTSIDE; } // no intersection.
	
	// now, check if is inside of the segment or if is coincident with any vertex of segment.
	var distA = this.startVertex.point3d.distToPoint(point);
	var distB = this.endVertex.point3d.distToPoint(point);
	var distTotal = this.getLength();
	
	if (distA < error)
	{ return Constant.INTERSECTION_POINT_A; }
	
	if (distB < error)
	{ return Constant.INTERSECTION_POINT_B; }
	
	if (distA> distTotal || distB> distTotal)
	{
		return Constant.INTERSECTION_OUTSIDE;
	}
	
	if (Math.abs(distA + distB - distTotal) < error)
	{ return Constant.INTERSECTION_INSIDE; }	
};
















































'use strict';

/**
 * 메세지
 * 
 * @class
 */
var Message = function(i18next, message) 
{
	this.handle  = i18next;
	this.message = message || MessageSource;
};

/**
 * 메세지 클래스 초기화
 *
 * @param {Function} callback
 */
Message.prototype.init = function (callback)
{
	var h = this.handle;
	this.handle.use(i18nextXHRBackend)
		.use(i18nextBrowserLanguageDetector)
		.init({
			// Useful for debuging, displays which key is missing
			debug: false,

			detection: {
				// keys or params to lookup language from
				lookupQuerystring  : 'lang',
				lookupCookie       : 'i18nextLang',
				lookupLocalStorage : 'i18nextLang',
			},
    
			// If translation key is missing, which lang use instead
			fallbackLng: 'en',

			resources: this.message,

			// all, languageOnly
			load: "languageOnly",

			ns        : ['common'],
			// Namespace to use by default, when not indicated
			defaultNS : 'common',
    
			keySeparator     : ".",
			nsSeparator      : ":",
			pluralSeparator  : "_",
			contextSeparator : "_"

		}, function(err, t)
		{
			console.log("detected user language: " + h.language);
			console.log("loaded languages: " + h.languages.join(', '));
			h.changeLanguage(h.languages[0]);
			callback(err, t);
		});
};

/**
 * 메세지 핸들러를 가져온다.
 *
 * @returns {i18next} message handler
 */
Message.prototype.getHandle = function ()
{
	return this.handle;
};

/**
 * 메세지를 가져온다.
 *
 * @returns {Object} message
 */
Message.prototype.getMessage = function ()
{
	return this.message;
};

'use strict';
var MessageSource = {};
MessageSource.en = {
  "common": {
    "welcome" : "Welcome",
    "error": {
        "title" : "Error",
        "construct" : {
            "create" : "This object should be created using new."
        }
    }
  }
};
MessageSource.ko = {
    "common": {
      "welcome" : "환영합니다.",
      "error": {
          "title" : "오류",
          "construct" : {
              "create" : "이 객체는 new 를 사용하여 생성해야 합니다."
          }
      }
    }
  };

'use strict';

/**
 * Geoserver for mago3Djs object.
 * @class Geoserver
 */
var GeoServer = function() 
{

	this.serverInfo = {};
}; 

GeoServer.prototype.setServerInfo = function(info) 
{
	this.serverInfo = info;
};

GeoServer.prototype.getDataUrl = function() 
{
	return this.serverInfo.dataUrl;
};

GeoServer.prototype.getDataWorkspace = function() 
{
	return this.serverInfo.dataWorkspace;
};

GeoServer.prototype.getDataRequestUrl = function() 
{
	return this.getDataUrl() + '/' + this.getDataWorkspace();
};

GeoServer.prototype.getWmsVersion = function() 
{
	return this.serverInfo.wmsVersion;
};
'use strict';

/**
 * AnimatedPerson is a class object.
 * 
 * @class AnimatedPerson
 * @constructor 
 * @param {string} The name of the AnimatedPerson.
 */
var AnimatedPerson = function(name) 
{
	this.skeletalAnimObject;
	
};

AnimatedPerson.prototype.render = function(magoManager)
{
	
};
'use strict';


var Arrow = function(width, length, height, option) 
{
	MagoRenderable.call(this);
	this.color4 = new Color();
	this.color4.setRGBA(0.2, 0.2, 0.25, 1);

	this.type = 'extruded';

	this.totalLength = 10;
	if (length) 
	{
		this.totalLength = length;
	}

	this.bodyWidth = 1;
	if (width) 
	{
		this.bodyWidth = width * 0.5;
	}
	this.headWidth = 1.5;
	if (width) 
	{
		this.headWidth = width;
	}

	this.extrude = 1;
	if (height) 
	{
		this.extrude = height;
	}
	
	this.tailLength = this.totalLength * 0.7;

	if (option) 
	{
		var bodyWidth = option.bodyWidth;
		if (bodyWidth) 
		{
			this.bodyWidth = bodyWidth;
		}
        
		var headWidth = option.headWidth;
		if (headWidth) 
		{
			this.headWidth = headWidth;
		}
        
		var headLength = option.headLength;
		if (headLength) 
		{
			this.headLength = headLength;
		}
        
		var totalLength = option.totalLength;
		if (totalLength) 
		{
			this.totalLength = totalLength;
		}
        
		var tailLength = option.tailLength;
		if (tailLength) 
		{
			this.tailLength = tailLength;
		}

		var extrude = option.extrude;
		if (extrude) 
		{
			this.extrude = extrude;
		}
	}

	if (this.headWidth < this.bodyWidth) 
	{
		this.headWidth = this.bodyWidth * 1.5;
	}

	if (!this.headLength) 
	{
		this.headLength = this.totalLength *0.3;
	}
};
Arrow.prototype = Object.create(MagoRenderable.prototype);
Arrow.prototype.constructor = Arrow;

Arrow.prototype.makeMesh = function() 
{
	var profile2dAux = new Profile2D();
	
	// Outer ring.**
	var outerRing = profile2dAux.newOuterRing();
 
	var halfBodyWidth = this.bodyWidth * 0.5;
	var halfHeadWidth = this.headWidth * 0.5;
	var bodyLengthWithoutHead = this.totalLength - this.headLength;

	var polyline = outerRing.newElement("POLYLINE");
	
	if (this.tailLength)
	{
		polyline.newPoint2d(0, 0);
		polyline.newPoint2d(halfBodyWidth, this.tailLength);
		polyline.newPoint2d(halfBodyWidth, bodyLengthWithoutHead);
		polyline.newPoint2d(halfHeadWidth, bodyLengthWithoutHead);
		polyline.newPoint2d(0, this.totalLength);
		polyline.newPoint2d(-halfHeadWidth, bodyLengthWithoutHead);
		polyline.newPoint2d(-halfBodyWidth, bodyLengthWithoutHead);
		polyline.newPoint2d(-halfBodyWidth, this.tailLength);
	}
	else 
	{
		polyline.newPoint2d(-halfBodyWidth, 0);    
		polyline.newPoint2d(halfBodyWidth, 0);    
		polyline.newPoint2d(halfBodyWidth, bodyLengthWithoutHead);
		polyline.newPoint2d(halfHeadWidth, bodyLengthWithoutHead);
		polyline.newPoint2d(0, this.totalLength);
		polyline.newPoint2d(-halfHeadWidth, bodyLengthWithoutHead);
		polyline.newPoint2d(-halfBodyWidth, bodyLengthWithoutHead);
	}

	var extrudeSegmentsCount = 1;
	var extrusionVector = undefined;
	var bIncludeBottomCap = false;
	var bIncludeTopCap = false;
    
	var mesh = Modeler.getExtrudedMesh(profile2dAux, this.extrude, extrudeSegmentsCount, extrusionVector, bIncludeBottomCap, bIncludeTopCap, mesh);
	this.mesh = mesh;
	this.dirty = false;
};

/**
 * Renders the factory.
 */
Arrow.prototype.render = function(magoManager, shader, renderType, glPrimitive)
{
	if (this.attributes && this.attributes.isVisible !== undefined && this.attributes.isVisible === false) 
	{
		return;
	}
	if (this.dirty)
	{ this.makeMesh(); }
	
	if (this.mesh === undefined)
	{ return false; }

	// Set geoLocation uniforms.***
	
	var gl = magoManager.getGl();
	/*
	var buildingGeoLocation = this.geoLocDataManager.getCurrentGeoLocationData();
	buildingGeoLocation.bindGeoLocationUniforms(gl, shader); // rotMatrix, positionHIGH, positionLOW.
	
	gl.uniform1i(shader.refMatrixType_loc, 0); // in magoManager case, there are not referencesMatrix.***
	gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.***
	*/
	if (renderType === 2)
	{
		// Selection render.***
		var selectionColor = magoManager.selectionColor;
		var colorAux = magoManager.selectionColor.getAvailableColor(undefined);
		var idxKey = magoManager.selectionColor.decodeColor3(colorAux.r, colorAux.g, colorAux.b);
		magoManager.selectionManager.setCandidateGeneral(idxKey, this);
		
		gl.uniform4fv(shader.oneColor4_loc, [colorAux.r/255.0, colorAux.g/255.0, colorAux.b/255.0, 1.0]);
		gl.disable(gl.BLEND);
	}
	
	this.renderRaw(magoManager, shader, renderType, glPrimitive);
	//this.mesh.render(magoManager, shader, renderType, glPrimitive);

	gl.disable(gl.BLEND);
};

Arrow.prototype.renderAsChild = function(magoManager, shader, renderType, glPrimitive, bIsSelected) 
{
	if (this.attributes && this.attributes.isVisible !== undefined && this.attributes.isVisible === false) 
	{
		return;
	}
	if (this.dirty)
	{ this.makeMesh(); }
	
	if (this.mesh === undefined)
	{ return false; }

	// Set geoLocation uniforms.***
	var gl = magoManager.getGl();
	if (this.tMat && this.tMat instanceof Matrix4) 
	{
		gl.uniformMatrix4fv(shader.buildingRotMatrix_loc, false, this.tMat._floatArrays);
	}
	
	if (renderType === 0)
	{
		// Depth render.***
	}
	else if (renderType === 1)
	{
		// Color render.***
		//gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );
		gl.enable(gl.BLEND);
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.***
		
		// Check if is selected.***
		var selectionManager = magoManager.selectionManager;
		if (bIsSelected !== undefined && bIsSelected)
		{
			//gl.disable(gl.BLEND);
			gl.uniform4fv(shader.oneColor4_loc, [this.color4.r, this.color4.g, this.color4.b, 1.0]);
		}
		else if (selectionManager.isObjectSelected(this))
		{
			//gl.disable(gl.BLEND);
			gl.uniform4fv(shader.oneColor4_loc, [this.color4.r, this.color4.g, this.color4.b, 1.0]);
		}
		else 
		{
			gl.uniform4fv(shader.oneColor4_loc, [this.color4.r, this.color4.g, this.color4.b, this.color4.a]);
		}
		
	}

	this.mesh.render(magoManager, shader, renderType, glPrimitive, bIsSelected);

	gl.disable(gl.BLEND);
};

/**
 * Renders the factory.
 */
Arrow.prototype.renderRaw = function(magoManager, shader, renderType, glPrimitive, bIsSelected)
{
	if (this.dirty)
	{ this.makeMesh(); }
	
	if (this.mesh === undefined)
	{ return false; }

	// Set geoLocation uniforms.***
	var gl = magoManager.getGl();
	var buildingGeoLocation = this.geoLocDataManager.getCurrentGeoLocationData();
	buildingGeoLocation.bindGeoLocationUniforms(gl, shader); // rotMatrix, positionHIGH, positionLOW.
	
	if (renderType === 0)
	{
		// Depth render.***
	}
	else if (renderType === 1)
	{
		// Color render.***
		//gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );
		gl.enable(gl.BLEND);
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.***
		
		// Check if is selected.***
		var selectionManager = magoManager.selectionManager;
		if (bIsSelected !== undefined && bIsSelected)
		{
			//gl.disable(gl.BLEND);
			gl.uniform4fv(shader.oneColor4_loc, [this.color4.r, this.color4.g, this.color4.b, 1.0]);
		}
		else if (selectionManager.isObjectSelected(this))
		{
			//gl.disable(gl.BLEND);
			gl.uniform4fv(shader.oneColor4_loc, [this.color4.r, this.color4.g, this.color4.b, 1.0]);
		}
		else 
		{
			gl.uniform4fv(shader.oneColor4_loc, [this.color4.r, this.color4.g, this.color4.b, this.color4.a]);
		}
		
	}

	this.mesh.render(magoManager, shader, renderType, glPrimitive, bIsSelected);

	gl.disable(gl.BLEND);
};
'use strict';

/**
 * Factory shaped object.
 * @class BasicFactory
 */
var BasicFactory = function(factoryWidth, factoryLength, factoryHeight, options) 
{
	if (!(this instanceof BasicFactory)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	MagoRenderable.call(this);
	/**
	 * The name of the factory.
	 * @type {String}
	 * @default undefined
	 */
	this.name;
	
	/**
	 * The entire width of the factory.
	 * @type {Number}
	 * @default undefined
	 */
	this.width = factoryWidth;
	
	/**
	 * The entire length of the factory.
	 * @type {Number}
	 * @default undefined
	 */
	this.length = factoryLength;
	
	/**
	 * The entire height of the factory.
	 * @type {Number}
	 * @default undefined
	 */
	this.height = factoryHeight;
	
	/**
	 * This boolean variable indicates if the factory has his own ground.
	 * @type {Boolean}
	 * @default false
	 */
	this.bHasGround = false;
	
	/**
	 * This minimum height of the roof.
	 * @type {Number}
	 * @default undefined
	 */
	this.roofMinHeight;
	
	
	/**
	 * The geographic location of the factory.
	 * @type {GeoLocationDataManager}
	 * @default undefined
	 */
	this.geoLocDataManager;
	
	/**
	 * Array of the objects that configures the fatory.
	 * @type {Array}
	 * @default undefined
	 */
	this.objectsArray;
	
	this.objectsMap;
	
	/**
	 * The bounding box of the fatory.
	 * @type {BoundingBox}
	 * @default undefined
	 */
	this.bbox;
	
	/**
	 * Boolean variable that indicates that the geometry is dirty.
	 * @type {Boolean}
	 * @default true
	 */
	this.dirty = true;
	
	this.roofColor4 = new Color();
	this.roofColor4.setRGBA(98/256, 233/256, 134/256, 0.3);
	
	this.options = options;

	// After check the option values, set the boundingBox.***
	this.bbox = new BoundingBox();
	this.bbox.set(-this.width/2, -this.length/2, 0, this.width/2, this.length/2, this.height);
	
	this.attributes = {isVisible: true};
};

BasicFactory.prototype = Object.create(MagoRenderable.prototype);
BasicFactory.prototype.constructor = BasicFactory;

/**
 * BasicFactory wallType.
 */
BasicFactory.wallType = {
	'FRONT' : 'front',
	'REAR'  : 'rear',
	'LEFT'  : 'left',
	'RIGHT' : 'right'
};
/**
 * Returns the bbox.
 */
BasicFactory.prototype.getBoundingBox = function()
{
	return this.bbox;
};

/**
 * Returns the bbox.
 */
BasicFactory.getFactoryDimensionsByGeoCoordsArray = function(geoCoordsArray, edgeIdxOfDoor, magoManager)
{
	if (geoCoordsArray === undefined || geoCoordsArray.length < 4)
	{ return undefined; }
	
	var geoCoord_0 = geoCoordsArray[0];
	var geoCoord_1 = geoCoordsArray[1];
	var geoCoord_2 = geoCoordsArray[2];
	var geoCoord_3 = geoCoordsArray[3];
	var fWidth, fLength, headingAngDeg;
	if (edgeIdxOfDoor === 0)
	{
		var geoCoordSegment = new GeographicCoordSegment(geoCoord_0, geoCoord_1);
		var geoCoordSegment2 = new GeographicCoordSegment(geoCoord_1, geoCoord_2);
	}
	else if (edgeIdxOfDoor === 1)
	{
		var geoCoordSegment = new GeographicCoordSegment(geoCoord_1, geoCoord_2);
		var geoCoordSegment2 = new GeographicCoordSegment(geoCoord_2, geoCoord_3);
	}
	else if (edgeIdxOfDoor === 2)
	{
		var geoCoordSegment = new GeographicCoordSegment(geoCoord_2, geoCoord_3);
		var geoCoordSegment2 = new GeographicCoordSegment(geoCoord_3, geoCoord_0);
	}
	else if (edgeIdxOfDoor === 3)
	{
		var geoCoordSegment = new GeographicCoordSegment(geoCoord_3, geoCoord_0);
		var geoCoordSegment2 = new GeographicCoordSegment(geoCoord_0, geoCoord_1);
	}
	
	fWidth = GeographicCoordSegment.getLengthInMeters(geoCoordSegment, magoManager);
	fLength = GeographicCoordSegment.getLengthInMeters(geoCoordSegment2, magoManager);
	headingAngDeg = GeographicCoordSegment.calculateHeadingAngRadToNorthOfSegment(geoCoordSegment2, magoManager)*180/Math.PI;
	
	var lon = (geoCoord_0.longitude + geoCoord_0.longitude + geoCoord_0.longitude + geoCoord_0.longitude )/4;
	var lat = (geoCoord_0.latitude + geoCoord_0.latitude + geoCoord_0.latitude + geoCoord_0.latitude )/4;
	
	var result = {
		factoryWidth  : fWidth,
		factoryLength : fLength,
		headingDeg    : headingAngDeg,
		longitude     : lon,
		latitude      : lat
	};
	return result;
};

/**
 * Makes triangular wall profile.
 */
BasicFactory.getTriangularWallProfile2d = function(options, resultProfile2d)
{
	// Triangular wall with opening.****************************************
	//
	//                   Y
	//                   ^
	//                   |
	//                  /7\             <-- height
	//                /  |  \
	//              /    |    \
	//            /      |      \
	//          8        |        6     <-- roofMinHeight
	//          |        |         |
	//          |  2------------3  |    <-- openingHeight (if exist).
	//          |  |     |      |  |
	//          |  |     |      |  |
	//          0--1     +      4--5-------> X
	//
	
	// Triangular wall without opening.**************************************
	//
	//                   Y
	//                   ^
	//                   |
	//                  /3\             <-- height
	//                /  |  \
	//              /    |    \
	//            /      |      \
	//          4        |        2     <-- roofMinHeigh
	//          |        |         |
	//          |        |         |    
	//          |        |         |
	//          |        |         |
	//          0--------+---------1-------> X
	//
	
	if (options === undefined)
	{ return resultProfile2d; }
	
	if (resultProfile2d === undefined)
	{ resultProfile2d = new Profile2D(); }
	
	var hasOpening = options.hasOpening;
	if (hasOpening === undefined)
	{ hasOpening = false; }
	
	// factory width.
	var width = options.width;
	
	// factory height.
	var height = options.height;
	
	// factory roof min height.
	var roofMinHeight = options.roofMinHeight;
	if (roofMinHeight === undefined)
	{ roofMinHeight = height * 0.75; }
	
	var halfWidth = width * 0.5;
	
	if (hasOpening)
	{
		// opening dimensions.
		var openingHeight = options.openingHeight;
		if (openingHeight === undefined)
		{ openingHeight = height * 0.6; }
		
		var openingWidth = options.openingWidth;
		if (openingWidth === undefined)
		{ openingWidth = width * 0.8; }
		
		var openingLeftWidth = openingWidth * 0.5;
		var openingRightWidth = openingWidth * 0.5;
	
		// Create a outer ring in the Profile2d.
		var outerRing = resultProfile2d.newOuterRing();
		var polyline = outerRing.newElement("POLYLINE");
		polyline.newPoint2d(-halfWidth, 0);                          // 0
		polyline.newPoint2d(-openingLeftWidth, 0);                   // 1
		polyline.newPoint2d(-openingLeftWidth, openingHeight);       // 2
		polyline.newPoint2d(openingRightWidth, openingHeight);       // 3
		polyline.newPoint2d(openingRightWidth, 0);                   // 4
		polyline.newPoint2d(halfWidth, 0);                           // 5
		polyline.newPoint2d(halfWidth, roofMinHeight);               // 6
		polyline.newPoint2d(0, height);                              // 7
		polyline.newPoint2d(-halfWidth, roofMinHeight);              // 8
	}
	else 
	{
		// wall without opening.
		// Create a outer ring in the Profile2d.
		var outerRing = resultProfile2d.newOuterRing();
		var polyline = outerRing.newElement("POLYLINE");
		polyline.newPoint2d(-halfWidth, 0);                          // 0
		polyline.newPoint2d(halfWidth, 0);                           // 1
		polyline.newPoint2d(halfWidth, roofMinHeight);               // 2
		polyline.newPoint2d(0, height);                              // 3
		polyline.newPoint2d(-halfWidth, roofMinHeight);              // 4
	}
	
	return resultProfile2d;
};

/**
 * Makes triangular wall profile.
 */
BasicFactory.getLateralWallProfile2d = function(options, resultProfile2d)
{
	//
	//   15-----------------------------------------------------------14      <-- height
	//   |                                                            |
	//   |                      6--------------7                      |               
	//   |   2-----------3      |              |                      |       <-- openingHeight
	//   |   |           |      |              |                      |
	//   |   |           |      |              |      10----------11  |       <-- openingHeight
	//   |   |           |      |              |      |           |   |
	//   0---1           4------5              8------9           12--13
	//
	//   offset,width,height    offset,width,height    offset,width,height ...
	
	if (resultProfile2d === undefined)
	{ resultProfile2d = new Profile2D(); }

	// wall height.
	var height = options.height;
	var length = options.length;
	
	// Create a outer ring in the Profile2d.
	var outerRing = resultProfile2d.newOuterRing();
	var polyline = outerRing.newElement("POLYLINE");
	
	// create the 1rst point2d.
	polyline.newPoint2d(0, 0);   
	var currOffSet = 0;
	
	// insert openings if exist.
	var openingsDataArray = options.openingsDataArray;
	var openingsCount = 0;
	if (openingsDataArray !== undefined)
	{ openingsCount = openingsDataArray.length; }
	
	for (var i=0; i<openingsCount; i++)
	{
		var openingData = options.openingsDataArray[i];
		var openingOffSet = openingData.offSet;
		var openingHeight = openingData.height;
		var openingWidth = openingData.width;
		
		// insert opening into profile.
		polyline.newPoint2d(currOffSet + openingOffSet, 0);
		polyline.newPoint2d(currOffSet + openingOffSet, openingHeight);
		polyline.newPoint2d(currOffSet + openingOffSet + openingWidth, openingHeight);
		polyline.newPoint2d(currOffSet + openingOffSet + openingWidth, 0);
		
		// update currentOffSet.
		currOffSet = currOffSet + openingOffSet + openingWidth;
	}
	
	// Now, finish the profile (13).
	polyline.newPoint2d(length, 0);
	polyline.newPoint2d(length, height);
	polyline.newPoint2d(0, height);
	
	return resultProfile2d;
};

/**
 * 공장 벽 프로파일
 * @param {string} wallType 벽 위치
 * @param {object} wallOption 벽 옵션, 존재하면 문을 그림.
 * @param {Profile2d}} resultProfile2d
 * @return {Profile2d}
 */
BasicFactory.prototype.getWallProfile2d = function(wallType, wallOption, resultProfile2d) 
{
	if (resultProfile2d === undefined)
	{ resultProfile2d = new Profile2D(); }

	// 앞뒤인지 여부
	var isFrontOrRear = (wallType === BasicFactory.wallType.FRONT || wallType === BasicFactory.wallType.REAR);
	// factory width.
	var width = isFrontOrRear ? this.width : this.length;
	// factory height.
	var height = this.height;
	// factory roof min height.
	var roofMinHeight = this.roofMinHeight;

	var outerRing = resultProfile2d.newOuterRing();
	var polyline = outerRing.newElement("POLYLINE");
	polyline.newPoint2d(0, 0);
	if (wallOption && wallOption.openingInfo) 
	{
		if (Array.isArray(wallOption.openingInfo)) 
		{
			var curOffset = 0;
			var openingInfos = wallOption.openingInfo;
			for (var i=0, len=openingInfos.length;i<len;i++) 
			{
				var openingInfo = openingInfos[i];

				if (!defined(openingInfo.offset)) { continue; }

				var doorOffset = openingInfo.offset;
				var doorHeight = openingInfo.height;
				var doorWidth = openingInfo.width;

				curOffset = curOffset + doorOffset;
				openingInfo.centerPropterties = this.calculateOpeningProperties(wallType, curOffset, doorWidth, doorHeight, openingInfo.thickness);

				polyline.newPoint2d(curOffset, 0);
				polyline.newPoint2d(curOffset, doorHeight);

				curOffset = curOffset + doorWidth;
				polyline.newPoint2d(curOffset, doorHeight);
				polyline.newPoint2d(curOffset, 0);
			}
		}
		else 
		{
			var openingInfo = wallOption.openingInfo;
			var offset = defined(openingInfo.offset) ? openingInfo.offset : (width - openingInfo.width) * 0.5;

			var doorHeight = openingInfo.height;
			var doorWidth = openingInfo.width;

			openingInfo.centerPropterties = this.calculateOpeningProperties(wallType, offset, doorWidth, doorHeight, openingInfo.thickness);
			polyline.newPoint2d(offset, 0);
			polyline.newPoint2d(offset, doorHeight);
			polyline.newPoint2d(offset + doorWidth, doorHeight);
			polyline.newPoint2d(offset + doorWidth, 0);
		}
	}

	polyline.newPoint2d(width, 0);
	polyline.newPoint2d(width, roofMinHeight);
	if (isFrontOrRear) 
	{
		polyline.newPoint2d(width*0.5, height);
	}
	polyline.newPoint2d(0, roofMinHeight);

	return resultProfile2d;
};
BasicFactory.prototype.calculateOpeningProperties = function(wallType, start, width, height) 
{
	var profile2d = new Profile2D();
	var outerRing = profile2d.newOuterRing();
	var polyline = outerRing.newElement("POLYLINE");

	/*polyline.newPoint2d(start, 0);
	polyline.newPoint2d(start, height);
	polyline.newPoint2d(start + width, height);
	polyline.newPoint2d(start + width, 0);*/

	polyline.newPoint2d(start, 0);
	polyline.newPoint2d(start + width, 0);
	polyline.newPoint2d(start + width, height);
	polyline.newPoint2d(start, height);
	
	var vp =  new VtxProfile();
	vp.makeByProfile2D(profile2d);

	this.validateWallGeom(wallType, vp);

	var outerRing = vp.outerVtxRing;
	var outerVertexList = outerRing.vertexList;
	var openingBbox = outerVertexList.getBoundingBox();

	var openingCenterPointLC = openingBbox.getCenterPoint();
	var openingNormalLC = outerRing.calculatePlaneNormal();

	var geoLocDataManager = this.geoLocDataManager;
	var geoLocData = geoLocDataManager.getCurrentGeoLocationData();
	var rotMatrix = geoLocData.rotMatrix;

	var openingCenterPointWC = geoLocData.localCoordToWorldCoord(openingCenterPointLC);
	var openingNormalWC = rotMatrix.transformPoint3D(openingNormalLC);

	return {
		openeingProfile2d : profile2d,
		centerLC          : openingCenterPointLC,
		normalLC          : openingNormalLC,
		centerWC          : openingCenterPointWC,
		normalWC          : openingNormalWC
	};
};

BasicFactory.prototype.getOpeningProperties = function(wallType, index) 
{
	var wallOptions = this.options.wallOptions;

	if (!defined(index)) { index = 0; }

	var wallOption;
	if (wallOptions) 
	{
		for (var j in wallOptions) 
		{
			if (wallOptions[j].type === wallType) 
			{
				wallOption = wallOptions[j];
			}
		}
	}
	var centerProperties;
	if (Array.isArray(wallOption.openingInfo)) 
	{
		if (wallOption.openingInfo[index].centerPropterties) 
		{
			wallOption.openingInfo[index].centerPropterties.wallType = wallType;
		}
		centerProperties = wallOption.openingInfo[index].centerPropterties;
	}
	else 
	{
		if (wallOption.openingInfo.centerPropterties) 
		{
			wallOption.openingInfo.centerPropterties.wallType = wallType;
		}
		centerProperties = wallOption.openingInfo.centerPropterties;
	}

	return centerProperties;
};
/**
 * Makes the geometry mesh.
 */
BasicFactory.prototype.makeMesh = function()
{	
	if (this.width === undefined || this.length === undefined || this.height === undefined)
	{ return; }
	
	if (this.objectsArray === undefined)
	{ this.objectsArray = []; }

	if (this.objectsMap === undefined)
	{ this.objectsMap = {}; }
	
	if (this.bHasGround)
	{
		// Make the ground.***
		var groundWidth = this.width;
		var groundLength = this.length;
		var groundHeight = this.height * 0.02;
		
		var groundMesh = new Box(groundWidth, groundLength, groundHeight, "ground");
		groundMesh.setOneColor(0.2, 0.3, 0.3, 1.0);
		groundMesh.owner = this;
		this.objectsArray.push(groundMesh);
		this.objectsMap[groundMesh.name] = groundMesh;
	}
	this.roofMinHeight = defaultValue(this.options.roofMinHeight, this.height*0.75);

	// Walls.***
	var wallOptions = this.options.wallOptions;
	var extrusionDist = 0.4;
	var extrudeSegmentsCount = 1;
	var extrusionVector = undefined;
	var bIncludeBottomCap = true;
	var bIncludeTopCap = true;

	for (var key in BasicFactory.wallType) 
	{
		if (!BasicFactory.wallType.hasOwnProperty(key)) { continue; }
		
		var wallType = BasicFactory.wallType[key];
		var wallOption;
		if (wallOptions) 
		{
			for (var j in wallOptions) 
			{
				if (wallOptions[j].type === wallType) 
				{
					wallOption = wallOptions[j];
					extrusionDist = defaultValue(wallOption.thickness, 0.4);
					break;
				}
				else 
				{
					wallOption = null;
				}
			}
			var meshName = wallType + "Wall";
      		if (!this.objectsMap[meshName]) 
			{
        		var profileAux = this.getWallProfile2d(wallType, wallOption, undefined);

        		var mesh = Modeler.getExtrudedMesh(profileAux, extrusionDist, extrudeSegmentsCount, extrusionVector, bIncludeBottomCap, bIncludeTopCap, undefined);
        		mesh.name = meshName;
        		this.objectsArray.push(mesh);
        		this.objectsMap[meshName] = mesh;

        		this.validateWallGeom(wallType, mesh);
      		}
		}
	}

	// Roof.*******************************************************************************************************************************
	var halfWidth = this.width * 0.5;
	var roofMinHeigh = this.roofMinHeight;
	var polylineAux = new PolyLine2D();
	polylineAux.newPoint2d(halfWidth, roofMinHeigh);                 // 0
	polylineAux.newPoint2d(0, this.height);                          // 1
	polylineAux.newPoint2d(-halfWidth, roofMinHeigh);                // 2
	var leftExpandDist = 0;
	var rightExpandDist = 0.2;
	var polyline = new PolyLine2D();
	polyline.point2dArray = Point2DList.getExpandedPoints(polylineAux.point2dArray, polyline.point2dArray, leftExpandDist, rightExpandDist);
	
	// Make roof profile.***
	profileAux = new Profile2D();
	var outerRing = profileAux.newOuterRing();
	outerRing.addElement(polyline);
	extrusionDist = this.length;
	var mesh = Modeler.getExtrudedMesh(profileAux, extrusionDist, extrudeSegmentsCount, extrusionVector, bIncludeBottomCap, bIncludeTopCap, undefined);
	mesh.name = "roof";
	mesh.owner = this;
	this.objectsArray.push(mesh);
	this.objectsMap[mesh.name] = mesh;
	
	// Now rotate the roof.***
	mesh.rotate(90, 1, 0, 0);
	
	// Now translate the roof to front.***
	mesh.translate(0, this.length*0.5, 0);
	mesh.setOneColor(98/256, 233/256, 134/256, 0.3);
	
	// Check if there are roof's material.
	var roofMaterial;
	var roofOptions = this.options.roofOptions;
	if (roofOptions !== undefined)
	{
		roofMaterial = roofOptions.material;
		if (roofMaterial !== undefined)
		{
			// check if there are texture. If exist texture then calculate texCoord for the roofMesh.
			if (roofMaterial.diffuseTexture !== undefined)
			{
				// Calculate texCoords for the roofMesh.
				// the difusse texture represents aprox 20x60 meters in the roofTexture.jpg image.
				var texCoordsBBox = new BoundingBox();
				var length = 60;
				var width = this.width;
				var height = 20;
				texCoordsBBox.set(-width, -length, -height, width, length, height);
				mesh.calculateTexCoordsBox(texCoordsBBox);
				mesh.material = roofMaterial;
			}
			
		}
	}
	
	this.dirty = false;
};

/**
 * Renders the factory.
 */
BasicFactory.prototype.getObjectByName = function(objectName)
{
	return this.objectsMap[objectName];
};

/**
 * delete mesh from this factory.
 * @param {string} name Mesh name
 */
BasicFactory.prototype.removeMesh = function(name) 
{
	if (this.objectsMap && this.objectsMap[name]) { this.objectsMap[name] = undefined; }

	if (this.objectsArray && Array.isArray(this.objectsArray)) 
	{
		this.objectsArray = this.objectsArray.filter(function(item) 
		{
			return item.name !== name;
		});
	}
};
/**
 * @param {string} wallType
 * @param {Object} geom must have rotate function and translate function
 */
BasicFactory.prototype.validateWallGeom = function(wallType, geom, extrusionDist) 
{
	if (typeof geom.rotate !== 'function' || typeof geom.translate !== 'function') 
	{
		throw new Error('invalid geometry type.');
	}

	if (!defined(extrusionDist)) { extrusionDist = 0.4; }

	switch (wallType) 
	{
	case 'front' : {
		// Now rotate the front wall
		geom.rotate(90, 1, 0, 0);

		// Now translate the front wall to front
		geom.translate(-this.width*0.5, -this.length*0.5+extrusionDist, 0);
		break;
	}
	case 'rear' : {
		// Now rotate the rear wall
		geom.rotate(90, 1, 0, 0);

		// Now translate the rear wall to rear
		geom.translate(-this.width*0.5, this.length*0.5, 0);
		break;
	}
	case 'left' : {
		// Now rotate the left wall
		geom.rotate(90, 1, 0, 0);
		geom.rotate(90, 0, 0, 1);

		// Now translate the left wall to left
		geom.translate(-this.width*0.5, -this.length*0.5, 0);
		break;
	}
	case 'right' : {
		// Now rotate the right wall.***
		geom.rotate(90, 1, 0, 0);
		geom.rotate(90, 0, 0, 1);

		// Now translate the right wall to right
		geom.translate(this.width*0.5 - extrusionDist, -this.length*0.5, 0);
		break;
	}
	}

	if (geom instanceof Mesh) 
	{
		geom.setOneColor(0.9, 0.9, 0.9, 1.0);
	}
};
'use strict';

/**
 * @param {*} option 
 * @class BasicVehicle
 */
var BasicVehicle = function()
{
};

BasicVehicle.degreeValidator = function(deg)
{
	//if (deg > 360) { deg -= 360; }
	//if (deg < -360) { deg += 360; }

	return deg;
};

BasicVehicle.MODE = {
	'NORMAL'             : 0,
	'PARALLEL_TRANSLATE' : 1,
	'PARALLEL_ROTATION'  : 2,
	'CIRCULAR_ROTATION'  : 3
};
BasicVehicle.ACCEL_STATUS = {
	'FORWARD' : 0,
	'REVERSE' : 1,
	'NONE'    : 2
};
'use strict';

/**
 * Box geometry.
 * @class Box
 */
var Box = function(width, length, height, name) 
{
	MagoRenderable.call(this);
	if (!(this instanceof Box)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	// See MagoRenderable's members.
	// Initially, box centered at the center of the bottom.***
	this.mesh;
	this.centerPoint; // Usually (0,0,0).***
	this.width;
	this.length;
	this.height;
	this.owner;
	
	if (name !== undefined)
	{ this.name = name; }
	
	if (width !== undefined)
	{ this.width = width; }
	
	if (length !== undefined)
	{ this.length = length; }
	
	if (height !== undefined)
	{ this.height = height; }

};
Box.prototype = Object.create(MagoRenderable.prototype);
Box.prototype.constructor = Box;

/**
 * Returns the mesh.
 */
Box.prototype.getMesh = function()
{
	if (this.mesh === undefined)
	{
		this.mesh = this.makeMesh(this.width, this.length, this.height);
	}
	
	return this.mesh;
};

Box.prototype.moved = function()
{
	// do something.
};

/**
 * Makes the box mesh.
 * @param {Number} width
 * @param {Number} length
 * @param {Number} height 
 */
Box.prototype.makeMesh = function()
{
	var profileAux = new Profile2D();
	
	// Create a outer ring in the Profile2d.
	var outerRing = profileAux.newOuterRing();

	var halfWidth = this.width * 0.5;
	var halLength = this.length * 0.5;
	var polyline = outerRing.newElement("POLYLINE");

	polyline.newPoint2d(-halfWidth, -halLength);
	polyline.newPoint2d(halfWidth, -halLength);
	polyline.newPoint2d(halfWidth, halLength);
	polyline.newPoint2d(-halfWidth, halLength);

	//var rect = outerRing.newElement("RECTANGLE");
	//rect.setCenterPosition(this.centerPoint.x, this.centerPoint.y);
	//rect.setDimensions(this.width, this.length);
	
	// Extrude the Profile.
	var extrudeSegmentsCount = 1;
	var extrusionVector = undefined;
	var extrusionDist = this.height;
	var bIncludeBottomCap = true;
	var bIncludeTopCap = true;

	var mesh = Modeler.getExtrudedMesh(profileAux, extrusionDist, extrudeSegmentsCount, extrusionVector, bIncludeBottomCap, bIncludeTopCap, undefined);
	this.objectsArray.push(mesh);
	this.dirty = false;
};
'use strict';

/**
 * ClippingBox geometry.
 * @class ClippingBox
 */
var ClippingBox = function(width, length, height, name) 
{
	MagoRenderable.call(this);
	if (!(this instanceof ClippingBox)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	// Initially, box centered at the center of the bottom.***
	this.centerPoint; // Usually (0,0,0).***
	this.width;
	this.length;
	this.height;

	if (name !== undefined)
	{ this.name = name; }
	
	if (width !== undefined)
	{ this.width = width; }
	
	if (length !== undefined)
	{ this.length = length; }
	
	if (height !== undefined)
	{ this.height = height; }

	this.planesVec4Array;

};

ClippingBox.prototype = Object.create(MagoRenderable.prototype);
ClippingBox.prototype.constructor = ClippingBox;

ClippingBox.prototype.getPlanesRelToEyevec4Array = function(magoManager)
{
	//if (this.planesVec4Array === undefined)
	//{ 
	this.planesVec4Array = []; 
	var planesArray = this.getPlanesRelToEye(undefined, magoManager);
	var planesCount = planesArray.length;
	for (var i=0; i<planesCount; i++)
	{
		var plane = planesArray[i];
		this.planesVec4Array.push(plane.a);
		this.planesVec4Array.push(plane.b);
		this.planesVec4Array.push(plane.c);
		this.planesVec4Array.push(plane.d);
	}
	//}

	return this.planesVec4Array;
};

ClippingBox.prototype.moved = function()
{
	this.planesVec4Array = undefined;
};

ClippingBox.prototype.getPlanesRelToEye = function(resultPlanesArray, magoManager)
{
	// 1rst, calculate planes on the initial state.
	// Initially, box centered at the center of the bottom.***
	if (resultPlanesArray === undefined)
	{ resultPlanesArray = []; }

	var sceneState = magoManager.sceneState;
	var mvMat = sceneState.modelViewMatrix;
	var mvMatRelToEye = sceneState.modelViewRelToEyeMatrix;
	var camera = sceneState.camera;
	var camPos = camera.position;
	var mvMat_inv = sceneState.modelViewMatrixInv;
	
	var geoLocDataManager = this.getGeoLocDataManager();
	var geoLocData = geoLocDataManager.getCurrentGeoLocationData();
	var rotMat = geoLocData.rotMatrix;
	
	var point = new Point3D();
	var dir = new Point3D();
	var pointWC = new Point3D();
	var dirWC = new Point3D();
	var pointCamCoord = new Point3D();
	var dirCamCoord = new Point3D();
	
	// top plane.
	point.set(0.0, 0.0, this.height);
	dir.set(0.0, 0.0, 1.0);
	pointWC = geoLocData.localCoordToWorldCoord(point, pointWC);
	dirWC = rotMat.transformPoint3D(dir, dirWC);
	pointCamCoord = mvMat.transformPoint3D(pointWC, pointCamCoord);
	dirCamCoord = mvMatRelToEye.transformPoint3D(dirWC, dirCamCoord);
	var plane = new Plane();
	plane.setPointAndNormal(pointCamCoord.x, pointCamCoord.y, pointCamCoord.z, dirCamCoord.x, dirCamCoord.y, dirCamCoord.z);
	resultPlanesArray.push(plane);
	
	// bottom plane.
	point.set(0.0, 0.0, 0.0);
	dir.set(0.0, 0.0, -1.0);
	pointWC = geoLocData.localCoordToWorldCoord(point, pointWC);
	dirWC = rotMat.transformPoint3D(dir, dirWC);
	pointCamCoord = mvMat.transformPoint3D(pointWC, pointCamCoord);
	dirCamCoord = mvMatRelToEye.transformPoint3D(dirWC, dirCamCoord);
	var plane = new Plane();
	plane.setPointAndNormal(pointCamCoord.x, pointCamCoord.y, pointCamCoord.z, dirCamCoord.x, dirCamCoord.y, dirCamCoord.z);
	resultPlanesArray.push(plane);
	
	// front plane.
	point.set(0.0, -this.length/2, this.height/2);
	dir.set(0.0, -1.0, 0.0);
	pointWC = geoLocData.localCoordToWorldCoord(point, pointWC);
	dirWC = rotMat.transformPoint3D(dir, dirWC);
	pointCamCoord = mvMat.transformPoint3D(pointWC, pointCamCoord);
	dirCamCoord = mvMatRelToEye.transformPoint3D(dirWC, dirCamCoord);
	var plane = new Plane();
	plane.setPointAndNormal(pointCamCoord.x, pointCamCoord.y, pointCamCoord.z, dirCamCoord.x, dirCamCoord.y, dirCamCoord.z);
	resultPlanesArray.push(plane);
	
	// rear plane.
	point.set(0.0, this.length/2, this.height/2);
	dir.set(0.0, 1.0, 0.0);
	pointWC = geoLocData.localCoordToWorldCoord(point, pointWC);
	dirWC = rotMat.transformPoint3D(dir, dirWC);
	pointCamCoord = mvMat.transformPoint3D(pointWC, pointCamCoord);
	dirCamCoord = mvMatRelToEye.transformPoint3D(dirWC, dirCamCoord);
	var plane = new Plane();
	plane.setPointAndNormal(pointCamCoord.x, pointCamCoord.y, pointCamCoord.z, dirCamCoord.x, dirCamCoord.y, dirCamCoord.z);
	resultPlanesArray.push(plane);
	
	// left plane.
	point.set(-this.width/2, 0.0, this.height/2);
	dir.set(-1.0, 0.0, 0.0);
	pointWC = geoLocData.localCoordToWorldCoord(point, pointWC);
	dirWC = rotMat.transformPoint3D(dir, dirWC);
	pointCamCoord = mvMat.transformPoint3D(pointWC, pointCamCoord);
	dirCamCoord = mvMatRelToEye.transformPoint3D(dirWC, dirCamCoord);
	var plane = new Plane();
	plane.setPointAndNormal(pointCamCoord.x, pointCamCoord.y, pointCamCoord.z, dirCamCoord.x, dirCamCoord.y, dirCamCoord.z);
	resultPlanesArray.push(plane);
	
	// right plane.
	point.set(this.width/2, 0.0, this.height/2);
	dir.set(1.0, 0.0, 0.0);
	pointWC = geoLocData.localCoordToWorldCoord(point, pointWC);
	dirWC = rotMat.transformPoint3D(dir, dirWC);
	pointCamCoord = mvMat.transformPoint3D(pointWC, pointCamCoord);
	dirCamCoord = mvMatRelToEye.transformPoint3D(dirWC, dirCamCoord);
	var plane = new Plane();
	plane.setPointAndNormal(pointCamCoord.x, pointCamCoord.y, pointCamCoord.z, dirCamCoord.x, dirCamCoord.y, dirCamCoord.z);
	resultPlanesArray.push(plane);
	
	return resultPlanesArray;
};

ClippingBox.prototype.getPlanes = function(resultPlanesArray, magoManager)
{
	// 1rst, calculate planes on the initial state.
	// Initially, box centered at the center of the bottom.***
	if (resultPlanesArray === undefined)
	{ resultPlanesArray = []; }

	var sceneState = magoManager.sceneState;
	var mvMat = sceneState.modelViewMatrix;
	var mvMatRelToEye = sceneState.modelViewRelToEyeMatrix;
	var camera = sceneState.camera;
	var camPos = camera.position;
	var mvMat_inv = sceneState.modelViewMatrixInv;
	
	var geoLocDataManager = this.getGeoLocDataManager();
	var geoLocData = geoLocDataManager.getCurrentGeoLocationData();
	var rotMat = geoLocData.rotMatrix;
	
	var point = new Point3D();
	var dir = new Point3D();
	var pointWC = new Point3D();
	var dirWC = new Point3D();
	var pointCamCoord = new Point3D();
	var dirCamCoord = new Point3D();
	
	// top plane.
	point.set(0.0, 0.0, this.height);
	dir.set(0.0, 0.0, 1.0);
	pointWC = rotMat.transformPoint3D(point, pointWC);
	dirWC = rotMat.transformPoint3D(dir, dirWC);
	var plane = new Plane();
	plane.setPointAndNormal(pointWC.x, pointWC.y, pointWC.z, dirWC.x, dirWC.y, dirWC.z);
	resultPlanesArray.push(plane);
	
	// bottom plane.
	point.set(0.0, 0.0, 0.0);
	dir.set(0.0, 0.0, -1.0);
	pointWC = rotMat.transformPoint3D(point, pointWC);
	dirWC = rotMat.transformPoint3D(dir, dirWC);
	var plane = new Plane();
	plane.setPointAndNormal(pointWC.x, pointWC.y, pointWC.z, dirWC.x, dirWC.y, dirWC.z);
	resultPlanesArray.push(plane);
	
	// front plane.
	point.set(0.0, -this.length/2, this.height/2);
	dir.set(0.0, -1.0, 0.0);
	pointWC = rotMat.transformPoint3D(point, pointWC);
	dirWC = rotMat.transformPoint3D(dir, dirWC);
	var plane = new Plane();
	plane.setPointAndNormal(pointWC.x, pointWC.y, pointWC.z, dirWC.x, dirWC.y, dirWC.z);
	resultPlanesArray.push(plane);
	
	// rear plane.
	point.set(0.0, this.length/2, this.height/2);
	dir.set(0.0, 1.0, 0.0);
	pointWC = rotMat.transformPoint3D(point, pointWC);
	dirWC = rotMat.transformPoint3D(dir, dirWC);
	var plane = new Plane();
	plane.setPointAndNormal(pointWC.x, pointWC.y, pointWC.z, dirWC.x, dirWC.y, dirWC.z);
	resultPlanesArray.push(plane);
	
	// left plane.
	point.set(-this.width/2, 0.0, this.height/2);
	dir.set(-1.0, 0.0, 0.0);
	pointWC = rotMat.transformPoint3D(point, pointWC);
	dirWC = rotMat.transformPoint3D(dir, dirWC);
	var plane = new Plane();
	plane.setPointAndNormal(pointWC.x, pointWC.y, pointWC.z, dirWC.x, dirWC.y, dirWC.z);
	resultPlanesArray.push(plane);
	
	// right plane.
	point.set(this.width/2, 0.0, this.height/2);
	dir.set(1.0, 0.0, 0.0);
	pointWC = rotMat.transformPoint3D(point, pointWC);
	dirWC = rotMat.transformPoint3D(dir, dirWC);
	var plane = new Plane();
	plane.setPointAndNormal(pointWC.x, pointWC.y, pointWC.z, dirWC.x, dirWC.y, dirWC.z);
	resultPlanesArray.push(plane);
	
	return resultPlanesArray;
};

/**
 * Makes the box mesh.
 * @param {Number} width
 * @param {Number} length
 * @param {Number} height 
 */
ClippingBox.prototype.makeMesh = function()
{
	var profileAux = new Profile2D();
	
	// Create a outer ring in the Profile2d.
	var outerRing = profileAux.newOuterRing();

	var halfWidth = this.width * 0.5;
	var halLength = this.length * 0.5;
	var polyline = outerRing.newElement("POLYLINE");

	polyline.newPoint2d(-halfWidth, -halLength);
	polyline.newPoint2d(halfWidth, -halLength);
	polyline.newPoint2d(halfWidth, halLength);
	polyline.newPoint2d(-halfWidth, halLength);

	//var rect = outerRing.newElement("RECTANGLE");
	//rect.setCenterPosition(this.centerPoint.x, this.centerPoint.y);
	//rect.setDimensions(this.width, this.length);
	
	// Extrude the Profile.
	var extrudeSegmentsCount = 1;
	var extrusionVector = undefined;
	var extrusionDist = this.height;
	var bIncludeBottomCap = true;
	var bIncludeTopCap = true;

	var mesh = Modeler.getExtrudedMesh(profileAux, extrusionDist, extrudeSegmentsCount, extrusionVector, bIncludeBottomCap, bIncludeTopCap, undefined);
	
	// set attributes & options.
	this.setOneColor(0.2, 0.7, 0.8, 0.3);
	this.attributes.isMovable = true;
	this.attributes.isSelectable = true;
	this.attributes.name = "clippingBox";
	this.attributes.selectedColor4 = new Color(1.0, 0.0, 0.0, 0.0); // selectedColor fully transparent.
	if (this.options === undefined)
	{ this.options = {}; }
	
	this.options.renderWireframe = true;
	this.options.renderShaded = true;
	this.options.depthMask = true;
	
	this.objectsArray.push(mesh);
	this.dirty = false;
	return mesh;
};
'use strict';
/**
 * 같은 중심을 가진 튜브들의 모임. 우측과 같이 생긴 모양을 뜻함.-> ◎ 
 * @class ConcetricTubes
 * 
 * @param {Object} option 
 * @param {GeoLocationDataManager} geoLocDataManager Optional
 */
var ConcentricTubes = function(option, geoLocDataManager)
{
	MagoRenderable.call(this);
	/**
	 * @type {number}
	 * @default 0
	 */
	this.height = defaultValue(option.height, 0);

	/**
	 * The geographic location of the factory.
	 * @type {GeoLocationDataManager}
	 * @default undefined
	 */
	this.geoLocDataManager;

	if (defined(geoLocDataManager)) 
	{
		this.geoLocDataManager = geoLocDataManager;
	}
    
	
	this.bbox;
	this.options = option;
};

ConcentricTubes.prototype = Object.create(MagoRenderable.prototype);
ConcentricTubes.prototype.constructor = ConcentricTubes;
/**
 * 초기 튜브 정보를 가지고 튜브들을 초기화 함.
 */
ConcentricTubes.prototype.clear = function() 
{
	this.objectsArray = [];
};

/**
 * 튜브정보를 이용하여 튜브 생성 후 튜브어레이에 넣음
 * @param {Object} option
 */
ConcentricTubes.prototype.makeMesh = function() 
{
	var tubeInfos = this.options.tubeInfos;
	if (defined(tubeInfos))
	{	
		this.clear();
		for (var i=0, len=tubeInfos.length;i<len;i++) 
		{
			this.makeTube(tubeInfos[i]);
		}
		
		this.setDirty(false);
	}
};

/**
 * 튜브정보를 이용하여 튜브 생성 후 튜브어레이에 넣음
 * @param {Object} option
 */
ConcentricTubes.prototype.makeTube = function(option) 
{
	var interiorRadius = option.interiorRadius;
	var exteriorRadius = option.exteriorRadius;
	var height = this.getHeight(); 
	var options = option;

	var tube = new Tube(interiorRadius, exteriorRadius, height, options);
	tube.owner = this;
	this.objectsArray.push(tube);
};

/**
 * Returns the bbox.
 */
ConcentricTubes.prototype.getBoundingBox = function()
{
	if (this.bbox === undefined)
	{
		this.bbox = new BoundingBox();
		for (var i=0, len=this.getSize(); i<len; i++) 
		{
			var tube = this.getTube(i);

			var tubeBbox = tube.getBoundingBox();
			if (i === 0)
			{ this.bbox.copyFrom(tubeBbox); }
			else
			{ this.bbox.addBox(tubeBbox); }
		}
	}
	return this.bbox;
};

/**
 * 높이 설정
 * @param {number} height
 */
ConcentricTubes.prototype.setHeight = function(height) 
{
	this.height = height;
};

/**
 * 높이 반환
 * @return {number}
 */
ConcentricTubes.prototype.getHeight = function(height) 
{
	return this.height;
};

/**
 * 튜브 추가
 * @param {Tube} tube
 */
ConcentricTubes.prototype.addTube = function(tube) 
{
	this.objectsArray.push(tube);
};
/**
 * 튜브 목록 반환
 * @return {Array.<Tube>}
 */
ConcentricTubes.prototype.getTubes = function() 
{
	return this.objectsArray;
};
/**
 * 인덱스에 해당하는 튜브 반환
 * @param {number} index array index
 * @return {Tube}
 */
ConcentricTubes.prototype.getTube = function(index) 
{
	return this.objectsArray[index];
};

/**
 * 튜브 갯수 반환
 * @return {number}
 */
ConcentricTubes.prototype.getSize = function() 
{
	return this.objectsArray.length;
};














'use strict';

/**
 * Cylinder.
 * @class Cylinder
 */
var Cylinder = function(radius, height, options) 
{
	MagoRenderable.call(this);
	if (!(this instanceof Cylinder)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.radius = 10;
	this.height = 5;
	
	if (radius !== undefined)
	{ this.radius = radius; }
	
	if (height !== undefined)
	{ this.height = height; }
	
	this.dirty = true;
	this.mesh;
	this.bbox;
	
	/**
	 * The geographic location of the factory.
	 * @type {GeoLocationDataManager}
	 * @default undefined
	 */
	this.geoLocDataManager;
	this.color4;
	
	if (options !== undefined)
	{
		var color = options.color;
		if (color)
		{
			this.color4 = new Color();
			this.color4.setRGBA(color.r, color.g, color.b, color.a);
		}
		var selectedColor = options.selectedColor;
		if (selectedColor)
		{
			this.selectedColor4 = new Color();
			this.selectedColor4.setRGBA(selectedColor.r, selectedColor.g, selectedColor.b, selectedColor.a);
		}
	}
};
Cylinder.prototype = Object.create(MagoRenderable.prototype);
Cylinder.prototype.constructor = Cylinder;

/**
 * Makes the geometry mesh.
 */
Cylinder.prototype.makeMesh = function()
{
	var profileAux = new Profile2D();
	var circle;
	
	// Create a outer ring in the Profile2d.
	var outerRing = profileAux.newOuterRing();
	circle = outerRing.newElement("CIRCLE");
	circle.setCenterPosition(0, 0);
	circle.setRadius(this.radius);
	
	var extrusionDist = this.height;
	var extrudeSegmentsCount = 1;
	var extrusionVector; // undefined.
	var bIncludeBottomCap = true;
	var bIncludeTopCap = true;
	
	var mesh = Modeler.getExtrudedMesh(profileAux, extrusionDist, extrudeSegmentsCount, extrusionVector, bIncludeBottomCap, bIncludeTopCap, undefined);
	this.objectsArray.push(mesh);
	this.dirty = false;
};
































'use strict';

/**
 * This class represents ellipsoid geometry.
 * @class Ellipsoid
 */
var Ellipsoid = function(radiusX, radiusY, radiusZ) 
{
	if (!(this instanceof Ellipsoid)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	// Ellipsoid: x^2/a^2 + y^2/b^2 + z^2/c^2 = 1, (a, b, c) = (radiusX, radiusY, radiusZ).
	// Parametrization:
	// polarAng = 90 - latitude, azimuthAng = longitude.
	// x = a*sin(polarAng)*cos(azimuthAng)
	// y = b*sin(polarAng)*sin(azimuthAng)
	// z = c*cos(polarAng)
	
	this.radiusX;
	this.radiusY;
	this.radiusZ;
	
	this.centerPosition;
	
	this.strLonRad;
	this.endLonRad;
	this.strLatRad;
	this.endLatRad;
	
	this.lonSegments = 120;
	this.latSegments = 60;
	
	// positions(x, y, z), normals, texCoords, colors & indices array.
	this.cartesiansArray;
	this.normalsArray;
	this.texCoordsArray;
	this.colorsArray;
	this.indices;
	
	this.mesh;
	
	if (radiusX !== undefined)
	{ this.radiusX = radiusX; }
	
	if (radiusY !== undefined)
	{ this.radiusY = radiusY; }
	
	if (radiusZ !== undefined)
	{ this.radiusZ = radiusZ; }

	if (this.strLonRad === undefined)
	{ this.strLonRad = 0.0; }
	if (this.endLonRad === undefined)
	{ this.endLonRad = Math.PI*2; }
	if (this.strLatRad === undefined)
	{ this.strLatRad = -Math.PI/2; }
	if (this.endLatRad === undefined)
	{ this.endLatRad = Math.PI/2; }	

	//this.strLonRad = 0.0;
	//this.endLonRad = Math.PI/8;
	//this.strLatRad = 0.0;
	//this.endLatRad = Math.PI/8;

};

/**
 * Render this feature
 * @param {MagoManager} magoManager
 * @param {Shader} shader
 * @param {Number} renderType
 */
Ellipsoid.prototype.render = function(magoManager, shader, renderType, glPrimitive)
{
	var gl = magoManager.getGl();
		
	
	if (renderType === 2)
	{
		var colorAux;
		colorAux = magoManager.selectionColor.getAvailableColor(colorAux);
		var idxKey = magoManager.selectionColor.decodeColor3(colorAux.r, colorAux.g, colorAux.b);
		magoManager.selectionManager.setCandidateGeneral(idxKey, this);
		
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
		gl.uniform4fv(shader.oneColor4_loc, [colorAux.r/255.0, colorAux.g/255.0, colorAux.b/255.0, 1.0]);
	}
	
	// render this tinTerrain.
	var renderWireframe = false;
	
	var vboKey = this.vboKeyContainer.vboCacheKeysArray[0];
	
	// Positions.
	if (!vboKey.bindDataPosition(shader, magoManager.vboMemoryManager))
	{ return false; }

	// Normals.***
	if (vboKey.vboBufferNor !== undefined)
	{
		// Has normal data.***
		if (!vboKey.bindDataNormal(shader, magoManager.vboMemoryManager))
		{ return false; }
	}

	// TexCoords (No necessary for depth rendering).
	/*
	if (!bDepth)
	{
		if (!vboKey.bindDataTexCoord(shader, magoManager.vboMemoryManager))
		{ return false; }
	}
	*/
	
	// Colors.
	// todo:
	
	// Indices.
	if (!vboKey.bindDataIndice(shader, magoManager.vboMemoryManager))
	{ return false; }
	
	var indicesCount = vboKey.indicesCount;
	
	if (renderWireframe)
	{
		var trianglesCount = indicesCount;
		for (var i=0; i<trianglesCount; i++)
		{
			gl.drawElements(gl.LINE_LOOP, 3, gl.UNSIGNED_SHORT, i*3); // Fill.
		}
	}
	else
	{
		gl.drawElements(gl.TRIANGLES, indicesCount, gl.UNSIGNED_SHORT, 0); // Fill.
	}
};

/**
 * Makes the vbo mesh.
 */
Ellipsoid.prototype.makeVbo = function(vboMemManager)
{
	if (this.cartesiansArray === undefined)
	{ return; }
	
	if (this.vboKeyContainer === undefined)
	{ this.vboKeyContainer = new VBOVertexIdxCacheKeysContainer(); }
	
	var vboKey = this.vboKeyContainer.newVBOVertexIdxCacheKey();
	
	// Positions.
	vboKey.setDataArrayPos(this.cartesiansArray, vboMemManager);
	
	// Normals.
	if (this.normalsArray)
	{
		vboKey.setDataArrayNor(this.normalsArray, vboMemManager);
	}
	
	// TexCoords.
	if (this.texCoordsArray)
	{
		vboKey.setDataArrayTexCoord(this.texCoordsArray, vboMemManager);
	}
		
	// Indices.
	vboKey.setDataArrayIdx(this.indices, vboMemManager);
		
	/*
	// Todo:
	if (normal)
	{ vboKey.norVboDataArray = Int8Array.from(norArray); }
	
	if (color)
	{ vboKey.colVboDataArray = Uint8Array.from(colArray); }
	this.cartesiansArray;
	this.texCoordsArray;
	this.colorsArray;
	this.indices;
	*/
};

/**
 * Makes the ellipsoid mesh.
 */
Ellipsoid.prototype.makeMesh = function(options)
{
	var bTrianglesSenseCCW = true;
	if (options !== undefined)
	{
		if (options.bTrianglesSenseCCW !== undefined)
		{ bTrianglesSenseCCW = options.bTrianglesSenseCCW; }
	}
	
	if (this.strLonRad > this.endLonRad)
	{
		this.strLonRad -= 2*Math.PI;
	}
	var increLon = (this.endLonRad - this.strLonRad)/this.lonSegments;
	var increLat = (this.endLatRad - this.strLatRad)/this.latSegments;
	var currLonRad = this.strLonRad;
	var currLatRad = this.strLatRad;
	var radiusX = this.radiusX;
	var radiusY = this.radiusY;
	var radiusZ = this.radiusZ;
	var radiusX2 = radiusX*radiusX;
	var radiusY2 = radiusY*radiusY;
	var radiusZ2 = radiusZ*radiusZ;
	
	var totalPointsCount = (this.lonSegments+1)*(this.latSegments+1);
	this.cartesiansArray = new Float32Array(totalPointsCount*3); // Init.***
	this.normalsArray = new Int8Array(totalPointsCount*3); // Init.***
	var idx = 0;
	
	var bbox = new BoundingBox();
	
	for (var j=0; j<this.latSegments+1; j++)
	{
		currLatRad = this.strLatRad + j*increLat;
		var sinLat = Math.sin(currLatRad);
		var cosLat = Math.cos(currLatRad);
		for (var i = 0; i<this.lonSegments+1; i++)
		{
			currLonRad = this.strLonRad + i*increLon;
			var sinLon = Math.sin(currLonRad);
			var cosLon = Math.cos(currLonRad);
	
			// Position.***
			var x = radiusX * cosLat * cosLon;
			var y = radiusY * cosLat * sinLon;
			var z = radiusZ * sinLat;
			
			this.cartesiansArray[idx*3] = x;
			this.cartesiansArray[idx*3+1] = y;
			this.cartesiansArray[idx*3+2] = z;
			
			// Normal.***
			var point = new Point3D(x, y, z);

			// Calculate bbox before of normalizing the point.***
			if (idx === 0)
			{
				bbox.init(point);
			}
			else 
			{
				bbox.addPoint(point);
			}
			
			point.set(x/radiusX2, y/radiusY2, z/radiusZ2);
			point.unitary();
			
			if (bTrianglesSenseCCW)
			{
				this.normalsArray[idx*3] = point.x*127;
				this.normalsArray[idx*3+1] = point.y*127;
				this.normalsArray[idx*3+2] = point.z*127;
			}
			else 
			{
				this.normalsArray[idx*3] = -point.x*127;
				this.normalsArray[idx*3+1] = -point.y*127;
				this.normalsArray[idx*3+2] = -point.z*127;
			}
			
			
			idx += 1;
		}
	}
	
	// Calculate the centerPosition of the ellipsoid.***
	this.centerPosition = bbox.getCenterPoint();
	
	for (var i=0; i<totalPointsCount; i++)
	{
		this.cartesiansArray[i*3] -= this.centerPosition.x;
		this.cartesiansArray[i*3+1] -= this.centerPosition.y;
		this.cartesiansArray[i*3+2] -= this.centerPosition.z;
	}
	
	if (this.terrainPositionHIGH === undefined)
	{ this.terrainPositionHIGH = new Float32Array(3); }

	if (this.terrainPositionLOW === undefined)
	{ this.terrainPositionLOW = new Float32Array(3); }
	ManagerUtils.calculateSplited3fv([this.centerPosition.x, this.centerPosition.y, this.centerPosition.z], this.terrainPositionHIGH, this.terrainPositionLOW);
	
	/*
	for (var i = 0; i<this.lonSegments+1; i++)
	{
		currLonRad = this.strLonRad + i*increLon;
		var sinLon = Math.sin(currLonRad);
		var cosLon = Math.cos(currLonRad);
		for (var j=0; j<this.latSegments+1; j++)
		{
			// Position.***
			currLatRad = this.strLatRad + j*increLat;
			var sinLat = Math.sin(currLatRad);
			var x = radiusX * sinLat * cosLon;
			var y = radiusY * sinLat * sinLon;
			var z = radiusZ*Math.cos(currLatRad);
			
			this.cartesiansArray[idx*3] = x;
			this.cartesiansArray[idx*3+1] = y;
			this.cartesiansArray[idx*3+2] = z;
			
			// Normal.***
			var normal = new Point3D(x, y, z);
			normal.unitary();
			
			this.normalsArray[idx*3] = normal.x*255;
			this.normalsArray[idx*3+1] = normal.y*255;
			this.normalsArray[idx*3+2] = normal.z*255;
			
			idx += 1;
		}
	}
	*/
	
	// Finally make indices array.***
	var numCols = this.lonSegments + 1;
	var numRows = this.latSegments + 1;

	var resultObject = GeometryUtils.getIndicesTrianglesRegularNet(numCols, numRows, undefined, undefined, undefined, undefined, undefined, options);
	this.indices = resultObject.indicesArray;
};




































'use strict';

/**
 * GolfHoleFlag.
 * @class GolfHoleFlag
 */
var GolfHoleFlag = function(radius, height, options) 
{
	MagoRenderable.call(this);
	if (!(this instanceof GolfHoleFlag)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.radius = 1.0;
	this.height = 5;
	
	if (radius !== undefined)
	{ this.radius = radius; }
	
	if (height !== undefined)
	{ this.height = height; }

	this.baseRadius = 4.0*this.radius;
	this.flagOrientation;
	
	this.dirty = true;
	this.mesh;
	this.bbox;
	
	/**
	 * The geographic location of the factory.
	 * @type {GeoLocationDataManager}
	 * @default undefined
	 */
	this.geoLocDataManager;
	this.color4;
	
	if (options !== undefined)
	{
		var color = options.color;
		if (color)
		{
			this.color4 = new Color();
			this.color4.setRGBA(color.r, color.g, color.b, color.a);
		}
		var selectedColor = options.selectedColor;
		if (selectedColor)
		{
			this.selectedColor4 = new Color();
			this.selectedColor4.setRGBA(selectedColor.r, selectedColor.g, selectedColor.b, selectedColor.a);
		}
	}
	
};
GolfHoleFlag.prototype = Object.create(MagoRenderable.prototype);
GolfHoleFlag.prototype.constructor = GolfHoleFlag;

/**
 * Makes the geometry mesh.
 */
GolfHoleFlag.prototype.makeMesh = function()
{
	if (this.objectsArray === undefined)
	{ this.objectsArray = []; }

	// Create the base of the flag.**************************************************
	var baseHeight = this.height * 0.01;
	var options = {
		color: new Color(1.0, 1.0, 0.0, 1.0)
	};
	var base = new Cylinder(this.baseRadius, baseHeight, options);
	this.objectsArray.push(base);
	
	// Create the flag flagpole.**************************************************
	var options = {
		color: new Color(0.9, 0.9, 0.95, 1.0)
	};
	var flagpole = new Cylinder(this.radius, this.height, options);
	this.objectsArray.push(flagpole);
	
	// Create the triangle flag.**************************************************
	var profile2dAux = new Profile2D();
	
	// Outer ring.**
	var outerRing = profile2dAux.newOuterRing();
 
	var flagHeight = 2;
	var flagWidth = 10.0;

	var polyline = outerRing.newElement("POLYLINE");
	
	polyline.newPoint2d(-flagHeight/2, 0);    
	polyline.newPoint2d(flagHeight/2, 0);    
	polyline.newPoint2d(0, flagWidth);

	var extrudeSegmentsCount = 1;
	var extrusionVector = undefined;
	var bIncludeBottomCap = false;
	var bIncludeTopCap = false;
	var extrudeDist = 0.1;
	var mesh = Modeler.getExtrudedMesh(profile2dAux, extrudeDist, extrudeSegmentsCount, extrusionVector, bIncludeBottomCap, bIncludeTopCap, mesh);
	mesh.setOneColor(1.0, 0.1, 0.1, 1.0);
	mesh.rotate(90.0, 0.0, 1.0, 0.0);
	mesh.rotate(45.0, 0.0, 0.0, 1.0);
	mesh.translate(0.0, 0.0, this.height - flagHeight/2);

	this.objectsArray.push(mesh);
	
	this.dirty = false;
};







































'use strict';

/**
 * ImageViewerRectangle.
 * @class ImageViewerRectangle
 */
var ImageViewerRectangle = function(width, height) 
{
	if (!(this instanceof ImageViewerRectangle)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.width = width;
	this.height = height;
	this.geoLocDataManager;
	this.vboKeysContainer;
};

/**
 * Render this box feature
 * @param {MagoManager} magoManager
 * @param {Shader} shader
 */
ImageViewerRectangle.prototype.makeMesh = function(magoManager)
{
	// There are only 4 vertices.***
	var semiWidth = this.width/2;
	var semiHeight = this.height/2;
	
	var vertex_ld = new Vertex();
	vertex_ld.point3d.set(-semiWidth, -semiHeight, 0);
	vertex_ld.normal = new Point3D(0, 0, 1);
	vertex_ld.texCoord = new Point2D(0, 0);
	
	var vertex_rd = new Vertex();
	vertex_rd.point3d.set(semiWidth, -semiHeight, 0);
	vertex_rd.normal = new Point3D(0, 0, 1);
	vertex_rd.texCoord = new Point2D(1, 0);
	
	var vertex_ru = new Vertex();
	vertex_ru.point3d.set(semiWidth, semiHeight, 0);
	vertex_ru.normal = new Point3D(0, 0, 1);
	vertex_ru.texCoord = new Point2D(1, 1);
	
	var vertex_lu = new Vertex();
	vertex_lu.point3d.set(-semiWidth, semiHeight, 0);
	vertex_lu.normal = new Point3D(0, 0, 1);
	vertex_lu.texCoord = new Point2D(0, 1);
	
	var verticesArray = [vertex_ld, vertex_rd, vertex_ru, vertex_lu];
	
	if (this.vboKeysContainer === undefined)
	{ this.vboKeysContainer = new VBOVertexIdxCacheKeysContainer(); }
	
	var vboMemManager = magoManager.vboMemoryManager;
	var vbo = this.vboKeysContainer.newVBOVertexIdxCacheKey();
	VertexList.setIdxInList(verticesArray);
	VertexList.getVboDataArrays(verticesArray, vbo, vboMemManager);
	
	// Finally make the indices.***
	var idxDataArray = new Uint16Array([0, 1, 3, 1, 2, 3]);
	vbo.setDataArrayIdx(idxDataArray, vboMemManager);
};

/**
 * Render this box feature
 * @param {MagoManager} magoManager
 * @param {Shader} shader
 */
ImageViewerRectangle.prototype.render = function(magoManager, shader, glPrimitive)
{
	if (this.vboKeysContainer === undefined)
	{
		this.makeMesh(magoManager);
	}
	
	var vboMemManager = magoManager.vboMemoryManager;
	var gl = magoManager.sceneState.gl;
	var primitive;
	
	if (this.color4)
	{ gl.uniform4fv(shader.oneColor4_loc, [this.color4.r, this.color4.g, this.color4.b, 1.0]); }

	shader.useProgram();
	shader.resetLastBuffersBinded();

	shader.enableVertexAttribArray(shader.position3_loc);
	shader.disableVertexAttribArray(shader.color4_loc);
	shader.enableVertexAttribArray(shader.normal3_loc); 
	shader.enableVertexAttribArray(shader.texCoord2_loc); 
	
	shader.bindUniformGenerals();
	
	var buildingGeoLocation = this.geoLocDataManager.getCurrentGeoLocationData();
	buildingGeoLocation.bindGeoLocationUniforms(gl, shader); // rotMatrix, positionHIGH, positionLOW.
	
	
	var vboKeysCount = this.vboKeysContainer.vboCacheKeysArray.length;
	for (var i=0; i<vboKeysCount; i++)
	{
		var vboKey = this.vboKeysContainer.vboCacheKeysArray[i];
		
		// Positions.
		if (!vboKey.bindDataPosition(shader, vboMemManager))
		{ return false; }
		
		// Normals.
		if (vboKey.vboBufferNor)
		{
			if (!vboKey.bindDataNormal(shader, vboMemManager))
			{ return false; }
		}
		else 
		{
			shader.disableVertexAttribArray(shader.normal3_loc);
		}
		
		// Colors.
		if (vboKey.vboBufferCol)
		{
			if (!vboKey.bindDataColor(shader, vboMemManager))
			{ return false; }
		}
		else 
		{
			shader.disableVertexAttribArray(shader.color4_loc);
		}
		
		// TexCoords.
		if (vboKey.vboBufferTCoord)
		{
			if (!vboKey.bindDataTexCoord(shader, vboMemManager))
			{ return false; }
		}
		else 
		{
			shader.disableVertexAttribArray(shader.texCoord2_loc);
		}
		
		// Indices.
		if (!vboKey.bindDataIndice(shader, vboMemManager))
		{ return false; }
		
		if (glPrimitive)
		{ primitive = glPrimitive; }
		else
		{ primitive = gl.TRIANGLES; }
		
		gl.drawElements(primitive, vboKey.indicesCount, gl.UNSIGNED_SHORT, 0);
	}
};



















































'use strict';

/**
 * Pipe.
 * @class Pipe
 */
var Pipe = function(interiorRadius, exteriorRadius, height, options) 
{
	if (!(this instanceof Pipe)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.intRadius = 10;
	this.extRadius = 20;
	this.height = 5;
	
	if (interiorRadius !== undefined)
	{ this.intRadius = interiorRadius; }
	
	if (exteriorRadius !== undefined)
	{ this.extRadius = exteriorRadius; }
	
	if (height !== undefined)
	{ this.height = height; }
	
	this.dirty = true;
	this.mesh;
	
	/**
	 * The geographic location of the factory.
	 * @type {GeoLocationDataManager}
	 * @default undefined
	 */
	this.geoLocDataManager;
	this.color4;
	
	if (options !== undefined)
	{
		var color = options.color;
		if (color)
		{
			this.color4 = new Color();
			this.color4.setRGBA(color.r, color.g, color.b, color.a);
		}
	}
};

/**
 * Makes the geometry mesh.
 */
Pipe.prototype.makeMesh = function()
{
	var profileAux = new Profile2D();
	var circle;
	
	// Create a outer ring in the Profile2d.
	var outerRing = profileAux.newOuterRing();
	circle = outerRing.newElement("CIRCLE");
	circle.setCenterPosition(0, 0);
	circle.setRadius(this.extRadius);
	
	// Now create interior ring.***
	var innerRing = profileAux.newInnerRing();
	circle = innerRing.newElement("CIRCLE");
	circle.setCenterPosition(0, 0);
	circle.setRadius(this.intRadius);
	
	var extrusionDist = this.height;
	var extrudeSegmentsCount = 1;
	var extrusionVector; // undefined.
	var bIncludeBottomCap = true;
	var bIncludeTopCap = true;
	
	this.mesh = Modeler.getExtrudedMesh(profileAux, extrusionDist, extrudeSegmentsCount, extrusionVector, bIncludeBottomCap, bIncludeTopCap, undefined);
	
	this.dirty = false;
};

/**
 * Renders the factory.
 */
Pipe.prototype.render = function(magoManager, shader, renderType, glPrimitive)
{
	if (this.dirty)
	{ this.makeMesh(); }
	
	if (this.mesh === undefined)
	{ return false; }

	// Set geoLocation uniforms.***
	var gl = magoManager.getGl();
	var buildingGeoLocation = this.geoLocDataManager.getCurrentGeoLocationData();
	buildingGeoLocation.bindGeoLocationUniforms(gl, shader); // rotMatrix, positionHIGH, positionLOW.
	
	gl.uniform1i(shader.refMatrixType_loc, 0); // in magoManager case, there are not referencesMatrix.***
	
	if (renderType === 0)
	{
		// Depth render.***
	}
	else if (renderType === 1)
	{
		// Color render.***
		//gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );
		gl.enable(gl.BLEND);
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.***
		
		// Check if is selected.***
		var selectionManager = magoManager.selectionManager;
		if (selectionManager.isObjectSelected(this))
		{
			gl.disable(gl.BLEND);
			gl.uniform4fv(shader.oneColor4_loc, [this.color4.r, this.color4.g, this.color4.b, 1.0]);
		}
		else 
		{
			gl.uniform4fv(shader.oneColor4_loc, [this.color4.r, this.color4.g, this.color4.b, this.color4.a]);
		}
		
	}
	else if (renderType === 2)
	{
		// Selection render.***
		var selectionColor = magoManager.selectionColor;
		var colorAux = magoManager.selectionColor.getAvailableColor(undefined);
		var idxKey = magoManager.selectionColor.decodeColor3(colorAux.r, colorAux.g, colorAux.b);
		magoManager.selectionManager.setCandidateGeneral(idxKey, this);
		
		gl.uniform4fv(shader.oneColor4_loc, [colorAux.r/255.0, colorAux.g/255.0, colorAux.b/255.0, 1.0]);
		gl.disable(gl.BLEND);
	}

	this.mesh.render(magoManager, shader, renderType, glPrimitive);

};














































'use strict';

/**
 * RenderableObject geometry.
 * @class RenderableObject
 */
var RenderableObject = function(options) 
{
	MagoRenderable.call(this);
	if (!(this instanceof RenderableObject)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	// See MagoRenderable's members.
	this.setDirty(false);

};
RenderableObject.prototype = Object.create(MagoRenderable.prototype);
RenderableObject.prototype.constructor = RenderableObject;
'use strict';

/**
 * SkeletalAnimationObject is a class object.
 * 
 * @class SkeletalAnimationObject
 * @constructor 
 * @param {string} The name of the SkeletalAnimationObject.
 */
var SkeletalAnimationObject = function(name) 
{
	this.modelMesh;
	
};

SkeletalAnimationObject.prototype.init_TEST = function()
{
	
};
'use strict';
/**
 * SpeechBubble is a class object.
 * 
 * @class SpeechBubble
 * @constructor 
 */
var SpeechBubble = function() 
{
	this.point2dArray = [];
	this.repository = {};
};

/**
 * set default speech bubble profile
 */
SpeechBubble.prototype.makeDefault = function(imageSize)
{
	//origin is left up corner 0,0
	//--------------
	//
	var width = imageSize[0];
	var height = imageSize[1];

	var minSize = (width > height) ? height : width;

	var offset = minSize * 0.05;
	var bubbleHeight = 0.75 * height;
	var tailWidth = 0.2 * width;
	var center = 0.5 * width;
	var cornerRadius = minSize * 0.20;



	this.point2dArray[0] = getObj(center, height-offset, 'moveTo');
	this.point2dArray[1] = getObj(center + tailWidth/2, bubbleHeight, 'lineTo');
	this.point2dArray[2] = getObj(width - cornerRadius, bubbleHeight, 'lineTo');
	this.point2dArray[3] = getObj(width-offset, bubbleHeight, 'quadraticCurveTo', width-offset, bubbleHeight - cornerRadius);
	this.point2dArray[4] = getObj(width-offset, cornerRadius, 'lineTo');
	this.point2dArray[5] = getObj(width-offset, offset, 'quadraticCurveTo', width - cornerRadius, offset);
	this.point2dArray[6] = getObj(cornerRadius, offset, 'lineTo');
	this.point2dArray[7] = getObj(offset, offset, 'quadraticCurveTo', offset, cornerRadius);
	this.point2dArray[8] = getObj(offset, bubbleHeight - cornerRadius, 'lineTo');
	this.point2dArray[9] = getObj(offset, bubbleHeight, 'quadraticCurveTo', cornerRadius, bubbleHeight);
	this.point2dArray[10] = getObj(center - tailWidth/2, bubbleHeight, 'lineTo');
    
	function getObj(x, y, command, targetX, targetY) 
	{
		var point = [x, y];
		if (targetX && targetY) 
		{
			point.push(targetX);
			point.push(targetY);
		}
		return {
			point   : point,
			command : command
		};
	}
};

/**
 * @param {Array<number>} imageSize
 * @param {Color} color
 * @param {object} textOption
 */
SpeechBubble.prototype.getPng = function (imageSize, color, textOption) 
{
	//need validation
	//var hexColor = color.getHexCode();
	var aux = [];
	aux.push(imageSize);
	aux.push(color);
	aux.push(textOption);
	var id = JSON.stringify(aux);

	if (this.repository[id])
	{
		return this.repository[id].toDataURL();
	}

	this.makeDefault(imageSize);
	var canvas = makeCanvas(imageSize, color, textOption, this.point2dArray);
	this.repository[id] = canvas;
	return canvas.toDataURL();

	function makeCanvas(size, hex, tOption, p2dArray) 
	{
		var c = document.createElement("canvas");
		var w = size[0];
		var h = size[1];
		c.width = w;
		c.height = h;

		var ctx = c.getContext("2d");
		ctx.save();
		ctx.fillStyle = hex;
		ctx.strokeStyle = '#000000';
		ctx.lineWidth = 2;
		ctx.beginPath();
		
		var p2dLength = p2dArray.length;
		for (var i=0;i<p2dLength;i++) 
		{
			var p2d = p2dArray[i];
			if (p2d.point.length === 2) 
			{
				ctx[p2d.command].call(ctx, p2d.point[0], p2d.point[1]);
			}
			else 
			{
				ctx[p2d.command].call(ctx, p2d.point[0], p2d.point[1], p2d.point[2], p2d.point[3]);
			}
		}

		ctx.closePath();
		ctx.fill();
		ctx.stroke();
		
		if (tOption) 
		{
			var textValue = tOption.text; //required.
			var fontPixel = defaultValue(tOption.pixel, 10);
			var fontType = defaultValue(tOption.font, 'sans-serif');
			var fontColor = defaultValue(tOption.color, 'white');
			var fontBorderColor = defaultValue(tOption.borderColor, 'black');

			ctx.font = 'bold ' + fontPixel + "px " + fontType;
			ctx.fillStyle = fontColor;
			ctx.strokeStyle = fontBorderColor;
			ctx.textAlign = "center";
			ctx.strokeText(textValue, w /2, h /2);
			ctx.fillText(textValue, w /2, h /2);
		}

		ctx.restore();
		return c;
	}
};
'use strict';

/**
 * TestFreeContourWallBuilding geometry.
 * @class TestFreeContourWallBuilding
 */
var TestFreeContourWallBuilding = function(options) 
{
	MagoRenderable.call(this, options);
	if (!(this instanceof TestFreeContourWallBuilding)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.height;
	this.point2DList;
	if (options !== undefined)
	{
		if (options.points2dArray !== undefined)
		{
			if (this.point2DList === undefined)
			{
				this.point2DList = new Point2DList();
			}
			
			this.point2DList.pointsArray = options.points2dArray;
		}
		
		if (options.height !== undefined)
		{
			this.height = options.height;
		}
	}
	
	
};

TestFreeContourWallBuilding.prototype = Object.create(MagoRenderable.prototype);
TestFreeContourWallBuilding.prototype.constructor = TestFreeContourWallBuilding;

/*
if (this.testClippingPlanes === undefined)
	{
		// make a modelmatrix for the clippingPlanes.
		var modelMatrix;
		var geoCoord = new GeographicCoord(126.61340759235748, 37.57613526692086, 0);
		var modelmatrix = Globe.transformMatrixAtGeographicCoord(geoCoord, undefined);
		var globe = this.scene._globe;
		globe.clippingPlanes = new Cesium.ClippingPlaneCollection({
			modelMatrix : modelmatrix,
			planes      : [
				new Cesium.ClippingPlane(new Cesium.Cartesian3( 1.0,  0.0, 0.0), -50.0),
				new Cesium.ClippingPlane(new Cesium.Cartesian3(-1.0,  0.0, 0.0), -50.0),
				new Cesium.ClippingPlane(new Cesium.Cartesian3( 0.0,  1.0, 0.0), -200.0),
				new Cesium.ClippingPlane(new Cesium.Cartesian3( 0.0, -1.0, 0.0), -200.0)
			],
			edgeWidth : 1.0,
			edgeColor : Cesium.Color.WHITE,
			enabled   : true
		});
	
		this.testClippingPlanes = true;
	}
	*/
	
TestFreeContourWallBuilding.prototype.makeMesh = function()
{
	var profileAux = new Profile2D();
	
	// Create a outer ring in the Profile2d.
	var outerRing = profileAux.newOuterRing();
	var polyline = outerRing.newElement("POLYLINE");

	var pointsCount = this.point2DList.getPointsCount();
	for (var i=0; i<pointsCount; i++)
	{
		var point2d = this.point2DList.getPoint(i);
		polyline.newPoint2d(point2d.x, point2d.y);
	}
	//var leftExpandDist = 0.2;
	//var innerPointsArray = Point2DList.getExpandedPoints(this.point2DList.pointsArray, undefined, leftExpandDist, rightExpandDist, bLoop);
	
	// Now create interior ring.***
	//var innerRing = profileAux.newInnerRing();
	//var circle = innerRing.newElement("CIRCLE");
	//circle.setCenterPosition(0, 0);
	//circle.setRadius(2);
	
	// Extrude the Profile.
	var extrudeSegmentsCount = 1;
	var extrusionVector = undefined;
	var extrusionDist = this.height;
	var bIncludeBottomCap = true;
	var bIncludeTopCap = true;
	
	if (this.objectsArray === undefined)
	{ this.objectsArray = []; }

	var mesh = Modeler.getExtrudedMesh(profileAux, extrusionDist, extrudeSegmentsCount, extrusionVector, bIncludeBottomCap, bIncludeTopCap, undefined);
	this.objectsArray.push(mesh);
	this.dirty = false;
};










































'use strict';

/**
 * Tube.
 * @class Tube
 */
var Tube = function(interiorRadius, exteriorRadius, height, options) 
{
	MagoRenderable.call(this);
	if (!(this instanceof Tube)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.intRadius = 10;
	this.extRadius = 20;
	this.height = 5;
	
	if (interiorRadius !== undefined)
	{ this.intRadius = interiorRadius; }
	
	if (exteriorRadius !== undefined)
	{ this.extRadius = exteriorRadius; }
	
	if (height !== undefined)
	{ this.height = height; }
	
	this.dirty = true;
	this.mesh;
	this.bbox;
	
	/**
	 * The geographic location of the factory.
	 * @type {GeoLocationDataManager}
	 * @default undefined
	 */
	this.geoLocDataManager;
	this.color4;
	
	if (options !== undefined)
	{
		var color = options.color;
		if (color)
		{
			this.color4 = new Color();
			this.color4.setRGBA(color.r, color.g, color.b, color.a);
		}
		var selectedColor = options.selectedColor;
		if (selectedColor)
		{
			this.selectedColor4 = new Color();
			this.selectedColor4.setRGBA(selectedColor.r, selectedColor.g, selectedColor.b, selectedColor.a);
		}
	}
};
Tube.prototype = Object.create(MagoRenderable.prototype);
Tube.prototype.constructor = Tube;

/**
 * Returns the bbox.
 */
Tube.prototype.getBoundingBox = function()
{
	if (this.bbox === undefined)
	{
		this.bbox = new BoundingBox();
		var maxRadius = this.extRadius;
		if (maxRadius < this.intRadius)
		{ maxRadius = this.intRadius; }
		
		this.bbox.set(-maxRadius, -maxRadius, 0.0, maxRadius, maxRadius, this.height);
	}
	return this.bbox;
};

/**
 * Makes the geometry mesh.
 */
Tube.prototype.makeMesh = function()
{
	var profileAux = new Profile2D();
	var circle;
	
	// Create a outer ring in the Profile2d.
	var outerRing = profileAux.newOuterRing();
	circle = outerRing.newElement("CIRCLE");
	circle.setCenterPosition(0, 0);
	circle.setRadius(this.extRadius);
	
	// Now create interior ring.***
	var innerRing = profileAux.newInnerRing();
	circle = innerRing.newElement("CIRCLE");
	circle.setCenterPosition(0, 0);
	circle.setRadius(this.intRadius);
	
	var extrusionDist = this.height;
	var extrudeSegmentsCount = 1;
	var extrusionVector; // undefined.
	var bIncludeBottomCap = true;
	var bIncludeTopCap = true;
	
	var mesh = Modeler.getExtrudedMesh(profileAux, extrusionDist, extrudeSegmentsCount, extrusionVector, bIncludeBottomCap, bIncludeTopCap, undefined);
	this.objectsArray.push(mesh);
	this.dirty = false;
};
'use strict';

/**
 * vector geometry.
 * This class is analog to "Mesh" class, but vectorMesh is for points, lines, polylines data type.
 * @class VectorMesh
 */
var VectorMesh = function(options) 
{
	if (!(this instanceof VectorMesh)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	// This class is analog to "Mesh" class, but "VectorMesh" is for points, lines, polylines data type.

	this.name;
	this.id;
	this.thickness = 1.0;
	this.color4;
	
	this.vertexList;

	this.vboKeysContainer;
	
	if (options)
	{
		if (options.thickness)
		{ this.thickness = options.thickness; }
		
		if (options.color)
		{ this.color4 = options.color; }
	}
};

/**
 * Render the VectorMesh as child. equal render
 * @param {MagoManager}magoManager
 * @param {Shader} shader
 * @param {Number} renderType
 * @param glPrimitive
 * @TODO : 누가 이 gl primitive의 type 정체를 안다면 좀 달아주세요ㅠㅠ 세슘 쪽인거 같은데ㅠㅠ
 */
VectorMesh.prototype.renderAsChild = function (magoManager, shader, renderType, glPrimitive, isSelected, options) 
{
	var depthMask = true;
	var gl = magoManager.getGl();
	
	if (options)
	{
		if (options.depthMask !== undefined)
		{
			depthMask = options.depthMask;
		}
	}

	gl.depthMask(depthMask);
	this.render(magoManager, shader, renderType, glPrimitive, isSelected);
	gl.depthMask(true);

};

/**
 * Render the VectorMesh
 * @param {MagoManager}magoManager
 * @param {Shader} shader
 * @param {Number} renderType
 * @param glPrimitive
 * @TODO : 누가 이 gl primitive의 type 정체를 안다면 좀 달아주세요ㅠㅠ 세슘 쪽인거 같은데ㅠㅠ
 */
VectorMesh.prototype.render = function(magoManager, shader, renderType, glPrimitive, isSelected)
{
	if (this.vboKeysContainer === undefined)
	{ return; }
	
	var vbo = this.vboKeysContainer.getVboKey(0);
	var gl = magoManager.getGl();

	//gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
	//gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
	gl.disable(gl.CULL_FACE);
	
	gl.enableVertexAttribArray(shader.prev_loc);
	gl.enableVertexAttribArray(shader.current_loc);
	gl.enableVertexAttribArray(shader.next_loc);
	
	gl.disableVertexAttribArray(shader.color4_loc);

	var sceneState = magoManager.sceneState;
	var projMat = sceneState.projectionMatrix;
	var viewMat = sceneState.modelViewMatrix;
	var drawingBufferWidth = sceneState.drawingBufferWidth;
	var drawingBufferHeight = sceneState.drawingBufferHeight;
	
	if (this.thickness === undefined)
	{ this.thickness = 2.0; }
	
	gl.uniform4fv(shader.oneColor4_loc, [0.5, 0.7, 0.9, 1.0]);
	gl.uniform2fv(shader.viewport_loc, [drawingBufferWidth[0], drawingBufferHeight[0]]);
	gl.uniform1f(shader.thickness_loc, this.thickness);

	var vboPos = vbo.vboBufferPos;
	var dim = vboPos.dataDimensions; // in this case dimensions = 4.
	if (!vboPos.isReady(gl, magoManager.vboMemoryManager))
	{
		return;
	}
	
	if (vbo.vboBufferCol)
	{
		if (!vbo.bindDataColor(shader, magoManager.vboMemoryManager) )
		{
			return;
		}
		gl.uniform1i(shader.colorType_loc, 1);
	}
	else 
	{
		gl.uniform1i(shader.colorType_loc, 0);
		gl.disableVertexAttribArray(shader.color4_loc);
	}
	gl.enableVertexAttribArray(shader.color4_loc);

	gl.bindBuffer(gl.ARRAY_BUFFER, vboPos.key);
	gl.vertexAttribPointer(shader.prev_loc, dim, gl.FLOAT, false, 16, 0);
	gl.vertexAttribPointer(shader.current_loc, dim, gl.FLOAT, false, 16, 64-32);
	gl.vertexAttribPointer(shader.next_loc, dim, gl.FLOAT, false, 16, 128-32);

	gl.drawArrays(gl.TRIANGLE_STRIP, 0, vbo.vertexCount-4);

	gl.enable(gl.CULL_FACE);
	
};
'use strict';

var Vehicle = function(width, length, height, options) 
{
	MagoRenderable.call(this);

	if (!(this instanceof Vehicle)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.PARALLEL_ROTATION_ANGLE = 90;
	this.frame;
	this.frontArrow;
	this.rearArrow;
    
	this.frontArrowPos;
	this.rearArrowPos;
    
	this.width = width;
	this.length = length;
	this.height = height;

	/**
	 * distance between wheel axis
	 * @type {number}
	 */
	this.wheelbase = length * 0.8;
    
	/**
	 * y axix is zero degree
	 * @type {number}
	 */
	this.rearAngleDeg = 0;

	/**
	 * y axix is zero degree
	 * @type {number}
	 */
	this.frontAngleDeg = 0;

	this.isDrawArrow = true;

	this.eventStatus = {
		changingFrontArrow : false,
		changingRearArrow  : false,
		footOnAccel        : false
	};

	this.mode = BasicVehicle.MODE.NORMAL;
	this.accelStatus = BasicVehicle.ACCEL_STATUS.FORWARD;

	//this.changingFrontArrow = false;
	this.changingFrontArrowType = 0;
	this.changingFrontArrowSpeed = 0.1;

	//this.changingRearArrow = false;
	this.changingRearArrowType = 0;
	this.changingRearArrowSpeed = 0.1;

	//move
	/**
	 * unit m/s, EXAMPLE. 1.388889M/S IS 5KM/H 
	 * @type {number}
	 */
	this.maxSpeed = 12;
	this.frontCurrentSpeed = 0;
	this.frontAcceleration = 1;
	this.frontDeacceleration = 3.8;

	this.rearCurrentSpeed = 0;
	this.rearAcceleration = 1;
	this.rearDeacceleration = 3.8;

	this.pivotPointLC;
	this.isParallelDirection = false;

	this.guidePoint = new Point3DList();

	this.auxOffsetVector;

	this.parallelRotationDist = 10;
    
	this.frame;

	this.carriedObjectsArray = [];

	this.shimmyMatDimension = new Point2D(this.width * 0.7, this.wheelbase);
	this.shimmyMat = new Point2D(2, 12);

	var maxPointCount = 50;

	this.trajectoryLength = this.length * 2;
	this.frontTrajectoryPointList = new Point3DList();
	this.rearTrajectoryPointList = new Point3DList();

	while (this.frontTrajectoryPointList.getPointsCount() !== maxPointCount) 
	{
		this.frontTrajectoryPointList.newPoint();
	}
	while (this.rearTrajectoryPointList.getPointsCount() !== maxPointCount) 
	{
		this.rearTrajectoryPointList.newPoint();
	}

	this.objectsArray.push(this.frontTrajectoryPointList);
	this.objectsArray.push(this.rearTrajectoryPointList);
};

Vehicle.prototype = Object.create(MagoRenderable.prototype);
Vehicle.prototype.constructor = Vehicle;


/**
 * @param {Object} object this must have geoLocationDatamanager. 
 */
Vehicle.prototype.addToContainer = function(object, magoManager) 
{

	this.carriedObjectsArray.push(object);
	this.updateContainer(magoManager);
};

/**
 * @param {Object} object this must have geoLocationDatamanager. 
 */
Vehicle.prototype.updateContainer = function(magoManager) 
{
	var vehicleGeoLocation = this.geoLocDataManager.getCurrentGeoLocationData();
	var vehicleGeoCoord = vehicleGeoLocation.getGeographicCoords();
	//ManagerUtils.calculateGeoLocationData = function(longitude, latitude, altitude, heading, pitch, roll, resultGeoLocationData) 
	for (var i=0, len=this.carriedObjectsArray.length;i<len;i++) 
	{
		var object = this.carriedObjectsArray[i];
		if (object instanceof Node) 
		{
			object.data.mapping_type = 'boundingboxcenter';
			var objectGeoLocation = object.data.geoLocDataManager.getCurrentGeoLocationData();
			
			var heading = vehicleGeoLocation.heading;// + objectGeoLocation.heading;

			var height = object.data.bbox.getZLength()/2;


			object.changeLocationAndRotation(vehicleGeoCoord.latitude, vehicleGeoCoord.longitude, vehicleGeoCoord.altitude + this.height + height, heading, undefined, undefined, magoManager);
		}
	}
	
};

Vehicle.prototype.render = function(magoManager, shader, renderType, glPrimitive) 
{
	if (this.attributes && this.attributes.isVisible !== undefined && this.attributes.isVisible === false) 
	{
		return;
	}

	if (this.dirty)
	{ this.makeMesh(); this.arrowDirectionChanged(magoManager); }//20191114
	
	if (this.objectsArray === undefined)
	{ return false; }

	// Set geoLocation uniforms.***
	var gl = magoManager.getGl();
	var buildingGeoLocation = this.geoLocDataManager.getCurrentGeoLocationData();
	buildingGeoLocation.bindGeoLocationUniforms(gl, shader); // rotMatrix, positionHIGH, positionLOW.
	gl.uniform4fv(shader.oneColor4_loc, [0, 1, 0, 1.0]); 
	//20191114
	//방향 변경
	this.changeArrow(magoManager);

	this.move(magoManager);

	gl.uniform1i(shader.refMatrixType_loc, 0); // in magoManager case, there are not referencesMatrix.***
	var isSelected = false;
	
	if (renderType === 0)
	{
		// Depth render.***
	}
	else if (renderType === 1)
	{
		// Color render.***
		// Color render.***
		var selectionManager = magoManager.selectionManager;
		if (selectionManager.isObjectSelected(this))
		{ isSelected = true; }
	
		//gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );
		gl.enable(gl.BLEND);
		gl.uniform1i(shader.bApplySsao_loc, true); // apply ssao.***
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.***
		if (this.color4) 
		{
			gl.uniform4fv(shader.oneColor4_loc, [this.color4.r, this.color4.g, this.color4.b, 1.0]);
		}		
	}
	else if (renderType === 2)
	{
		// Selection render.***
		var selectionColor = magoManager.selectionColor;
		var colorAux = magoManager.selectionColor.getAvailableColor(undefined);
		var idxKey = magoManager.selectionColor.decodeColor3(colorAux.r, colorAux.g, colorAux.b);
		magoManager.selectionManager.setCandidateGeneral(idxKey, this);
		
		gl.uniform4fv(shader.oneColor4_loc, [colorAux.r/255.0, colorAux.g/255.0, colorAux.b/255.0, 1.0]);
		gl.disable(gl.BLEND);
	}
	
	
	if (isSelected)
	{
		if (this.selColor4 === undefined)
		{
			this.selColor4 = new Color();
			this.selColor4.setRGBA(0.8, 0.4, 0.5, 1.0);
		}
		gl.uniform4fv(shader.oneColor4_loc, [this.selColor4.r, this.selColor4.g, this.selColor4.b, 1.0]); 
	}

	//gl.uniform1i(shader.refMatrixType_loc, 0); // in magoManager case, there are not referencesMatrix.***
	//buildingGeoLocation.bindGeoLocationUniforms(gl, shader); // rotMatrix, positionHIGH, positionLOW.
	//shader.disableVertexAttribArrayAll();
	shader.enableVertexAttribArray(shader.position3_loc);
	this.guidePoint.renderAsChild(magoManager, shader, renderType, glPrimitive);

	shader.enableVertexAttribArray(shader.normal3_loc);

	var objectsCount = this.objectsArray.length;
	for (var i=0; i<objectsCount; i++)
	{
		var object = this.objectsArray[i];
		object.renderAsChild(magoManager, shader, renderType, glPrimitive, isSelected);
		/*if (object instanceof Arrow || object instanceof ShimmyGearAssembly) 
		{
			object.renderAsChild(magoManager, shader, renderType, glPrimitive, isSelected);
		}
		else 
		{
			object.render(magoManager, shader, renderType, glPrimitive, isSelected);
		}*/
	}
	
	gl.disable(gl.BLEND);
};
Vehicle.prototype.renderAsChild = function(magoManager, shader, renderType, glPrimitive) 
{

};
Vehicle.prototype.makeMesh = function() 
{
	if (this.objectsArray === undefined)
	{ this.objectsArray = []; }

	//width, length, height
	//caculate frame dimension
	var frameWidth = this.width;
	var frameLength = this.length;
	var frameHeight = this.height * 0.15;

	var frame = new Box(frameWidth, frameLength, frameHeight, 'frame');
	frame.setOneColor(196/255, 117/255, 0.0, 1);
    
	var frameTranslatePoint3D = new Point3D(0.0, 0.0, this.height - frameHeight);
	frame.tMatOriginal = new Matrix4();
	frame.tMatOriginal.setTranslation(frameTranslatePoint3D.x, frameTranslatePoint3D.y, frameTranslatePoint3D.z);

	this.objectsArray.push(frame);
	this.frame = frame;

	var totalLength = 2;
	var bodyWidth = totalLength * 0.1;
	var headWidth = totalLength * 0.2;
	var tailLength = totalLength * 0.2;
	var extrude = totalLength * 0.05;
    
	var frontArrow = new Arrow(10, 50, 0.5, {
		totalLength : 12,
		bodyWidth   : 2,
		headWidth   : 4,
		tailLength  : 1,
		extrude     : 2
	});

	var rearArrow = new Arrow(10, 50, 0.5, {
		totalLength : 12,
		bodyWidth   : 2,
		headWidth   : 4,
		tailLength  : 1,
		extrude     : 2
	});

	this.objectsArray.push(frontArrow);
	this.frontArrow = frontArrow;
	this.frontArrow.setOneColor(0.9, 0.1, 0.1, 1);
	this.frontArrowPos = new Point3D(0.0, this.wheelbase * 1.5, this.height);
	frontArrow.tMatOriginal = new Matrix4();
	frontArrow.tMatOriginal.setTranslation(this.frontArrowPos.x, this.frontArrowPos.y, this.frontArrowPos.z);
	
	this.objectsArray.push(rearArrow);
	this.rearArrow = rearArrow;
    
	this.rearArrowPos = new Point3D(0.0, -this.wheelbase * 1.5, this.height);
	rearArrow.tMatOriginal = new Matrix4();
	rearArrow.tMatOriginal.setTranslation(this.rearArrowPos.x, this.rearArrowPos.y, this.rearArrowPos.z);
    
	var shimmyWidth = this.width * 0.25;
	var shimmyLength = 0.5;
	var shimmyHeight = this.height - frameHeight;
 
	var ShimmyGearAssemblyPrimitive = this.getShimmyGearAssembly();
	this.shimmyGearAssembly = new ShimmyGearAssemblyPrimitive(shimmyWidth, shimmyLength, shimmyHeight);
	this.shimmyGearAssembly.setOneColor(196/255, 117/255, 0.0, 1);
	//this.objectsArray.push(this.shimmyGearAssembly);


	this.shimmyGearAssembly.tMatOriginal = new Matrix4();
	this.shimmyGearAssembly.tMatOriginal.setTranslation(0, 0, shimmyHeight);
	this.shimmyGearAssembly.makeMesh();

	// shimmy matrix.
	var numCols = this.shimmyMat.x;
	var numRows = this.shimmyMat.y;

	var refRow = numRows/2;
	var colDist = this.shimmyMatDimension.x / (numCols-1);
	var rowDist = this.shimmyMatDimension.y / (numRows-1);

	for (var c=0;c<numCols;c++) 
	{
		for (var r=0;r<numRows;r++)
		{
			var auxShimmy = new ShimmyGearAssemblyPrimitive(shimmyWidth, shimmyLength, shimmyHeight);
			auxShimmy.frame = this.shimmyGearAssembly.frame;
			auxShimmy.rightWheel = this.shimmyGearAssembly.rightWheel;
			auxShimmy.leftWheel = this.shimmyGearAssembly.leftWheel;
			auxShimmy.color4 = this.shimmyGearAssembly.color4;
			auxShimmy.makeMesh();

			var x = colDist * c;
			var y = rowDist * r;

			var orginShimmyPos = new Point3D(x - this.shimmyMatDimension.x * 0.5, y - this.shimmyMatDimension.y * 0.5, shimmyHeight);
			auxShimmy.tMatOriginal = new Matrix4();
			auxShimmy.tMatOriginal.setTranslation(orginShimmyPos.x, orginShimmyPos.y, orginShimmyPos.z);
			auxShimmy.orginShimmyPos = orginShimmyPos;
			this.objectsArray.push(auxShimmy);
		}
	}

	this.updateMatrix();
	this.setDirty(false);
};

Vehicle.prototype.doChangeFrontAngleDeg = function(type) 
{
	this.eventStatus.changingFrontArrow = true;
	if (type === 'left') 
	{
		this.changingFrontArrowType = 0;
	}
	else 
	{
		this.changingFrontArrowType = 1;
	}
};

Vehicle.prototype.stopChangeFrontAngleDeg = function() 
{
	this.eventStatus.changingFrontArrow = false;
};

Vehicle.prototype.doChangeRearAngleDeg = function(type) 
{
	this.eventStatus.changingRearArrow = true;
	if (type === 'left') 
	{
		this.changingRearArrowType = 0;
	}
	else 
	{
		this.changingRearArrowType = 1;
	}
};
Vehicle.prototype.stopChangeRearAngleDeg = function() 
{
	this.eventStatus.changingRearArrow = false;
};
Vehicle.prototype._updateLastTime = function(currentTime) 
{
	this.lastTime = currentTime;
};
Vehicle.prototype.moveParallelTranslate = function(deltaTime, magoManager)
{
	var geoLocManager = this.geoLocDataManager;
	//IF YOU WANT TRACKING OR DRIVING THE VEHICLE, USE NEWGEOLOCATIONDATA. ELSE USE GETCURRENTGEOLOCATIONDATA
	var geoLocData = geoLocManager.newGeoLocationData();
	var geoCoord = geoLocData.geographicCoord;

	var direction = this.frontDirection2D;//this.getFrontDirection2D(new Point2D());
	if (this.accelStatus === BasicVehicle.ACCEL_STATUS.REVERSE) 
	{
		direction = new Point2D();
		direction.copyFrom(this.frontDirection2D);
		direction.inverse();
	}
		
	var direction3D = new Point3D(direction.x, direction.y, 0);
	var posLC = new Point3D(direction3D.x * this.frontCurrentSpeed * deltaTime, direction3D.y * this.frontCurrentSpeed * deltaTime, direction3D.z * this.frontCurrentSpeed * deltaTime);

	var rotMat = geoLocData.rotMatrix;
	var posLcRot = rotMat.rotatePoint3D(posLC);

	var posWCHIGH = new Float32Array(3);
	var posWCLOW = new Float32Array(3);

	posWCLOW[0] = geoLocData.positionLOW[0] + posLcRot.x;
	posWCLOW[1] = geoLocData.positionLOW[1] + posLcRot.y;
	posWCLOW[2] = geoLocData.positionLOW[2] + posLcRot.z;

	posWCHIGH[0] = geoLocData.positionHIGH[0];
	posWCHIGH[1] = geoLocData.positionHIGH[1];
	posWCHIGH[2] = geoLocData.positionHIGH[2];

	var posWC = geoLocData.localCoordToWorldCoord(posLC);
	geoCoord = ManagerUtils.pointToGeographicCoord(posWC, geoCoord);

	geoLocData = ManagerUtils.calculateGeoLocationDataByAbsolutePoint(posWCLOW[0] + posWCHIGH[0], posWCLOW[1] + posWCHIGH[1], posWCLOW[2] + posWCHIGH[2], geoLocData, magoManager);
};
Vehicle.prototype.moveCircularRotation = function(deltaTime, magoManager) 
{
	if (!this.pivotPointLC) { return; }
    
	var geoLocManager = this.geoLocDataManager;
	//IF YOU WANT TRACKING OR DRIVING THE VEHICLE, USE NEWGEOLOCATIONDATA. ELSE USE GETCURRENTGEOLOCATIONDATA
	var geoLocData = geoLocManager.newGeoLocationData();
	var geoCoord = geoLocData.geographicCoord;
	// do rotate
	var radiusErr = 10E-4;
	var frontArrowPos = this.frontArrowPos;
	var rearArrowPos = this.rearArrowPos;
	var frontLine2D = this.frontLine2D;
	var rearLine2D = this.rearLine2D;
	var frontDirection2D = this.frontDirection2D;
	var rearDirection2D = this.rearDirection2D;
    
	if (!this.auxOffsetVector) 
	{
		this.auxOffsetVector = new Point3D(0, 0, 0);
	}

	//front
	var frontSpeed = this.frontCurrentSpeed;
	var frontDist = frontSpeed * deltaTime;
	var frontPosTranslated = new Point3D(frontArrowPos.x, frontArrowPos.y, 0);
	frontPosTranslated.add(this.auxOffsetVector.x, this.auxOffsetVector.y, 0);
	var frontRadius = this.pivotPointLC.distToPoint(frontArrowPos);

	//rotation radius coincident
	if (frontRadius < radiusErr) 
	{ 
		this._updateLastTime(undefined);
		this.frontCurrentSpeed = 0;
		return; 
	}

	var frontRad = frontDist / frontRadius;
	var frontRelativeSideOfPoint = frontLine2D.getRelativeSideOfPoint(this.pivotPointLC);
	if (frontRelativeSideOfPoint === CODE.relativePosition2D.RIGHT) 
	{ frontRad *= -1; }
	
	if (this.accelStatus === BasicVehicle.ACCEL_STATUS.REVERSE) 
	{
		frontRad *= -1;
	}
	/*if (Math.abs(frontRad) > 0.0001) 
	{
		if (frontRad > 0) 
		{
			frontRad = 0.0001;
		}
		else 
		{
			frontRad = -0.0001;
		}
	}*/

	var frontAuxMatrix = new Matrix4();
	frontAuxMatrix.rotationAxisAngRad(frontRad, 0, 0, 1);
	var frontPosRotated = frontAuxMatrix.rotatePoint3D(frontPosTranslated);
	var frontPosTransformed = new Point3D(frontPosRotated.x, frontPosRotated.y, frontPosRotated.z);
	frontPosTransformed.add(-this.auxOffsetVector.x, -this.auxOffsetVector.y, 0);

	//rear
	var scalarProduct = rearDirection2D.scalarProduct(frontDirection2D);
	var rearSpeed = frontSpeed * scalarProduct;
	var rearDist = rearSpeed * deltaTime;
	var rearPosTranslated = new Point3D(rearArrowPos.x, rearArrowPos.y, 0);
	rearPosTranslated.add(this.auxOffsetVector.x, this.auxOffsetVector.y, 0);
	var rearRadius = this.pivotPointLC.distToPoint(rearArrowPos);
	
	//rotation radius coincident
	/*if (rearRadius < radiusErr) 
	{ 
		this._updateLastTime(undefined);
		this.frontCurrentSpeed = 0;
		return; 
	}*/

	//var rearRad = rearDist / rearRadius;
	var rearRad = frontRad;

	//var rearRelativeSideOfPoint = rearLine2D.getRelativeSideOfPoint(this.pivotPointLC);
	//if (rearRelativeSideOfPoint === CODE.relativePosition2D.RIGHT) { rearRad *= -1; }

	var rearAuxMatrix = new Matrix4();
	rearAuxMatrix.rotationAxisAngRad(rearRad, 0, 0, 1);
	var rearPosRotated = rearAuxMatrix.rotatePoint3D(rearPosTranslated);
	var rearPosTransformed = new Point3D(rearPosRotated.x, rearPosRotated.y, rearPosRotated.z);
	rearPosTransformed.add(-this.auxOffsetVector.x, -this.auxOffsetVector.y, 0);

	//frame
	var framePosLC = new Point3D((frontPosTransformed.x + rearPosTransformed.x) / 2, (frontPosTransformed.y + rearPosTransformed.y) / 2, 0);
	var frameSegemnt = new Segment2D(rearPosTransformed, frontPosTransformed);
	var frameDirection = frameSegemnt.getDirection();
	var initialFrameDirection = new Point2D(0, 1);//this.getFrameDirection2D();

	var heading = frameDirection.angleDegToVector(initialFrameDirection);
	if (frameDirection.x > 0 ) { heading *= -1; }

	var rotMat = geoLocData.rotMatrix;

	var posWCHIGH = new Float32Array(3);
	var posWCLOW = new Float32Array(3);

	var framePosWCRot = rotMat.rotatePoint3D(framePosLC);

	posWCLOW[0] = geoLocData.positionLOW[0] + framePosWCRot.x;
	posWCLOW[1] = geoLocData.positionLOW[1] + framePosWCRot.y;
	posWCLOW[2] = geoLocData.positionLOW[2] + framePosWCRot.z;

	posWCHIGH[0] = geoLocData.positionHIGH[0];
	posWCHIGH[1] = geoLocData.positionHIGH[1];
	posWCHIGH[2] = geoLocData.positionHIGH[2];
	if (geoLocData.heading === undefined) { geoLocData.heading = 0; }
	heading = geoLocData.heading + heading;
	//geoLocData.heading = Vehicle.degreeValidator(heading);
	//geoLocData = ManagerUtils.calculateGeoLocationDataByAbsolutePoint(posWCLOW[0] + posWCHIGH[0], posWCLOW[1] + posWCHIGH[1], posWCLOW[2] + posWCHIGH[2], geoLocData, magoManager);

	var auxPoint3DWC = new Point3D(posWCLOW[0] + posWCHIGH[0], posWCLOW[1] + posWCHIGH[1], posWCLOW[2] + posWCHIGH[2]);
	var auxGeoCoord = ManagerUtils.pointToGeographicCoord(auxPoint3DWC);
	
	auxGeoCoord.altitude = 0;
	geoLocData = ManagerUtils.calculateGeoLocationData(auxGeoCoord.longitude, auxGeoCoord.latitude, auxGeoCoord.altitude, BasicVehicle.degreeValidator(heading), geoLocData.pitch, geoLocData.roll, geoLocData, magoManager);

	//헤딩이 변할 시 화살표 업데이트 해줘야함.
	this.update(magoManager);
};
Vehicle.prototype.changeParallelRotationDist = function(mode) 
{
	if (mode === 0 ) 
	{
		this.parallelRotationDist -= 0.1;
	}
	else 
	{
		this.parallelRotationDist += 0.1;
	}
};
Vehicle.prototype.moveNormal = function(deltaTime, magoManager)
{
	if (this.isParallelDirection) 
	{
		this.moveParallelTranslate(deltaTime, magoManager);
	}
	else 
	{
		this.moveCircularRotation(deltaTime, magoManager);
	}
};
Vehicle.prototype.moveParallelRotation = function(deltaTime, magoManager) 
{
	var geoLocManager = this.geoLocDataManager;
	//IF YOU WANT TRACKING OR DRIVING THE VEHICLE, USE NEWGEOLOCATIONDATA. ELSE USE GETCURRENTGEOLOCATIONDATA
	var geoLocData = geoLocManager.newGeoLocationData();
	var geoCoord = geoLocData.geographicCoord;
	// do rotate
	var radiusErr = 10E-4;
	var frontArrowPos = this.frontArrowPos;
	var rearArrowPos = this.rearArrowPos;
	var frontDirection2D = this.frontDirection2D;
	var rearDirection2D = this.rearDirection2D;

	var frontArrowSegment = new Segment2D(new Point2D(frontArrowPos.x, frontArrowPos.y), new Point2D(frontArrowPos.x + frontDirection2D.x, frontArrowPos.y + frontDirection2D.y));
	var rearArrowSegment = new Segment2D(new Point2D(rearArrowPos.x, rearArrowPos.y),  new Point2D(rearArrowPos.x + rearDirection2D.x, rearArrowPos.y + rearDirection2D.y));

	this.frontLine2D = frontArrowSegment.getLine(); 
	this.rearLine2D = rearArrowSegment.getLine();

	var frontLine2D = this.frontLine2D;
	var rearLine2D = this.rearLine2D;
	

	if (!this.pivotPointLC) { this.pivotPointLC = new Point3D(); }
	this.setPivotPointLC(0, this.parallelRotationDist, 0, magoManager);

	this.guidePoint.deleteObjects(magoManager);
	this.guidePoint.addPoint(new Point3D(this.pivotPointLC.x, this.pivotPointLC.y, 2.2));

	var translationVector = new Point2D(this.pivotPointLC.x, this.pivotPointLC.y);
	translationVector.inverse();

	this.auxOffsetVector = translationVector;

	//front
	var frontSpeed = this.frontCurrentSpeed;
	var frontDist = frontSpeed * deltaTime;
	var frontPosTranslated = new Point3D(frontArrowPos.x, frontArrowPos.y, 0);
	frontPosTranslated.add(this.auxOffsetVector.x, this.auxOffsetVector.y, 0);
	var frontRadius = this.pivotPointLC.distToPoint(frontArrowPos);

	//rotation radius coincident
	if (frontRadius < radiusErr) 
	{ 
		this._updateLastTime(undefined);
		this.frontCurrentSpeed = 0;
		return; 
	}

	var frontRad = frontDist / frontRadius;
	var frontRelativeSideOfPoint = frontLine2D.getRelativeSideOfPoint(this.pivotPointLC);
	if (frontRelativeSideOfPoint === CODE.relativePosition2D.RIGHT) 
	{ frontRad *= -1; }

	if (this.accelStatus === BasicVehicle.ACCEL_STATUS.REVERSE) 
	{
		frontRad *= -1;
	}
	
	var frontAuxMatrix = new Matrix4();
	frontAuxMatrix.rotationAxisAngRad(frontRad, 0, 0, 1);
	var frontPosRotated = frontAuxMatrix.rotatePoint3D(frontPosTranslated);
	var frontPosTransformed = new Point3D(frontPosRotated.x, frontPosRotated.y, frontPosRotated.z);
	frontPosTransformed.add(-this.auxOffsetVector.x, -this.auxOffsetVector.y, 0);

	//rear
	var rearDist = this.parallelRotationDist + this.wheelbase * 0.5;
	var frontDist = this.parallelRotationDist - this.wheelbase * 0.5;
	var rearSpeed = (frontSpeed * rearDist) / frontDist;

	var rearPosTranslated = new Point3D(rearArrowPos.x, rearArrowPos.y, 0);
	rearPosTranslated.add(this.auxOffsetVector.x, this.auxOffsetVector.y, 0);
	var rearRadius = this.pivotPointLC.distToPoint(rearArrowPos);
	


	//var rearRad = rearDist / rearRadius;
	var rearRad = frontRad;

	//var rearRelativeSideOfPoint = rearLine2D.getRelativeSideOfPoint(this.pivotPointLC);
	//if (rearRelativeSideOfPoint === CODE.relativePosition2D.RIGHT) { rearRad *= -1; }

	var rearAuxMatrix = new Matrix4();
	rearAuxMatrix.rotationAxisAngRad(rearRad, 0, 0, 1);
	var rearPosRotated = rearAuxMatrix.rotatePoint3D(rearPosTranslated);
	var rearPosTransformed = new Point3D(rearPosRotated.x, rearPosRotated.y, rearPosRotated.z);
	rearPosTransformed.add(-this.auxOffsetVector.x, -this.auxOffsetVector.y, 0);

	//frame
	var framePosLC = new Point3D((frontPosTransformed.x + rearPosTransformed.x) / 2, (frontPosTransformed.y + rearPosTransformed.y) / 2, 0);
	var frameSegemnt = new Segment2D(rearPosTransformed, frontPosTransformed);
	var frameDirection = frameSegemnt.getDirection();
	var initialFrameDirection = new Point2D(0, 1);//this.getFrameDirection2D();

	var heading = frameDirection.angleDegToVector(initialFrameDirection);
	if (frameDirection.x > 0 ) { heading *= -1; }

	var rotMat = geoLocData.rotMatrix;

	var posWCHIGH = new Float32Array(3);
	var posWCLOW = new Float32Array(3);

	var framePosWCRot = rotMat.rotatePoint3D(framePosLC);

	posWCLOW[0] = geoLocData.positionLOW[0] + framePosWCRot.x;
	posWCLOW[1] = geoLocData.positionLOW[1] + framePosWCRot.y;
	posWCLOW[2] = geoLocData.positionLOW[2] + framePosWCRot.z;

	posWCHIGH[0] = geoLocData.positionHIGH[0];
	posWCHIGH[1] = geoLocData.positionHIGH[1];
	posWCHIGH[2] = geoLocData.positionHIGH[2];
	if (geoLocData.heading === undefined) { geoLocData.heading = 0; }
	heading = geoLocData.heading + heading;
	//geoLocData.heading = Vehicle.degreeValidator(heading);
	//geoLocData = ManagerUtils.calculateGeoLocationDataByAbsolutePoint(posWCLOW[0] + posWCHIGH[0], posWCLOW[1] + posWCHIGH[1], posWCLOW[2] + posWCHIGH[2], geoLocData, magoManager);

	var auxPoint3DWC = new Point3D(posWCLOW[0] + posWCHIGH[0], posWCLOW[1] + posWCHIGH[1], posWCLOW[2] + posWCHIGH[2]);
	var auxGeoCoord = ManagerUtils.pointToGeographicCoord(auxPoint3DWC);
	
	auxGeoCoord.altitude = 0;
	geoLocData = ManagerUtils.calculateGeoLocationData(auxGeoCoord.longitude, auxGeoCoord.latitude, auxGeoCoord.altitude, BasicVehicle.degreeValidator(heading), geoLocData.pitch, geoLocData.roll, geoLocData, magoManager);

	//헤딩이 변할 시 화살표 업데이트 해줘야함.
	this.update(magoManager);
};
Vehicle.prototype.move = function(magoManager) 
{
	if (this.renderingFase === undefined || this.renderingFase === null) { this.renderingFase = magoManager.renderingFase; }
	if (this.renderingFase === magoManager.renderingFase)
	{ return; }
	if (!this.eventStatus.footOnAccel && this.frontCurrentSpeed === 0) { return; }
	
	var frontSpeed = 1;
	var rearSpeed = 0.8;
	var currentTime = magoManager.getCurrentTime();
	if (!this.lastTime) { this._updateLastTime(currentTime); }

	var deltaTime = (currentTime - this.lastTime) / 1000;
	if (deltaTime === 0) { return; }

	var accel = this.eventStatus.footOnAccel ? this.frontAcceleration : -this.frontDeacceleration;
	this.frontCurrentSpeed = calculateSpeed(deltaTime, accel, this.frontCurrentSpeed);

	if (this.frontCurrentSpeed > this.maxSpeed) { this.frontCurrentSpeed = this.maxSpeed; }

	
	
	//this.frontDirection2D = this.getFrontDirection2D(new Point2D());
	//this.rearDirection2D = this.getRearDirection2D(new Point2D());


	var mode = this.mode;
	switch (mode) 
	{
	//NORMAL
	case BasicVehicle.MODE.NORMAL : {
		this.moveNormal(deltaTime, magoManager);
		break;
	}
	case BasicVehicle.MODE.CIRCULAR_ROTATION : {
		this.moveCircularRotation(deltaTime, magoManager);
		break;
	}
	case BasicVehicle.MODE.PARALLEL_TRANSLATE : {
		this.moveParallelTranslate(deltaTime, magoManager);
		break;
	}
	case BasicVehicle.MODE.PARALLEL_ROTATION : {
		this.moveParallelRotation(deltaTime, magoManager);
		break;
	}
	}

	var geoLocManager = this.geoLocDataManager;
	var geoLocData = geoLocManager.getCurrentGeoLocationData();

	var geoCoord = geoLocData.geographicCoord;
	var tile = this.smartTileOwner;
	var lon = geoCoord.longitude;
	var lat = geoCoord.latitude;
	
	if (!tile.intersectPoint(lon, lat))
	{
		tile.eraseObjectByComparision(this, 'name');
		var targetDepth = tile.depth;
		
		magoManager.smartTileManager.putObject(targetDepth, this, magoManager);
	}
	
	//시간 초기화
	if (this.frontCurrentSpeed === 0 && !this.eventStatus.footOnAccel) { currentTime = undefined; }
	this._updateLastTime(currentTime);

	this.renderingFase = !this.renderingFase;

	this.updateContainer(magoManager);
	function calculateSpeed(dTime, acc, currentSpeed) 
	{
		var deltaSpeed = acc * dTime;
		currentSpeed = currentSpeed + deltaSpeed;

		if (currentSpeed < 0) { currentSpeed = 0; }
		return currentSpeed;
	}
};
/**
 * @return {Point2D}
 */
Vehicle.prototype.getFrameDirection2D = function(resultPoint2D)
{
	if (!resultPoint2D) { resultPoint2D = new Point2D(); }
	var geoLocManager = this.geoLocDataManager;
	var geoLocData = geoLocManager.getCurrentGeoLocationData();
	var heading = geoLocData.heading;

	var headingRad = heading * Math.PI / 180;
	resultPoint2D.set(-Math.sin(headingRad), Math.cos(headingRad));
	
	return resultPoint2D;
};
/**
 * @return {Point2D}
 */
Vehicle.prototype.getFrontDirection2D = function(resultPoint2D)
{
	if (!resultPoint2D) { resultPoint2D = new Point2D(); }
	var frontAngleRad = this.frontAngleDeg * Math.PI / 180;
	resultPoint2D.set(-Math.sin(frontAngleRad), Math.cos(frontAngleRad));
	return resultPoint2D;
};
/**
 * @return {Point2D}
 */
Vehicle.prototype.getRearDirection2D = function(resultPoint2D) 
{
	if (!resultPoint2D) { resultPoint2D = new Point2D(); }
	var rearAngleRad = this.rearAngleDeg * Math.PI / 180;
	resultPoint2D.set(-Math.sin(rearAngleRad), Math.cos(rearAngleRad));
	return resultPoint2D;
};
Vehicle.prototype.footOnAccel = function() 
{
	this.eventStatus.footOnAccel = true;
	this.accelStatus = BasicVehicle.ACCEL_STATUS.FORWARD;
};
Vehicle.prototype.footOnReverseAccel = function() 
{
	this.eventStatus.footOnAccel = true;
	this.accelStatus = BasicVehicle.ACCEL_STATUS.REVERSE;
};
Vehicle.prototype.footOffAccel = function() 
{
	this.eventStatus.footOnAccel = false;
};
Vehicle.prototype.arrowDirectionChanged = function(magoManager) 
{
	//front arrow
	this.update(magoManager);
	var frontDirection2D = this.frontDirection2D;//this.getFrontDirection2D(new Point2D());
	var rearDirection2D = this.rearDirection2D;//this.getRearDirection2D(new Point2D());

	var error = 0.1;
	this.isParallelDirection = frontDirection2D.isParallelToPoint(rearDirection2D, error);

	if (!this.isParallelDirection) 
	{
		var frontArrowPos = this.frontArrowPos;
		var rearArrowPos = this.rearArrowPos;

		var frontArrowSegment = new Segment2D(new Point2D(frontArrowPos.x, frontArrowPos.y), new Point2D(frontArrowPos.x + frontDirection2D.x, frontArrowPos.y + frontDirection2D.y));
		var rearArrowSegment = new Segment2D(new Point2D(rearArrowPos.x, rearArrowPos.y),  new Point2D(rearArrowPos.x + rearDirection2D.x, rearArrowPos.y + rearDirection2D.y));

		this.frontLine2D = frontArrowSegment.getLine(); 
		this.rearLine2D = rearArrowSegment.getLine();
		
		var frontLine2D = this.frontLine2D;
		var rearLine2D = this.rearLine2D;
		//getPerpendicularRight
		var frontLinePerpendicular2D = frontLine2D.getPerpendicularRight();
		var rearLinePerpendicular2D = rearLine2D.getPerpendicularRight();

		var intersectPoint2D = frontLinePerpendicular2D.intersectionWithLine(rearLinePerpendicular2D);

		if (!intersectPoint2D) { return; }
		
		this.setPivotPointLC(intersectPoint2D.x, intersectPoint2D.y, 0, magoManager);
		this.guidePoint.deleteObjects(magoManager);
		this.guidePoint.addPoint(new Point3D(this.pivotPointLC.x, this.pivotPointLC.y, 2.2));

		var translationVector = new Point2D(intersectPoint2D.x, intersectPoint2D.y);
		translationVector.inverse();

		this.auxOffsetVector = translationVector;
	}
	else 
	{
		this.linearTrajectory();
		this.frontTrajectoryPointList.deleteVboKeysContainer(magoManager);
		this.rearTrajectoryPointList.deleteVboKeysContainer(magoManager);
	}
};
Vehicle.prototype.changeArrow = function(magoManager) 
{
	var isUpdate = false;
	var mode = this.mode;
	switch (mode) 
	{
	//NORMAL
	case BasicVehicle.MODE.NORMAL : {
		if (this.eventStatus.changingFrontArrow) 
		{
			var factor = this.changingFrontArrowSpeed;//(currTime - this.changingFrontArrowStartTime) /5000;
			if (this.changingFrontArrowType > 0) { factor = -factor; }
			this.frontAngleDeg = this.frontAngleDeg + factor;

			this.frontAngleDeg = BasicVehicle.degreeValidator(this.frontAngleDeg);
			isUpdate = true;
		}

		if (this.eventStatus.changingRearArrow) 
		{
			var factor = this.changingRearArrowSpeed;
			if (this.changingRearArrowType > 0) { factor = -factor; }
			this.rearAngleDeg = this.rearAngleDeg + factor;

			this.rearAngleDeg = BasicVehicle.degreeValidator(this.rearAngleDeg);
			isUpdate = true;
		}
		break;
	}
	case BasicVehicle.MODE.CIRCULAR_ROTATION : 
	case BasicVehicle.MODE.PARALLEL_TRANSLATE : {
		if (this.eventStatus.changingFrontArrow || this.eventStatus.changingRearArrow) 
		{
			var factor = this.changingFrontArrowSpeed;

			var arrowType = 0;
			if (this.eventStatus.changingFrontArrow) 
			{
				arrowType = this.changingFrontArrowType;
			}
			else 
			{ /*if(this.eventStatus.changingRearArrow){*/
				arrowType = this.changingRearArrowType;
			}

			if (arrowType > 0) { factor = -factor; }
			this.frontAngleDeg = this.frontAngleDeg + factor;
			this.rearAngleDeg = (mode === BasicVehicle.MODE.CIRCULAR_ROTATION) ? -this.frontAngleDeg : this.frontAngleDeg; 

			isUpdate = true;
		} 

		break;
	}
	case BasicVehicle.MODE.PARALLEL_ROTATION : {
		this.frontAngleDeg = this.PARALLEL_ROTATION_ANGLE;
		this.rearAngleDeg = this.PARALLEL_ROTATION_ANGLE;

		isUpdate = true;
		break;
	}
	}
	if (isUpdate) { this.arrowDirectionChanged(magoManager); }
};
Vehicle.prototype.update = function(magoManager) 
{
	//front arrow
	var frontArrow = this.frontArrow;

	var frontTranslateAuxMat = new Matrix4();
	frontTranslateAuxMat.setTranslation(this.frontArrowPos.x, this.frontArrowPos.y, this.frontArrowPos.z);
	var frontRotAuxMat = new Matrix4();
	frontRotAuxMat.rotationAxisAngDeg(this.frontAngleDeg, 0, 0, 1);

	this.frontDirection2D = this.getFrontDirection2D();
	var frontTAuxMat = frontRotAuxMat.getMultipliedByMatrix(frontTranslateAuxMat);
	frontArrow.tMatOriginal = frontTAuxMat;
	//rear arrow
	var rearArrow = this.rearArrow;
	var rearTranslateAuxMat = new Matrix4();
	rearTranslateAuxMat.setTranslation(this.rearArrowPos.x, this.rearArrowPos.y, this.rearArrowPos.z);
	var rearRotAuxMat = new Matrix4();
	rearRotAuxMat.rotationAxisAngDeg(this.rearAngleDeg, 0, 0, 1);

	this.rearDirection2D = this.getRearDirection2D();
	var rearTAuxMat = rearRotAuxMat.getMultipliedByMatrix(rearTranslateAuxMat);
	rearArrow.tMatOriginal = rearTAuxMat;

	var pivotPointLc = this.pivotPointLC;
	if (!pivotPointLc || pivotPointLc.x === Infinity) 
	{ 
		for (var i=0, len=this.objectsArray.length; i<len;i++)
		{
			var object = this.objectsArray[i];
			if (object instanceof Box || object instanceof Arrow || object instanceof Point3DList) { continue; }
			
			
			var pos = object.orginShimmyPos;

			var shimmyTranslateAuxMat = new Matrix4();
			shimmyTranslateAuxMat.setTranslation(pos.x, pos.y, pos.z);
			var shimmyRotAuxMat = new Matrix4();

			shimmyRotAuxMat.rotationAxisAngDeg(this.frontAngleDeg, 0, 0, 1);

			var tAuxMat = shimmyRotAuxMat.getMultipliedByMatrix(shimmyTranslateAuxMat);
			object.tMatOriginal = tAuxMat;
		}
	}
	else 
	{
		var pivotPoint2D = new Point2D(pivotPointLc.x, pivotPointLc.y);
		var auxDirction =  new Point2D(0, 1);
		for (var i=0, len=this.objectsArray.length; i<len;i++)
		{
			var object = this.objectsArray[i];
			if (object instanceof Box || object instanceof Arrow || object instanceof Point3DList) { continue; }
			
			
			var pos = object.orginShimmyPos;

			var shimmyTranslateAuxMat = new Matrix4();
			shimmyTranslateAuxMat.setTranslation(pos.x, pos.y, pos.z);
			var shimmyRotAuxMat = new Matrix4();

			var direction = pivotPoint2D.getVectorToPoint(new Point2D(pos.x, pos.y));
			direction.unitary();
			var auxAngleDeg = auxDirction.angleDegToVector(direction);

			var angleDeg = 90 - auxAngleDeg;
			if (direction.x < 0) { angleDeg *= -1; }

			shimmyRotAuxMat.rotationAxisAngDeg(angleDeg, 0, 0, 1);

			var tAuxMat = shimmyRotAuxMat.getMultipliedByMatrix(shimmyTranslateAuxMat);
			object.tMatOriginal = tAuxMat;
		}
	}

	this.updateMatrix();
};

Vehicle.prototype.getShimmyGearAssembly = function() 
{
	var ShimmyGearAssembly = function(width, length, height, options) 
	{
		MagoRenderable.call(this);
		this.width = width;
		this.height = height;
		this.wheelRadius = this.height * 0.4;
		this.frameLength = length * 0.4;
		this.frameHeight = this.height - this.wheelRadius*0.5;

		this.frame;
	};
	ShimmyGearAssembly.prototype = Object.create(MagoRenderable.prototype);
	ShimmyGearAssembly.prototype.constructor = ShimmyGearAssembly;

	ShimmyGearAssembly.prototype.makeMesh = function() 
	{
		if (this.objectsArray === undefined)
		{ this.objectsArray = []; }

		if (this.objectsMap === undefined)
		{ this.objectsMap = {}; }

		//frame
		var profile2dAux = new Profile2D();
	
		// Outer ring.**
		var outerRing = profile2dAux.newOuterRing();
		var frameHalfLength = this.frameLength * 0.5;
		var frameWidth = this.width * 0.25;

		var polyline = outerRing.newElement("POLYLINE");
		polyline.newPoint2d(frameHalfLength, 0);
		polyline.newPoint2d(-frameHalfLength, 0);
		polyline.newPoint2d(-frameHalfLength, -this.frameHeight);
		polyline.newPoint2d(frameHalfLength, -this.frameHeight);
		polyline.newPoint2d(frameHalfLength * 2.5, -this.frameHeight * 0.5);

		var extrusionDist = frameWidth;
		var extrudeSegmentsCount = 1;
		var extrusionVector = undefined;
		var bIncludeBottomCap = true;
		var bIncludeTopCap = true;
		
		var mesh = Modeler.getExtrudedMesh(profile2dAux, extrusionDist, extrudeSegmentsCount, extrusionVector, bIncludeBottomCap, bIncludeTopCap, undefined);
		mesh.name = 'frame';
		mesh.rotate(90, 1, 0, 0);
		mesh.rotate(90, 0, 0, 1);
		mesh.translate(-extrusionDist * 0.5, 0, 0);

		this.objectsArray.push(mesh);
		this.objectsMap[mesh.name] = mesh;

		var exteriorRadius = this.wheelRadius;
		var interiorRadius = exteriorRadius * 0.5;
		var wheelWidth = this.width * 0.5 - frameWidth*0.5;
        
		var leftWheel = new Wheel(interiorRadius, exteriorRadius, wheelWidth, {borderRadius: wheelWidth * 0.2});
		var rightWheel = new Wheel(interiorRadius, exteriorRadius, wheelWidth, {borderRadius: wheelWidth * 0.2});
		leftWheel.setOneColor(0.1, 0.1, 0.15, 1);
		rightWheel.setOneColor(0.1, 0.1, 0.15, 1);
		this.objectsArray.push(leftWheel);
		this.objectsArray.push(rightWheel);

		var leftWheelTranslation = new Point3D(-frameWidth*0.5-wheelWidth*0.5, 0, -this.height + exteriorRadius);
		var rightWheelTranslation = new Point3D(frameWidth*0.5+wheelWidth*0.5, 0, -this.height + exteriorRadius);

		leftWheel.tMatOriginal = new Matrix4();
		leftWheel.tMatOriginal.setTranslation(leftWheelTranslation.x, leftWheelTranslation.y, leftWheelTranslation.z);

		rightWheel.tMatOriginal = new Matrix4();
	    rightWheel.tMatOriginal.setTranslation(rightWheelTranslation.x, rightWheelTranslation.y, rightWheelTranslation.z);

		this.dirty = false;
	};
	ShimmyGearAssembly.prototype.renderAsChild = function(magoManager, shader, renderType, glPrimitive) 
	{
		if (this.attributes && this.attributes.isVisible !== undefined && this.attributes.isVisible === false) 
		{
			return;
		}

		if (this.dirty)
		{ this.makeMesh(); }
		
		if (this.objectsArray === undefined)
		{ return false; }


		
		// Set geoLocation uniforms.***
		var gl = magoManager.getGl();
		gl.uniform1i(shader.refMatrixType_loc, 0); // in magoManager case, there are not referencesMatrix.***
		var isSelected = false;
		
		if (renderType === 0)
		{
			// Depth render.***
		}
		else if (renderType === 1)
		{
			// Color render.***
			// Color render.***
			var selectionManager = magoManager.selectionManager;
			if (selectionManager.isObjectSelected(this))
			{ isSelected = true; }
		
			//gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );
			gl.enable(gl.BLEND);
			gl.uniform1i(shader.bApplySsao_loc, true); // apply ssao.***
			gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.***
			if (this.color4) 
			{
				gl.uniform4fv(shader.oneColor4_loc, [this.color4.r, this.color4.g, this.color4.b, 1.0]);
			}
		}
		else if (renderType === 2)
		{
			// Selection render.***
			var selectionColor = magoManager.selectionColor;
			var colorAux = magoManager.selectionColor.getAvailableColor(undefined);
			var idxKey = magoManager.selectionColor.decodeColor3(colorAux.r, colorAux.g, colorAux.b);
			magoManager.selectionManager.setCandidateGeneral(idxKey, this);
			
			gl.uniform4fv(shader.oneColor4_loc, [colorAux.r/255.0, colorAux.g/255.0, colorAux.b/255.0, 1.0]);
			gl.disable(gl.BLEND);
		}
		
		
		if (isSelected)
		{
			if (this.selColor4 === undefined)
			{
				this.selColor4 = new Color();
				this.selColor4.setRGBA(0.8, 0.4, 0.5, 1.0);
			}
			gl.uniform4fv(shader.oneColor4_loc, [this.selColor4.r, this.selColor4.g, this.selColor4.b, 1.0]); 
		}
		//shader.disableVertexAttribArrayAll();
		//shader.enableVertexAttribArray(shader.position3_loc);
		//shader.enableVertexAttribArray(shader.normal3_loc);
		if (this.tMat) 
		{
			gl.uniformMatrix4fv(shader.buildingRotMatrix_loc, false, this.tMat._floatArrays);
		}
		
		var objectsCount = this.objectsArray.length;

		for (var i=0; i<objectsCount; i++)
		{
			var object = this.objectsArray[i];
			object.renderAsChild(magoManager, shader, renderType, glPrimitive, isSelected);
		}
		
		gl.disable(gl.BLEND);
	};
    
	return ShimmyGearAssembly;
};



Vehicle.prototype.setPivotPointLC = function(x, y, z, magoManager) 
{
	if (!this.pivotPointLC) { this.pivotPointLC = new Point3D(); }
	this.pivotPointLC.set(x, y, z);

	//calculate trajectory points
	var mode = this.mode;	
	
	switch (mode) 
	{
	//NORMAL
	case BasicVehicle.MODE.NORMAL : {
		if (this.isParallelDirection) 
		{
			//
			this.linearTrajectory();
		}
		else 
		{
			//
			this.circleTrajectory();
		}
		break;
	}
	case BasicVehicle.MODE.PARALLEL_TRANSLATE : {
		this.linearTrajectory();
		break;
	}
	case BasicVehicle.MODE.CIRCULAR_ROTATION : 
	case BasicVehicle.MODE.PARALLEL_ROTATION : {
		this.circleTrajectory();
		break;
	}
	}

	this.frontTrajectoryPointList.deleteVboKeysContainer(magoManager);
	this.rearTrajectoryPointList.deleteVboKeysContainer(magoManager);
};


Vehicle.prototype.linearTrajectory = function() 
{
	var pointCount = this.frontTrajectoryPointList.getPointsCount();
	var increDist = this.trajectoryLength / pointCount;
	for (var i=0;i<pointCount;i++)
	{
		var frontTPoint = this.frontTrajectoryPointList.getPoint(i);
		var rearTPoint = this.rearTrajectoryPointList.getPoint(i);

		frontTPoint.set(this.frontDirection2D.x * increDist * (i+1), this.frontDirection2D.y * increDist * (i+1), this.height);
		rearTPoint.set(this.frontDirection2D.x * -increDist * (i+1), this.frontDirection2D.y * -increDist * (i+1), this.height);
	}
};

Vehicle.prototype.circleTrajectory = function() 
{
	if (!this.pivotPointLC) { return; }

	var pointCount = this.frontTrajectoryPointList.getPointsCount();
	var pivotPoint2DLC = new Point2D(-this.pivotPointLC.x, -this.pivotPointLC.y);
	var xAxis2D = new Point2D(1, 0);
	var startAngleRad =pivotPoint2DLC.angleRadToVector(xAxis2D);
	if (pivotPoint2DLC.y < 0) { startAngleRad*= -1; }

	var pivotPointLength = pivotPoint2DLC.getModul();
	var totalAngleRad = this.trajectoryLength / pivotPointLength;
	var icreAngleRad = totalAngleRad /  (pointCount-1);
		
	for (var i=0;i<pointCount;i++)
	{
		var frontTPoint = this.frontTrajectoryPointList.getPoint(i);
		var rearTPoint = this.rearTrajectoryPointList.getPoint(i);

		var frontCurrAngleRad = startAngleRad + (i * icreAngleRad);
		var rearCurrAngleRad = startAngleRad + (i * -icreAngleRad);
		frontTPoint.set(-pivotPoint2DLC.x + pivotPointLength * Math.cos(frontCurrAngleRad), -pivotPoint2DLC.y + pivotPointLength * Math.sin(frontCurrAngleRad), this.height);
		rearTPoint.set(-pivotPoint2DLC.x + pivotPointLength * Math.cos(rearCurrAngleRad), -pivotPoint2DLC.y + pivotPointLength * Math.sin(rearCurrAngleRad), this.height);
	}
};





'use strict';

/**
 * @typedef
 * @property {number} interiorRadius
 * @property {number} exteriorRadius
 * @property {number} width
 * @property {object} options
 */

/**
 * @param {*} option 
 * @class Wheel
 */
var Wheel = function(interiorRadius, exteriorRadius, width, options)
{
	MagoRenderable.call(this);
	if (!(this instanceof Wheel)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
    
	this.intRadius = 10;
	this.extRadius = 20;
	this.width = 5;
	this.color4 = new Color();
	this.color4.setRGBA(0.2, 0.2, 0.25, 1);
    
	if (interiorRadius !== undefined)
	{ this.intRadius = interiorRadius; }
	
	if (exteriorRadius !== undefined)
	{ this.extRadius = exteriorRadius; }
	
	if (width !== undefined)
	{ this.width = width; }
    
	this.borderRadius = (this.extRadius - this.intRadius ) * 0.2;
    
	if (options !== undefined)
	{
		var color = options.color;
		if (color)
		{
			this.color4.setRGBA(color.r, color.g, color.b, color.a);
		}
		var borderRadius = options.borderRadius;
		if (borderRadius) 
		{
			this.borderRadius = borderRadius;
		}
	}
    
	this.width < this.borderRadius, this.borderRadius = this.width * 0.2;
};
Wheel.prototype = Object.create(MagoRenderable.prototype);
Wheel.prototype.constructor = Wheel;
/**
 * Makes the geometry mesh.
 */
Wheel.prototype.makeMesh = function()
{
	var profile2dAux = new Profile2D();
	
	// Outer ring.**
	var outerRing = profile2dAux.newOuterRing();

	var halfWidth = this.width * 0.5;
	var exteriorRadiusWithoutBorder = this.extRadius - this.borderRadius;

	var polyline = outerRing.newElement("POLYLINE");
	polyline.newPoint2d(-halfWidth, this.intRadius);            
	polyline.newPoint2d(halfWidth, this.intRadius);             
	polyline.newPoint2d(halfWidth, exteriorRadiusWithoutBorder);

	var rightArc = outerRing.newElement("ARC");
	rightArc.setCenterPosition(halfWidth - this.borderRadius, exteriorRadiusWithoutBorder);
	rightArc.setRadius(this.borderRadius);
	rightArc.setStartAngleDegree(0);
	rightArc.setSweepAngleDegree(90);
    
	var polylineUpper = outerRing.newElement("POLYLINE");
	polylineUpper.newPoint2d(halfWidth - this.borderRadius, this.extRadius);
	polylineUpper.newPoint2d(-halfWidth + this.borderRadius, this.extRadius);

	var leftArc = outerRing.newElement("ARC");
	leftArc.setCenterPosition(-halfWidth + this.borderRadius, exteriorRadiusWithoutBorder);
	leftArc.setRadius(this.borderRadius);
	leftArc.setStartAngleDegree(90);
	leftArc.setSweepAngleDegree(90);

	var polylineLeft = outerRing.newElement("POLYLINE");
	polylineLeft.newPoint2d(-halfWidth, exteriorRadiusWithoutBorder);
	
	var revolveAngDeg = 360;
	var revolveSegmentsCount = 18;
	var revolveSegment2d = new Segment2D();
	var strPoint2d = new Point2D(-1, 0);
	var endPoint2d = new Point2D(1, 0);
	revolveSegment2d.setPoints(strPoint2d, endPoint2d);
	var bIncludeBottomCap = false;
	var bIncludeTopCap = false;
	var mesh = Modeler.getRevolvedSolidMesh(profile2dAux, revolveAngDeg, revolveSegmentsCount, revolveSegment2d, bIncludeBottomCap, bIncludeTopCap, undefined);
	this.mesh = mesh.getCopySurfaceIndependentMesh(mesh);
	this.dirty = false;
};

/**
 * Renders the factory.
 */
Wheel.prototype.render = function(magoManager, shader, renderType, glPrimitive)
{
	if (this.attributes && this.attributes.isVisible !== undefined && this.attributes.isVisible === false) 
	{
		return;
	}
	if (this.dirty)
	{ this.makeMesh(); }
	
	if (this.mesh === undefined)
	{ return false; }

	// Set geoLocation uniforms.***
	
	var gl = magoManager.getGl();
	if (!this.geoLocDataManager) { return; }

	var buildingGeoLocation = this.geoLocDataManager.getCurrentGeoLocationData();
	buildingGeoLocation.bindGeoLocationUniforms(gl, shader); // rotMatrix, positionHIGH, positionLOW.
	
	gl.uniform1i(shader.refMatrixType_loc, 0); // in magoManager case, there are not referencesMatrix.***
	gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.***
	
	if (renderType === 2)
	{
		// Selection render.***
		var selectionColor = magoManager.selectionColor;
		var colorAux = magoManager.selectionColor.getAvailableColor(undefined);
		var idxKey = magoManager.selectionColor.decodeColor3(colorAux.r, colorAux.g, colorAux.b);
		magoManager.selectionManager.setCandidateGeneral(idxKey, this);
		
		gl.uniform4fv(shader.oneColor4_loc, [colorAux.r/255.0, colorAux.g/255.0, colorAux.b/255.0, 1.0]);
		gl.disable(gl.BLEND);
	}
	
	this.mesh.render(magoManager, shader, renderType, glPrimitive);

	gl.disable(gl.BLEND);
};


/**
 * Renders the factory.
 */
Wheel.prototype.renderAsChild = function(magoManager, shader, renderType, glPrimitive)
{
	if (this.attributes && this.attributes.isVisible !== undefined && this.attributes.isVisible === false) 
	{
		return;
	}
	if (this.dirty)
	{ this.makeMesh(); }
	
	if (this.mesh === undefined)
	{ return false; }

	// Set geoLocation uniforms.***
	
	var gl = magoManager.getGl();
	var bIsSelected = false;
	if (renderType === 1)
	{
		// Color render.***
		//gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );
		gl.enable(gl.BLEND);
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.***
		
		// Check if is selected.***
		var selectionManager = magoManager.selectionManager;
		if (bIsSelected !== undefined && bIsSelected)
		{
			//gl.disable(gl.BLEND);
			if (this.color4) 
			{
				gl.uniform4fv(shader.oneColor4_loc, [this.color4.r, this.color4.g, this.color4.b, 1.0]);
			}
			
		}
		else if (selectionManager.isObjectSelected(this))
		{
			//gl.disable(gl.BLEND);
			gl.uniform4fv(shader.oneColor4_loc, [0.9, 0.1, 0.1, 1.0]);
		}
		else 
		{
			if (this.color4) 
			{
				gl.uniform4fv(shader.oneColor4_loc, [this.color4.r, this.color4.g, this.color4.b, 1.0]);
			}
		}
		
	}
	else if (renderType === 2)
	{
		// Selection render.***
		var selectionColor = magoManager.selectionColor;
		var colorAux = magoManager.selectionColor.getAvailableColor(undefined);
		var idxKey = magoManager.selectionColor.decodeColor3(colorAux.r, colorAux.g, colorAux.b);
		magoManager.selectionManager.setCandidateGeneral(idxKey, this);
		
		gl.uniform4fv(shader.oneColor4_loc, [colorAux.r/255.0, colorAux.g/255.0, colorAux.b/255.0, 1.0]);
		gl.disable(gl.BLEND);
	}

	if (this.tMat) 
	{
		gl.uniformMatrix4fv(shader.buildingRotMatrix_loc, false, this.tMat._floatArrays);
	}
	
	this.mesh.render(magoManager, shader, renderType, glPrimitive);

	gl.disable(gl.BLEND);
};
'use strict';

/**
 * This class contains the current objects that are rendering. 
 * @class CurrentObjectsRendering
 */
var CurrentObjectsRendering = function() 
{
	if (!(this instanceof CurrentObjectsRendering)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	/**
	 * The current node that is in rendering process.
	 * @type {Node}
	 * @default undefined
	 */
	this.curNode = undefined;
	
	/**
	 * The current building that is in rendering process.
	 * @type {NeoBuilding}
	 * @default undefined
	 */
	this.curBuilding = undefined;
	
	/**
	 * The current octree (octree of a building) that is in rendering process.
	 * @type {Octree}
	 * @default undefined
	 */
	this.curOctree = undefined;
	
	/**
	 * The current object that is in rendering process.
	 * @type {NeoReference}
	 * @default undefined
	 */
	this.curObject = undefined;
};


/**
 * This class manages the rendering of all classes.
 * @class Renderer
 */
var Renderer = function(manoManager) 
{
	if (!(this instanceof Renderer)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	/**
	 * The current objects that is in rendering process.
	 * @type {CurrentObjectsRendering}
	 * @default CurrentObjectsRendering
	 */
	this.currentObjectsRendering = new CurrentObjectsRendering();
	
	/**
	 * This parameter indicates that if is using normals in the shader.
	 * @type {Boolean}
	 * @default true
	 */
	this.renderNormals = true;
	
	/**
	 * This parameter indicates that if is using textures in the shader.
	 * @type {Boolean}
	 * @default true
	 */
	this.renderTexture = true;
	
	/**
	 * The main mago3d class. This object manages the main pipe-line of the Mago3D.
	 * @type {ManoManager}
	 * @default ManoManager
	 */
	this.magoManager = manoManager;
};

/**
 * This function renders all nodes of "visibleNodesArray".
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Array} visibleNodesArray Array that contains the nodes to render.
 * @param {ManoManager} magoManager The main mago3d class. This object manages the main pipe-line of the Mago3D.
 * @param {PostFxShader} shader The PostFxShader class object.
 * @param {Boolean} renderTexture This parameter indicates that if is using textures in the shader.
 * @param {Number} renderType If renderType = 0 (depth render), renderType = 1 (color render), renderType = 2 (colorCoding render).
 * @param {Number} maxSizeToRender This parameter limites the minimum size in the rendering process.
 * @param {Number} refMatrixIdxKey Indicates the references transformation matrix index.
 */
Renderer.prototype.renderNodes = function(gl, visibleNodesArray, magoManager, shader, renderTexture, renderType, maxSizeToRender, refMatrixIdxKey) 
{
	// do render.
	var node;
	var nodesCount = visibleNodesArray.length;
	
	var sceneState = magoManager.sceneState;
	var bApplyShadow = sceneState.applySunShadows;
	if (bApplyShadow && renderType === 1)
	{
		var light0 = sceneState.sunSystem.getLight(0);
		var light0MaxDistToCam = light0.maxDistToCam;
		var light0BSphere = light0.bSphere;
		if (light0BSphere === undefined)
		{ return; }
	
		var light0Radius = light0BSphere.getRadius();
		
		var light0CenterPoint = light0BSphere.getCenterPoint();
		for (var i=0; i<nodesCount; i++)
		{
			node = visibleNodesArray[i];
			
			// now check if the node is inside of the light0 bSphere.
			var bboxAbsoluteCenterPos = node.bboxAbsoluteCenterPos;
			if (bboxAbsoluteCenterPos === undefined)
			{ 
				gl.uniform1i(shader.sunIdx_loc, 1);
			}
			else
			{
				var bbox = node.data.bbox;
				var radiusAprox = bbox.getRadiusAprox();
				var distToLight0 = light0CenterPoint.distToPoint(bboxAbsoluteCenterPos);//+radiusAprox;
				
				if (distToLight0 < light0Radius)
				{
					gl.uniform1i(shader.sunIdx_loc, 0);
				}
				else
				{
					gl.uniform1i(shader.sunIdx_loc, 1);
				}
			}
			node.renderContent(magoManager, shader, renderType, refMatrixIdxKey);
		}
	}
	else
	{
		for (var i=0; i<nodesCount; i++)
		{
			node = visibleNodesArray[i];
			node.renderContent(magoManager, shader, renderType, refMatrixIdxKey);
		}
	}
	
	
	
};

/**
 * This function returns the vertices count recommended to render for determined distance to camera.
 * @param {Number} distToCam WebGL Rendering Context.
 * @param {Number} realPointsCount The real current points count.
 * @param {ManoManager} magoManager The main mago3d class. This object manages the main pipe-line of the Mago3D.
 */
Renderer.prototype.getPointsCountForDistance = function(distToCam, realPointsCount, magoManager) 
{
	var vertices_count = realPointsCount;
	var pCloudSettings = magoManager.magoPolicy.getPointsCloudSettings();
		
	if (distToCam <= 10)
	{
		// Render all points.
		vertices_count =  Math.floor(pCloudSettings.MaxPerUnitPointsRenderDistToCam0m * realPointsCount);
	}
	else if (distToCam < 100)
	{
		vertices_count = Math.floor(pCloudSettings.MaxPerUnitPointsRenderDistToCam100m * realPointsCount);
	}
	else if (distToCam < 200)
	{
		vertices_count = Math.floor(pCloudSettings.MaxPerUnitPointsRenderDistToCam200m * realPointsCount);
	}
	else if (distToCam < 400)
	{
		vertices_count = Math.floor(pCloudSettings.MaxPerUnitPointsRenderDistToCam400m * realPointsCount);
	}
	else if (distToCam < 800)
	{
		vertices_count = Math.floor(pCloudSettings.MaxPerUnitPointsRenderDistToCam800m * realPointsCount);
	}
	else if (distToCam < 1600)
	{
		vertices_count = Math.floor(pCloudSettings.MaxPerUnitPointsRenderDistToCam1600m * realPointsCount);
	}
	else
	{
		vertices_count = Math.floor(pCloudSettings.MaxPerUnitPointsRenderDistToCamMoreThan1600m * realPointsCount);
	}
	
	return vertices_count;
};

/**
 * This function renders the pCloud object. The pCloud object is "Lego" class.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Lego} pCloud The points cloud data to render.
 * @param {ManoManager} magoManager The main mago3d class. This object manages the main pipe-line of the Mago3D.
 * @param {PostFxShader} shader The PostFxShader class object.
 * @param {Number} renderType If renderType = 0 (depth render), renderType = 1 (color render), renderType = 2 (colorCoding render).
 * @param {Number} distToCam The current distance to camera.
 */
Renderer.prototype.renderPCloud = function(gl, pCloud, magoManager, shader, renderType, distToCam) 
{
	// Note: "pCloud" is "Lego" class.
	if (pCloud.vbo_vicks_container.vboCacheKeysArray.length === 0) 
	{
		return;
	}
	gl.frontFace(gl.CCW);
	
	var vbo_vicky = pCloud.vbo_vicks_container.vboCacheKeysArray[0]; // there are only one.
	var vertices_count = vbo_vicky.vertexCount;
	
	if (vertices_count === 0) 
	{ return; }
	
	var pointsCountToDraw = this.getPointsCountForDistance(distToCam, vertices_count, magoManager);
	
	if (magoManager.isCameraMoving)// && !isInterior && magoManager.isCameraInsideBuilding)
	{
		pointsCountToDraw = Math.floor(pointsCountToDraw/5);
	}

	if (pointsCountToDraw <= 0)
	{ return; }

	if (renderType === 0) // depth.
	{
		// 1) Position.
		if (!vbo_vicky.bindDataPosition(shader, magoManager.vboMemoryManager))
		{ return false; }
		
		gl.drawArrays(gl.POINTS, 0, pointsCountToDraw);
	}
	else if (renderType === 1) // color.
	{
		if (!vbo_vicky.bindDataPosition(shader, magoManager.vboMemoryManager))
		{ return false; }

		if (!vbo_vicky.bindDataColor(shader, magoManager.vboMemoryManager))
		{ return false; }
		
		gl.drawArrays(gl.POINTS, 0, pointsCountToDraw);
		
		magoManager.sceneState.pointsRenderedCount += pointsCountToDraw;
		
	}
	
	
};

/**
 * This function renders the neoBuildings as points-cloud projects.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Array} visibleNodesArray Array that contains the nodes to render.
 * @param {ManoManager} magoManager The main mago3d class. This object manages the main pipe-line of the Mago3D.
 * @param {PostFxShader} shader The PostFxShader class object.
 * @param {Boolean} renderTexture This parameter indicates that if is using textures in the shader.
 * @param {Number} renderType If renderType = 0 (depth render), renderType = 1 (color render), renderType = 2 (colorCoding render).
 */
Renderer.prototype.renderNeoBuildingsPCloud = function(gl, visibleNodesArray, magoManager, shader, renderTexture, renderType) 
{
	var node;
	var rootNode;
	var geoLocDataManager;
	var neoBuilding;
	var lowestOctreesCount;
	var lowestOctree;
	var lastExtureId;
	
	// Do some gl settings.
	//gl.uniform1i(shader.bUse1Color_loc, false);
	gl.uniform1f(shader.fixPointSize_loc, 1.0);
	gl.uniform1i(shader.bUseFixPointSize_loc, false);
	
	var nodesCount = visibleNodesArray.length;
	for (var i=0; i<nodesCount; i++)
	{
		node = visibleNodesArray[i];
		
		var attributes = node.data.attributes;
		if (attributes)
		{
			if (attributes.isVisible !== undefined && attributes.isVisible === false) 
			{
				continue;
			}
		}

		rootNode = node.getRoot();
		geoLocDataManager = rootNode.data.geoLocDataManager;
		neoBuilding = node.data.neoBuilding;
		
		if (neoBuilding === undefined)
		{ continue; }
		
		if (neoBuilding.octree === undefined)
		{ continue; }

		var projectDataType = neoBuilding.metaData.projectDataType;
		
		var buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
		gl.uniformMatrix4fv(shader.buildingRotMatrix_loc, false, buildingGeoLocation.rotMatrix._floatArrays);
		gl.uniform3fv(shader.buildingPosHIGH_loc, buildingGeoLocation.positionHIGH);
		gl.uniform3fv(shader.buildingPosLOW_loc, buildingGeoLocation.positionLOW);
		
		if (projectDataType !== undefined && projectDataType === 5)
		{
			if (magoManager.myCameraRelative === undefined)
			{ magoManager.myCameraRelative = new Camera(); }

			var relativeCam = magoManager.myCameraRelative;
			relativeCam.frustum.copyParametersFrom(magoManager.myCameraSCX.bigFrustum);
			relativeCam = buildingGeoLocation.getTransformedRelativeCamera(magoManager.sceneState.camera, relativeCam);
			relativeCam.calculateFrustumsPlanes();
			var renderType = renderType;// testing.
			var bPrepareData = true;
			
			neoBuilding.octree.test__renderPCloud(magoManager, neoBuilding, renderType, shader, relativeCam, bPrepareData);
		}
	}
	
	shader.disableVertexAttribArrayAll();
};

/**
 * This function enables the webgl stencil-test option.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 */
Renderer.prototype.enableStencilBuffer = function(gl)
{
	// Active stencil if the object is selected.
	gl.enable(gl.STENCIL_TEST);
	
	gl.stencilFunc(gl.ALWAYS, 1, 1);
	// (stencil-fail: replace), (stencil-pass & depth-fail: replace), (stencil-pass & depth-pass: replace).
	//gl.stencilOp(gl.REPLACE, gl.REPLACE, gl.REPLACE);
	gl.stencilOp(gl.KEEP, gl.REPLACE, gl.REPLACE);
	gl.enable(gl.POLYGON_OFFSET_FILL);
};

/**
 * This function disables the webgl stencil-test option.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 */
Renderer.prototype.disableStencilBuffer = function(gl)
{
	gl.disable(gl.STENCIL_TEST);
	gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
	gl.disable(gl.POLYGON_OFFSET_FILL);
};

/**
 * This function renders provisional ParametricMesh objects that has no self render function.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {ParametricMesh} renderable ParametricMesh type object to render.
 * @param {ManoManager} magoManager The main mago3d class. This object manages the main pipe-line of the Mago3D.
 * @param {PostFxShader} shader The PostFxShader class object.
 * @param {Number} renderType If renderType = 0 (depth render), renderType = 1 (color render), renderType = 2 (colorCoding render).
 * @param {Boolean} bRenderLines Optional boolean. Indicates if render edges.
 */
Renderer.prototype.renderObject = function(gl, renderable, magoManager, shader, renderType, bRenderLines)
{
	// This function actually is used for axis (origin) object.
	var vbo_vicks_container = renderable.getVboKeysContainer();
	
	if (vbo_vicks_container === undefined)
	{ return; }
	
	if (vbo_vicks_container.vboCacheKeysArray.length === 0) 
	{ return; }
	
	if (bRenderLines === undefined)
	{ bRenderLines = false; }

	var vbosCount = vbo_vicks_container.getVbosCount();
	for (var i=0; i<vbosCount; i++)
	{
		// 1) Position.
		var vbo_vicky = vbo_vicks_container.vboCacheKeysArray[i]; // there are only one.

		var vertices_count = vbo_vicky.vertexCount;
		if (vertices_count === 0) 
		{ return; }

		if (!vbo_vicky.bindDataPosition(shader, magoManager.vboMemoryManager))
		{ return false; }

		if (renderType === 1) // ssao.
		{
			if (!vbo_vicky.bindDataNormal(shader, magoManager.vboMemoryManager))
			{ return false; }

			if (!vbo_vicky.bindDataColor(shader, magoManager.vboMemoryManager))
			{ return false; }
			
			// TexCoords todo:
		}
		
		if (bRenderLines === false)
		{
			if (vbo_vicky.indicesCount > 0)
			{
				if (!vbo_vicky.bindDataIndice(shader, magoManager.vboMemoryManager))
				{ return false; }

				gl.drawElements(gl.TRIANGLES, vbo_vicky.indicesCount, gl.UNSIGNED_SHORT, 0); // Fill.
			}
			else 
			{
				gl.drawArrays(gl.TRIANGLES, 0, vertices_count);
			}
		}
		else 
		{
			gl.drawArrays(gl.LINE_STRIP, 0, vertices_count);
			//gl.drawArrays(gl.TRIANGLES, 0, vertices_count);
		}
		
		var glError = gl.getError();
		if (glError !== gl.NO_ERROR)
		{ var hola = 0; }
	}
};


/**
 * This function renders provisional ParametricMesh objects that has no self render function.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Number} renderType If renderType = 0 (depth render), renderType = 1 (color render), renderType = 2 (colorCoding render).
 * @param {VisibleObjectsController} visibleObjControlerNodes This object contains visible objects for the camera frustum.
 */
Renderer.prototype.renderGeometryDepth = function(gl, renderType, visibleObjControlerNodes) 
{
	var currentShader;
	var shaderProgram;
	var renderTexture = false;
	
	var magoManager = this.magoManager;
	var renderType = 0;
	magoManager.currentProcess = CODE.magoCurrentProcess.DepthRendering;
	
	// Test Modeler Rendering.********************************************************************
	// Test Modeler Rendering.********************************************************************
	// Test Modeler Rendering.********************************************************************
	// tin terrain.***
	if (magoManager.tinTerrainManager !== undefined)
	{
		var bDepth = true;
		magoManager.tinTerrainManager.render(magoManager, bDepth, renderType);
		gl.useProgram(null);
	}
	
	if (magoManager.modeler !== undefined)
	{
		currentShader = magoManager.postFxShadersManager.getShader("modelRefDepth"); 
		currentShader.resetLastBuffersBinded();
		shaderProgram = currentShader.program;

		currentShader.useProgram();
		magoManager.effectsManager.setCurrentShader(currentShader);
		currentShader.disableVertexAttribArrayAll();
		currentShader.enableVertexAttribArray(currentShader.position3_loc);

		currentShader.bindUniformGenerals();
		gl.uniform3fv(currentShader.scaleLC_loc, [1.0, 1.0, 1.0]); // init referencesMatrix.
		
		gl.uniform1i(currentShader.bApplySsao_loc, false); // apply ssao.***

		var refTMatrixIdxKey = 0;
		var minSizeToRender = 0.0;
		
		var refMatrixIdxKey =0; // provisionally set this var here.***
		magoManager.modeler.render(magoManager, currentShader, renderType);

		currentShader.disableVertexAttribArrayAll();
		gl.useProgram(null);

	}

	if (visibleObjControlerNodes.hasRenderables())
	{
		// Make depth for all visible objects.***
		currentShader = magoManager.postFxShadersManager.getShader("modelRefDepth"); 
		currentShader.resetLastBuffersBinded();
		shaderProgram = currentShader.program;

		currentShader.useProgram();
		currentShader.disableVertexAttribArrayAll();
		currentShader.enableVertexAttribArray(currentShader.position3_loc);

		currentShader.bindUniformGenerals();
		gl.uniform3fv(currentShader.scaleLC_loc, [1.0, 1.0, 1.0]); // init referencesMatrix.
		
		// check if exist clippingPlanes.
		if (magoManager.modeler.clippingBox !== undefined)
		{
			var planesVec4Array = magoManager.modeler.clippingBox.getPlanesRelToEyevec4Array(magoManager);
			var planesVec4FloatArray = new Float32Array(planesVec4Array);
			
			//shader.bApplyClippingPlanes_loc = gl.getUniformLocation(shader.program, "bApplyClippingPlanes");
			//shader.clippingPlanesCount_loc = gl.getUniformLocation(shader.program, "clippingPlanesCount");
			//shader.clippingPlanes_loc = gl.getUniformLocation(shader.program, "clippingPlanes");
			
			gl.uniform1i(currentShader.bApplyClippingPlanes_loc, true);
			gl.uniform1i(currentShader.clippingPlanesCount_loc, 6);
			gl.uniform4fv(currentShader.clippingPlanes_loc, planesVec4FloatArray);
		}
		else 
		{
			gl.uniform1i(currentShader.bApplyClippingPlanes_loc, false);
		}
			

		// RenderDepth for all buildings.***
		var refTMatrixIdxKey = 0;
		var minSize = 0.0;
		// excavation objects.
		this.renderExcavationObjects(gl, currentShader, renderType, visibleObjControlerNodes);

		magoManager.renderer.renderNodes(gl, visibleObjControlerNodes.currentVisibles0, magoManager, currentShader, renderTexture, renderType, minSize, 0, refTMatrixIdxKey);
		magoManager.renderer.renderNodes(gl, visibleObjControlerNodes.currentVisibles2, magoManager, currentShader, renderTexture, renderType, minSize, 0, refTMatrixIdxKey);
		magoManager.renderer.renderNodes(gl, visibleObjControlerNodes.currentVisibles3, magoManager, currentShader, renderTexture, renderType, minSize, 0, refTMatrixIdxKey);
		// native objects.
		var bIncludeTransparentObjects = false;
		this.renderNativeObjects(gl, currentShader, renderType, visibleObjControlerNodes, bIncludeTransparentObjects);

		currentShader.disableVertexAttribArray(currentShader.position3_loc); 
		gl.useProgram(null);

	}

	// PointsCloud.****************************************************************************************
	// PointsCloud.****************************************************************************************
	var nodesPCloudCount = magoManager.visibleObjControlerNodes.currentVisiblesAux.length;
	if (nodesPCloudCount > 0)
	{
		currentShader = magoManager.postFxShadersManager.getShader("pointsCloudDepth");
		currentShader.useProgram();
		
		currentShader.resetLastBuffersBinded();
		currentShader.disableVertexAttribArrayAll();
		currentShader.enableVertexAttribArray(currentShader.position3_loc);
		
		currentShader.bindUniformGenerals();
		var pCloudSettings = magoManager.magoPolicy.getPointsCloudSettings();
		gl.uniform1f(currentShader.maxPointSize_loc, pCloudSettings.maxPointSize);
		gl.uniform1f(currentShader.minPointSize_loc, pCloudSettings.minPointSize);
		gl.uniform1f(currentShader.pendentPointSize_loc, pCloudSettings.pendentPointSize);
		
		// Test to load pCloud.***
		if (magoManager.visibleObjControlerPCloudOctrees === undefined)
		{ magoManager.visibleObjControlerPCloudOctrees = new VisibleObjectsController(); }
		magoManager.visibleObjControlerPCloudOctrees.clear();

		magoManager.renderer.renderNeoBuildingsPCloud(gl, magoManager.visibleObjControlerNodes.currentVisiblesAux, magoManager, currentShader, renderTexture, renderType); 
		currentShader.disableVertexAttribArrayAll();
		
		gl.useProgram(null);
		
		// Load pCloud data.***
		var visiblesSortedOctreesArray = magoManager.visibleObjControlerPCloudOctrees.currentVisibles0;
		var octreesCount = visiblesSortedOctreesArray.length;

		var loadCount = 0;
		if (!magoManager.isCameraMoving && !magoManager.mouseLeftDown && !magoManager.mouseMiddleDown)
		{
			for (var i=0; i<octreesCount; i++)
			{
				var octree = visiblesSortedOctreesArray[i];
				if (octree.preparePCloudData(magoManager))
				{
					loadCount++;
				}
				
				if (loadCount > 1)
				{ break; }
			}
		}

	}
	
	
	// Render cuttingPlanes of temperaturalayers if exist.***
	if (magoManager.weatherStation)
	{ magoManager.weatherStation.test_renderCuttingPlanes(magoManager, renderType); }
	
	
	
	// Test.***
	var selGeneralObjects = magoManager.selectionManager.getSelectionCandidatesFamily("general");
	if (selGeneralObjects)
	{
		var currObjectSelected = selGeneralObjects.currentSelected;
		if (currObjectSelected)
		{
			// check if is a cuttingPlane.***
			if (currObjectSelected instanceof CuttingPlane)
			{
				// Test. Render depth only for the selected object.***************************
				magoManager.test_renderDepth_objectSelected(currObjectSelected);
			}
		}
	}
	
	// Depth for silhouette.***************************************************************************************
	// Check if there are node selected.***********************************************************
	if (magoManager.nodeSelected && magoManager.magoPolicy.getObjectMoveMode() === CODE.moveMode.ALL && magoManager.buildingSelected)
	{
		var node = magoManager.nodeSelected;
		if (node !== undefined) // test code.***
		{
			magoManager.currentProcess = CODE.magoCurrentProcess.SilhouetteDepthRendering;
			var silhouetteDepthFbo = magoManager.getSilhouetteDepthFbo();
			silhouetteDepthFbo.bind(); 
			
			if (magoManager.isFarestFrustum())
			{
				gl.clearColor(0, 0, 0, 1);
				gl.clearDepth(1);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			}
			
			magoManager.swapRenderingFase();
			
			var currentShader;
			currentShader = magoManager.postFxShadersManager.getShader("modelRefDepth"); 
			currentShader.resetLastBuffersBinded();

			currentShader.useProgram();
			currentShader.disableVertexAttribArrayAll();
			currentShader.enableVertexAttribArray(currentShader.position3_loc);

			currentShader.bindUniformGenerals();
			gl.uniform3fv(currentShader.scaleLC_loc, [1.0, 1.0, 1.0]); // init referencesMatrix.
			
			// check if exist clippingPlanes.
			if (magoManager.modeler.clippingBox !== undefined)
			{
				var planesVec4Array = magoManager.modeler.clippingBox.getPlanesRelToEyevec4Array(magoManager);
				var planesVec4FloatArray = new Float32Array(planesVec4Array);
				
				gl.uniform1i(currentShader.bApplyClippingPlanes_loc, true);
				gl.uniform1i(currentShader.clippingPlanesCount_loc, 6);
				gl.uniform4fv(currentShader.clippingPlanes_loc, planesVec4FloatArray);
			}
			else 
			{
				gl.uniform1i(currentShader.bApplyClippingPlanes_loc, false);
			}
			
			var renderType = 0;
			var refMatrixIdxKey = 0;
			node.renderContent(magoManager, currentShader, renderType, refMatrixIdxKey);

			silhouetteDepthFbo.unbind(); 
			magoManager.swapRenderingFase();
		}
	}
	
	// Check if there are a object selected.**********************************************************************
	if (magoManager.magoPolicy.getObjectMoveMode() === CODE.moveMode.OBJECT && magoManager.objectSelected)
	{
		var node = magoManager.nodeSelected;
		var neoBuilding = magoManager.buildingSelected;
		if (magoManager.objectSelected instanceof NeoReference && node !== undefined && neoBuilding !== undefined) // test code.***
		{
			magoManager.currentProcess = CODE.magoCurrentProcess.SilhouetteDepthRendering;
			var geoLocDataManager = node.getNodeGeoLocDataManager();

			var buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
			var neoReferencesMotherAndIndices = magoManager.octreeSelected.neoReferencesMotherAndIndices;
			var glPrimitive = gl.POINTS;
			glPrimitive = gl.TRIANGLES;
			var maxSizeToRender = 0.0;
			var refMatrixIdxKey = 0;
			
			magoManager.currentProcess = CODE.magoCurrentProcess.StencilSilhouetteRendering;
			
			// do as the "getSelectedObjectPicking".**********************************************************
			var silhouetteDepthFbo = magoManager.getSilhouetteDepthFbo();
			silhouetteDepthFbo.bind(); 
				
			if (magoManager.isFarestFrustum())
			{
				gl.clearColor(0, 0, 0, 1);
				gl.clearDepth(1);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			}
				
			var currentShader;
			currentShader = magoManager.postFxShadersManager.getShader("modelRefDepth"); 
			currentShader.resetLastBuffersBinded();

			currentShader.useProgram();
			currentShader.disableVertexAttribArrayAll();
			currentShader.enableVertexAttribArray(currentShader.position3_loc);

			currentShader.bindUniformGenerals();
			gl.uniform3fv(currentShader.scaleLC_loc, [1.0, 1.0, 1.0]); // init referencesMatrix.
			
			buildingGeoLocation.bindGeoLocationUniforms(gl, currentShader);

			glPrimitive = gl.TRIANGLES;
			var localRenderType = 0; // only need positions.***
			var minSizeToRender = 0.0;
			var offsetSize = 3/1000;
			
			gl.disable(gl.CULL_FACE);
			
			magoManager.objectSelected.render(magoManager, neoBuilding, localRenderType, renderTexture, currentShader, refMatrixIdxKey, minSizeToRender);
			silhouetteDepthFbo.unbind(); 
			
			gl.enable(gl.CULL_FACE);
		}
	}
};

/**
 * This function renders the sunPointOfView depth.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {VisibleObjectsController} visibleObjControlerNodes This object contains visible objects for the camera frustum.
 */
Renderer.prototype.renderDepthSunPointOfView = function(gl, visibleObjControlerNodes, sunLight, sunSystem) 
{
	if (sunLight.tMatrix === undefined)
	{ return; }

	// collect all shadowCaster's nodes.
	//var resultVisiblesArray = [].concat(visibleObjControlerNodes.currentVisibles0, visibleObjControlerNodes.currentVisibles2, visibleObjControlerNodes.currentVisibles3);
	//var 
	
	var magoManager = this.magoManager;
	magoManager.currentProcess = CODE.magoCurrentProcess.DepthShadowRendering;

	// Do the depth render.***
	var shaderName = "orthogonalDepth";
	var currentShader = magoManager.postFxShadersManager.getShader(shaderName); 
	currentShader.resetLastBuffersBinded();
	var shaderProgram = currentShader.program;

	currentShader.useProgram();
	magoManager.effectsManager.setCurrentShader(currentShader);
	currentShader.disableVertexAttribArrayAll();
	currentShader.enableVertexAttribArray(currentShader.position3_loc);

	currentShader.bindUniformGenerals();
	
	//var sunGeoLocData = sunSystem.sunGeoLocDataManager.getCurrentGeoLocationData();
	//var sunTMatrix = sunGeoLocData.getRotMatrixInv();

	//gl.uniformMatrix4fv(currentShader.modelViewMatrixRelToEye_loc, false, sunTMatrix._floatArrays);
	gl.uniformMatrix4fv(currentShader.modelViewProjectionMatrixRelToEye_loc, false, sunLight.tMatrix._floatArrays);
	gl.uniform3fv(currentShader.encodedCameraPositionMCHigh_loc, sunLight.positionHIGH);
	gl.uniform3fv(currentShader.encodedCameraPositionMCLow_loc, sunLight.positionLOW);
	gl.uniform3fv(currentShader.scaleLC_loc, [1.0, 1.0, 1.0]); // init referencesMatrix.
	
	gl.uniform1i(currentShader.bApplySsao_loc, false); // apply ssao.***
	gl.disable(gl.CULL_FACE);
	var renderType = 0;
	
	// Do render.***
	var refTMatrixIdxKey = 0;
	var minSize = 0.0;
	var renderTexture = false;

	magoManager.renderer.renderNodes(gl, visibleObjControlerNodes.currentVisibles0, magoManager, currentShader, renderTexture, renderType, minSize, 0, refTMatrixIdxKey);
	magoManager.renderer.renderNodes(gl, visibleObjControlerNodes.currentVisibles2, magoManager, currentShader, renderTexture, renderType, minSize, 0, refTMatrixIdxKey);
	magoManager.renderer.renderNodes(gl, visibleObjControlerNodes.currentVisibles3, magoManager, currentShader, renderTexture, renderType, minSize, 0, refTMatrixIdxKey);
	
	// Mago native geometries.
	this.renderNativeObjects(gl, currentShader, renderType, visibleObjControlerNodes);
	
	// tin terrain.***
	if (magoManager.tinTerrainManager !== undefined)
	{
		var bDepth = true;
		//magoManager.tinTerrainManager.render(magoManager, bDepth, renderType, currentShader);
		//gl.useProgram(null);
	}
	
	gl.enable(gl.CULL_FACE);
	currentShader.disableVertexAttribArrayAll();
	gl.useProgram(null);
};


/**
 * Test function.
 */
Renderer.prototype.renderImageViewRectangle = function(gl, magoManager, depthFbo) 
{
	// Render a test quad to render created textures.***
	if (magoManager.imageViewerRectangle === undefined)
	{
		magoManager.imageViewerRectangle = new ImageViewerRectangle(100, 100);
		magoManager.imageViewerRectangle.geoLocDataManager = new GeoLocationDataManager();
		var geoLocDataManager = magoManager.imageViewerRectangle.geoLocDataManager;
		var geoLocData = geoLocDataManager.newGeoLocationData("noName");
		geoLocData = ManagerUtils.calculateGeoLocationData(126.61673801297405, 37.580105647225956, 50, undefined, undefined, undefined, geoLocData, magoManager);
	}

		
	if (depthFbo !== undefined)
	{
		var shaderName = "imageViewerRectangle";
		var currentShader = magoManager.postFxShadersManager.getShader(shaderName); 
		currentShader.useProgram();
		var bApplySsao = false;
			
		gl.uniform1i(currentShader.refMatrixType_loc, 0); // in this case, there are not referencesMatrix.
			
		gl.enableVertexAttribArray(currentShader.texCoord2_loc);
		gl.enableVertexAttribArray(currentShader.position3_loc);
		//gl.disableVertexAttribArray(currentShader.normal3_loc);
		//gl.disableVertexAttribArray(currentShader.color4_loc); 
			
		currentShader.bindUniformGenerals();
		gl.uniform1f(currentShader.externalAlpha_loc, 1.0);
		gl.uniform1i(currentShader.colorType_loc, 2); // 0= oneColor, 1= attribColor, 2= texture.
		gl.uniform4fv(currentShader.oneColor4_loc, [0.1, 0.8, 0.99, 1.0]); //.***
			
		gl.uniform3fv(currentShader.buildingPosHIGH_loc, [0.0, 0.0, 0.0]);
		gl.uniform3fv(currentShader.buildingPosLOW_loc, [0.0, 0.0, 0.0]);

			
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, magoManager.depthFboNeo.colorBuffer);  // original.***
		gl.activeTexture(gl.TEXTURE1);
		gl.bindTexture(gl.TEXTURE_2D, null);
		gl.activeTexture(gl.TEXTURE2); 
		gl.bindTexture(gl.TEXTURE_2D, depthFbo.colorBuffer);
		currentShader.last_tex_id = depthFbo.colorBuffer;
			
		magoManager.imageViewerRectangle.render(magoManager, currentShader);
			
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, null);  // original.***
		gl.activeTexture(gl.TEXTURE1);
		gl.bindTexture(gl.TEXTURE_2D, null);
		gl.activeTexture(gl.TEXTURE2);
		gl.bindTexture(gl.TEXTURE_2D, null);
			
		currentShader.disableVertexAttribArrayAll();
		gl.useProgram(null);
	}
		
	
};

/**
 * This function renders provisional ParametricMesh objects that has no self render function.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Number} renderType If renderType = 0 (depth render), renderType = 1 (color render), renderType = 2 (colorCoding render).
 * @param {VisibleObjectsController} visibleObjControlerNodes This object contains visible objects for the camera frustum.
 */
Renderer.prototype.renderAtmosphere = function(gl, renderType) 
{
	// Atmosphere.*******************************************************************************
	// Test render sky.***
	var magoManager = this.magoManager;
	if (magoManager.sky === undefined)
	{ magoManager.sky = new Sky(); }
	
	var currentShader = magoManager.postFxShadersManager.getShader("atmosphere"); 
	currentShader.useProgram();
	var bApplySsao = false;
	
	gl.uniform1i(currentShader.bApplySsao_loc, bApplySsao); // apply ssao default.***
	
	gl.uniform1i(currentShader.bApplySpecularLighting_loc, false);
	gl.disableVertexAttribArray(currentShader.texCoord2_loc);
	gl.enableVertexAttribArray(currentShader.position3_loc);
	//gl.disableVertexAttribArray(currentShader.normal3_loc);
	//gl.disableVertexAttribArray(currentShader.color4_loc); 
	
	currentShader.bindUniformGenerals();
	gl.uniform1f(currentShader.externalAlpha_loc, 1.0);
	gl.uniform1i(currentShader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
	gl.uniform4fv(currentShader.oneColor4_loc, [0.1, 0.8, 0.99, 1.0]); //.***
	
	gl.uniform3fv(currentShader.buildingPosHIGH_loc, [0.0, 0.0, 0.0]);
	gl.uniform3fv(currentShader.buildingPosLOW_loc, [0.0, 0.0, 0.0]);
	
	var refTMatrixIdxKey = 0;
	var minSizeToRender = 0.0;
	var renderType = 1;
	var refMatrixIdxKey =0; // provisionally set magoManager var here.***
	var glPrimitive = undefined;

	magoManager.sky.render(magoManager, currentShader, renderType, glPrimitive);
	
	currentShader.disableVertexAttribArrayAll();
	gl.useProgram(null);
	
	// Render a test quad to render created textures.***
	if (magoManager.sunDepthFbo !== undefined)
	{
		this.renderImageViewRectangle(gl, magoManager, magoManager.sunDepthFbo);
	}
	
};

/**
 * This function renders provisional ParametricMesh objects that has no self render function.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Number} renderType If renderType = 0 (depth render), renderType = 1 (color render), renderType = 2 (colorCoding render).
 * @param {VisibleObjectsController} visibleObjControlerNodes This object contains visible objects for the camera frustum.
 */
Renderer.prototype.renderNativeObjects = function(gl, shader, renderType, visibleObjControlerNodes, bIncludeTransparentObjects) 
{
	var magoManager = this.magoManager;
	var glPrimitive = undefined;
	if (bIncludeTransparentObjects === undefined)
	{ bIncludeTransparentObjects = true; }
	
	// 1rst, opaques.
	var opaquesArray = visibleObjControlerNodes.currentVisibleNativeObjects.opaquesArray;
	var nativeObjectsCount = opaquesArray.length;
	for (var i=0; i<nativeObjectsCount; i++)
	{
		opaquesArray[i].render(magoManager, shader, renderType, glPrimitive);
	}
	
	// transparents.
	if (bIncludeTransparentObjects)
	{
		var transparentsArray = visibleObjControlerNodes.currentVisibleNativeObjects.transparentsArray;
		nativeObjectsCount = transparentsArray.length;
		for (var i=0; i<nativeObjectsCount; i++)
		{
			transparentsArray[i].render(magoManager, shader, renderType, glPrimitive);
		}
	}
	
	// vectorType objects.
	if (renderType === 1)
	{
		var vectorTypeObjectsArray = visibleObjControlerNodes.currentVisibleNativeObjects.vectorTypeArray;
		var vectorTypeObjectsCount = vectorTypeObjectsArray.length;
		if (vectorTypeObjectsCount > 0)
		{
			// change shader. use "thickLines" shader.
			var sceneState = magoManager.sceneState;
			var thickLineShader = magoManager.postFxShadersManager.getShader("thickLine"); 
			thickLineShader.useProgram();
			thickLineShader.bindUniformGenerals();
			
			gl.uniform4fv(thickLineShader.oneColor4_loc, [0.3, 0.9, 0.5, 1.0]);
			gl.uniform1i(thickLineShader.colorType_loc, 0);
			gl.uniform2fv(thickLineShader.viewport_loc, [sceneState.drawingBufferWidth, sceneState.drawingBufferHeight]);
			gl.uniform1f(thickLineShader.thickness_loc, 5.0);
				
			for (var i=0; i<vectorTypeObjectsCount; i++)
			{
				vectorTypeObjectsArray[i].render(magoManager, thickLineShader, renderType, glPrimitive);
			}
			
			// return to the current shader.
			shader.useProgram();
		}
	}
};

/**
 * This function renders Excavation type objects that has no self render function.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Number} renderType If renderType = 0 (depth render), renderType = 1 (color render), renderType = 2 (colorCoding render).
 * @param {VisibleObjectsController} visibleObjControlerNodes This object contains visible objects for the camera frustum.
 */
Renderer.prototype.renderExcavationObjects = function(gl, shader, renderType, visibleObjControlerNodes) 
{
	var magoManager = this.magoManager;
	var glPrimitive = undefined;
	
	// excavation
	var excavationsArray = visibleObjControlerNodes.currentVisibleNativeObjects.excavationsArray;
	var nativeObjectsCount = excavationsArray.length;
	for (var i=0; i<nativeObjectsCount; i++)
	{
		excavationsArray[i].render(magoManager, shader, renderType, glPrimitive);
	}
};

/**
 * This function renders the stencil shadows meshes of the scene.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Number} renderType If renderType = 0 (depth render), renderType = 1 (color render), renderType = 2 (colorCoding render).
 * @param {VisibleObjectsController} visibleObjControlerNodes This object contains visible objects for the camera frustum.
 */
Renderer.prototype.renderSilhouette = function() 
{
	// Render screenQuad with effects.
	var magoManager = this.magoManager;
	var gl = magoManager.getGl();
	
	// Now render screenQuad with the silhouette effect.***
	var magoManager = this.magoManager;
	var sceneState = magoManager.sceneState;
	
	var currentShader = magoManager.postFxShadersManager.getShader("screenQuad"); 
	currentShader.useProgram();
	
	currentShader.bindUniformGenerals();
	var projectionMatrixInv = sceneState.getProjectionMatrixInv();
	gl.uniformMatrix4fv(currentShader.projectionMatrixInv_loc, false, projectionMatrixInv._floatArrays);
	var modelViewMatrixRelToEyeInv = sceneState.getModelViewRelToEyeMatrixInv();
	gl.uniformMatrix4fv(currentShader.modelViewMatrixRelToEyeInv_loc, false, modelViewMatrixRelToEyeInv._floatArrays);
	
	var bApplyShadow = false;
	var bSilhouette = true;
	gl.uniform1i(currentShader.bApplyShadow_loc, bApplyShadow);
	gl.uniform1i(currentShader.bSilhouette_loc, bSilhouette);
	
	var sunSystem = sceneState.sunSystem;
	var sunLight = sunSystem.getLight(0);
	var textureAux1x1 = magoManager.texturesStore.getTextureAux1x1();
	var silhouetteDepthFbo = magoManager.getSilhouetteDepthFbo();
	
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, silhouetteDepthFbo.colorBuffer);  // silhouette depth texture.***
	gl.activeTexture(gl.TEXTURE3); 
	gl.bindTexture(gl.TEXTURE_2D, textureAux1x1);
	gl.activeTexture(gl.TEXTURE4); 
	gl.bindTexture(gl.TEXTURE_2D, textureAux1x1);

	currentShader.last_tex_id = textureAux1x1;
			
	gl.disable(gl.POLYGON_OFFSET_FILL);
	//gl.disable(gl.CULL_FACE);
	gl.colorMask(true, true, true, true);
	gl.depthMask(false);
	gl.depthRange(0.0, 0.01);

	gl.disable(gl.DEPTH_TEST);
	gl.enable(gl.BLEND);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); // Original.***
	//gl.cullFace(gl.FRONT);

	if (this.screenQuad === undefined)
	{
		this.screenQuad = new ScreenQuad(magoManager.vboMemoryManager);
	}
	
	this.screenQuad.render(magoManager, currentShader);

	// Restore settings.***
	gl.colorMask(true, true, true, true);
	gl.depthMask(true);
	gl.disable(gl.BLEND);
	gl.depthRange(0.0, 1.0);
	
	// Restore magoManager rendering phase.
	//magoManager.renderingFase = currRenderingPhase;
};

/**
 * This function renders the stencil shadows meshes of the scene.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Number} renderType If renderType = 0 (depth render), renderType = 1 (color render), renderType = 2 (colorCoding render).
 * @param {VisibleObjectsController} visibleObjControlerNodes This object contains visible objects for the camera frustum.
 */
Renderer.prototype.renderTerrainShadow = function(gl) 
{
	var currentShader;
	var magoManager = this.magoManager;
	var sceneState = magoManager.sceneState;
	
	if (magoManager.czm_globeDepthText === undefined)
	{ magoManager.czm_globeDepthText = magoManager.scene._context._us.globeDepthTexture._texture; }

	var bApplyShadow = false;
	if (sceneState.sunSystem !== undefined && sceneState.applySunShadows)
	{ bApplyShadow = true; }

	if (!bApplyShadow || !magoManager.czm_globeDepthText)
	{ return; }

	currentShader = magoManager.postFxShadersManager.getShader("screenQuad"); 
	currentShader.useProgram();
	
	currentShader.bindUniformGenerals();
	var projectionMatrixInv = sceneState.getProjectionMatrixInv();
	gl.uniformMatrix4fv(currentShader.projectionMatrixInv_loc, false, projectionMatrixInv._floatArrays);
	var modelViewMatrixRelToEyeInv = sceneState.getModelViewRelToEyeMatrixInv();
	gl.uniformMatrix4fv(currentShader.modelViewMatrixRelToEyeInv_loc, false, modelViewMatrixRelToEyeInv._floatArrays);
	
	var bSilhouette = false;
	gl.uniform1i(currentShader.bApplyShadow_loc, bApplyShadow);
	gl.uniform1i(currentShader.bSilhouette_loc, bSilhouette);
	var sunSystem = sceneState.sunSystem;
	var sunLight = sunSystem.getLight(0);
	var textureAux1x1 = magoManager.texturesStore.getTextureAux1x1();
	
	if (bApplyShadow)
	{
		// Set sunMatrix uniform.***
		
		var sunMatFloat32Array = sunSystem.getLightsMatrixFloat32Array();
		var sunPosLOWFloat32Array = sunSystem.getLightsPosLOWFloat32Array();
		var sunPosHIGHFloat32Array = sunSystem.getLightsPosHIGHFloat32Array();
		var sunDirWC = sunSystem.getSunDirWC();
		
		if (sunLight.tMatrix!== undefined)
		{
			gl.uniformMatrix4fv(currentShader.sunMatrix_loc, false, sunMatFloat32Array);
			gl.uniform3fv(currentShader.sunPosHigh_loc, sunPosHIGHFloat32Array);
			gl.uniform3fv(currentShader.sunPosLow_loc, sunPosLOWFloat32Array);
			gl.uniform1f(currentShader.shadowMapWidth_loc, sunLight.targetTextureWidth);
			gl.uniform1f(currentShader.shadowMapHeight_loc, sunLight.targetTextureHeight);
			gl.uniform3fv(currentShader.sunDirWC_loc, sunDirWC);
			gl.uniform1i(currentShader.sunIdx_loc, 1);
		}
	}
	
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, magoManager.czm_globeDepthText);  // cesium globeDepthTexture.***
	gl.activeTexture(gl.TEXTURE3); 
	if (bApplyShadow && sunLight.depthFbo)
	{
		var sunSystem = sceneState.sunSystem;
		var sunLight = sunSystem.getLight(0);
		gl.bindTexture(gl.TEXTURE_2D, sunLight.depthFbo.colorBuffer);
	}
	else 
	{
		gl.bindTexture(gl.TEXTURE_2D, textureAux1x1);
	}
	
	gl.activeTexture(gl.TEXTURE4); 
	if (bApplyShadow && sunLight.depthFbo)
	{
		var sunSystem = sceneState.sunSystem;
		var sunLight = sunSystem.getLight(1);
		gl.bindTexture(gl.TEXTURE_2D, sunLight.depthFbo.colorBuffer);
	}
	else 
	{
		gl.bindTexture(gl.TEXTURE_2D, textureAux1x1);
	}
	currentShader.last_tex_id = textureAux1x1;
			
	
	gl.disable(gl.POLYGON_OFFSET_FILL);
	//gl.disable(gl.CULL_FACE);
	gl.colorMask(true, true, true, true);
	gl.depthMask(false);

	gl.disable(gl.DEPTH_TEST);
	gl.enable(gl.BLEND);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); // Original.***
	//gl.cullFace(gl.FRONT);

	if (this.screenQuad === undefined)
	{
		this.screenQuad = new ScreenQuad(magoManager.vboMemoryManager);
	}
	
	this.screenQuad.render(magoManager, currentShader);

	// Restore settings.***
	gl.colorMask(true, true, true, true);
	gl.depthMask(true);
	gl.disable(gl.BLEND);
	gl.depthRange(0.0, 1.0);	
};

/**
 * This function renders the stencil shadows meshes of the scene.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Number} renderType If renderType = 0 (depth render), renderType = 1 (color render), renderType = 2 (colorCoding render).
 * @param {VisibleObjectsController} visibleObjControlerNodes This object contains visible objects for the camera frustum.
 */
Renderer.prototype.renderScreenQuadShadow = function(gl, depthTex) 
{
	var currentShader;
	var shaderProgram;
	var neoBuilding;
	var node;
	var rootNode;
	var geoLocDataManager;
	var magoManager = this.magoManager;
	var sceneState = magoManager.sceneState;

	var bApplyShadow = false;
	if (sceneState.sunSystem !== undefined && sceneState.applySunShadows)
	{ bApplyShadow = true; }

	bApplyShadow = true;

	//if (!bApplyShadow)
	//{ return; }

	currentShader = magoManager.postFxShadersManager.getShader("screenQuad"); 
	currentShader.useProgram();
	
	currentShader.bindUniformGenerals();
	var projectionMatrixInv = sceneState.getProjectionMatrixInv();
	
	if (!projectionMatrixInv._floatArrays)
	{ return; }
	
	gl.uniformMatrix4fv(currentShader.projectionMatrixInv_loc, false, projectionMatrixInv._floatArrays);
	var modelViewMatrixRelToEyeInv = sceneState.getModelViewRelToEyeMatrixInv();
	gl.uniformMatrix4fv(currentShader.modelViewMatrixRelToEyeInv_loc, false, modelViewMatrixRelToEyeInv._floatArrays);
	
	gl.uniform1i(currentShader.bApplyShadow_loc, bApplyShadow);
	var sunSystem = sceneState.sunSystem;
	var sunLight = sunSystem.getLight(0);
	var textureAux1x1 = magoManager.texturesStore.getTextureAux1x1();
	
	if (bApplyShadow)
	{
		// Set sunMatrix uniform.***
		
		var sunMatFloat32Array = sunSystem.getLightsMatrixFloat32Array();
		var sunPosLOWFloat32Array = sunSystem.getLightsPosLOWFloat32Array();
		var sunPosHIGHFloat32Array = sunSystem.getLightsPosHIGHFloat32Array();
		var sunDirWC = sunSystem.getSunDirWC();
		
		if (sunLight.tMatrix!== undefined)
		{
			gl.uniformMatrix4fv(currentShader.sunMatrix_loc, false, sunMatFloat32Array);
			gl.uniform3fv(currentShader.sunPosHigh_loc, sunPosHIGHFloat32Array);
			gl.uniform3fv(currentShader.sunPosLow_loc, sunPosLOWFloat32Array);
			gl.uniform1f(currentShader.shadowMapWidth_loc, sunLight.targetTextureWidth);
			gl.uniform1f(currentShader.shadowMapHeight_loc, sunLight.targetTextureHeight);
			gl.uniform3fv(currentShader.sunDirWC_loc, sunDirWC);
			gl.uniform1i(currentShader.sunIdx_loc, 1);
		}
	}
	
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, depthTex);  
	gl.activeTexture(gl.TEXTURE3); 
	if (bApplyShadow && sunLight.depthFbo)
	{
		var sunSystem = sceneState.sunSystem;
		var sunLight = sunSystem.getLight(0);
		gl.bindTexture(gl.TEXTURE_2D, sunLight.depthFbo.colorBuffer);
	}
	else 
	{
		gl.bindTexture(gl.TEXTURE_2D, textureAux1x1);
	}
	
	gl.activeTexture(gl.TEXTURE4); 
	if (bApplyShadow && sunLight.depthFbo)
	{
		var sunSystem = sceneState.sunSystem;
		var sunLight = sunSystem.getLight(1);
		gl.bindTexture(gl.TEXTURE_2D, sunLight.depthFbo.colorBuffer);
	}
	else 
	{
		gl.bindTexture(gl.TEXTURE_2D, textureAux1x1);
	}
	currentShader.last_tex_id = textureAux1x1;
			
	
	gl.disable(gl.POLYGON_OFFSET_FILL);
	//gl.disable(gl.CULL_FACE);
	gl.colorMask(true, true, true, true);
	gl.depthMask(false);

	gl.disable(gl.DEPTH_TEST);
	gl.enable(gl.BLEND);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); // Original.***
	//gl.cullFace(gl.FRONT);

	if (this.screenQuad === undefined)
	{
		this.screenQuad = new ScreenQuad(magoManager.vboMemoryManager);
	}
	
	this.screenQuad.render(magoManager, currentShader);
		
	
	
	// Restore settings.***
	gl.colorMask(true, true, true, true);
	gl.depthMask(true);
	gl.disable(gl.BLEND);
	gl.depthRange(0.0, 1.0);	
};

/**
 * This function renders the stencil shadows meshes of the scene.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Number} renderType If renderType = 0 (depth render), renderType = 1 (color render), renderType = 2 (colorCoding render).
 * @param {VisibleObjectsController} visibleObjControlerNodes This object contains visible objects for the camera frustum.
 */
Renderer.prototype.renderGeometryStencilShadowMeshes__original = function(gl, renderType, visibleObjControlerNodes) 
{
	gl.frontFace(gl.CCW);	
	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LEQUAL);
	gl.enable(gl.CULL_FACE);
	
	//return;
	
	var currentShader;
	var shaderProgram;
	var neoBuilding;
	var node;
	var rootNode;
	var geoLocDataManager;
	var magoManager = this.magoManager;
	var renderingSettings = magoManager._settings.getRenderingSettings();

	var renderTexture = false;
	//gl.clearStencil(0);
	
	//if (renderType === 3) 
	{
		// SHADOW SETTINGS.**********************************************************************************
		gl.colorMask(false, false, false, false);
		gl.depthMask(false);
		gl.enable(gl.CULL_FACE);
		gl.enable(gl.STENCIL_TEST);
		//gl.enable(gl.POLYGON_OFFSET_FILL);
		//gl.polygonOffset(1.0, 2.0); // Original.***
		
		//gl.clear(gl.STENCIL_BUFFER_BIT);
		if (magoManager.isFarestFrustum())
		{ gl.clearStencil(0); }
	
		var textureAux1x1 = magoManager.texturesStore.getTextureAux1x1();
		var noiseTexture = magoManager.texturesStore.getNoiseTexture4x4();
		

		var bApplySsao = false;
		var bApplyShadow = false;
		var bApplySpecularLighting = false;
			
		// ssao render.************************************************************************************************************
		var visibleObjectControllerHasRenderables = visibleObjControlerNodes.hasRenderables();
		//if (visibleObjectControllerHasRenderables || magoManager.modeler !== undefined)
		//if (visibleObjControlerNodes.currentVisibles3.length > 0)
		//if (magoManager.currentFrustumIdx === 1)
		{
			
			gl.enable(gl.BLEND);
			currentShader = magoManager.postFxShadersManager.getShader("modelRefSsao"); 
			currentShader.useProgram();
			gl.uniform1i(currentShader.bApplySsao_loc, bApplySsao); // apply ssao default.***
			gl.uniform1i(currentShader.bApplyShadow_loc, bApplyShadow);
			gl.uniform1i(currentShader.bApplySpecularLighting_loc, bApplySpecularLighting);

			
			// check if exist clippingPlanes.
			if (magoManager.modeler.clippingBox !== undefined)
			{
				var planesVec4Array = magoManager.modeler.clippingBox.getPlanesRelToEyevec4Array(magoManager);
				var planesVec4FloatArray = new Float32Array(planesVec4Array);
				
				gl.uniform1i(currentShader.bApplyClippingPlanes_loc, true);
				gl.uniform1i(currentShader.clippingPlanesCount_loc, 6);
				gl.uniform4fv(currentShader.clippingPlanes_loc, planesVec4FloatArray);
			}
			else 
			{
				gl.uniform1i(currentShader.bApplyClippingPlanes_loc, false);
			}
			
			gl.disableVertexAttribArray(currentShader.texCoord2_loc);
			gl.enableVertexAttribArray(currentShader.position3_loc);
			gl.enableVertexAttribArray(currentShader.normal3_loc);
			gl.disableVertexAttribArray(currentShader.color4_loc); 
			
			currentShader.bindUniformGenerals();
			gl.uniform1f(currentShader.externalAlpha_loc, 1.0);
			gl.uniform1i(currentShader.textureFlipYAxis_loc, magoManager.sceneState.textureFlipYAxis);
			gl.uniform1i(currentShader.refMatrixType_loc, 0); // init referencesMatrix.
			
			// Test sphericalKernel for ssao.************************
			//gl.uniform3fv(currentShader.kernel32_loc, magoManager.sceneState.ssaoSphereKernel32);
			// End test.---------------------------------------------

			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, magoManager.depthFboNeo.colorBuffer);  // original.***
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, noiseTexture);
			gl.activeTexture(gl.TEXTURE2); 
			gl.bindTexture(gl.TEXTURE_2D, textureAux1x1);
			currentShader.last_tex_id = textureAux1x1;
			

			var refTMatrixIdxKey = 0;
			var minSizeToRender = 0.0;
			var refMatrixIdxKey =0; // provisionally set magoManager var here.***
			
			// temp test excavation, thickLines, etc.***.
			//magoManager.modeler.render(magoManager, currentShader, renderType);
			// excavation objects.
			
			//this.renderExcavationObjects(gl, currentShader, renderType, visibleObjControlerNodes);
			//this.renderNodes(gl, visibleObjControlerNodes.currentVisibles0, magoManager, currentShader, renderTexture, renderType, minSizeToRender, refTMatrixIdxKey);
			gl.stencilMask(0xff);
			
			
			// First pas.****************************************************************************************************
			gl.cullFace(gl.FRONT);
			gl.stencilFunc(gl.ALWAYS, 0x0, 0xff);
			gl.stencilOp(gl.KEEP, gl.INCR, gl.KEEP);

			////this.renderNodes(gl, visibleObjControlerNodes.currentVisibles2, magoManager, currentShader, renderTexture, renderType, minSizeToRender, refTMatrixIdxKey);
			this.renderNodes(gl, visibleObjControlerNodes.currentVisibles3, magoManager, currentShader, renderTexture, renderType, minSizeToRender, refTMatrixIdxKey);

			
			// Second pass.****************************************************************************************************
			gl.cullFace(gl.BACK);
			gl.stencilFunc(gl.ALWAYS, 0x0, 0xff);
			gl.stencilOp(gl.KEEP, gl.DECR, gl.KEEP);
			
			////this.renderNodes(gl, visibleObjControlerNodes.currentVisibles2, magoManager, currentShader, renderTexture, renderType, minSizeToRender, refTMatrixIdxKey);
			this.renderNodes(gl, visibleObjControlerNodes.currentVisibles3, magoManager, currentShader, renderTexture, renderType, minSizeToRender, refTMatrixIdxKey);

			
			// native objects.
			//this.renderNativeObjects(gl, currentShader, renderType, visibleObjControlerNodes);
			
			currentShader.disableVertexAttribArrayAll();
			gl.useProgram(null);
			
			// 3rd pass.********************************************************************************************************
			// Once finished rendering shadow meshes, then render the screenQuad.
			
			currentShader = magoManager.postFxShadersManager.getShader("screenQuad"); 
			currentShader.useProgram();
			
			gl.disable(gl.POLYGON_OFFSET_FILL);
			//gl.disable(gl.CULL_FACE);
			gl.colorMask(true, true, true, true);
			gl.depthMask(false);
			gl.stencilMask(0x00);

			gl.stencilFunc(gl.EQUAL, 1, 0xff);
			//gl.stencilFunc(gl.LEQUAL, 1, 0xff);
			//gl.stencilFunc(gl.LESS, 1, 0xff);
			//gl.stencilOp(gl.REPLACE, gl.REPLACE, gl.REPLACE); // stencilOp(fail, zfail, zpass)
			gl.stencilOp(gl.REPLACE, gl.KEEP, gl.REPLACE); // stencilOp(fail, zfail, zpass)

			gl.disable(gl.DEPTH_TEST);
			gl.enable(gl.BLEND);
			gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); // Original.***
			//gl.cullFace(gl.FRONT);
	
			if (this.screenQuad === undefined)
			{
				this.screenQuad = new ScreenQuad(magoManager.vboMemoryManager);
			}
			
			this.screenQuad.render(magoManager, currentShader);

			gl.stencilMask(0xff);
		}
	}
	
	// Restore settings.***
	gl.colorMask(true, true, true, true);
	gl.depthMask(true);
	gl.disable(gl.STENCIL_TEST);
	gl.disable(gl.BLEND);
	gl.depthRange(0.0, 1.0);	
};


/**
 * This function renders provisional ParametricMesh objects that has no self render function.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Number} renderType If renderType = 0 (depth render), renderType = 1 (color render), renderType = 2 (colorCoding render).
 * @param {VisibleObjectsController} visibleObjControlerNodes This object contains visible objects for the camera frustum.
 */
Renderer.prototype.renderGeometry = function(gl, renderType, visibleObjControlerNodes) 
{
	gl.frontFace(gl.CCW);	
	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LEQUAL);
	gl.enable(gl.CULL_FACE);
	
	var currentShader;
	var shaderProgram;
	var neoBuilding;
	var node;
	var rootNode;
	var geoLocDataManager;
	var magoManager = this.magoManager;
	var renderingSettings = magoManager._settings.getRenderingSettings();

	var renderTexture = false;
	
	if (renderType === 0 ) 
	{
		gl.disable(gl.BLEND);
		magoManager.renderer.renderGeometryDepth(gl, renderType, visibleObjControlerNodes);
		
		// Draw the axis.***
		if (magoManager.magoPolicy.getShowOrigin() && magoManager.nodeSelected !== undefined)
		{
			node = magoManager.nodeSelected;
			var nodes = [node];
			
			this.renderAxisNodes(nodes, renderType);
		}

		var sceneState = magoManager.sceneState;
		//sceneState.applySunShadows = true;
		// SunLight.***
		if (sceneState.applySunShadows && !this.isCameraMoving && !this.mouseLeftDown && !this.mouseMiddleDown)
		{
			visibleObjControlerNodes.calculateBoundingFrustum(sceneState.camera);
		
			var sunSystem = sceneState.sunSystem;
			var sunLightsCount = sunSystem.lightSourcesArray.length;
			for (var i=0; i<sunLightsCount; i++)
			{
				var sunLight = sunSystem.getLight(i);
				var imageWidth = sunLight.targetTextureWidth;
				var imageHeight = sunLight.targetTextureHeight;
				
				if (sunLight.depthFbo === undefined) 
				{ 
					sunLight.depthFbo = new FBO(gl, imageWidth, imageHeight ); 
				}
				
				// Must swap rendering phase before render depth from the sun.***
				magoManager.swapRenderingFase();
				
				sunLight.depthFbo.bind();
				if (magoManager.isFarestFrustum())
				{
					gl.clearColor(1, 1, 1, 1);
					gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				}
				gl.viewport(0, 0, imageWidth, imageHeight);
				
				this.renderDepthSunPointOfView(gl, visibleObjControlerNodes, sunLight, sunSystem);
				
				sunLight.depthFbo.unbind();
			}
			
			magoManager.depthFboNeo.bind(); 
			gl.viewport(0, 0, sceneState.drawingBufferWidth[0], sceneState.drawingBufferHeight[0]);
			gl.clearColor(0, 0, 0, 1);
		}
		
	}
	if (renderType === 1 )//&& magoManager.currentFrustumIdx === 1) 
	{
		var textureAux1x1 = magoManager.texturesStore.getTextureAux1x1();
		var noiseTexture = magoManager.texturesStore.getNoiseTexture4x4();
		
		magoManager.currentProcess = CODE.magoCurrentProcess.ColorRendering;
		
		// Set default blending setting.
		gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );
		
		// Test TinTerrain.**************************************************************************
		// Test TinTerrain.**************************************************************************
		// render tiles, rendertiles.***
		
		if (magoManager.tinTerrainManager !== undefined)
		{
			gl.enable(gl.BLEND);
			
			// Atmosphere.*******************************************************************************
			this.renderAtmosphere(gl, renderType);

			//gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
			//gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
			var bDepthRender = false; // magoManager is no depth render.***
			magoManager.tinTerrainManager.render(magoManager, bDepthRender, renderType);
			
			
		}

		var bApplySsao = false;
		var bApplyShadow = false;
		if (magoManager.currentFrustumIdx < 2)
		{ bApplySsao = true; }
	
	
		if (magoManager.sceneState.sunSystem !== undefined && magoManager.sceneState.applySunShadows)
		{ bApplyShadow = true; }
	
		
		// check changesHistory.
		magoManager.checkChangesHistoryMovements(visibleObjControlerNodes.currentVisibles0);
		magoManager.checkChangesHistoryColors(visibleObjControlerNodes.currentVisibles0);
		
		magoManager.checkChangesHistoryMovements(visibleObjControlerNodes.currentVisibles2);
		magoManager.checkChangesHistoryColors(visibleObjControlerNodes.currentVisibles2);
		
		magoManager.checkChangesHistoryMovements(visibleObjControlerNodes.currentVisibles3);
		magoManager.checkChangesHistoryColors(visibleObjControlerNodes.currentVisibles3);
			
		// ssao render.************************************************************************************************************
		var visibleObjectControllerHasRenderables = visibleObjControlerNodes.hasRenderables();
		if (visibleObjectControllerHasRenderables || magoManager.modeler !== undefined)
		{
			
			gl.enable(gl.BLEND);
			currentShader = magoManager.postFxShadersManager.getShader("modelRefSsao"); 
			currentShader.useProgram();
			magoManager.effectsManager.setCurrentShader(currentShader);
			gl.uniform1i(currentShader.bApplySsao_loc, bApplySsao); // apply ssao default.***
			gl.uniform1i(currentShader.bApplyShadow_loc, bApplyShadow);
			gl.uniform1i(currentShader.bApplySpecularLighting_loc, true);
			var sunSystem = magoManager.sceneState.sunSystem;
			var sunLight = sunSystem.getLight(0);
			if (bApplyShadow)
			{
				// Set sunMatrix uniform.***
				var sunMatFloat32Array = sunSystem.getLightsMatrixFloat32Array();
				var sunPosLOWFloat32Array = sunSystem.getLightsPosLOWFloat32Array();
				var sunPosHIGHFloat32Array = sunSystem.getLightsPosHIGHFloat32Array();
				var sunDirWC = sunSystem.getSunDirWC();
				
				if (sunLight.tMatrix!== undefined)
				{
					gl.uniformMatrix4fv(currentShader.sunMatrix_loc, false, sunMatFloat32Array);
					gl.uniform3fv(currentShader.sunPosHigh_loc, sunPosHIGHFloat32Array);
					gl.uniform3fv(currentShader.sunPosLow_loc, sunPosLOWFloat32Array);
					gl.uniform1f(currentShader.shadowMapWidth_loc, sunLight.targetTextureWidth);
					gl.uniform1f(currentShader.shadowMapHeight_loc, sunLight.targetTextureHeight);
					gl.uniform3fv(currentShader.sunDirWC_loc, sunDirWC);
					gl.uniform1i(currentShader.sunIdx_loc, 1);
				}
			}
			
			// check if exist clippingPlanes.
			if (magoManager.modeler.clippingBox !== undefined)
			{
				var planesVec4Array = magoManager.modeler.clippingBox.getPlanesRelToEyevec4Array(magoManager);
				var planesVec4FloatArray = new Float32Array(planesVec4Array);
				
				gl.uniform1i(currentShader.bApplyClippingPlanes_loc, true);
				gl.uniform1i(currentShader.clippingPlanesCount_loc, 6);
				gl.uniform4fv(currentShader.clippingPlanes_loc, planesVec4FloatArray);
			}
			else 
			{
				gl.uniform1i(currentShader.bApplyClippingPlanes_loc, false);
			}
			
			gl.enableVertexAttribArray(currentShader.texCoord2_loc);
			gl.enableVertexAttribArray(currentShader.position3_loc);
			gl.enableVertexAttribArray(currentShader.normal3_loc);
			if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
			
			currentShader.bindUniformGenerals();
			gl.uniform1f(currentShader.externalAlpha_loc, 1.0);
			gl.uniform1i(currentShader.textureFlipYAxis_loc, magoManager.sceneState.textureFlipYAxis);
			gl.uniform1i(currentShader.refMatrixType_loc, 0); // init referencesMatrix.
			gl.uniform3fv(currentShader.scaleLC_loc, [1.0, 1.0, 1.0]); // init local scale.
			gl.uniform4fv(currentShader.colorMultiplier_loc, [1.0, 1.0, 1.0, 1.0]);
			gl.uniform3fv(currentShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.
			
			// Test sphericalKernel for ssao.************************
			//gl.uniform3fv(currentShader.kernel32_loc, magoManager.sceneState.ssaoSphereKernel32);
			// End test.---------------------------------------------

			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, magoManager.depthFboNeo.colorBuffer);  // original.***
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, noiseTexture);
			gl.activeTexture(gl.TEXTURE2); 
			gl.bindTexture(gl.TEXTURE_2D, textureAux1x1);
			currentShader.last_tex_id = textureAux1x1;
			
			gl.activeTexture(gl.TEXTURE3); 
			if (bApplyShadow && sunLight.depthFbo)
			{
				var sunLight = sunSystem.getLight(0);
				gl.bindTexture(gl.TEXTURE_2D, sunLight.depthFbo.colorBuffer);
			}
			else 
			{
				gl.bindTexture(gl.TEXTURE_2D, textureAux1x1);
			}
			
			gl.activeTexture(gl.TEXTURE4); 
			if (bApplyShadow && sunLight.depthFbo)
			{
				var sunLight = sunSystem.getLight(1);
				gl.bindTexture(gl.TEXTURE_2D, sunLight.depthFbo.colorBuffer);
			}
			else 
			{
				gl.bindTexture(gl.TEXTURE_2D, textureAux1x1);
			}

			/*
			if (MagoConfig.getPolicy().geo_cull_face_enable === "true") 
			{ gl.enable(gl.CULL_FACE); }
			else 
			{ gl.disable(gl.CULL_FACE); }
			*/
			gl.enable(gl.CULL_FACE);
			var refTMatrixIdxKey = 0;
			var minSizeToRender = 0.0;
			var renderType = 1;
			var refMatrixIdxKey =0; // provisionally set magoManager var here.***
			
			// temp test excavation, thickLines, etc.***.
			magoManager.modeler.render(magoManager, currentShader, renderType);
			// excavation objects.
			
			this.renderExcavationObjects(gl, currentShader, renderType, visibleObjControlerNodes);
			this.renderNodes(gl, visibleObjControlerNodes.currentVisibles0, magoManager, currentShader, renderTexture, renderType, minSizeToRender, refTMatrixIdxKey);
			
			//bApplySsao = false;
			gl.uniform1i(currentShader.bApplySsao_loc, bApplySsao); 
			
			this.renderNodes(gl, visibleObjControlerNodes.currentVisibles2, magoManager, currentShader, renderTexture, renderType, minSizeToRender, refTMatrixIdxKey);
			this.renderNodes(gl, visibleObjControlerNodes.currentVisibles3, magoManager, currentShader, renderTexture, renderType, minSizeToRender, refTMatrixIdxKey);
			
			// native objects.
			this.renderNativeObjects(gl, currentShader, renderType, visibleObjControlerNodes);
			
			currentShader.disableVertexAttribArrayAll();
			gl.useProgram(null);
		}
		

		if (magoManager.nodeSelected) // if there are an object selected then there are a building selected.***
		{
			if (magoManager.magoPolicy.getObjectMoveMode() === CODE.moveMode.OBJECT && magoManager.objectSelected)
			{
				this.renderSilhouette();
			}
			
			if (magoManager.magoPolicy.getObjectMoveMode() === CODE.moveMode.ALL && magoManager.buildingSelected)
			{
				node = magoManager.nodeSelected;
				if (node !== undefined) // test code.***
				{
					// New.
					this.renderSilhouette();
				}
			}
			
			// draw the axis.***
			if (magoManager.magoPolicy.getShowOrigin())
			{
				var node = magoManager.nodeSelected;
				//var geoLocDataManager = node.getNodeGeoLocDataManager();
				var nodes = [node];
				
				this.renderAxisNodes(nodes, renderType);
			}
		}
		
		
		// Render Animated Man.********************************************************************************************************************
		
		// Test Modeler Rendering.********************************************************************
		// Test Modeler Rendering.********************************************************************
		// Test Modeler Rendering.********************************************************************
		/*
		if (magoManager.modeler !== undefined)
		{
			currentShader = magoManager.postFxShadersManager.getShader("modelRefSsao"); 
			currentShader.resetLastBuffersBinded();
			shaderProgram = currentShader.program;

			currentShader.useProgram();
			currentShader.disableVertexAttribArrayAll();
			currentShader.enableVertexAttribArray(currentShader.position3_loc);

			currentShader.bindUniformGenerals();
			
			gl.uniform1i(currentShader.bApplySsao_loc, false); // apply ssao.***

			var refTMatrixIdxKey = 0;
			var minSizeToRender = 0.0;
			var renderType = 1;
			var refMatrixIdxKey =0; // provisionally set this var here.***
			magoManager.modeler.render(magoManager, currentShader, renderType);

			currentShader.disableVertexAttribArrayAll();
			gl.useProgram(null);

		}
		*/
		
		// 3) now render bboxes.*******************************************************************************************************************
		if (visibleObjectControllerHasRenderables)
		{
			if (magoManager.magoPolicy.getShowBoundingBox())
			{
				
				var bRenderLines = true;
				//var currentVisiblesArray = visibleObjControlerNodes.currentVisibles0.concat(visibleObjControlerNodes.currentVisibles2,);
				this.renderBoundingBoxesNodes(magoManager.visibleObjControlerNodes.currentVisibles0, undefined, bRenderLines);
				this.renderBoundingBoxesNodes(magoManager.visibleObjControlerNodes.currentVisibles2, undefined, bRenderLines);
				this.renderBoundingBoxesNodes(magoManager.visibleObjControlerNodes.currentVisibles3, undefined, bRenderLines);
				this.renderBoundingBoxesNodes(magoManager.visibleObjControlerNodes.currentVisiblesAux, undefined, bRenderLines);
			}
		}
		
		// 4) Render ObjectMarkers.********************************************************************************************************
		magoManager.objMarkerManager.render(magoManager, renderType); 

		// test renders.***
		// render cctv.***
		/*
		magoManager.test_cctv();
		var cctvsCount = 0;
		if (magoManager.cctvList !== undefined)
		{
			cctvsCount = magoManager.cctvList.getCCTVCount();
		}
		if (cctvsCount > 0)
		{
			currentShader = magoManager.postFxShadersManager.getShader("modelRefSsao"); 
			magoManager.cctvList.render(magoManager, currentShader );
		}
		*/
		
		// PointsCloud.****************************************************************************************
		// PointsCloud.****************************************************************************************
		var nodesPCloudCount = magoManager.visibleObjControlerNodes.currentVisiblesAux.length;
		if (nodesPCloudCount > 0)
		{
			magoManager.sceneState.camera.setCurrentFrustum(0);
			var frustumIdx = magoManager.currentFrustumIdx;
			magoManager.sceneState.camera.frustum.near[0] = magoManager.sceneState.camera.frustumsArray[frustumIdx].near[0];
			magoManager.sceneState.camera.frustum.far[0] = magoManager.sceneState.camera.frustumsArray[frustumIdx].far[0];
			
			if (renderingSettings.getApplySsao())
			{ 
				if (renderingSettings.getPointsCloudInColorRamp())
				{ currentShader = magoManager.postFxShadersManager.getShader("pointsCloudSsao_rainbow"); } 
				else
				{ currentShader = magoManager.postFxShadersManager.getShader("pointsCloudSsao"); } 
			}
			else
			{ 
				if (renderingSettings.getPointsCloudInColorRamp())
				{ currentShader = magoManager.postFxShadersManager.getShader("pointsCloudSsao_rainbow"); } // change this for "pointsCloud_rainbow" todo:
				else
				{ currentShader = magoManager.postFxShadersManager.getShader("pointsCloud"); } 
			}
			currentShader.useProgram();
			currentShader.resetLastBuffersBinded();
			currentShader.enableVertexAttribArray(currentShader.position3_loc);
			currentShader.enableVertexAttribArray(currentShader.color4_loc);
			currentShader.bindUniformGenerals();
			
			gl.uniform1f(currentShader.externalAlpha_loc, 1.0);
			var bApplySsao = true;
			gl.uniform1i(currentShader.bApplySsao_loc, bApplySsao); // apply ssao default.***
			
			if (magoManager.pointsCloudWhite !== undefined && magoManager.pointsCloudWhite)
			{
				gl.uniform1i(currentShader.bUse1Color_loc, true);
				gl.uniform4fv(currentShader.oneColor4_loc, [0.99, 0.99, 0.99, 1.0]); //.***
			}
			else 
			{
				gl.uniform1i(currentShader.bUse1Color_loc, false);
			}
			var pCloudSettings = magoManager.magoPolicy.getPointsCloudSettings();
			gl.uniform1i(currentShader.bUseColorCodingByHeight_loc, true);
			gl.uniform1f(currentShader.minHeight_rainbow_loc, pCloudSettings.minHeightRainbow);
			gl.uniform1f(currentShader.maxHeight_rainbow_loc, pCloudSettings.maxHeightRainbow);
			gl.uniform1f(currentShader.maxPointSize_loc, pCloudSettings.maxPointSize);
			gl.uniform1f(currentShader.minPointSize_loc, pCloudSettings.minPointSize);
			gl.uniform1f(currentShader.pendentPointSize_loc, pCloudSettings.pendentPointSize);
			
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, magoManager.depthFboNeo.colorBuffer);
			
			// Test to load pCloud.***
			if (magoManager.visibleObjControlerPCloudOctrees === undefined)
			{ magoManager.visibleObjControlerPCloudOctrees = new VisibleObjectsController(); }
			
			magoManager.visibleObjControlerPCloudOctrees.clear();
			magoManager.renderer.renderNeoBuildingsPCloud(gl, magoManager.visibleObjControlerNodes.currentVisiblesAux, magoManager, currentShader, renderTexture, renderType); // lod0.***
			currentShader.disableVertexAttribArrayAll();
			
			gl.useProgram(null);

		}
		
	}

	
	gl.disable(gl.BLEND);
	gl.depthRange(0.0, 1.0);	
};


/**
 * This function renders the axis coordinates of the nodes.
 * @param {Array} nodesArray Nodes that render the axis.
 * @param {Number} renderType If renderType = 0 (depth render), renderType = 1 (color render), renderType = 2 (colorCoding render).
 */
Renderer.prototype.renderAxisNodes = function(nodesArray, renderType) 
{
	var magoManager = this.magoManager;
	
	if (magoManager.axisXYZ.vbo_vicks_container.vboCacheKeysArray.length === 0)
	{ 
		var mesh = magoManager.axisXYZ.makeMesh(30); 
		mesh.getVboTrianglesConvex(magoManager.axisXYZ.vbo_vicks_container, magoManager.vboMemoryManager);
	}
	
	var gl = magoManager.getGl();
	var color;
	var node;
	var currentShader;
	if (renderType === 0)
	{
		currentShader = magoManager.postFxShadersManager.getShader("modelRefDepth"); 
		gl.disable(gl.BLEND);
	}
	if (renderType === 1)
	{
		currentShader = magoManager.postFxShadersManager.getShader("modelRefSsao"); 
		gl.enable(gl.BLEND);
	}
	
	var noiseTexture = magoManager.texturesStore.getNoiseTexture4x4();
	
	// Test rendering by modelRefShader.****
	currentShader.useProgram();
	gl.uniform1i(currentShader.bApplySsao_loc, true); // apply ssao.***
	gl.uniform1i(currentShader.refMatrixType_loc, 0); // in magoManager case, there are not referencesMatrix.***
	gl.uniform1i(currentShader.colorType_loc, 1); // 0= oneColor, 1= attribColor, 2= texture.***
	
	// -------------------------------------
	
	currentShader.disableVertexAttribArray(currentShader.texCoord2_loc);
	
	var shaderProgram = currentShader.program;
	currentShader.bindUniformGenerals();
	gl.enableVertexAttribArray(currentShader.position3_loc);
		
	if (renderType === 1)
	{
		var textureAux1x1 = magoManager.texturesStore.getTextureAux1x1();
		
		// provisionally render all native projects.***
		gl.enableVertexAttribArray(currentShader.normal3_loc);
		gl.enableVertexAttribArray(currentShader.color4_loc);

		gl.uniform1i(currentShader.bUse1Color_loc, false);
		if (color)
		{
			gl.uniform4fv(currentShader.oneColor4_loc, [color.r, color.g, color.b, 1.0]); //.***
		}
		else 
		{
			gl.uniform4fv(currentShader.oneColor4_loc, [1.0, 0.1, 0.1, 1.0]); //.***
		}
		
		gl.uniform1i(currentShader.bUseNormal_loc, true);

		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, magoManager.depthFboNeo.colorBuffer);  // original.***
		gl.activeTexture(gl.TEXTURE1);
		gl.bindTexture(gl.TEXTURE_2D, noiseTexture);
		gl.activeTexture(gl.TEXTURE2); 
		gl.bindTexture(gl.TEXTURE_2D, textureAux1x1);
	}
	
	var neoBuilding;
	var natProject, mesh;
	var geoLocDataManager;
	var buildingGeoLocation;
	var nodesCount = nodesArray.length;
	for (var b=0; b<nodesCount; b++)
	{
		node = nodesArray[b];
		neoBuilding = node.data.neoBuilding;

		gl.uniform3fv(currentShader.scale_loc, [1, 1, 1]); //.***
		var buildingGeoLocation = node.getNodeGeoLocDataManager().getCurrentGeoLocationData();
		
		buildingGeoLocation.bindGeoLocationUniforms(gl, currentShader);
		gl.uniform3fv(currentShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***
		
		magoManager.renderer.renderObject(gl, magoManager.axisXYZ, magoManager, currentShader, renderType);
	}
	

	currentShader.disableVertexAttribArrayAll();
	
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, null);  // original.***
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, null);
	gl.activeTexture(gl.TEXTURE2); 
	gl.bindTexture(gl.TEXTURE_2D, null);
	
	gl.disable(gl.BLEND);
};

/**
 * This function renders the bounding boxex of nodes included in nodesArray.
 * @param {Array} nodesArray Nodes that render the bbox.
 * @param {Color} color The color of the bounding box.
 * @param {Boolean} bRenderLines Parameter that indicates if render the edges of the bounding box.
 */
Renderer.prototype.renderBoundingBoxesNodes = function(nodesArray, color, bRenderLines) 
{
	var magoManager = this.magoManager;
	var gl = magoManager.getGl();
	
	if (nodesArray === undefined || nodesArray.length === 0)
	{ return; }
	
	if (magoManager.unitaryBoxSC === undefined)
	{
		magoManager.unitaryBoxSC = new BoxAux();
		magoManager.unitaryBoxSC.makeAABB(1.0, 1.0, 1.0); // make a unitary box.***
		magoManager.unitaryBoxSC.vBOVertexIdxCacheKey = magoManager.unitaryBoxSC.triPolyhedron.getVBOArrayModePosNorCol(magoManager.unitaryBoxSC.vBOVertexIdxCacheKey, magoManager.vboMemoryManager);
	}
	
	var node;
	var currentShader = magoManager.postFxShadersManager.getTriPolyhedronShader(); // box ssao.***
	var shaderProgram = currentShader.program;
	gl.enable(gl.BLEND);
	gl.frontFace(gl.CCW);
	gl.useProgram(shaderProgram);
	currentShader.disableVertexAttribArrayAll();
	currentShader.disableTextureImagesUnitsAll();

	gl.uniformMatrix4fv(currentShader.modelViewProjectionMatrix4RelToEye_loc, false, magoManager.sceneState.modelViewProjRelToEyeMatrix._floatArrays);
	gl.uniformMatrix4fv(currentShader.modelViewMatrix4RelToEye_loc, false, magoManager.sceneState.modelViewRelToEyeMatrix._floatArrays); // original.***
	gl.uniformMatrix4fv(currentShader.modelViewMatrix4_loc, false, magoManager.sceneState.modelViewMatrix._floatArrays);
	gl.uniformMatrix4fv(currentShader.projectionMatrix4_loc, false, magoManager.sceneState.projectionMatrix._floatArrays);
	gl.uniform3fv(currentShader.cameraPosHIGH_loc, magoManager.sceneState.encodedCamPosHigh);
	gl.uniform3fv(currentShader.cameraPosLOW_loc, magoManager.sceneState.encodedCamPosLow);

	gl.uniform1f(currentShader.near_loc, magoManager.sceneState.camera.frustum.near);
	gl.uniform1f(currentShader.far_loc, magoManager.sceneState.camera.frustum.far);
	
	gl.uniform1i(currentShader.bApplySsao_loc, false);

	gl.uniformMatrix4fv(currentShader.normalMatrix4_loc, false, magoManager.sceneState.normalMatrix4._floatArrays);
	//-----------------------------------------------------------------------------------------------------------

	gl.uniform1i(currentShader.hasAditionalMov_loc, true);
	gl.uniform3fv(currentShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***
	gl.uniform1i(currentShader.bScale_loc, true);
	var alfa = 1.0;
	gl.uniform1i(currentShader.bUse1Color_loc, true);
	if (color)
	{
		gl.uniform4fv(currentShader.oneColor4_loc, [color.r, color.g, color.b, alfa]); //.***
	}
	else 
	{
		gl.uniform4fv(currentShader.oneColor4_loc, [1.0, 0.0, 1.0, alfa]); //.***
	}

	gl.uniform1i(currentShader.depthTex_loc, 0);
	gl.uniform1i(currentShader.noiseTex_loc, 1);
	gl.uniform1i(currentShader.diffuseTex_loc, 2); // no used.***
	gl.uniform1f(currentShader.fov_loc, magoManager.sceneState.camera.frustum.fovyRad);	// "frustum._fov" is in radians.***
	gl.uniform1f(currentShader.aspectRatio_loc, magoManager.sceneState.camera.frustum.aspectRatio);
	gl.uniform1f(currentShader.screenWidth_loc, magoManager.sceneState.drawingBufferWidth);	
	gl.uniform1f(currentShader.screenHeight_loc, magoManager.sceneState.drawingBufferHeight);

	var noiseTexture = magoManager.texturesStore.getNoiseTexture4x4();
	gl.uniform2fv(currentShader.noiseScale2_loc, [magoManager.depthFboNeo.width/noiseTexture.width, magoManager.depthFboNeo.height/noiseTexture.height]);
	gl.uniform3fv(currentShader.kernel16_loc, magoManager.sceneState.ssaoKernel16);
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, magoManager.depthFboNeo.colorBuffer);  // original.***
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, noiseTexture);
	
	

	var neoBuilding;
	var bbox;
	var ssao_idx = 1;
	var nodesCount = nodesArray.length;
	for (var b=0; b<nodesCount; b++)
	{
		currentShader.resetLastBuffersBinded();
		
		node = nodesArray[b];
		neoBuilding = node.data.neoBuilding;
		bbox = node.getBBox();

		gl.uniform3fv(currentShader.scale_loc, [bbox.getXLength(), bbox.getYLength(), bbox.getZLength()]); //.***
		var buildingGeoLocation = node.getNodeGeoLocDataManager().getCurrentGeoLocationData();
		
		buildingGeoLocation.bindGeoLocationUniforms(gl, currentShader);

		magoManager.pointSC = bbox.getCenterPoint(magoManager.pointSC);
		gl.uniform3fv(currentShader.aditionalMov_loc, [magoManager.pointSC.x, magoManager.pointSC.y, magoManager.pointSC.z]); //.***
		//gl.uniform3fv(currentShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***
		this.renderObject(gl, magoManager.unitaryBoxSC, magoManager, currentShader, ssao_idx, bRenderLines);
	}

	currentShader.resetLastBuffersBinded();
	currentShader.disableVertexAttribArrayAll();
	currentShader.disableTextureImagesUnitsAll();
	
	gl.disable(gl.BLEND);
};

/**
 * This function renders a quad fitted to the screen.
 */
Renderer.prototype.renderFilter = function() 
{
	var magoManager = this.magoManager;
	var gl = magoManager.getGl();
	
	if (magoManager.screenQuad === undefined)
	{
		var sceneState = magoManager.sceneState;
		var camera = magoManager.myCameraSCX;
		var frustum = camera.bigFrustum;
		
		var fovyRad = magoManager.sceneState.camera.frustum.fovyRad;
		var aspectRatio = frustum.aspectRatio[0];
		var halfHeight = frustum.tangentOfHalfFovy[0];
		var halfWidth = halfHeight * aspectRatio;
		
		var lb = new Point3D(-halfWidth, -halfHeight, -1.0); // leftBottom.***
		var rb = new Point3D(halfWidth, -halfHeight, -1.0); // rightBottom.***
		var ru = new Point3D(halfWidth, halfHeight, -1.0); // rightUp.***
		var lu = new Point3D(-halfWidth, halfHeight, -1.0); // leftUp.***
	
		var data = new Float32Array([lb.x, lb.y, lb.z,   rb.x, rb.y, rb.z,   lu.x, lu.y, lu.z,   
			rb.x, rb.y, rb.z,   ru.x, ru.y, ru.z,   lu.x, lu.y, lu.z]);
		magoManager.screenQuad = FBO.createBuffer(gl, data);
	}
	
	var shaderName = "filterSilhouette"; 
	var currentShader = magoManager.postFxShadersManager.getShader(shaderName); 
	currentShader.useProgram();
	gl.uniform1i(currentShader.bApplySsao_loc, true); // apply ssao default.***
	
	var noiseTexture = magoManager.texturesStore.getNoiseTexture4x4();
	
	gl.enable(gl.BLEND);
	gl.disable(gl.DEPTH_TEST);
	gl.enableVertexAttribArray(currentShader.position3_loc);
	
	currentShader.bindUniformGenerals();
	gl.uniform1i(currentShader.textureFlipYAxis_loc, magoManager.sceneState.textureFlipYAxis);

	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, magoManager.depthFboNeo.colorBuffer);  // original.***
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, noiseTexture);
	gl.activeTexture(gl.TEXTURE2); 
	//gl.bindTexture(gl.TEXTURE_2D, magoManager.textureAux_1x1);
	//currentShader.last_tex_id = magoManager.textureAux_1x1;
	
	// do render.***
	gl.bindBuffer(gl.ARRAY_BUFFER, magoManager.screenQuad);
	gl.vertexAttribPointer(currentShader.position3_loc, 3, gl.FLOAT, false, 0, 0);
	gl.drawArrays(gl.TRIANGLES, 0, 6);
	
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, null);  // original.***
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, null);
	//gl.activeTexture(gl.TEXTURE2);
	//gl.bindTexture(gl.TEXTURE_2D, null);
	
	gl.disable(gl.BLEND);
	gl.enable(gl.DEPTH_TEST);
	
	currentShader.disableVertexAttribArrayAll();
	gl.useProgram(null);
};

/**
 * Renders the current frustumVolumen with colorCoding for selection.
 * @param {VisibleObjectsControler} visibleObjControlerBuildings Contains the current visible objects clasified by LOD.
 */
Renderer.prototype.renderGeometryColorCoding = function(visibleObjControlerNodes) 
{
	var magoManager = this.magoManager;
	var gl = magoManager.getGl();
	var renderType = 2; // 0 = depthRender, 1= colorRender, 2 = selectionRender.***
	
	magoManager.currentProcess = CODE.magoCurrentProcess.ColorCodeRendering;
	
	// Render mago modeler objects.***
	/*
	if (magoManager.modeler !== undefined)
	{
		currentShader = magoManager.postFxShadersManager.getShader("modelRefColorCoding"); 
		currentShader.useProgram();

		currentShader.enableVertexAttribArray(currentShader.position3_loc);
		currentShader.disableVertexAttribArray(currentShader.texCoord2_loc);
		currentShader.disableVertexAttribArray(currentShader.normal3_loc);
		
		currentShader.bindUniformGenerals();
		
		var refTMatrixIdxKey = 0;
		gl.uniform1i(currentShader.refMatrixType_loc, 0); // in this case, there are not referencesMatrix.
		magoManager.modeler.render(magoManager, currentShader, renderType);

		currentShader.disableVertexAttribArrayAll();
		gl.useProgram(null);
	}
	*/
	
	// Render f4d objects.***
	//if (magoManager.selectionFbo.dirty) // todo.
	{
		var refTMatrixIdxKey = 0;
		var renderTexture = false;

		var currentShader = magoManager.postFxShadersManager.getShader("modelRefColorCoding"); 
		currentShader.useProgram();
		currentShader.enableVertexAttribArray(currentShader.position3_loc);
		currentShader.disableVertexAttribArray(currentShader.texCoord2_loc);
		currentShader.disableVertexAttribArray(currentShader.normal3_loc);
		
		currentShader.bindUniformGenerals();
		
		gl.disable(gl.CULL_FACE);
		// do the colorCoding render.***
		var minSizeToRender = 0.0;
		magoManager.renderer.renderNodes(gl, visibleObjControlerNodes.currentVisibles0, magoManager, currentShader, renderTexture, renderType, minSizeToRender, refTMatrixIdxKey);
		magoManager.renderer.renderNodes(gl, visibleObjControlerNodes.currentVisibles2, magoManager, currentShader, renderTexture, renderType, minSizeToRender, refTMatrixIdxKey);
		magoManager.renderer.renderNodes(gl, visibleObjControlerNodes.currentVisibles3, magoManager, currentShader, renderTexture, renderType, minSizeToRender, refTMatrixIdxKey);
		// native objects.
		var glPrimitive = undefined;
		this.renderNativeObjects(gl, currentShader, renderType, visibleObjControlerNodes);
		/*
		var nativeObjectsCount = visibleObjControlerNodes.currentVisibleNativeObjects.length;
		for (var i=0; i<nativeObjectsCount; i++)
		{
			visibleObjControlerNodes.currentVisibleNativeObjects[i].render(magoManager, currentShader, renderType, glPrimitive);
		}
		*/
		gl.enable(gl.CULL_FACE);
		currentShader.disableVertexAttribArray(currentShader.position3_loc);
		gl.useProgram(null);
		
		// Render cuttingPlanes of temperaturalayers if exist.***
		if (magoManager.weatherStation)
		{ magoManager.weatherStation.test_renderCuttingPlanes(magoManager, renderType); }
	}
	if (magoManager.magoPolicy.objectMoveMode === CODE.moveMode.GEOGRAPHICPOINTS)
	{
		// render geographicCoords of the modeler.***
		if (magoManager.modeler !== undefined)
		{
			var shader = magoManager.postFxShadersManager.getShader("modelRefColorCoding"); 
			shader.useProgram();
			shader.enableVertexAttribArray(shader.position3_loc);
			shader.disableVertexAttribArray(shader.texCoord2_loc);
			shader.disableVertexAttribArray(shader.normal3_loc);
		
			shader.bindUniformGenerals();
			
			gl.disable(gl.CULL_FACE);
			magoManager.modeler.render(magoManager, shader, renderType);
		}
	}
	
	// tin terrain.***
	if (magoManager.tinTerrainManager !== undefined)
	{
		var bDepth = false;
		magoManager.tinTerrainManager.render(magoManager, bDepth, renderType);
		gl.useProgram(null);
	}
	
	// pins.**********************************************************************
	magoManager.objMarkerManager.render(magoManager, renderType);
	
}; 


/**
 * Mago geometries generation test.***
 * @param {Number} renderType If renderType = 0 (depth render), renderType = 1 (color render), renderType = 2 (colorCoding render).
 */
Renderer.prototype.renderMagoGeometries = function(renderType) 
{
	var magoManager = this.magoManager;
	
	// 1rst, make the test object if no exist.***
	//return;
	
	if (magoManager.nativeProjectsArray === undefined)
	{
		magoManager.nativeProjectsArray = [];
		var natProject = new MagoNativeProject();
		magoManager.nativeProjectsArray.push(natProject);
		
		var pMesh = natProject.newParametricMesh();
		
		pMesh.profile = new Profile2D(); // provisional.***
		var profileAux = pMesh.profile; // provisional.***
		
		profileAux.TEST__setFigureHole_2();
		//profileAux.TEST__setFigure_1();
		
		if (pMesh.vboKeyContainer === undefined)
		{ pMesh.vboKeyContainer = new VBOVertexIdxCacheKeysContainer(); }
		
		if (pMesh.vboKeyContainerEdges === undefined)
		{ pMesh.vboKeyContainerEdges = new VBOVertexIdxCacheKeysContainer(); }
		
		var bIncludeBottomCap, bIncludeTopCap;
		var extrusionVector, extrusionDist, extrudeSegmentsCount;
		/*
		extrudeSegmentsCount = 120;
		extrusionDist = 15.0;
		pMesh.extrude(profileAux, extrusionDist, extrudeSegmentsCount, extrusionVector);
		*/
		
		var revolveAngDeg, revolveSegmentsCount, revolveSegment2d;
		revolveAngDeg = 90.0;
		revolveSegment2d = new Segment2D();
		var strPoint2d = new Point2D(20, -10);
		var endPoint2d = new Point2D(20, 10);
		revolveSegment2d.setPoints(strPoint2d, endPoint2d);
		revolveSegmentsCount = 24;
		pMesh.revolve(profileAux, revolveAngDeg, revolveSegmentsCount, revolveSegment2d);
		
		bIncludeBottomCap = true;
		bIncludeTopCap = true;
		var mesh = pMesh.getSurfaceIndependentMesh(undefined, bIncludeBottomCap, bIncludeTopCap);
		mesh.setColor(0.1, 0.5, 0.5, 1.0);

		mesh.getVbo(pMesh.vboKeyContainer, magoManager.vboMemoryManager);
		mesh.getVboEdges(pMesh.vboKeyContainerEdges, magoManager.vboMemoryManager);
		
		// Now, provisionally make a geoLocationData for the nativeProject.*************************************
		if (natProject.geoLocDataManager === undefined)
		{
			natProject.geoLocDataManager = new GeoLocationDataManager();
			var geoLoc = natProject.geoLocDataManager.newGeoLocationData("deploymentLoc"); 
			
			var longitude = 126.61120237344926;
			var latitude = 37.577213509597016;
			var altitude = 50;
			var heading = 0.0;
			var pitch = 0.0;
			var roll = 0.0;

			ManagerUtils.calculateGeoLocationData(longitude, latitude, altitude, heading, pitch, roll, geoLoc, magoManager);
		}
		
	}
	//---------------------------------------------------------------------------------------------------------------
	var gl = magoManager.sceneState.gl;
	var color;
	var node;
	var currentShader;
	if (renderType === 0)
	{
		currentShader = magoManager.postFxShadersManager.getShader("modelRefDepth"); 
		gl.disable(gl.BLEND);
	}
	if (renderType === 1)
	{
		currentShader = magoManager.postFxShadersManager.getShader("modelRefSsao"); 
		gl.enable(gl.BLEND);
	}
	
	
	// Test rendering by modelRefShader.****
	currentShader.useProgram();
	gl.uniform1i(currentShader.bApplySsao_loc, true); // apply ssao.***
	gl.uniform1i(currentShader.refMatrixType_loc, 0); // in magoManager case, there are not referencesMatrix.***
	gl.uniform1i(currentShader.colorType_loc, 1); // 0= oneColor, 1= attribColor, 2= texture.***
	gl.uniform1i(currentShader.bApplySpecularLighting_loc, true); // turn on/off specular lighting & normals.***
	
	// -------------------------------------
	
	currentShader.disableVertexAttribArray(currentShader.texCoord2_loc);
	
	var shaderProgram = currentShader.program;
	currentShader.bindUniformGenerals();
	gl.enableVertexAttribArray(currentShader.position3_loc);
		
	if (renderType === 1)
	{
		var textureAux1x1 = magoManager.texturesStore.getTextureAux1x1();
		var noiseTexture = magoManager.texturesStore.getNoiseTexture4x4();
		
		// provisionally render all native projects.***
		gl.enableVertexAttribArray(currentShader.normal3_loc);
		gl.enableVertexAttribArray(currentShader.color4_loc);

		gl.uniform1i(currentShader.bUse1Color_loc, false);
		if (color)
		{
			gl.uniform4fv(currentShader.oneColor4_loc, [color.r, color.g, color.b, 1.0]); //.***
		}
		else 
		{
			gl.uniform4fv(currentShader.oneColor4_loc, [1.0, 0.1, 0.1, 1.0]); //.***
		}
		
		gl.uniform1i(currentShader.bUseNormal_loc, true);
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, magoManager.depthFboNeo.colorBuffer);  // original.***
		gl.activeTexture(gl.TEXTURE1);
		gl.bindTexture(gl.TEXTURE_2D, noiseTexture);
		gl.activeTexture(gl.TEXTURE2); 
		gl.bindTexture(gl.TEXTURE_2D, textureAux1x1);
	}
	
	var neoBuilding;
	var natProject, pMesh;
	var geoLocDataManager;
	var buildingGeoLocation;
	var bRenderLines = false;
	var nativeProjectsCount = magoManager.nativeProjectsArray.length;
	for (var i=0; i<nativeProjectsCount; i++)
	{
		natProject = magoManager.nativeProjectsArray[i];
		geoLocDataManager = natProject.geoLocDataManager;
		
		gl.uniform3fv(currentShader.scale_loc, [1, 1, 1]); //.***
		buildingGeoLocation = geoLocDataManager.getCurrentGeoLocationData();
		buildingGeoLocation.bindGeoLocationUniforms(gl, currentShader);

		gl.uniform3fv(currentShader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.***
		
		var meshesCount = natProject.getMeshesCount();
		for (var j=0; j<meshesCount; j++)
		{
			pMesh = natProject.getMesh(j);
			magoManager.renderer.renderObject(gl, pMesh, magoManager, currentShader, renderType, bRenderLines);
		}
	}
	
	if (currentShader)
	{
		if (currentShader.texCoord2_loc !== -1){ gl.disableVertexAttribArray(currentShader.texCoord2_loc); }
		if (currentShader.position3_loc !== -1){ gl.disableVertexAttribArray(currentShader.position3_loc); }
		if (currentShader.normal3_loc !== -1){ gl.disableVertexAttribArray(currentShader.normal3_loc); }
		if (currentShader.color4_loc !== -1){ gl.disableVertexAttribArray(currentShader.color4_loc); }
	}
	
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, null);  // original.***
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, null);
	gl.activeTexture(gl.TEXTURE2); 
	gl.bindTexture(gl.TEXTURE_2D, null);
	
	gl.disable(gl.BLEND);
	
};






'use strict';

/**
 * This class contains rendering settings.
 * @class RenderingSettings
 */
var RenderingSettings = function() 
{
	if (!(this instanceof RenderingSettings)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	/**
	 * Boolean parameter that indicates if apply screen space ambient occlusion when render.
	 * @type {Boolean}
	 * @default true
	 */
	this._bApplySsao = true;
	
	/**
	 * Boolean parameter that indicates if apply color ramp in pointsCloud.
	 * @type {Boolean}
	 * @default false
	 */
	this._bPointsCloudInColorRamp = false;
};

/**
 * Returns the _bApplySsao variable.
 * @return {Boolean} this._bApplySsao
 */
RenderingSettings.prototype.getApplySsao = function()
{
	return this._bApplySsao;
};

/**
 * Sets the _bApplySsao variable.
 * @param {Boolean} bApplySsao
 */
RenderingSettings.prototype.setApplySsao = function(bApplySsao)
{
	this._bApplySsao = bApplySsao;
};

/**
 * Returns the _PointsCloudInColorRamp variable.
 * @return {Boolean} this._PointsCloudInColorRamp
 */
RenderingSettings.prototype.getPointsCloudInColorRamp = function()
{
	return this._bPointsCloudInColorRamp;
};

/**
 * Sets the _bPointsCloudInColorRamp variable.
 * @param {Boolean} bPointsCloudInColorRamp
 */
RenderingSettings.prototype.setPointsCloudInColorRamp = function(bPointsCloudInColorRamp)
{
	this._bPointsCloudInColorRamp = bPointsCloudInColorRamp;
};
'use strict';

/**
 * This class contains the camera transformation matrices and other parameters that affects the scene.
 * @class SceneState
 */
var SceneState = function() 
{
	if (!(this instanceof SceneState)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.gl;

	// this contains the model matrices and camera position.
	this.modelMatrix = new Matrix4(); // created as identity matrix.
	this.viewMatrix = new Matrix4(); // created as identity matrix.
	this.modelViewProjRelToEyeMatrix = new Matrix4(); // created as identity matrix.
	this.modelViewRelToEyeMatrix = new Matrix4(); // created as identity matrix.
	this.modelViewRelToEyeMatrixInv = new Matrix4(); // created as identity matrix.
	this.modelViewMatrix = new Matrix4(); // created as identity matrix.
	this.modelViewMatrixInv = new Matrix4(); // created as identity matrix.
	this.projectionMatrix = new Matrix4(); // created as identity matrix.
	this.projectionMatrixInv = new Matrix4(); // created as identity matrix.
	this.modelViewProjMatrix = new Matrix4(); // created as identity matrix.
	this.modelViewProjMatrixInv; // initially undefined.
	this.normalMatrix4 = new Matrix4(); // created as identity matrix.
	this.identityMatrix4 = new Matrix4(); // created as identity matrix.
	this.modelViewMatrixLast = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // Number array.
	this.projectionMatrixLast = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // Number array.

	this.encodedCamPosHigh = new Float32Array([0.0, 0.0, 0.0]);
	this.encodedCamPosLow = new Float32Array([0.0, 0.0, 0.0]);
	
	this.camera = new Camera();
	this.drawingBufferWidth = new Int32Array([1000]);
	this.drawingBufferHeight = new Int32Array([1000]);
	this.mouseAction = new MouseAction();
	
	// Sun.***
	// omni = 0, spot = 1, directional = 2, area = 3, volume = 4.
	var lightType = 2;
	this.sunLight = new LightSource(lightType); // OLD.***
	this.sunSystem = new SunSystem();
	this.applySunShadows = false;
	
	// lighting & ssao.
	this.ambientReflectionCoef = new Float32Array([0.5]); // 0.7.
	this.diffuseReflectionCoef = new Float32Array([1.0]); // 0.4
	this.specularReflectionCoef = new Float32Array([0.6]); // 0.6
	this.specularColor = new Float32Array([0.7, 0.7, 0.7]);
	this.ambientColor = new Float32Array([1.0, 1.0, 1.0]);
	this.ssaoRadius = new Float32Array([0.15]);
	this.shininessValue = new Float32Array([40.0]);
	this.ssaoNoiseScale2 = new Float32Array([1.0, 1.0]); // [this.depthFboNeo.width[0]/this.noiseTexture.width, this.depthFboNeo.height[0]/this.noiseTexture.height]
	this.ssaoKernel16 = new Float32Array([ 0.33, 0.0, 0.85,
		0.25, 0.3, 0.5,
		0.1, 0.3, 0.85,
		-0.15, 0.2, 0.85,
		-0.33, 0.05, 0.6,
		-0.1, -0.15, 0.85,
		-0.05, -0.32, 0.25,
		0.2, -0.15, 0.85,
		0.6, 0.0, 0.55,
		0.5, 0.6, 0.45,
		-0.01, 0.7, 0.35,
		-0.33, 0.5, 0.45,
		-0.45, 0.0, 0.55,
		-0.65, -0.5, 0.7,
		0.0, -0.5, 0.55,
		0.33, 0.3, 0.35]);
	/*
	var hAux = 1.0;
	this.ssaoKernel16 = new Float32Array([ 0.33, 0.0, hAux,
		0.25, 0.3, hAux,
		0.1, 0.3, hAux,
		-0.15, 0.2, hAux,
		-0.33, 0.05, hAux,
		-0.1, -0.15, hAux,
		-0.05, -0.32, hAux,
		0.2, -0.15, hAux,
		0.6, 0.0, hAux,
		0.5, 0.6, hAux,
		-0.01, 0.7, hAux,
		-0.33, 0.5, hAux,
		-0.45, 0.0, hAux,
		-0.65, -0.5, hAux,
		0.0, -0.5, hAux,
		0.33, 0.3, hAux]);
		*/
		
	this.ssaoSphereKernel32 = new Float32Array([ 0.33, 0.0, 0.85,
		0.25, 0.3, 0.5,
		0.1, 0.3, 0.85,
		-0.15, 0.2, 0.85,
		-0.33, 0.05, 0.6,
		-0.1, -0.15, 0.85,
		-0.05, -0.32, 0.25,
		0.2, -0.15, 0.85,
		0.6, 0.0, 0.55,
		0.5, 0.6, 0.45,
		-0.01, 0.7, 0.35,
		-0.33, 0.5, 0.45,
		-0.45, 0.0, 0.55,
		-0.65, -0.5, 0.7,
		0.0, -0.5, 0.55,
		0.33, 0.3, 0.35,
		
		 0.33, 0.0, -0.85,
		0.25, 0.3, -0.5,
		0.1, 0.3, -0.85,
		-0.15, 0.2, -0.85,
		-0.33, 0.05, -0.6,
		-0.1, -0.15, -0.85,
		-0.05, -0.32, -0.25,
		0.2, -0.15, -0.85,
		0.6, 0.0, -0.55,
		0.5, 0.6, -0.45,
		-0.01, 0.7, -0.35,
		-0.33, 0.5, -0.45,
		-0.45, 0.0, -0.55,
		-0.65, -0.5, -0.7,
		0.0, -0.5, -0.55,
		0.33, 0.3, -0.35]);
		
	this.bMust = false;
	
	// webWorldWind vars.
	this.dc;
	
	// insertIssue states.
	this.insertIssueState = 0; // 0 = no started. 1 = started.
	
	// provisionally.
	this.textureFlipYAxis = false;
	
	// mouse.
	this.mouseButton = -1;
	
	// some stadistics.
	this.trianglesRenderedCount = 0;
	this.pointsRenderedCount = 0;
	this.fps = 0.0;
	
};

/**
 */
SceneState.prototype.resetStadistics = function() 
{
	this.trianglesRenderedCount = 0;
	this.pointsRenderedCount = 0;
	this.fps = 0.0;
};

/**
 */
SceneState.prototype.restoreDefaultValuesAmbientDiffuseSpecularCoeficients = function() 
{
	this.ambientReflectionCoef[0] = 0.7; 
	this.diffuseReflectionCoef[0] = 0.40; 
	this.specularReflectionCoef[0] = 0.6; 
};

/**
 * Returns the modelViewMatrixInverse.
 * @returns {Matrix4} modelViewMatrixInv.
 */
SceneState.prototype.getModelViewMatrixInv = function() 
{
	return this.modelViewMatrixInv;
};

/**
 * Returns the modelViewMatrixInverse.
 * @returns {Matrix4} modelViewMatrixInv.
 */
SceneState.prototype.getProjectionMatrixInv = function() 
{
	if (this.projectionMatrixInv === undefined)
	{
		this.projectionMatrixInv = new Matrix4();
		this.projectionMatrixInv._floatArrays = glMatrix.mat4.invert(this.projectionMatrixInv._floatArrays, this.projectionMatrix._floatArrays);
	}
	return this.projectionMatrixInv;
};

/**
 * Returns the modelViewMatrixInverse.
 * @returns {Matrix4} modelViewMatrixInv.
 */
SceneState.prototype.getModelViewProjectionMatrixInv = function() 
{
	if (this.modelViewProjMatrixInv === undefined)
	{
		this.modelViewProjMatrixInv = new Matrix4();
		this.modelViewProjMatrixInv._floatArrays = glMatrix.mat4.invert(this.modelViewProjMatrixInv._floatArrays, this.modelViewProjMatrix._floatArrays);
	}
	return this.modelViewProjMatrixInv;
};

/**
 * Returns the modelViewMatrixInverse.
 * @returns {Matrix4} modelViewMatrixInv.
 */
SceneState.prototype.getModelViewRelToEyeMatrixInv = function() 
{
	if (this.modelViewRelToEyeMatrixInv === undefined)
	{
		this.modelViewRelToEyeMatrixInv = new Matrix4();
		this.modelViewRelToEyeMatrixInv._floatArrays = glMatrix.mat4.invert(this.modelViewRelToEyeMatrixInv._floatArrays, this.modelViewRelToEyeMatrix._floatArrays);
	}
	return this.modelViewRelToEyeMatrixInv;
};

/**
 * Returns the camera.
 */
SceneState.prototype.getCamera = function() 
{
	return this.camera;
};

/**
 * Returns the camera.
 */
SceneState.prototype.setApplySunShadows = function(bApplySunShadows) 
{
	this.applySunShadows = bApplySunShadows;
};

































'use strict';

// NO USED.

/**
 * 어떤 일을 하고 있습니까?
 * @class Selection
 */
var Selection = function() 
{
	if (!(this instanceof Selection)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.drawing_height;
	this.drawing_width;
	this.GAIA_selectFrameBuffer;
	this.GAIA_selectRenderBuffer;
	this.GAIA_selectRttTexture;
	
	this.currentByteColorPicked = new Uint8Array(4);
	this.currentSelectedObj_idx = -1;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param drawingBufferWidth 변수
 * @param drawingBufferHeight 변수
 */
Selection.prototype.init = function(gl, drawingBufferWidth, drawingBufferHeight) 
{
	// http://www.webglacademy.com/courses.php?courses=0|1|20|2|3|4|23|5|6|7|10#10
	this.drawing_height = drawingBufferHeight;
	this.drawing_width = drawingBufferWidth;
	//this.lastCapturedColourMap = new Uint8Array(this.drawing_width * this.drawing_height * 4);
	this.GAIA_selectFrameBuffer = gl.createFramebuffer();
	gl.bindFramebuffer(gl.FRAMEBUFFER, this.GAIA_selectFrameBuffer);
	
	this.GAIA_selectRenderBuffer = gl.createRenderbuffer();
	gl.bindRenderbuffer(gl.RENDERBUFFER, this.GAIA_selectRenderBuffer);
	gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.drawing_width, this.drawing_height);

	this.GAIA_selectRttTexture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, this.GAIA_selectRttTexture);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.drawing_width, this.drawing_height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.GAIA_selectRttTexture, 0);
	gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.GAIA_selectRenderBuffer);
	
	// Finally...
	gl.bindTexture(gl.TEXTURE_2D, null);
	gl.bindRenderbuffer(gl.RENDERBUFFER, null);
	gl.bindFramebuffer(gl.FRAMEBUFFER, null);
};
'use strict';

/**
 * SelectionCandidateFamily
 * 
 * @alias SelectionCandidateFamily
 * @class SelectionCandidateFamily
 */
var SelectionCandidateFamily = function() 
{
	if (!(this instanceof SelectionCandidateFamily)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.familyTypeName;
	this.candidatesMap = {};
	this.currentSelected;
};

/**
 */
SelectionCandidateFamily.prototype.setCandidate = function(idxKey, candidate)
{
	if (idxKey !== undefined && candidate)
	{
		this.candidatesMap[idxKey] = candidate;
	}
};

/**
 * SelectionCandidateFamily
 */
SelectionCandidateFamily.prototype.clearCandidate = function()
{
	this.candidatesMap = {};
	this.currentSelected = undefined;
};

/**
 * SelectionCandidateFamily
 */
SelectionCandidateFamily.prototype.clearCurrentSelected = function()
{
	this.currentSelected = undefined;
};

/**
 * SelectionCandidateFamily
 */
SelectionCandidateFamily.prototype.selectObject = function(idxKey)
{
	this.currentSelected = this.candidatesMap[idxKey];
	return this.currentSelected;
};

'use strict';

/**
 * SelectionManager. This class manages the selection process and the selection candidates.
 * 
 * @alias SelectionManager
 * @class SelectionManager
 */
var SelectionManager = function(magoManager) 
{
	if (!(this instanceof SelectionManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	//2020 01 24 추가
	this.magoManager = magoManager;

	// General candidates. 
	this.selCandidatesMap = {};
	this.currentGeneralObjectSelected;
	
	// Default f4d objectsMap. // Deprecated.
	this.referencesMap = {}; // Deprecated.
	this.octreesMap = {}; // Deprecated.
	this.buildingsMap = {}; // Deprecated.
	this.nodesMap = {}; // Deprecated.
	
	this.currentReferenceSelected; // Deprecated.
	this.currentOctreeSelected; // Deprecated.
	this.currentBuildingSelected; // Deprecated.
	this.currentNodeSelected; // Deprecated.
	
	// Custom candidates.
	this.selCandidatesFamilyMap = {};

	// Parameter that indicates that we are rendering selected data structure.
	this.parentSelected = false;
};

/**
 * SelectionManager
 * 
 * @alias SelectionManager
 * @class SelectionManager
 */
SelectionManager.prototype.newCandidatesFamily = function(candidatesFamilyTypeName)
{
	var selCandidate = new SelectionCandidateFamily();
	selCandidate.familyTypeName = candidatesFamilyTypeName;
	this.selCandidatesFamilyMap[candidatesFamilyTypeName] = selCandidate;
	return selCandidate;
};

/**
 * SelectionManager
 * 
 * @alias SelectionManager
 * @class SelectionManager
 */
SelectionManager.prototype.getSelectionCandidatesFamily = function(familyName)
{
	return this.selCandidatesFamilyMap[familyName];
};

/**
 * SelectionManager
 * 
 * @alias SelectionManager
 * @class SelectionManager
 */
SelectionManager.prototype.setCandidateCustom = function(idxKey, familyName, object)
{
	var selCandidatesFamily = this.getSelectionCandidatesFamily(familyName);
	if (selCandidatesFamily)
	{
		selCandidatesFamily.setCandidate(idxKey, object);
	}
};

/**
 * SelectionManager. Recomended. Use this for all selection process.
 * 
 * @alias SelectionManager
 * @class SelectionManager
 */
SelectionManager.prototype.setCandidateGeneral = function(idxKey, candidateObject)
{
	this.selCandidatesMap[idxKey] = candidateObject;
};

/**
 * SelectionManager
 * 
 * @alias SelectionManager
 * @class SelectionManager
 */
SelectionManager.prototype.getCandidateGeneral = function(idxKey)
{
	return this.selCandidatesMap[idxKey];
};

/**
 * SelectionManager
 * 
 * @alias SelectionManager
 * @class SelectionManager
 */
SelectionManager.prototype.getSelectedGeneral = function()
{
	return this.currentGeneralObjectSelected;
};

/**
 * SelectionManager
 * 
 * @alias SelectionManager
 * @class SelectionManager
 */
SelectionManager.prototype.setCandidates = function(idxKey, reference, octree, building, node)
{
	if (reference)
	{
		this.referencesMap[idxKey] = reference;
	}
	
	if (octree)
	{
		this.octreesMap[idxKey] = octree;
	}
	
	if (building)
	{
		this.buildingsMap[idxKey] = building;
	}
	
	if (node)
	{
		this.nodesMap[idxKey] = node;
	}
};

/**
 * SelectionManager
 * 
 * @alias SelectionManager
 * @class SelectionManager
 */
SelectionManager.prototype.clearCandidates = function()
{
	this.referencesMap = {};
	this.octreesMap = {};
	this.buildingsMap = {};
	this.nodesMap = {};
	
	for (var key in this.selCandidatesFamilyMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.selCandidatesFamilyMap, key))
		{
			var selCandidateFamily = this.selCandidatesFamilyMap[key];
			selCandidateFamily.clearCandidate();
		}

	}
	
	// General selection candidates map.
	this.selCandidatesMap = {};
};

/**
 * SelectionManager
 * 
 * @alias SelectionManager
 * @class SelectionManager
 */
SelectionManager.prototype.selectObjects = function(idxKey)
{
	this.currentReferenceSelected = this.referencesMap[idxKey];
	this.currentOctreeSelected = this.octreesMap[idxKey];
	this.currentBuildingSelected = this.buildingsMap[idxKey];
	this.currentNodeSelected = this.nodesMap[idxKey];

	for (var key in this.selCandidatesFamilyMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.selCandidatesFamilyMap, key))
		{
			var selCandidateFamily = this.selCandidatesFamilyMap[key];
			selCandidateFamily.selectObject(idxKey);
		}
	}
	
	this.currentGeneralObjectSelected = this.selCandidatesMap[idxKey];
};

/**
 * SelectionManager
 */
SelectionManager.prototype.isObjectSelected = function(object)
{
	if (object === undefined)
	{ return false; }
	
	if (this.currentReferenceSelected === object)
	{ return true; }
	
	if (this.currentBuildingSelected === object)
	{ return true; }
	
	if (this.currentNodeSelected === object)
	{ return true; }
	
	if (this.currentGeneralObjectSelected === object)
	{ return true; }
	
	return false;
};

/**
 * SelectionManager
 * 
 * @alias SelectionManager
 * @class SelectionManager
 */
SelectionManager.prototype.clearCurrents = function()
{
	this.currentReferenceSelected = undefined;
	this.currentOctreeSelected = undefined;
	this.currentBuildingSelected = undefined;
	this.currentNodeSelected = undefined;
	
	for (var key in this.selCandidatesFamilyMap)
	{
		if (Object.prototype.hasOwnProperty.call(this.selCandidatesFamilyMap, key))
		{
			var selCandidateFamily = this.selCandidatesFamilyMap[key];
			selCandidateFamily.clearCurrentSelected();
		}
	}

	this.currentGeneralObjectSelected = undefined;
};

/**
 * SelectionManager
 * 
 * @alias SelectionManager
 * @class SelectionManager
 */
SelectionManager.prototype.TEST__CurrGeneralObjSel = function()
{
	if (this.currentGeneralObjectSelected)
	{ return true; }
	else
	{ return false; }
};

'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class AttribLocationState
 */
var AttribLocationState = function() 
{
	if (!(this instanceof AttribLocationState)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.attribLocationEnabled = false;
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class PostFxShader
 * @param gl 변수
 */
var PostFxShader = function(gl) 
{
	if (!(this instanceof PostFxShader)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl = gl;
	this.name;
	this.attribLocationCacheObj = {}; // old.
	this.uniformsArrayGeneral = []; // this array has the same uniforms that "uniformsCacheObj".
	this.uniformsMapGeneral = {}; // this object has the same uniforms that "uniformsArray".
	
	this.uniformsArrayLocal = []; // this array has the same uniforms that "uniformsCacheObj".
	this.uniformsMapLocal = {}; // this object has the same uniforms that "uniformsArray".
	
	// No general objects.
	this.camera;
	
	// shader program.
	this.program;
	this.shader_vertex;
	this.shader_fragment;
	
	// current buffers binded.
	this.last_tex_id;
	this.last_isAditionalMovedZero = false;
	
	this.lastVboKeyBindedMap = {};
	
	
	// attribLocations state management.
	this.attribLocationStateArray = [];
	
	this.shaderManager; 
};

PostFxShader.createShader = function(gl, type, source) 
{
	var shader = gl.createShader(type);
	gl.shaderSource(shader, source);

	gl.compileShader(shader);
	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) 
	{
		throw new Error(gl.getShaderInfoLog(shader));
	}

	return shader;
};

PostFxShader.createProgram = function(gl, vertexSource, fragmentSource) 
{
	// static function.***
	var program = gl.createProgram();

	var vertexShader = PostFxShader.createShader(gl, gl.VERTEX_SHADER, vertexSource);
	var fragmentShader = PostFxShader.createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);

	gl.attachShader(program, vertexShader);
	gl.attachShader(program, fragmentShader);

	gl.linkProgram(program);
	if (!gl.getProgramParameter(program, gl.LINK_STATUS)) 
	{
		throw new Error(gl.getProgramInfoLog(program));
	}

	var wrapper = {program: program};

	var numAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
	for (var i = 0; i < numAttributes; i++) 
	{
		var attribute = gl.getActiveAttrib(program, i);
		wrapper[attribute.name] = gl.getAttribLocation(program, attribute.name);
	}
	var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
	for (var i = 0; i < numUniforms; i++) 
	{
		var uniform = gl.getActiveUniform(program, i);
		wrapper[uniform.name] = gl.getUniformLocation(program, uniform.name);
	}

	return wrapper;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 * @returns shader
 */
PostFxShader.prototype.resetLastBuffersBinded = function()
{
	this.last_tex_id = undefined; // todo: must distinguish by channel.
	this.last_isAditionalMovedZero = false;
	
	this.lastVboKeyBindedMap = {};
	
	this.disableVertexAttribArrayAll();
	
	if (this.attribLocationStateArray)
	{
		var attribLocsCount = this.attribLocationStateArray.length;
		for (var i=0; i<attribLocsCount; i++)
		{
			var attribLocationState = this.attribLocationStateArray[i];
			if (attribLocationState !== undefined)
			{
				attribLocationState.attribLocationEnabled = undefined;
				this.attribLocationStateArray[i] = undefined;
			}
		}
		this.attribLocationStateArray.length = 0;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 * @returns shader
 */
PostFxShader.prototype.enableVertexAttribArray = function(attribLocation)
{
	if (attribLocation === undefined || attribLocation < 0)
	{ return false; }
	
	var attribLocationState = this.attribLocationStateArray[attribLocation];
	if (attribLocationState === undefined)
	{
		attribLocationState = new AttribLocationState();
		this.attribLocationStateArray[attribLocation] = attribLocationState;
		attribLocationState.attribLocationEnabled = false;
	}

	if (!attribLocationState.attribLocationEnabled)
	{
		this.gl.enableVertexAttribArray(attribLocation);
		attribLocationState.attribLocationEnabled = true;
	}
	
	return true;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 * @returns shader
 */
PostFxShader.prototype.disableTextureImagesUnitsAll = function()
{
	var gl = this.gl;
	var textureImagesUnitsCount = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
	for (var i = 0; i<textureImagesUnitsCount; i++)
	{ 
		gl.activeTexture(gl.TEXTURE0 + i);
		gl.bindTexture(gl.TEXTURE_2D, null);
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 * @returns shader
 */
PostFxShader.prototype.disableVertexAttribArrayAll = function()
{
	var gl = this.gl;
	var vertexAttribsCount = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
	for (var i = 0; i<vertexAttribsCount; i++)
	{ gl.disableVertexAttribArray(i); }
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 * @returns shader
 */
PostFxShader.prototype.disableVertexAttribArray = function(attribLocation)
{
	if (attribLocation === undefined || attribLocation < 0)
	{ return; }
	
	var attribLocationState = this.attribLocationStateArray[attribLocation];
	if (attribLocationState === undefined)
	{
		attribLocationState = new AttribLocationState();
		this.attribLocationStateArray[attribLocation] = attribLocationState;
		attribLocationState.attribLocationEnabled = true;
	}

	if (attribLocationState.attribLocationEnabled)
	{
		this.gl.disableVertexAttribArray(attribLocation);
		attribLocationState.attribLocationEnabled = false;
	}
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 * @returns shader
 */
PostFxShader.prototype.useProgram = function()
{
	var gl = this.gl;
	var currProgram = gl.getParameter(gl.CURRENT_PROGRAM);
	if (currProgram !== this.program)
	{
		gl.useProgram(this.program);
		this.shaderManager.currentShaderUsing = this;
	}
	this.resetLastBuffersBinded();
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 * @returns shader
 */
PostFxShader.prototype.bindUniformGenerals = function()
{
	if (this.uniformsArrayGeneral === undefined)
	{ return; }
	
	var uniformsDataPairsCount = this.uniformsArrayGeneral.length;
	for (var i=0; i<uniformsDataPairsCount; i++)
	{
		this.uniformsArrayGeneral[i].bindUniform();
	}
	
	// Bind camera uniforms.
	if (this.camera)
	{ this.camera.bindUniforms(this.gl, this); }
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 * @returns shader
 */
PostFxShader.prototype.newUniformDataPair = function(uniformType, uniformName)
{
	var uniformDataPair;//
	if (uniformType === "Matrix4fv")
	{
		uniformDataPair = new UniformMatrix4fvDataPair(this.gl, uniformName);
		this.uniformsArrayGeneral.push(uniformDataPair);
		this.uniformsMapGeneral[uniformName] = uniformDataPair;
	}
	else if (uniformType === "Vec4fv")
	{
		uniformDataPair = new UniformVec4fvDataPair(this.gl, uniformName);
		this.uniformsArrayGeneral.push(uniformDataPair);
		this.uniformsMapGeneral[uniformName] = uniformDataPair;
	}
	else if (uniformType === "Vec3fv")
	{
		uniformDataPair = new UniformVec3fvDataPair(this.gl, uniformName);
		this.uniformsArrayGeneral.push(uniformDataPair);
		this.uniformsMapGeneral[uniformName] = uniformDataPair;
	}
	else if (uniformType === "Vec2fv")
	{
		uniformDataPair = new UniformVec2fvDataPair(this.gl, uniformName);
		this.uniformsArrayGeneral.push(uniformDataPair);
		this.uniformsMapGeneral[uniformName] = uniformDataPair;
	}
	else if (uniformType === "1f")
	{
		uniformDataPair = new Uniform1fDataPair(this.gl, uniformName);
		this.uniformsArrayGeneral.push(uniformDataPair);
		this.uniformsMapGeneral[uniformName] = uniformDataPair;
	}
	else if (uniformType === "1i")
	{
		uniformDataPair = new Uniform1iDataPair(this.gl, uniformName);
		this.uniformsArrayGeneral.push(uniformDataPair);
		this.uniformsMapGeneral[uniformName] = uniformDataPair;
	}
	
	return uniformDataPair;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 * @returns shader
 */
PostFxShader.prototype.newUniformDataPairLocal = function(uniformType, uniformName)
{
	var uniformDataPair;//
	if (uniformType === "Matrix4fv")
	{
		uniformDataPair = new UniformMatrix4fvDataPair(this.gl, uniformName);
		this.uniformsArrayLocal.push(uniformDataPair);
		this.uniformsMapLocal[uniformName] = uniformDataPair;
	}
	else if (uniformType === "Vec4fv")
	{
		uniformDataPair = new UniformVec4fvDataPair(this.gl, uniformName);
		this.uniformsArrayLocal.push(uniformDataPair);
		this.uniformsMapLocal[uniformName] = uniformDataPair;
	}
	else if (uniformType === "Vec3fv")
	{
		uniformDataPair = new UniformVec3fvDataPair(this.gl, uniformName);
		this.uniformsArrayLocal.push(uniformDataPair);
		this.uniformsMapLocal[uniformName] = uniformDataPair;
	}
	else if (uniformType === "Vec2fv")
	{
		uniformDataPair = new UniformVec2fvDataPair(this.gl, uniformName);
		this.uniformsArrayLocal.push(uniformDataPair);
		this.uniformsMapLocal[uniformName] = uniformDataPair;
	}
	else if (uniformType === "1f")
	{
		uniformDataPair = new Uniform1fDataPair(this.gl, uniformName);
		this.uniformsArrayLocal.push(uniformDataPair);
		this.uniformsMapLocal[uniformName] = uniformDataPair;
	}
	else if (uniformType === "1i")
	{
		uniformDataPair = new Uniform1iDataPair(this.gl, uniformName);
		this.uniformsArrayLocal.push(uniformDataPair);
		this.uniformsMapLocal[uniformName] = uniformDataPair;
	}
	
	return uniformDataPair;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 */
PostFxShader.prototype.createUniformGenerals = function(gl, shader, sceneState)
{
	// Here create all generals uniforms, if exist, of the shader.
	var uniformDataPair;
	var uniformLocation;

	// 1. ModelViewProjectionMatrixRelToEye.              
	uniformLocation = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Matrix4fv", "mvpMat4RelToEye");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.matrix4fv = sceneState.modelViewProjRelToEyeMatrix._floatArrays;
	}
	
	// 1. ModelViewProjectionMatrix.
	uniformLocation = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrix");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Matrix4fv", "mvpMat4");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.matrix4fv = sceneState.modelViewProjMatrix._floatArrays;
	}
	
	// 2. modelViewMatrixRelToEye.
	uniformLocation = gl.getUniformLocation(shader.program, "modelViewMatrixRelToEye");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Matrix4fv", "mvMat4RelToEye");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.matrix4fv = sceneState.modelViewRelToEyeMatrix._floatArrays;
	}
	
	// 3. modelViewMatrix.
	uniformLocation = gl.getUniformLocation(shader.program, "modelViewMatrix");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Matrix4fv", "modelViewMatrix");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.matrix4fv = sceneState.modelViewMatrix._floatArrays;
	}
	
	// 3.1. modelViewMatrixInv.
	uniformLocation = gl.getUniformLocation(shader.program, "modelViewMatrixInv");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Matrix4fv", "modelViewMatrixInv");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.matrix4fv = sceneState.modelViewMatrixInv._floatArrays;
	}
	
	// 4. projectionMatrix.
	uniformLocation = gl.getUniformLocation(shader.program, "projectionMatrix");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Matrix4fv", "pMat4");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.matrix4fv = sceneState.projectionMatrix._floatArrays;
	}
	
	// 5. normalMatrix4.
	uniformLocation = gl.getUniformLocation(shader.program, "normalMatrix4");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Matrix4fv", "normalMat4");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.matrix4fv = sceneState.normalMatrix4._floatArrays;
	}
	
	// 6. encodedCameraPositionMCHigh.
	uniformLocation = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Vec3fv", "encodedCamPosHigh");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.vec3fv = sceneState.encodedCamPosHigh;
	}
	
	// 7. encodedCameraPositionMCLow.
	uniformLocation = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Vec3fv", "encodedCamPosLow");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.vec3fv = sceneState.encodedCamPosLow;
	}
	
	// 10. fovy.
	uniformLocation = gl.getUniformLocation(shader.program, "fov");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "fovyRad");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.camera.frustum.fovyRad;
	}
	
	// 10.1 tangentOfHalfFovy.
	uniformLocation = gl.getUniformLocation(shader.program, "tangentOfHalfFovy");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "tangentOfHalfFovy");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.camera.frustum.tangentOfHalfFovy;
	}
	
	// 11. aspectRatio.
	uniformLocation = gl.getUniformLocation(shader.program, "aspectRatio");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "aspectRatio");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.camera.frustum.aspectRatio;
	}
	
	// 12. drawBuffWidht.
	uniformLocation = gl.getUniformLocation(shader.program, "screenWidth");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "drawBuffWidht");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.drawingBufferWidth;
	}
	
	// 13. drawBuffHeight.
	uniformLocation = gl.getUniformLocation(shader.program, "screenHeight");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "drawBuffHeight");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.drawingBufferHeight;
	}
	
	// 14. depthTex.
	uniformLocation = gl.getUniformLocation(shader.program, "depthTex");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1i", "depthTex");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.intValue = 0;
	}
	
	// 15. noiseTex.
	uniformLocation = gl.getUniformLocation(shader.program, "noiseTex");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1i", "noiseTex");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.intValue = 1;
	}
	
	// 16. diffuseTex.
	uniformLocation = gl.getUniformLocation(shader.program, "diffuseTex");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1i", "diffuseTex");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.intValue = 2;
	}
	
	// 16.1 shadowMapTex.
	uniformLocation = gl.getUniformLocation(shader.program, "shadowMapTex");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1i", "shadowMapTex");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.intValue = 3;
	}
	
	// 16.2 shadowMapTex2.
	uniformLocation = gl.getUniformLocation(shader.program, "shadowMapTex2");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1i", "shadowMapTex2");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.intValue = 4;
	}
	
	// 17. specularColor.
	uniformLocation = gl.getUniformLocation(shader.program, "specularColor");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Vec3fv", "specularColor");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.vec3fv = sceneState.specularColor;
	}
	
	// 17. ambientColor.
	uniformLocation = gl.getUniformLocation(shader.program, "ambientColor");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Vec3fv", "ambientColor");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.vec3fv = sceneState.ambientColor;
	}
	
	// 18. ssaoRadius.
	uniformLocation = gl.getUniformLocation(shader.program, "radius");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "radius");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.ssaoRadius;
	}
	
	// 19. ambientReflectionCoef.
	uniformLocation = gl.getUniformLocation(shader.program, "ambientReflectionCoef");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "ambientReflectionCoef");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.ambientReflectionCoef;
	}
	
	// 20. diffuseReflectionCoef.
	uniformLocation = gl.getUniformLocation(shader.program, "diffuseReflectionCoef");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "diffuseReflectionCoef");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.diffuseReflectionCoef;
	}
	
	// 21. specularReflectionCoef.
	uniformLocation = gl.getUniformLocation(shader.program, "specularReflectionCoef");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "specularReflectionCoef");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.specularReflectionCoef;
	}
	
	// 22. shininessValue.
	uniformLocation = gl.getUniformLocation(shader.program, "shininessValue");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("1f", "shininessValue");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.floatValue = sceneState.shininessValue;
	}
	
	// 23. ssaoNoiseScale2.
	uniformLocation = gl.getUniformLocation(shader.program, "noiseScale");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Vec2fv", "ssaoNoiseScale2");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.vec2fv = sceneState.ssaoNoiseScale2;
	}
	
	// 24. ssaoKernel16.
	uniformLocation = gl.getUniformLocation(shader.program, "kernel");
	if (uniformLocation !== null && uniformLocation !== undefined)
	{
		uniformDataPair = shader.newUniformDataPair("Vec3fv", "ssaoKernel16");
		uniformDataPair.uniformLocation = uniformLocation;
		uniformDataPair.vec3fv = sceneState.ssaoKernel16;
	}
	
	// Set the camera.
	this.camera = sceneState.camera;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 */
PostFxShader.prototype.bindAttribLocations = function(gl, shader)
{
	gl.bindAttribLocation(shader.program, 0, "position");
	gl.bindAttribLocation(shader.program, 1, "normal");
	gl.bindAttribLocation(shader.program, 2, "texCoord");
	gl.bindAttribLocation(shader.program, 3, "color4");
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 */
PostFxShader.prototype.createUniformLocals = function(gl, shader, sceneState)
{
	// Here create all local uniforms, if exist, of the shader.
	var uniformDataPair;
	var uniformLocation;
	
	shader.buildingRotMatrix_loc = gl.getUniformLocation(shader.program, "buildingRotMatrix");
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");
	shader.sunMatrix_loc = gl.getUniformLocation(shader.program, "sunMatrix");
	
	shader.refMatrixType_loc = gl.getUniformLocation(shader.program, "refMatrixType");
	shader.refMatrix_loc = gl.getUniformLocation(shader.program, "RefTransfMatrix");
	shader.refTranslationVec_loc = gl.getUniformLocation(shader.program, "refTranslationVec");
	shader.aditionalMov_loc = gl.getUniformLocation(shader.program, "aditionalPosition");
	
	shader.hasTexture_loc = gl.getUniformLocation(shader.program, "hasTexture");
	shader.textureFlipYAxis_loc = gl.getUniformLocation(shader.program, "textureFlipYAxis");
	shader.kernel16_loc = gl.getUniformLocation(shader.program, "kernel");
	//shader.kernel32_loc = gl.getUniformLocation(shader.program, "kernel32");
	shader.noiseScale2_loc = gl.getUniformLocation(shader.program, "noiseScale");
	
	shader.sunPosHigh_loc = gl.getUniformLocation(shader.program, "sunPosHIGH");
	shader.sunPosLow_loc = gl.getUniformLocation(shader.program, "sunPosLOW");
	
	shader.shadowMapWidth_loc = gl.getUniformLocation(shader.program, "shadowMapWidth");
	shader.shadowMapHeight_loc = gl.getUniformLocation(shader.program, "shadowMapHeight");
	
	shader.sunDirWC_loc = gl.getUniformLocation(shader.program, "sunDirWC");
	shader.sunIdx_loc = gl.getUniformLocation(shader.program, "sunIdx");
	
	// Attributtes.*
	shader.position3_loc = gl.getAttribLocation(shader.program, "position");
	shader.texCoord2_loc = gl.getAttribLocation(shader.program, "texCoord");
	shader.normal3_loc = gl.getAttribLocation(shader.program, "normal");
	shader.color4_loc = gl.getAttribLocation(shader.program, "color4");
	
	
	shader.bUse1Color_loc = gl.getUniformLocation(shader.program, "bUse1Color");
	shader.oneColor4_loc = gl.getUniformLocation(shader.program, "oneColor4");
	shader.bApplySsao_loc = gl.getUniformLocation(shader.program, "bApplySsao");
	shader.bApplyShadow_loc = gl.getUniformLocation(shader.program, "bApplyShadow");
	shader.bSilhouette_loc = gl.getUniformLocation(shader.program, "bSilhouette");
	
	// clippingPlanes.
	shader.bApplyClippingPlanes_loc = gl.getUniformLocation(shader.program, "bApplyClippingPlanes");
	shader.clippingPlanesCount_loc = gl.getUniformLocation(shader.program, "clippingPlanesCount");
	shader.clippingPlanes_loc = gl.getUniformLocation(shader.program, "clippingPlanes");
	
	// compression data, for shaders with data compressed.
	// compressionMaxPoint & compressionMinPoint: for refObjects, this is the octree's size.
	shader.posDataByteSize_loc = gl.getUniformLocation(shader.program, "posDataByteSize");
	shader.texCoordByteSize_loc = gl.getUniformLocation(shader.program, "texCoordByteSize");
	shader.compressionMaxPoint_loc = gl.getUniformLocation(shader.program, "compressionMaxPoint");
	shader.compressionMinPoint_loc = gl.getUniformLocation(shader.program, "compressionMinPoint");
	
	shader.bApplySpecularLighting_loc = gl.getUniformLocation(shader.program, "bApplySpecularLighting");
	shader.colorType_loc = gl.getUniformLocation(shader.program, "colorType");
	shader.externalAlpha_loc = gl.getUniformLocation(shader.program, "externalAlpha");
	
	//uniform float fixPointSize;
	//uniform bool bUseFixPointSize;
	shader.fixPointSize_loc = gl.getUniformLocation(shader.program, "fixPointSize");
	shader.bUseFixPointSize_loc = gl.getUniformLocation(shader.program, "bUseFixPointSize");
	
	// Camera frustum near & far.
	// frustumNear.
	shader.frustumNear_loc = gl.getUniformLocation(shader.program, "near");

	// frustumFar.
	shader.frustumFar_loc = gl.getUniformLocation(shader.program, "far");
	
	shader.scaleLC_loc = gl.getUniformLocation(shader.program, "scaleLC");
	shader.colorMultiplier_loc = gl.getUniformLocation(shader.program, "colorMultiplier");
	shader.modelViewProjectionMatrixInv_loc = gl.getUniformLocation(shader.program, "modelViewProjectionMatrixInv");
	shader.projectionMatrixInv_loc = gl.getUniformLocation(shader.program, "projectionMatrixInv");
	shader.modelViewMatrixRelToEyeInv_loc = gl.getUniformLocation(shader.program, "modelViewMatrixRelToEyeInv");
};

'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class PostFxShadersManager
 */
var PostFxShadersManager = function() 
{
	if (!(this instanceof PostFxShadersManager)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl;
	this.pFx_shaders_array = []; // old.
	this.shadersMap = {};
	
	// preCreated shaders.
	this.modelRefShader;
	this.modelRefSilhouetteShader;
	this.lodBuildingShader;
	
	this.currentShaderUsing = undefined;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param shaderName 변수
 * @returns shader
 */
PostFxShadersManager.prototype.newShader = function(shaderName)
{
	var shader = new PostFxShader(this.gl);
	shader.name = shaderName;
	shader.shaderManager = this;
	this.shadersMap[shaderName] = shader;
	return shader;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param source 변수
 * @param type 변수
 * @param typeString 변수
 * @returns shader
 */
PostFxShadersManager.prototype.getShader = function(shaderName) 
{
	return this.shadersMap[shaderName];
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param source 변수
 * @param type 변수
 * @param typeString 변수
 * @returns shader
 */
PostFxShadersManager.prototype.createShaderProgram = function(gl, vertexSource, fragmentSource, shaderName, magoManager) 
{
	var shader = this.newShader(shaderName);
	shader.program = gl.createProgram();
	shader.shader_vertex = this.createShader(gl, vertexSource, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.createShader(gl, fragmentSource, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	shader.bindAttribLocations(gl, shader); // Do this before linkProgram.
	gl.linkProgram(shader.program);
			
	shader.createUniformGenerals(gl, shader, magoManager.sceneState);
	shader.createUniformLocals(gl, shader, magoManager.sceneState);
	
	
	// keep shader locations.
	var numAttributes = gl.getProgramParameter(shader.program, gl.ACTIVE_ATTRIBUTES);
	for (var i = 0; i < numAttributes; i++) 
	{
		var attribute = gl.getActiveAttrib(shader.program, i);
		shader[attribute.name] = gl.getAttribLocation(shader.program, attribute.name);
	}
	var numUniforms = gl.getProgramParameter(shader.program, gl.ACTIVE_UNIFORMS);
	for (var i = 0; i < numUniforms; i++) 
	{
		var uniform = gl.getActiveUniform(shader.program, i);
		shader[uniform.name] = gl.getUniformLocation(shader.program, uniform.name);
	}

	return shader;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 * @param source 변수
 * @param type 변수
 * @param typeString 변수
 * @returns shader
 */
PostFxShadersManager.prototype.createShader = function(gl, source, type, typeString) 
{
	// Source from internet.
	var shader = gl.createShader(type);
	gl.shaderSource(shader, source);
	gl.compileShader(shader);
	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) 
	{
		alert("ERROR IN "+typeString+ " SHADER : " + gl.getShaderInfoLog(shader));
		return false;
	}
	return shader;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createDefaultShaders = function(gl, sceneState) 
{
	this.modelRefSilhouetteShader = this.createSilhouetteShaderModelRef(gl); // 14.
	this.triPolyhedronShader = this.createSsaoShaderBox(gl); // 12.
	
	//this.invertedBoxShader = this.createInvertedBoxShader(gl); // TEST.
};

/**
 * 어떤 일을 하고 있습니까?
 */
PostFxShadersManager.prototype.getModelRefSilhouetteShader = function() 
{
	return this.modelRefSilhouetteShader;
};

/**
 * 어떤 일을 하고 있습니까?
 */
PostFxShadersManager.prototype.getTriPolyhedronDepthShader = function() 
{
	return this.triPolyhedronDepthShader;
};

/**
 * 어떤 일을 하고 있습니까?
 */
PostFxShadersManager.prototype.getTriPolyhedronShader = function() 
{
	return this.triPolyhedronShader;
};

/**
 * 어떤 일을 하고 있습니까?
 */
PostFxShadersManager.prototype.getInvertedBoxShader = function() 
{
	return this.invertedBoxShader;
};

// 14) Silhouette shader.
/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createSilhouetteShaderModelRef = function(gl) 
{
	// 14.
	var shader = new PostFxShader(this.gl);
	shader.name = "SilhouetteShaderModelRef";
	this.pFx_shaders_array.push(undefined);

	var ssao_vs_source = ShaderSource.SilhouetteVS;
	var ssao_fs_source = ShaderSource.SilhouetteFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	shader.bindAttribLocations(gl, shader); // Do this before linkProgram.
	gl.linkProgram(shader.program);

	shader.cameraPosHIGH_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh");
	shader.cameraPosLOW_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow");
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");

	shader.modelViewProjectionMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye");
	shader.refMatrix_loc = gl.getUniformLocation(shader.program, "RefTransfMatrix");
	shader.buildingRotMatrix_loc = gl.getUniformLocation(shader.program, "buildingRotMatrix");
	shader.refMatrixType_loc = gl.getUniformLocation(shader.program, "refMatrixType");
	shader.refTranslationVec_loc = gl.getUniformLocation(shader.program, "refTranslationVec");

	shader.position3_loc = gl.getAttribLocation(shader.program, "position");
	shader.attribLocationCacheObj.position = gl.getAttribLocation(shader.program, "position");

	shader.aditionalMov_loc = gl.getUniformLocation(shader.program, "aditionalPosition");

	shader.color4Aux_loc = gl.getUniformLocation(shader.program, "vColor4Aux");
	shader.camSpacePixelTranslation_loc = gl.getUniformLocation(shader.program, "camSpacePixelTranslation");
	shader.screenSize_loc = gl.getUniformLocation(shader.program, "screenSize");
	shader.ProjectionMatrix_loc = gl.getUniformLocation(shader.program, "ProjectionMatrix");
	shader.ModelViewMatrixRelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewMatrixRelToEye");
	
	return shader;
};

// box Shader.
/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createSsaoShaderBox = function(gl) 
{
	// 8.
	var shader = new PostFxShader(this.gl);
	this.pFx_shaders_array.push(shader);

	var ssao_vs_source = ShaderSource.BoxSsaoVS;
	var ssao_fs_source = ShaderSource.BoxSsaoFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	shader.bindAttribLocations(gl, shader); // Do this before linkProgram.
	gl.linkProgram(shader.program);

	shader.cameraPosHIGH_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh");
	shader.cameraPosLOW_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow");
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");

	shader.modelViewMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "modelViewMatrixRelToEye");
	shader.modelViewProjectionMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye");
	shader.normalMatrix4_loc = gl.getUniformLocation(shader.program, "normalMatrix4");
	shader.projectionMatrix4_loc = gl.getUniformLocation(shader.program, "projectionMatrix");
	shader.modelViewMatrix4_loc = gl.getUniformLocation(shader.program, "modelViewMatrix");
	//shader.refMatrix_loc = gl.getUniformLocation(shader.program, "RefTransfMatrix");
	shader.buildingRotMatrix_loc = gl.getUniformLocation(shader.program, "buildingRotMatrix");
	shader.bUse1Color_loc = gl.getUniformLocation(shader.program, "bUse1Color");
	shader.oneColor4_loc = gl.getUniformLocation(shader.program, "oneColor4");
	shader.bUseNormal_loc = gl.getUniformLocation(shader.program, "bUseNormal");
	shader.bScale_loc = gl.getUniformLocation(shader.program, "bScale");
	shader.scale_loc = gl.getUniformLocation(shader.program, "scale");


	
	gl.bindAttribLocation(shader.program, 0, "position");
	gl.bindAttribLocation(shader.program, 1, "normal");
	gl.bindAttribLocation(shader.program, 2, "texCoord");
	gl.bindAttribLocation(shader.program, 3, "color4");
	
	
	shader.position3_loc = gl.getAttribLocation(shader.program, "position");
	//shader.texCoord2_loc = gl.getAttribLocation(shader.program, "texCoord");
	shader.normal3_loc = gl.getAttribLocation(shader.program, "normal");
	shader.color4_loc = gl.getAttribLocation(shader.program, "color4");
	
	
	shader.attribLocationCacheObj.position = gl.getAttribLocation(shader.program, "position");
	shader.attribLocationCacheObj.normal = gl.getAttribLocation(shader.program, "normal");
	shader.attribLocationCacheObj.color4 = gl.getAttribLocation(shader.program, "color4");

	//
	shader.aditionalMov_loc = gl.getUniformLocation(shader.program, "aditionalPosition");

	// ssao uniforms.*
	shader.noiseScale2_loc = gl.getUniformLocation(shader.program, "noiseScale");
	shader.kernel16_loc = gl.getUniformLocation(shader.program, "kernel");

	// uniform values.
	shader.near_loc = gl.getUniformLocation(shader.program, "near");
	shader.far_loc = gl.getUniformLocation(shader.program, "far");
	shader.fov_loc = gl.getUniformLocation(shader.program, "fov");
	shader.aspectRatio_loc = gl.getUniformLocation(shader.program, "aspectRatio");

	shader.screenWidth_loc = gl.getUniformLocation(shader.program, "screenWidth");
	shader.screenHeight_loc = gl.getUniformLocation(shader.program, "screenHeight");

	shader.hasTexture_loc = gl.getUniformLocation(shader.program, "hasTexture");
	shader.color4Aux_loc = gl.getUniformLocation(shader.program, "vColor4Aux");

	// uniform samplers.
	shader.depthTex_loc = gl.getUniformLocation(shader.program, "depthTex");
	shader.noiseTex_loc = gl.getUniformLocation(shader.program, "noiseTex");
	shader.diffuseTex_loc = gl.getUniformLocation(shader.program, "diffuseTex");

	// ModelReference.*
	shader.useRefTransfMatrix_loc = gl.getUniformLocation(shader.program, "useRefTransfMatrix");
	shader.useTexture_loc = gl.getUniformLocation(shader.program, "useTexture");
	shader.invertNormals_loc  = gl.getUniformLocation(shader.program, "invertNormals");
	
	return shader;
};

// InvertedBox.
/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
PostFxShadersManager.prototype.createInvertedBoxShader = function(gl) 
{
	var shader = new PostFxShader(this.gl);
	this.pFx_shaders_array.push(undefined); // old.

	var ssao_vs_source = ShaderSource.InvertedBoxVS;
	var ssao_fs_source = ShaderSource.InvertedBoxFS;

	shader.program = gl.createProgram();
	shader.shader_vertex = this.createShader(gl, ssao_vs_source, gl.VERTEX_SHADER, "VERTEX");
	shader.shader_fragment = this.createShader(gl, ssao_fs_source, gl.FRAGMENT_SHADER, "FRAGMENT");

	gl.attachShader(shader.program, shader.shader_vertex);
	gl.attachShader(shader.program, shader.shader_fragment);
	shader.bindAttribLocations(gl, shader); // Do this before linkProgram.
	gl.linkProgram(shader.program);

	shader.cameraPosHIGH_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCHigh"); // sceneState.
	shader.cameraPosLOW_loc = gl.getUniformLocation(shader.program, "encodedCameraPositionMCLow"); // sceneState.
	shader.buildingPosHIGH_loc = gl.getUniformLocation(shader.program, "buildingPosHIGH");
	shader.buildingPosLOW_loc = gl.getUniformLocation(shader.program, "buildingPosLOW");

	shader.modelViewMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "modelViewMatrixRelToEye"); // sceneState.
	shader.modelViewProjectionMatrix4RelToEye_loc = gl.getUniformLocation(shader.program, "ModelViewProjectionMatrixRelToEye"); // sceneState.
	shader.normalMatrix4_loc = gl.getUniformLocation(shader.program, "normalMatrix4"); // sceneState.
	shader.projectionMatrix4_loc = gl.getUniformLocation(shader.program, "projectionMatrix"); // sceneState.
	shader.refMatrix_loc = gl.getUniformLocation(shader.program, "RefTransfMatrix");
	
	shader.buildingRotMatrix_loc = gl.getUniformLocation(shader.program, "buildingRotMatrix");
	shader.refMatrixType_loc = gl.getUniformLocation(shader.program, "refMatrixType");
	shader.refTranslationVec_loc = gl.getUniformLocation(shader.program, "refTranslationVec");

	shader.position3_loc = gl.getAttribLocation(shader.program, "position");
	shader.texCoord2_loc = gl.getAttribLocation(shader.program, "texCoord");
	shader.normal3_loc = gl.getAttribLocation(shader.program, "normal");
	
	shader.attribLocationCacheObj.position = gl.getAttribLocation(shader.program, "position");
	shader.attribLocationCacheObj.texCoord = gl.getAttribLocation(shader.program, "texCoord");
	shader.attribLocationCacheObj.normal = gl.getAttribLocation(shader.program, "normal");
	//
	shader.aditionalMov_loc = gl.getUniformLocation(shader.program, "aditionalPosition");

	// ssao uniforms.*
	shader.noiseScale2_loc = gl.getUniformLocation(shader.program, "noiseScale");
	shader.kernel16_loc = gl.getUniformLocation(shader.program, "kernel");

	// uniform values.
	shader.near_loc = gl.getUniformLocation(shader.program, "near"); // sceneState.
	shader.far_loc = gl.getUniformLocation(shader.program, "far"); // sceneState.
	shader.fov_loc = gl.getUniformLocation(shader.program, "fov"); // sceneState.
	shader.aspectRatio_loc = gl.getUniformLocation(shader.program, "aspectRatio"); // sceneState.

	shader.screenWidth_loc = gl.getUniformLocation(shader.program, "screenWidth"); // sceneState.
	shader.screenHeight_loc = gl.getUniformLocation(shader.program, "screenHeight"); // sceneState.
	
	shader.shininessValue_loc = gl.getUniformLocation(shader.program, "shininessValue");

	shader.hasTexture_loc = gl.getUniformLocation(shader.program, "hasTexture");
	shader.color4Aux_loc = gl.getUniformLocation(shader.program, "vColor4Aux");
	shader.textureFlipYAxis_loc = gl.getUniformLocation(shader.program, "textureFlipYAxis");

	// uniform samplers.
	shader.depthTex_loc = gl.getUniformLocation(shader.program, "depthTex");
	shader.noiseTex_loc = gl.getUniformLocation(shader.program, "noiseTex");
	shader.diffuseTex_loc = gl.getUniformLocation(shader.program, "diffuseTex"); 
	
	// lighting.
	shader.specularColor_loc = gl.getUniformLocation(shader.program, "specularColor");
	shader.ssaoRadius_loc = gl.getUniformLocation(shader.program, "radius");  

	shader.ambientReflectionCoef_loc = gl.getUniformLocation(shader.program, "ambientReflectionCoef");
	shader.diffuseReflectionCoef_loc = gl.getUniformLocation(shader.program, "diffuseReflectionCoef");
	shader.specularReflectionCoef_loc = gl.getUniformLocation(shader.program, "specularReflectionCoef");
	
	return shader;
};
'use strict';
var ShaderSource = {};
ShaderSource.atmosphereFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
\n\
uniform sampler2D depthTex;\n\
uniform sampler2D noiseTex;  \n\
uniform sampler2D diffuseTex;\n\
uniform bool textureFlipYAxis;\n\
uniform bool bIsMakingDepth;\n\
varying vec3 vNormal;\n\
uniform mat4 projectionMatrix;\n\
uniform mat4 m;\n\
uniform vec2 noiseScale;\n\
uniform float near;\n\
uniform float far;            \n\
uniform float fov;\n\
uniform float aspectRatio;    \n\
uniform float screenWidth;    \n\
uniform float screenHeight;    \n\
uniform float shininessValue;\n\
uniform vec3 kernel[16];   \n\
\n\
uniform vec4 oneColor4;\n\
uniform highp int colorType; // 0= oneColor, 1= attribColor, 2= texture.\n\
\n\
varying vec2 vTexCoord;   \n\
varying vec3 vLightWeighting;\n\
\n\
varying vec3 diffuseColor;\n\
uniform vec3 specularColor;\n\
varying vec3 vertexPos;\n\
varying float depthValue;\n\
varying vec3 v3Pos;\n\
varying vec3 camPos;\n\
\n\
const int kernelSize = 16;  \n\
uniform float radius;      \n\
\n\
uniform float ambientReflectionCoef;\n\
uniform float diffuseReflectionCoef;  \n\
uniform float specularReflectionCoef; \n\
uniform float externalAlpha;\n\
const float equatorialRadius = 6378137.0;\n\
const float polarRadius = 6356752.3142;\n\
const float PI = 3.1415926535897932384626433832795;\n\
const float PI_2 = 1.57079632679489661923; \n\
const float PI_4 = 0.785398163397448309616;\n\
\n\
float unpackDepth(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
} \n\
\n\
vec4 packDepth(const in float depth)\n\
{\n\
    const vec4 bit_shift = vec4(16777216.0, 65536.0, 256.0, 1.0);\n\
    const vec4 bit_mask  = vec4(0.0, 0.00390625, 0.00390625, 0.00390625); \n\
    vec4 res = fract(depth * bit_shift);\n\
    res -= res.xxyz * bit_mask;\n\
    return res;  \n\
}               \n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
    float hfar = 2.0 * tan(fov/2.0) * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
}\n\
\n\
//linear view space depth\n\
float getDepth(vec2 coord)\n\
{\n\
    return unpackDepth(texture2D(depthTex, coord.xy));\n\
}    \n\
\n\
void main()\n\
{  \n\
	float camElevation = length(camPos) - equatorialRadius;\n\
	if(v3Pos.z > (camElevation + equatorialRadius))\n\
		discard;\n\
		\n\
	vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight);	\n\
	float linearDepth = getDepth(screenPos);\n\
	if(linearDepth < 1.0)\n\
	discard;\n\
	\n\
	float distToCam = length(vec3(v3Pos));\n\
	\n\
	if(bIsMakingDepth)\n\
	{\n\
		gl_FragColor = packDepth(-depthValue);\n\
	}\n\
	else{\n\
		vec4 textureColor = oneColor4;\n\
		if(colorType == 0)\n\
		{\n\
			textureColor = oneColor4;\n\
			\n\
			if(textureColor.w == 0.0)\n\
			{\n\
				discard;\n\
			}\n\
		}\n\
		else if(colorType == 2)\n\
		{\n\
			//if(textureFlipYAxis)\n\
			//{\n\
			//	textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, 1.0 - vTexCoord.t));\n\
			//}\n\
			//else{\n\
			//	textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, vTexCoord.t));\n\
			//}\n\
			\n\
			if(textureColor.w == 0.0)\n\
			{\n\
				discard;\n\
			}\n\
		}\n\
		else{\n\
			textureColor = oneColor4;\n\
		}\n\
		// Calculate the angle between camDir & vNormal.***\n\
		vec3 camDir = normalize(vec3(v3Pos.x, v3Pos.y*0.5, -v3Pos.z));\n\
		vec3 normal = vNormal;\n\
		float angRad = acos(dot(camDir, normal));\n\
		float angDeg = angRad*180.0/PI;\n\
		/*\n\
		if(angDeg > 130.0)\n\
			textureColor = vec4(1.0, 0.0, 0.0, 1.0);\n\
		else if(angDeg > 120.0)\n\
			textureColor = vec4(0.0, 1.0, 0.0, 1.0);\n\
		else if(angDeg > 110.0)\n\
			textureColor = vec4(0.0, 0.0, 1.0, 1.0);\n\
		else if(angDeg > 100.0)\n\
			textureColor = vec4(1.0, 1.0, 0.0, 1.0);\n\
		else if(angDeg > 90.0)\n\
			textureColor = vec4(1.0, 0.0, 1.0, 1.0);\n\
			*/\n\
			\n\
		//textureColor = vec4(vNormal, 1.0);\n\
		\n\
		float maxAngDeg = 102.5;\n\
		float A = 1.0/(maxAngDeg-95.0);\n\
		float B = -A*95.0;\n\
		float alpha = A*angDeg+B;\n\
		if(alpha < 0.0 )\n\
		alpha = 0.0;\n\
		\n\
		float alphaPlusPerDist = 4.0*(distToCam/equatorialRadius);\n\
		if(alphaPlusPerDist > 1.0)\n\
		alphaPlusPerDist = 1.0;\n\
\n\
		textureColor = vec4(alpha*0.8*alphaPlusPerDist, alpha*0.95*alphaPlusPerDist, alpha, 1.0);\n\
\n\
\n\
		gl_FragColor = vec4(textureColor.xyz, alpha); \n\
	}\n\
}";
ShaderSource.atmosphereVS = "attribute vec3 position;\n\
attribute vec3 normal;\n\
attribute vec4 color4;\n\
attribute vec2 texCoord;\n\
\n\
uniform sampler2D diffuseTex;\n\
uniform mat4 projectionMatrix;  \n\
uniform mat4 modelViewMatrix;\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 ModelViewProjectionMatrix;\n\
uniform mat4 normalMatrix4;\n\
uniform mat4 buildingRotMatrix;  \n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform vec3 aditionalPosition;\n\
uniform vec4 oneColor4;\n\
uniform bool bUse1Color;\n\
uniform bool hasTexture;\n\
uniform bool bIsMakingDepth;\n\
uniform float near;\n\
uniform float far;\n\
\n\
varying vec3 vNormal;\n\
varying vec3 v3Pos;\n\
varying vec2 vTexCoord;   \n\
varying vec3 uAmbientColor;\n\
varying vec3 vLightWeighting;\n\
varying vec4 vcolor4;\n\
varying vec3 vertexPos;\n\
varying float depthValue;\n\
varying vec3 camPos;\n\
\n\
const float equatorialRadius = 6378137.0;\n\
const float polarRadius = 6356752.3142;\n\
const float PI = 3.1415926535897932384626433832795;\n\
const float PI_2 = 1.57079632679489661923; \n\
const float PI_4 = 0.785398163397448309616;\n\
\n\
void main()\n\
{	\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + position.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
	\n\
	vNormal = (normalMatrix4 * vec4(normal, 0.0)).xyz;\n\
\n\
	if(bIsMakingDepth)\n\
	{\n\
		depthValue = (modelViewMatrixRelToEye * pos4).z/far;\n\
	}\n\
	else\n\
	{\n\
		vTexCoord = texCoord;\n\
	}\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
	camPos = encodedCameraPositionMCHigh.xyz + encodedCameraPositionMCLow.xyz;\n\
	v3Pos = gl_Position.xyz;\n\
	\n\
}";
ShaderSource.BlendingCubeFS = "	precision lowp float;\n\
	varying vec4 vColor;\n\
\n\
	void main()\n\
    {\n\
		gl_FragColor = vColor;\n\
	}";
ShaderSource.BlendingCubeVS = "attribute vec3 position;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
attribute vec4 color;\n\
varying vec4 vColor;\n\
\n\
void main()\n\
{\n\
    vec3 highDifference = -encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = position.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(position.xyz, 1.0);\n\
\n\
    vColor=color;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
}";
ShaderSource.BlurFS = "#ifdef GL_ES\n\
    precision highp float;\n\
    #endif\n\
uniform sampler2D colorTex;\n\
uniform vec2 texelSize;\n\
varying vec2 vTexCoord; 	 	\n\
\n\
void main()\n\
{\n\
    vec3 result = vec3(0.0);\n\
    for (int i = 0; i < 4; ++i) {\n\
        for (int j = 0; j < 4; ++j) {\n\
            vec2 offset = vec2(texelSize.x * float(j), texelSize.y * float(i));\n\
            result += texture2D(colorTex, vTexCoord + offset).rgb;\n\
        }\n\
    }\n\
            \n\
    gl_FragColor.rgb = vec3(result * 0.0625); \n\
    gl_FragColor.a = 1.0;\n\
}\n\
";
ShaderSource.BlurVS = "attribute vec4 position;\n\
attribute vec2 texCoord;\n\
\n\
uniform mat4 projectionMatrix;\n\
uniform mat4 modelViewMatrix;  \n\
\n\
varying vec2 vTexCoord;\n\
\n\
void main()\n\
{	\n\
    vTexCoord = texCoord;\n\
    \n\
    gl_Position = projectionMatrix * modelViewMatrix * position;\n\
}\n\
";
ShaderSource.BoxSsaoFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
uniform sampler2D depthTex;\n\
uniform sampler2D noiseTex;  \n\
uniform sampler2D diffuseTex;\n\
uniform bool hasTexture;\n\
varying vec3 vNormal;\n\
uniform mat4 projectionMatrix;\n\
uniform mat4 m;\n\
uniform vec2 noiseScale;\n\
uniform float near;\n\
uniform float far;            \n\
uniform float fov;\n\
uniform float aspectRatio;    \n\
uniform float screenWidth;    \n\
uniform float screenHeight;    \n\
uniform vec3 kernel[16];   \n\
uniform vec4 vColor4Aux;\n\
uniform bool bUseNormal;\n\
\n\
varying vec2 vTexCoord;   \n\
varying vec3 vLightWeighting;\n\
varying vec4 vcolor4;\n\
\n\
const int kernelSize = 16;  \n\
const float radius = 0.5;      \n\
\n\
float unpackDepth(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
}                \n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
    float hfar = 2.0 * tan(fov/2.0) * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
}         \n\
            \n\
//linear view space depth\n\
float getDepth(vec2 coord)\n\
{                          \n\
    return unpackDepth(texture2D(depthTex, coord.xy));\n\
}    \n\
\n\
void main()\n\
{ \n\
	vec4 textureColor;\n\
	textureColor = vcolor4;  \n\
	if(bUseNormal)\n\
    {\n\
		vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight);		                 \n\
		float linearDepth = getDepth(screenPos);          \n\
		vec3 origin = getViewRay(screenPos) * linearDepth;   \n\
		vec3 normal2 = vNormal;   \n\
				\n\
		vec3 rvec = texture2D(noiseTex, screenPos.xy * noiseScale).xyz * 2.0 - 1.0;\n\
		vec3 tangent = normalize(rvec - normal2 * dot(rvec, normal2));\n\
		vec3 bitangent = cross(normal2, tangent);\n\
		mat3 tbn = mat3(tangent, bitangent, normal2);        \n\
		\n\
		float occlusion = 0.0;\n\
		for(int i = 0; i < kernelSize; ++i)\n\
		{    	 \n\
			vec3 sample = origin + (tbn * kernel[i]) * radius;\n\
			vec4 offset = projectionMatrix * vec4(sample, 1.0);		\n\
			offset.xy /= offset.w;\n\
			offset.xy = offset.xy * 0.5 + 0.5;        \n\
			float sampleDepth = -sample.z/far;\n\
			float depthBufferValue = getDepth(offset.xy);				              \n\
			float range_check = abs(linearDepth - depthBufferValue)+radius*0.998;\n\
			if (range_check < radius*1.001 && depthBufferValue <= sampleDepth)\n\
			{\n\
				occlusion +=  1.0;\n\
			}\n\
			\n\
		}   \n\
			\n\
		occlusion = 1.0 - occlusion / float(kernelSize);\n\
									\n\
		vec3 lightPos = vec3(10.0, 10.0, 10.0);\n\
		vec3 L = normalize(lightPos);\n\
		float DiffuseFactor = dot(normal2, L);\n\
		float NdotL = abs(DiffuseFactor);\n\
		vec3 diffuse = vec3(NdotL);\n\
		vec3 ambient = vec3(1.0);\n\
		gl_FragColor.rgb = vec3((textureColor.xyz)*vLightWeighting * occlusion); \n\
		gl_FragColor.a = 1.0; \n\
	}\n\
	else\n\
	{\n\
		gl_FragColor.rgb = vec3(textureColor.xyz); \n\
		gl_FragColor.a = 1.0; \n\
	}	\n\
}\n\
";
ShaderSource.BoxSsaoVS = "attribute vec3 position;\n\
attribute vec3 normal;\n\
attribute vec2 texCoord;\n\
attribute vec4 color4;\n\
\n\
uniform mat4 projectionMatrix;  \n\
uniform mat4 modelViewMatrix;\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 normalMatrix4;\n\
uniform mat4 buildingRotMatrix;  \n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform vec3 aditionalPosition;\n\
uniform vec4 oneColor4;\n\
uniform bool bUse1Color;\n\
uniform bool bUseNormal;\n\
uniform vec3 scale;\n\
uniform bool bScale;\n\
\n\
varying vec3 vNormal;\n\
varying vec2 vTexCoord;  \n\
varying vec3 uAmbientColor;\n\
varying vec3 vLightWeighting;\n\
varying vec4 vcolor4;\n\
\n\
void main()\n\
{	\n\
    vec4 position2 = vec4(position.xyz, 1.0);\n\
    if(bScale)\n\
    {\n\
        position2.x *= scale.x;\n\
        position2.y *= scale.y;\n\
        position2.z *= scale.z;\n\
    }\n\
    vec4 rotatedPos = buildingRotMatrix * vec4(position2.xyz + aditionalPosition.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
    if(bUseNormal)\n\
    {\n\
		vec4 rotatedNormal = buildingRotMatrix * vec4(normal.xyz, 1.0);\n\
		vLightWeighting = vec3(1.0, 1.0, 1.0);\n\
		uAmbientColor = vec3(0.8, 0.8, 0.8);\n\
		vec3 uLightingDirection = vec3(0.5, 0.5, 0.5);\n\
		vec3 directionalLightColor = vec3(0.6, 0.6, 0.6);\n\
		vNormal = (normalMatrix4 * vec4(rotatedNormal.x, rotatedNormal.y, rotatedNormal.z, 1.0)).xyz;\n\
		float directionalLightWeighting = max(dot(vNormal, uLightingDirection), 0.0);\n\
		vLightWeighting = uAmbientColor + directionalLightColor * directionalLightWeighting;\n\
	}\n\
    if(bUse1Color)\n\
    {\n\
        vcolor4 = oneColor4;\n\
    }\n\
    else\n\
    {\n\
        vcolor4 = color4;\n\
    }\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
}\n\
";
ShaderSource.CloudFS = "precision lowp float;\n\
varying vec3 vColor;\n\
\n\
void main()\n\
{\n\
    gl_FragColor = vec4(vColor, 1.);\n\
}";
ShaderSource.CloudVS = "attribute vec3 position;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 cloudPosHIGH;\n\
uniform vec3 cloudPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
attribute vec3 color;\n\
varying vec3 vColor;\n\
\n\
void main()\n\
{\n\
    vec3 objPosHigh = cloudPosHIGH;\n\
    vec3 objPosLow = cloudPosLOW.xyz + position.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
\n\
    vColor=color;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
}";
ShaderSource.ColorFS = "precision mediump float;\n\
uniform int byteColor_r;\n\
uniform int byteColor_g;\n\
uniform int byteColor_b;\n\
\n\
void main()\n\
{\n\
    float byteMaxValue = 255.0;\n\
\n\
    gl_FragColor = vec4(float(byteColor_r)/byteMaxValue, float(byteColor_g)/byteMaxValue, float(byteColor_b)/byteMaxValue, 1);\n\
}\n\
";
ShaderSource.ColorSelectionSsaoFS = "precision highp float;\n\
uniform vec4 oneColor4;\n\
\n\
void main()\n\
{          \n\
    gl_FragColor = oneColor4;\n\
}\n\
";
ShaderSource.ColorSelectionSsaoVS = "attribute vec3 position;\n\
\n\
uniform mat4 buildingRotMatrix;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 RefTransfMatrix;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform vec3 aditionalPosition;\n\
uniform vec3 refTranslationVec;\n\
uniform int refMatrixType; // 0= identity, 1= translate, 2= transform\n\
\n\
void main()\n\
{\n\
    vec4 rotatedPos;\n\
	if(refMatrixType == 0)\n\
	{\n\
		rotatedPos = buildingRotMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
	else if(refMatrixType == 1)\n\
	{\n\
		rotatedPos = buildingRotMatrix * vec4(position.xyz + refTranslationVec.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
	else if(refMatrixType == 2)\n\
	{\n\
		rotatedPos = RefTransfMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
    \n\
    gl_PointSize = 10.0;\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
}\n\
";
ShaderSource.ColorVS = "attribute vec3 position;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform mat4 RefTransfMatrix;\n\
\n\
void main()\n\
{\n\
    vec4 rotatedPos = RefTransfMatrix * vec4(position.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
    \n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
}\n\
";
ShaderSource.draw_frag = "precision mediump float;\n\
\n\
uniform sampler2D u_wind;\n\
uniform vec2 u_wind_min;\n\
uniform vec2 u_wind_max;\n\
uniform bool u_flipTexCoordY_windMap;\n\
uniform bool u_colorScale;\n\
\n\
varying vec2 v_particle_pos;\n\
\n\
void main() {\n\
	vec2 windMapTexCoord = v_particle_pos;\n\
	if(u_flipTexCoordY_windMap)\n\
	{\n\
		windMapTexCoord.y = 1.0 - windMapTexCoord.y;\n\
	}\n\
    vec2 velocity = mix(u_wind_min, u_wind_max, texture2D(u_wind, windMapTexCoord).rg);\n\
    float speed_t = length(velocity) / length(u_wind_max);\n\
\n\
	\n\
	if(u_colorScale)\n\
	{\n\
		speed_t *= 1.5;\n\
		if(speed_t > 1.0)speed_t = 1.0;\n\
		float b = 1.0 - speed_t;\n\
		float g;\n\
		if(speed_t > 0.5)\n\
		{\n\
			g = 2.0-2.0*speed_t;\n\
		}\n\
		else{\n\
			g = 2.0*speed_t;\n\
		}\n\
		float r = speed_t;\n\
		gl_FragColor = vec4(r,g,b,1.0);\n\
	}\n\
	else{\n\
		float intensity = speed_t*3.0;\n\
		if(intensity > 1.0)\n\
			intensity = 1.0;\n\
		gl_FragColor = vec4(intensity,intensity,intensity,1.0);\n\
	}\n\
}\n\
";
ShaderSource.draw_frag3D = "precision highp float;\n\
\n\
uniform sampler2D u_wind;\n\
uniform vec2 u_wind_min;\n\
uniform vec2 u_wind_max;\n\
uniform bool u_flipTexCoordY_windMap;\n\
uniform bool u_colorScale;\n\
uniform float u_tailAlpha;\n\
uniform float u_externAlpha;\n\
\n\
varying vec2 v_particle_pos;\n\
\n\
vec3 getRainbowColor_byHeight(float height)\n\
{\n\
	float minHeight_rainbow = 0.0;\n\
	float maxHeight_rainbow = 1.0;\n\
	float gray = (height - minHeight_rainbow)/(maxHeight_rainbow - minHeight_rainbow);\n\
	if (gray > 1.0){ gray = 1.0; }\n\
	else if (gray<0.0){ gray = 0.0; }\n\
	\n\
	float r, g, b;\n\
	\n\
	if(gray < 0.16666)\n\
	{\n\
		b = 0.0;\n\
		g = gray*6.0;\n\
		r = 1.0;\n\
	}\n\
	else if(gray >= 0.16666 && gray < 0.33333)\n\
	{\n\
		b = 0.0;\n\
		g = 1.0;\n\
		r = 2.0 - gray*6.0;\n\
	}\n\
	else if(gray >= 0.33333 && gray < 0.5)\n\
	{\n\
		b = -2.0 + gray*6.0;\n\
		g = 1.0;\n\
		r = 0.0;\n\
	}\n\
	else if(gray >= 0.5 && gray < 0.66666)\n\
	{\n\
		b = 1.0;\n\
		g = 4.0 - gray*6.0;\n\
		r = 0.0;\n\
	}\n\
	else if(gray >= 0.66666 && gray < 0.83333)\n\
	{\n\
		b = 1.0;\n\
		g = 0.0;\n\
		r = -4.0 + gray*6.0;\n\
	}\n\
	else if(gray >= 0.83333)\n\
	{\n\
		b = 6.0 - gray*6.0;\n\
		g = 0.0;\n\
		r = 1.0;\n\
	}\n\
	\n\
	float aux = r;\n\
	r = b;\n\
	b = aux;\n\
	\n\
	//b = -gray + 1.0;\n\
	//if (gray > 0.5)\n\
	//{\n\
	//	g = -gray*2.0 + 2.0; \n\
	//}\n\
	//else \n\
	//{\n\
	//	g = gray*2.0;\n\
	//}\n\
	//r = gray;\n\
	vec3 resultColor = vec3(r, g, b);\n\
    return resultColor;\n\
} \n\
\n\
void main() {\n\
	vec2 windMapTexCoord = v_particle_pos;\n\
	if(u_flipTexCoordY_windMap)\n\
	{\n\
		windMapTexCoord.y = 1.0 - windMapTexCoord.y;\n\
	}\n\
    vec2 velocity = mix(u_wind_min, u_wind_max, texture2D(u_wind, windMapTexCoord).rg);\n\
    float speed_t = length(velocity) / length(u_wind_max);\n\
\n\
	\n\
	if(u_colorScale)\n\
	{\n\
		speed_t *= 1.5;\n\
		if(speed_t > 1.0)speed_t = 1.0;\n\
		float b = 1.0 - speed_t;\n\
		float g;\n\
		if(speed_t > 0.5)\n\
		{\n\
			g = 2.0-2.0*speed_t;\n\
		}\n\
		else{\n\
			g = 2.0*speed_t;\n\
		}\n\
		vec3 col3 = getRainbowColor_byHeight(speed_t);\n\
		float r = speed_t;\n\
		gl_FragColor = vec4(col3.x, col3.y, col3.z ,u_tailAlpha*u_externAlpha);\n\
	}\n\
	else{\n\
		float intensity = speed_t*3.0;\n\
		if(intensity > 1.0)\n\
			intensity = 1.0;\n\
		gl_FragColor = vec4(intensity,intensity,intensity,u_tailAlpha*u_externAlpha);\n\
	}\n\
}";
ShaderSource.draw_vert = "precision mediump float;\n\
\n\
attribute float a_index;\n\
\n\
uniform sampler2D u_particles;\n\
uniform float u_particles_res;\n\
\n\
varying vec2 v_particle_pos;\n\
\n\
void main() {\n\
    vec4 color = texture2D(u_particles, vec2(\n\
        fract(a_index / u_particles_res),\n\
        floor(a_index / u_particles_res) / u_particles_res));\n\
\n\
    // decode current particle position from the pixel's RGBA value\n\
    v_particle_pos = vec2(\n\
        color.r / 255.0 + color.b,\n\
        color.g / 255.0 + color.a);\n\
\n\
    gl_PointSize = 1.0;\n\
    gl_Position = vec4(2.0 * v_particle_pos.x - 1.0, 1.0 - 2.0 * v_particle_pos.y, 0, 1);\n\
}\n\
";
ShaderSource.draw_vert3D = "precision highp float;\n\
\n\
// This shader draws windParticles in 3d directly from positions on u_particles image.***\n\
attribute float a_index;\n\
\n\
uniform sampler2D u_particles;\n\
uniform float u_particles_res;\n\
uniform mat4 buildingRotMatrix;\n\
uniform mat4 ModelViewProjectionMatrix;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform vec3 u_camPosWC;\n\
uniform vec3 u_geoCoordRadiansMax;\n\
uniform vec3 u_geoCoordRadiansMin;\n\
uniform float pendentPointSize;\n\
uniform float u_tailAlpha;\n\
uniform float u_layerAltitude;\n\
\n\
varying vec2 v_particle_pos;\n\
\n\
#define M_PI 3.1415926535897932384626433832795\n\
\n\
vec2 splitValue(float value)\n\
{\n\
	float doubleHigh;\n\
	vec2 resultSplitValue;\n\
	if (value >= 0.0) \n\
	{\n\
		doubleHigh = floor(value / 65536.0) * 65536.0; //unsigned short max\n\
		resultSplitValue.x = doubleHigh;\n\
		resultSplitValue.y = value - doubleHigh;\n\
	}\n\
	else \n\
	{\n\
		doubleHigh = floor(-value / 65536.0) * 65536.0;\n\
		resultSplitValue.x = -doubleHigh;\n\
		resultSplitValue.y = value + doubleHigh;\n\
	}\n\
	\n\
	return resultSplitValue;\n\
}\n\
	\n\
vec3 geographicToWorldCoord(float lonRad, float latRad, float alt)\n\
{\n\
	// defined in the LINZ standard LINZS25000 (Standard for New Zealand Geodetic Datum 2000)\n\
	// https://www.linz.govt.nz/data/geodetic-system/coordinate-conversion/geodetic-datum-conversions/equations-used-datum\n\
	// a = semi-major axis.\n\
	// e2 = firstEccentricitySquared.\n\
	// v = a / sqrt(1 - e2 * sin2(lat)).\n\
	// x = (v+h)*cos(lat)*cos(lon).\n\
	// y = (v+h)*cos(lat)*sin(lon).\n\
	// z = [v*(1-e2)+h]*sin(lat).\n\
	float equatorialRadius = 6378137.0; // meters.\n\
	float firstEccentricitySquared = 6.69437999014E-3;\n\
	float cosLon = cos(lonRad);\n\
	float cosLat = cos(latRad);\n\
	float sinLon = sin(lonRad);\n\
	float sinLat = sin(latRad);\n\
	float a = equatorialRadius;\n\
	float e2 = firstEccentricitySquared;\n\
	float v = a/sqrt(1.0 - e2 * sinLat * sinLat);\n\
	float h = alt;\n\
	\n\
	float x = (v+h)*cosLat*cosLon;\n\
	float y = (v+h)*cosLat*sinLon;\n\
	float z = (v*(1.0-e2)+h)*sinLat;\n\
	\n\
	\n\
	vec3 resultCartesian = vec3(x, y, z);\n\
	\n\
	return resultCartesian;\n\
}\n\
\n\
void main() {\n\
	\n\
    vec4 color = texture2D(u_particles, vec2(\n\
        fract(a_index / u_particles_res),\n\
        floor(a_index / u_particles_res) / u_particles_res));\n\
\n\
    // decode current particle position from the pixel's RGBA value\n\
    v_particle_pos = vec2(\n\
        color.r / 255.0 + color.b,\n\
        color.g / 255.0 + color.a);\n\
\n\
	// Now, must calculate geographic coords of the pos2d.***\n\
	float altitude = u_layerAltitude;\n\
	float minLonRad = u_geoCoordRadiansMin.x;\n\
	float maxLonRad = u_geoCoordRadiansMax.x;\n\
	float minLatRad = u_geoCoordRadiansMin.y;\n\
	float maxLatRad = u_geoCoordRadiansMax.y;\n\
	float lonRadRange = maxLonRad - minLonRad;\n\
	float latRadRange = maxLatRad - minLatRad;\n\
	float longitudeRad = -minLonRad + v_particle_pos.x * lonRadRange;\n\
	float latitudeRad = maxLatRad - v_particle_pos.y * latRadRange;\n\
	\n\
	// Now, calculate worldPosition of the geographicCoords (lon, lat, alt).***\n\
	//vec3 posWC = geographicToWorldCoord(longitudeRad, latitudeRad, altitude);\n\
	//vec4 posCC = vec4((posWC - encodedCameraPositionMCHigh) - encodedCameraPositionMCLow, 1.0);\n\
	\n\
	// Alternative.\n\
	\n\
	vec3 buildingPos = buildingPosHIGH + buildingPosLOW;\n\
	float radius = length(buildingPos);\n\
	float distortion = cos((minLatRad + v_particle_pos.y * latRadRange ));\n\
	float xOffset = (v_particle_pos.x - 0.5)*distortion * lonRadRange * radius;\n\
	float yOffset = (0.5 - v_particle_pos.y) * latRadRange * radius;\n\
	vec4 rotatedPos = buildingRotMatrix * vec4(xOffset, yOffset, 0.0, 1.0);\n\
	\n\
	\n\
	vec4 posWC = vec4((rotatedPos.xyz+buildingPosLOW) +( buildingPosHIGH ), 1.0);\n\
	vec4 posCC = vec4((rotatedPos.xyz+buildingPosLOW- encodedCameraPositionMCLow) +( buildingPosHIGH- encodedCameraPositionMCHigh), 1.0);\n\
	\n\
	// Now calculate the position on camCoord.***\n\
	//gl_Position = ModelViewProjectionMatrix * posWC;\n\
	gl_Position = ModelViewProjectionMatrixRelToEye * posCC;\n\
	//gl_Position = vec4(2.0 * v_particle_pos.x - 1.0, 1.0 - 2.0 * v_particle_pos.y, 0, 1);\n\
	//gl_Position = vec4(v_particle_pos.x, v_particle_pos.y, 0, 1);\n\
	\n\
	// Now calculate the point size.\n\
	float dist = distance(vec4(u_camPosWC.xyz, 1.0), vec4(posWC.xyz, 1.0));\n\
	gl_PointSize = (1.0 + pendentPointSize/(dist))*u_tailAlpha; \n\
	\n\
	if(gl_PointSize > 10.0)\n\
	gl_PointSize = 10.0;\n\
}\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
";
ShaderSource.filterSilhouetteFS = "precision mediump float;\n\
\n\
uniform sampler2D depthTex;\n\
uniform sampler2D noiseTex;  \n\
uniform mat4 projectionMatrix;\n\
uniform vec2 noiseScale;\n\
uniform float near;\n\
uniform float far;            \n\
uniform float fov;\n\
uniform float aspectRatio;    \n\
uniform float screenWidth;    \n\
uniform float screenHeight;    \n\
uniform vec3 kernel[16];   \n\
\n\
\n\
const int kernelSize = 16;  \n\
uniform float radius;      \n\
\n\
uniform bool bApplySsao;\n\
\n\
float unpackDepth(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
}                \n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
    float hfar = 2.0 * tan(fov/2.0) * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
}         \n\
            \n\
//linear view space depth\n\
float getDepth(vec2 coord)\n\
{\n\
    return unpackDepth(texture2D(depthTex, coord.xy));\n\
}    \n\
\n\
void main()\n\
{\n\
	float occlusion = 0.0;\n\
	vec3 normal2 = vec3(0.0, 0.0, 1.0);\n\
	float radiusAux = radius * 5.0;\n\
	if(bApplySsao)\n\
	{          \n\
		vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight);		                 \n\
		float linearDepth = getDepth(screenPos); \n\
		vec3 origin = getViewRay(screenPos) * linearDepth;   \n\
\n\
		vec3 rvec = texture2D(noiseTex, screenPos.xy * noiseScale).xyz * 2.0 - 1.0;\n\
		vec3 tangent = normalize(rvec - normal2 * dot(rvec, normal2));\n\
		vec3 bitangent = cross(normal2, tangent);\n\
		mat3 tbn = mat3(tangent, bitangent, normal2);        \n\
		\n\
		for(int i = 0; i < kernelSize; ++i)\n\
		{    	 \n\
			//vec3 sample = origin + (tbn * kernel[i]) * radiusAux;\n\
			vec3 sample = origin + (kernel[i]) * radiusAux;\n\
			vec4 offset = projectionMatrix * vec4(sample, 1.0);		\n\
			offset.xy /= offset.w;\n\
			offset.xy = offset.xy * 0.5 + 0.5;        \n\
			float sampleDepth = -sample.z/far;\n\
			if(sampleDepth > 0.49)\n\
				continue;\n\
			float depthBufferValue = getDepth(offset.xy);\n\
			float range_check = abs(linearDepth - depthBufferValue)+radiusAux*0.998;\n\
			if (range_check > radius*1.001 && depthBufferValue <= sampleDepth)\n\
			{\n\
				occlusion +=  1.0;\n\
			}\n\
		}   \n\
		\n\
		if(occlusion > float(kernelSize)*0.4)\n\
		{\n\
			occlusion = occlusion / float(kernelSize);\n\
		}\n\
		else{\n\
			occlusion = 0.0;\n\
		}\n\
		//occlusion = 1.0 - occlusion / float(kernelSize);\n\
	}\n\
	else{\n\
		occlusion = 0.0;\n\
	}\n\
\n\
    vec4 finalColor;\n\
	finalColor = vec4(1.0, 1.0, 1.0, occlusion*0.9);\n\
    gl_FragColor = finalColor; \n\
}\n\
";
ShaderSource.ImageViewerRectangleShaderFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
\n\
uniform sampler2D depthTex;\n\
uniform sampler2D noiseTex;  \n\
uniform sampler2D diffuseTex;\n\
uniform bool textureFlipYAxis;\n\
varying vec3 vNormal;\n\
uniform mat4 projectionMatrix;\n\
uniform mat4 m;\n\
uniform vec2 noiseScale;\n\
uniform float near;\n\
uniform float far;            \n\
uniform float fov;\n\
uniform float aspectRatio;    \n\
uniform float screenWidth;    \n\
uniform float screenHeight;    \n\
uniform float shininessValue;\n\
uniform vec3 kernel[16];   \n\
uniform vec4 oneColor4;\n\
varying vec4 aColor4; // color from attributes\n\
uniform bool bApplyScpecularLighting;\n\
uniform highp int colorType; // 0= oneColor, 1= attribColor, 2= texture.\n\
\n\
varying vec2 vTexCoord;   \n\
varying vec3 vLightWeighting;\n\
\n\
varying vec3 diffuseColor;\n\
uniform vec3 specularColor;\n\
varying vec3 vertexPos;\n\
\n\
const int kernelSize = 16;  \n\
uniform float radius;      \n\
\n\
uniform float ambientReflectionCoef;\n\
uniform float diffuseReflectionCoef;  \n\
uniform float specularReflectionCoef; \n\
varying float applySpecLighting;\n\
uniform bool bApplySsao;\n\
uniform float externalAlpha;\n\
\n\
float unpackDepth(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
}  \n\
\n\
float UnpackDepth32( in vec4 pack )\n\
{\n\
    float depth = dot( pack, 1.0 / vec4(1.0, 256.0, 256.0*256.0, 16777216.0) ); // 256.0*256.0*256.0 = 16777216.0\n\
    return depth * (16777216.0) / (16777216.0 - 1.0);\n\
}              \n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
    float hfar = 2.0 * tan(fov/2.0) * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
}         \n\
            \n\
//linear view space depth\n\
float getDepth(vec2 coord)\n\
{\n\
    return UnpackDepth32(texture2D(depthTex, coord.xy));\n\
}    \n\
\n\
void main()\n\
{\n\
	vec4 textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, vTexCoord.t));\n\
	float alfa = externalAlpha;\n\
	float depth = UnpackDepth32(textureColor);\n\
	\n\
    vec4 finalColor;\n\
	finalColor = vec4(depth, depth, depth, alfa);\n\
\n\
	//finalColor = vec4(vNormal, 1.0); // test to render normal color coded.***\n\
    gl_FragColor = finalColor; \n\
}";
ShaderSource.ImageViewerRectangleShaderVS = "	attribute vec3 position;\n\
	attribute vec3 normal;\n\
	attribute vec2 texCoord;\n\
	attribute vec4 color4;\n\
	\n\
	uniform mat4 buildingRotMatrix; \n\
	uniform mat4 projectionMatrix;  \n\
	uniform mat4 modelViewMatrix;\n\
	uniform mat4 modelViewMatrixRelToEye; \n\
	uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
	uniform mat4 RefTransfMatrix;\n\
	uniform mat4 normalMatrix4;\n\
	uniform vec3 buildingPosHIGH;\n\
	uniform vec3 buildingPosLOW;\n\
	uniform vec3 encodedCameraPositionMCHigh;\n\
	uniform vec3 encodedCameraPositionMCLow;\n\
	uniform vec3 aditionalPosition;\n\
	uniform vec3 refTranslationVec;\n\
	uniform int refMatrixType; // 0= identity, 1= translate, 2= transform\n\
	uniform bool bApplySpecularLighting;\n\
	uniform highp int colorType; // 0= oneColor, 1= attribColor, 2= texture.\n\
\n\
	varying vec3 vNormal;\n\
	varying vec2 vTexCoord;  \n\
	varying vec3 uAmbientColor;\n\
	varying vec3 vLightWeighting;\n\
	varying vec3 vertexPos;\n\
	varying float applySpecLighting;\n\
	varying vec4 aColor4; // color from attributes\n\
	\n\
	void main()\n\
    {	\n\
		vec4 rotatedPos;\n\
		mat3 currentTMat;\n\
		if(refMatrixType == 0)\n\
		{\n\
			rotatedPos = buildingRotMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
			currentTMat = mat3(buildingRotMatrix);\n\
		}\n\
		else if(refMatrixType == 1)\n\
		{\n\
			rotatedPos = buildingRotMatrix * vec4(position.xyz + refTranslationVec.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
			currentTMat = mat3(buildingRotMatrix);\n\
		}\n\
		else if(refMatrixType == 2)\n\
		{\n\
			rotatedPos = RefTransfMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
			currentTMat = mat3(RefTransfMatrix);\n\
		}\n\
\n\
		vec3 objPosHigh = buildingPosHIGH;\n\
		vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
		vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
		vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
		vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
\n\
		//vertexPos = vec3(modelViewMatrixRelToEye * pos4);\n\
		vec3 rotatedNormal = currentTMat * normal;\n\
		vLightWeighting = vec3(1.0, 1.0, 1.0);\n\
		uAmbientColor = vec3(0.8);\n\
		vec3 uLightingDirection = vec3(0.6, 0.6, 0.6);\n\
		vec3 directionalLightColor = vec3(0.7, 0.7, 0.7);\n\
		vNormal = (normalMatrix4 * vec4(rotatedNormal.x, rotatedNormal.y, rotatedNormal.z, 1.0)).xyz;\n\
		vTexCoord = texCoord;\n\
		float directionalLightWeighting = max(dot(vNormal, uLightingDirection), 0.0);\n\
		vLightWeighting = uAmbientColor + directionalLightColor * directionalLightWeighting;\n\
		\n\
		if(bApplySpecularLighting)\n\
			applySpecLighting = 1.0;\n\
		else\n\
			applySpecLighting = -1.0;\n\
\n\
        gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
		\n\
		if(colorType == 1)\n\
			aColor4 = color4;\n\
	}";
ShaderSource.InvertedBoxFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
\n\
uniform sampler2D depthTex;\n\
uniform sampler2D noiseTex;  \n\
uniform sampler2D diffuseTex;\n\
uniform bool hasTexture;\n\
uniform bool textureFlipYAxis;\n\
varying vec3 vNormal;\n\
uniform mat4 projectionMatrix;\n\
uniform mat4 m;\n\
uniform vec2 noiseScale;\n\
uniform float near;\n\
uniform float far;            \n\
uniform float fov;\n\
uniform float aspectRatio;    \n\
uniform float screenWidth;    \n\
uniform float screenHeight;    \n\
uniform float shininessValue;\n\
uniform vec3 kernel[16];   \n\
uniform vec4 vColor4Aux;\n\
\n\
varying vec2 vTexCoord;   \n\
varying vec3 vLightWeighting;\n\
\n\
varying vec3 diffuseColor;\n\
uniform vec3 specularColor;\n\
varying vec3 vertexPos;\n\
\n\
const int kernelSize = 16;  \n\
uniform float radius;      \n\
\n\
uniform float ambientReflectionCoef;\n\
uniform float diffuseReflectionCoef;  \n\
uniform float specularReflectionCoef; \n\
\n\
float unpackDepth(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
}                \n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
    float hfar = 2.0 * tan(fov/2.0) * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
}         \n\
            \n\
//linear view space depth\n\
float getDepth(vec2 coord)\n\
{\n\
    return unpackDepth(texture2D(depthTex, coord.xy));\n\
}    \n\
\n\
void main()\n\
{          \n\
    vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight);		                 \n\
    float linearDepth = getDepth(screenPos);          \n\
    vec3 origin = getViewRay(screenPos) * linearDepth;   \n\
\n\
    vec3 normal2 = vNormal;\n\
            \n\
    vec3 rvec = texture2D(noiseTex, screenPos.xy * noiseScale).xyz * 2.0 - 1.0;\n\
    vec3 tangent = normalize(rvec - normal2 * dot(rvec, normal2));\n\
    vec3 bitangent = cross(normal2, tangent);\n\
    mat3 tbn = mat3(tangent, bitangent, normal2);        \n\
    \n\
    float occlusion = 0.0;\n\
    for(int i = 0; i < kernelSize; ++i)\n\
    {    	 \n\
        vec3 sample = origin + (tbn * kernel[i]) * radius;\n\
        vec4 offset = projectionMatrix * vec4(sample, 1.0);		\n\
        offset.xy /= offset.w;\n\
        offset.xy = offset.xy * 0.5 + 0.5;        \n\
        float sampleDepth = -sample.z/far;\n\
		if(sampleDepth > 0.49)\n\
			continue;\n\
        float depthBufferValue = getDepth(offset.xy);				              \n\
        float range_check = abs(linearDepth - depthBufferValue)+radius*0.998;\n\
        if (range_check < radius*1.001 && depthBufferValue <= sampleDepth)\n\
        {\n\
            occlusion +=  1.0;\n\
        }\n\
    }   \n\
        \n\
    occlusion = 1.0 - occlusion / float(kernelSize);\n\
\n\
    vec3 lightPos = vec3(20.0, 60.0, 20.0);\n\
    vec3 L = normalize(lightPos - vertexPos);\n\
    float lambertian = max(dot(normal2, L), 0.0);\n\
    float specular = 0.0;\n\
    if(lambertian > 0.0)\n\
    {\n\
        vec3 R = reflect(-L, normal2);      // Reflected light vector\n\
        vec3 V = normalize(-vertexPos); // Vector to viewer\n\
        \n\
        // Compute the specular term\n\
        float specAngle = max(dot(R, V), 0.0);\n\
        specular = pow(specAngle, shininessValue);\n\
    }\n\
	\n\
	if(lambertian < 0.5)\n\
    {\n\
		lambertian = 0.5;\n\
	}\n\
\n\
    vec4 textureColor;\n\
    if(hasTexture)\n\
    {\n\
        if(textureFlipYAxis)\n\
        {\n\
            textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, 1.0 - vTexCoord.t));\n\
        }\n\
        else{\n\
            textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, vTexCoord.t));\n\
        }\n\
		\n\
        if(textureColor.w == 0.0)\n\
        {\n\
            discard;\n\
        }\n\
    }\n\
    else{\n\
        textureColor = vColor4Aux;\n\
    }\n\
	\n\
	vec3 ambientColor = vec3(textureColor.x, textureColor.y, textureColor.z);\n\
\n\
    gl_FragColor = vec4((ambientReflectionCoef * ambientColor + diffuseReflectionCoef * lambertian * textureColor.xyz + specularReflectionCoef * specular * specularColor)*vLightWeighting * occlusion, 1.0); \n\
}\n\
";
ShaderSource.InvertedBoxVS = "	attribute vec3 position;\n\
	attribute vec3 normal;\n\
	attribute vec2 texCoord;\n\
	\n\
	uniform mat4 buildingRotMatrix; \n\
	uniform mat4 projectionMatrix;  \n\
	uniform mat4 modelViewMatrix;\n\
	uniform mat4 modelViewMatrixRelToEye; \n\
	uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
	uniform mat4 RefTransfMatrix;\n\
	uniform mat4 normalMatrix4;\n\
	uniform vec3 buildingPosHIGH;\n\
	uniform vec3 buildingPosLOW;\n\
	uniform vec3 encodedCameraPositionMCHigh;\n\
	uniform vec3 encodedCameraPositionMCLow;\n\
	uniform vec3 aditionalPosition;\n\
	uniform vec3 refTranslationVec;\n\
	uniform int refMatrixType; // 0= identity, 1= translate, 2= transform\n\
\n\
	varying vec3 vNormal;\n\
	varying vec2 vTexCoord;  \n\
	varying vec3 uAmbientColor;\n\
	varying vec3 vLightWeighting;\n\
	varying vec3 vertexPos;\n\
	\n\
	void main()\n\
    {	\n\
		vec4 rotatedPos;\n\
		mat3 currentTMat;\n\
		if(refMatrixType == 0)\n\
		{\n\
			rotatedPos = buildingRotMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
			currentTMat = mat3(buildingRotMatrix);\n\
		}\n\
		else if(refMatrixType == 1)\n\
		{\n\
			rotatedPos = buildingRotMatrix * vec4(position.xyz + refTranslationVec.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
			currentTMat = mat3(buildingRotMatrix);\n\
		}\n\
		else if(refMatrixType == 2)\n\
		{\n\
			rotatedPos = RefTransfMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
			currentTMat = mat3(RefTransfMatrix);\n\
		}\n\
\n\
		vec3 objPosHigh = buildingPosHIGH;\n\
		vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
		vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
		vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
		vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
\n\
		vertexPos = vec3(modelViewMatrixRelToEye * pos4);\n\
		vec3 rotatedNormal = currentTMat * normal;\n\
		vLightWeighting = vec3(1.0, 1.0, 1.0);\n\
		uAmbientColor = vec3(0.8);\n\
		vec3 uLightingDirection = vec3(0.6, 0.6, 0.6);\n\
		vec3 directionalLightColor = vec3(0.7, 0.7, 0.7);\n\
		vNormal = (normalMatrix4 * vec4(rotatedNormal.x, rotatedNormal.y, rotatedNormal.z, 1.0)).xyz;\n\
		vTexCoord = texCoord;\n\
		float directionalLightWeighting = max(dot(vNormal, uLightingDirection), 0.0);\n\
		vLightWeighting = uAmbientColor + directionalLightColor * directionalLightWeighting;\n\
\n\
        gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
	}\n\
";
ShaderSource.ModelRefSsaoFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
\n\
uniform sampler2D depthTex;\n\
uniform sampler2D noiseTex;  \n\
uniform sampler2D diffuseTex;\n\
uniform sampler2D shadowMapTex;\n\
uniform sampler2D shadowMapTex2;\n\
uniform bool textureFlipYAxis;\n\
uniform mat4 projectionMatrix;\n\
uniform mat4 m;\n\
uniform vec2 noiseScale;\n\
uniform float near;\n\
uniform float far;            \n\
uniform float fov;\n\
uniform float tangentOfHalfFovy;\n\
uniform float aspectRatio;    \n\
uniform float screenWidth;    \n\
uniform float screenHeight;   \n\
uniform float shadowMapWidth;    \n\
uniform float shadowMapHeight; \n\
uniform float shininessValue;\n\
uniform vec3 kernel[16];   \n\
uniform vec4 oneColor4;\n\
varying vec4 aColor4; // color from attributes\n\
uniform bool bApplyScpecularLighting;\n\
uniform highp int colorType; // 0= oneColor, 1= attribColor, 2= texture.\n\
\n\
uniform vec3 specularColor;\n\
uniform vec3 ambientColor;\n\
\n\
const int kernelSize = 16;  \n\
uniform float radius;      \n\
\n\
uniform float ambientReflectionCoef;\n\
uniform float diffuseReflectionCoef;  \n\
uniform float specularReflectionCoef; \n\
uniform bool bApplySsao;\n\
uniform bool bApplyShadow;\n\
uniform float externalAlpha;\n\
uniform vec4 colorMultiplier;\n\
\n\
//uniform int sunIdx;\n\
\n\
// clipping planes.***\n\
//uniform bool bApplyClippingPlanes;\n\
//uniform int clippingPlanesCount;\n\
//uniform vec4 clippingPlanes[6];\n\
\n\
varying vec3 vNormal;\n\
varying vec2 vTexCoord;   \n\
varying vec3 vLightWeighting;\n\
varying vec3 diffuseColor;\n\
varying vec3 vertexPos;\n\
varying float applySpecLighting;\n\
varying vec4 vPosRelToLight; \n\
varying vec3 vLightDir; \n\
varying vec3 vNormalWC;\n\
varying float currSunIdx; \n\
varying float discardFrag;\n\
\n\
float unpackDepth(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);// original.***\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
}  \n\
\n\
\n\
float UnpackDepth32( in vec4 pack )\n\
{\n\
	float depth = dot( pack, vec4(1.0, 0.00390625, 0.000015258789, 0.000000059605) );\n\
    return depth * 1.000000059605;// 1.000000059605 = (16777216.0) / (16777216.0 - 1.0);\n\
}             \n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
	/*\n\
	// The \"far\" for depthTextures if fixed in \"RenderShowDepthVS\" shader.\n\
	float farForDepth = 30000.0;\n\
	float hfar = 2.0 * tangentOfHalfFovy * farForDepth;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -farForDepth);  \n\
	*/	\n\
	\n\
	\n\
	float hfar = 2.0 * tangentOfHalfFovy * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
	\n\
    return ray;                      \n\
}         \n\
            \n\
//linear view space depth\n\
float getDepth(vec2 coord)\n\
{\n\
	return unpackDepth(texture2D(depthTex, coord.xy));\n\
}   \n\
\n\
float getDepthShadowMap(vec2 coord)\n\
{\n\
	// currSunIdx\n\
	if(currSunIdx > 0.0 && currSunIdx < 1.0)\n\
	{\n\
		return UnpackDepth32(texture2D(shadowMapTex, coord.xy));\n\
	}\n\
    else if(currSunIdx > 1.0 && currSunIdx < 2.0)\n\
	{\n\
		return UnpackDepth32(texture2D(shadowMapTex2, coord.xy));\n\
	}\n\
	else\n\
		return -1.0;\n\
}  \n\
\n\
bool clipVertexByPlane(in vec4 plane, in vec3 point)\n\
{\n\
	float dist = plane.x * point.x + plane.y * point.y + plane.z * point.z + plane.w;\n\
	\n\
	if(dist < 0.0)\n\
	return true;\n\
	else return false;\n\
}\n\
\n\
void main()\n\
{\n\
	// 1rst, check if there are clipping planes.\n\
	/*\n\
	if(bApplyClippingPlanes)\n\
	{\n\
		bool discardFrag = true;\n\
		for(int i=0; i<6; i++)\n\
		{\n\
			vec4 plane = clippingPlanes[i];\n\
			if(!clipVertexByPlane(plane, vertexPos))\n\
			{\n\
				discardFrag = false;\n\
				break;\n\
			}\n\
			if(i >= clippingPlanesCount)\n\
			break;\n\
		}\n\
		\n\
		if(discardFrag)\n\
		discard;\n\
	}\n\
	*/\n\
\n\
	//bool testBool = false;\n\
	float occlusion = 1.0; // ambient occlusion.***\n\
	float shadow_occlusion = 1.0;\n\
	vec3 normal2 = vNormal;	\n\
		\n\
	if(bApplySsao)\n\
	{        \n\
		////float farForDepth = 30000.0;\n\
		vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight);\n\
		float linearDepth = getDepth(screenPos);  \n\
		vec3 ray = getViewRay(screenPos); // The \"far\" for depthTextures if fixed in \"RenderShowDepthVS\" shader.\n\
		vec3 origin = ray * linearDepth;  \n\
		float tolerance = radius/far; // original.***\n\
		////float tolerance = radius/(far-near);// test.***\n\
		////float tolerance = radius/farForDepth;\n\
\n\
		vec3 rvec = texture2D(noiseTex, screenPos.xy * noiseScale).xyz * 2.0 - 1.0;\n\
		vec3 tangent = normalize(rvec - normal2 * dot(rvec, normal2));\n\
		vec3 bitangent = cross(normal2, tangent);\n\
		mat3 tbn = mat3(tangent, bitangent, normal2);   \n\
		float minDepthBuffer;\n\
		float maxDepthBuffer;\n\
		for(int i = 0; i < kernelSize; ++i)\n\
		{    	 \n\
			vec3 sample = origin + (tbn * vec3(kernel[i].x*1.0, kernel[i].y*1.0, kernel[i].z)) * radius*2.0;\n\
			vec4 offset = projectionMatrix * vec4(sample, 1.0);					\n\
			offset.xy /= offset.w;\n\
			offset.xy = offset.xy * 0.5 + 0.5;  				\n\
			float sampleDepth = -sample.z/far;// original.***\n\
			////float sampleDepth = -sample.z/(far-near);// test.***\n\
			////float sampleDepth = -sample.z/farForDepth;\n\
\n\
			float depthBufferValue = getDepth(offset.xy);\n\
\n\
			if(depthBufferValue > 0.00391 && depthBufferValue < 0.00393)\n\
			{\n\
				if (depthBufferValue < sampleDepth-tolerance*1000.0)\n\
				{\n\
					occlusion +=  0.5;\n\
				}\n\
				\n\
				continue;\n\
			}			\n\
			\n\
			if (depthBufferValue < sampleDepth-tolerance)\n\
			{\n\
				occlusion +=  1.0;\n\
			}\n\
		} \n\
\n\
		occlusion = 1.0 - occlusion / float(kernelSize);	\n\
	}\n\
	\n\
    // Do specular lighting.***\n\
	float lambertian;\n\
	float specular;\n\
	\n\
	if(applySpecLighting> 0.0)\n\
	{\n\
		vec3 L;\n\
		if(bApplyShadow)\n\
		{\n\
			L = vLightDir;// test.***\n\
			lambertian = max(dot(normal2, L), 0.0); // original.***\n\
			//lambertian = max(dot(vNormalWC, L), 0.0); // test.\n\
		}\n\
		else\n\
		{\n\
			vec3 lightPos = vec3(1.0, 1.0, 1.0);\n\
			L = normalize(lightPos - vertexPos);\n\
			lambertian = max(dot(normal2, L), 0.0);\n\
		}\n\
		\n\
		specular = 0.0;\n\
		if(lambertian > 0.0)\n\
		{\n\
			vec3 R = reflect(-L, normal2);      // Reflected light vector\n\
			vec3 V = normalize(-vertexPos); // Vector to viewer\n\
			\n\
			// Compute the specular term\n\
			float specAngle = max(dot(R, V), 0.0);\n\
			specular = pow(specAngle, shininessValue);\n\
			\n\
			if(specular > 1.0)\n\
			{\n\
				specular = 1.0;\n\
			}\n\
		}\n\
		\n\
		if(lambertian < 0.5)\n\
		{\n\
			lambertian = 0.5;\n\
		}\n\
\n\
	}\n\
	\n\
	if(bApplyShadow)\n\
	{\n\
		if(currSunIdx > 0.0)\n\
		{\n\
			float ligthAngle = dot(vLightDir, vNormalWC);\n\
			if(ligthAngle > 0.0)\n\
			{\n\
				// The angle between the light direction & face normal is less than 90 degree, so, the face is in shadow.***\n\
				shadow_occlusion = 0.5;\n\
			}\n\
			else\n\
			{\n\
				vec3 posRelToLight = vPosRelToLight.xyz / vPosRelToLight.w;\n\
				float tolerance = 0.9963;\n\
				posRelToLight = posRelToLight * 0.5 + 0.5; // transform to [0,1] range\n\
				if(posRelToLight.x >= 0.0 && posRelToLight.x <= 1.0)\n\
				{\n\
					if(posRelToLight.y >= 0.0 && posRelToLight.y <= 1.0)\n\
					{\n\
						float depthRelToLight = getDepthShadowMap(posRelToLight.xy);\n\
						if(posRelToLight.z > depthRelToLight*tolerance )\n\
						{\n\
							shadow_occlusion = 0.5;\n\
						}\n\
					}\n\
				}\n\
\n\
				// test. Calculate the zone inside the pixel.************************************\n\
				//https://docs.microsoft.com/ko-kr/windows/win32/dxtecharts/cascaded-shadow-maps\n\
			}\n\
		}\n\
	}\n\
	\n\
\n\
    vec4 textureColor;\n\
    if(colorType == 2)\n\
    {\n\
        if(textureFlipYAxis)\n\
        {\n\
            textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, 1.0 - vTexCoord.t));\n\
        }\n\
        else{\n\
            textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, vTexCoord.t));\n\
        }\n\
		\n\
        if(textureColor.w == 0.0)\n\
        {\n\
            discard;\n\
        }\n\
    }\n\
    else if(colorType == 0)\n\
	{\n\
        textureColor = oneColor4;\n\
    }\n\
	else if(colorType == 1)\n\
	{\n\
        textureColor = aColor4;\n\
    }\n\
	\n\
	//textureColor = vec4(0.85, 0.85, 0.85, 1.0);\n\
	\n\
	vec3 ambientColorAux = vec3(textureColor.x*ambientColor.x, textureColor.y*ambientColor.y, textureColor.z*ambientColor.z);\n\
	float alfa = textureColor.w * externalAlpha;\n\
\n\
    vec4 finalColor;\n\
	if(applySpecLighting> 0.0)\n\
	{\n\
		finalColor = vec4((ambientReflectionCoef * ambientColorAux + \n\
							diffuseReflectionCoef * lambertian * textureColor.xyz + \n\
							specularReflectionCoef * specular * specularColor)*vLightWeighting * occlusion * shadow_occlusion, alfa); \n\
	}\n\
	else{\n\
		finalColor = vec4((textureColor.xyz) * occlusion * shadow_occlusion, alfa);\n\
	}\n\
	\n\
	//if(testBool)\n\
	//finalColor *= vec4(0.99, 0.33, 0.32, 1.0);\n\
	\n\
	finalColor *= colorMultiplier;\n\
\n\
\n\
	//finalColor = vec4(linearDepth, linearDepth, linearDepth, 1.0); // test to render depth color coded.***\n\
    gl_FragColor = finalColor; \n\
\n\
}";
ShaderSource.ModelRefSsaoVS = "\n\
	attribute vec3 position;\n\
	attribute vec3 normal;\n\
	attribute vec2 texCoord;\n\
	attribute vec4 color4;\n\
	\n\
	uniform mat4 buildingRotMatrix; \n\
	uniform mat4 projectionMatrix;  \n\
	uniform mat4 modelViewMatrix;\n\
	uniform mat4 modelViewMatrixRelToEye; \n\
	uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
	uniform mat4 RefTransfMatrix;\n\
	uniform mat4 normalMatrix4;\n\
	uniform mat4 sunMatrix[2]; \n\
	uniform vec3 buildingPosHIGH;\n\
	uniform vec3 buildingPosLOW;\n\
	uniform vec3 scaleLC;\n\
	uniform vec3 sunPosHIGH[2];\n\
	uniform vec3 sunPosLOW[2];\n\
	uniform int sunIdx;\n\
	uniform vec3 sunDirWC;\n\
	uniform vec3 encodedCameraPositionMCHigh;\n\
	uniform vec3 encodedCameraPositionMCLow;\n\
	uniform vec3 aditionalPosition;\n\
	uniform vec3 refTranslationVec;\n\
	uniform int refMatrixType; // 0= identity, 1= translate, 2= transform\n\
	uniform bool bApplySpecularLighting;\n\
	uniform highp int colorType; // 0= oneColor, 1= attribColor, 2= texture.\n\
	\n\
	uniform bool bApplyShadow;\n\
	\n\
	// clipping planes.***\n\
	uniform mat4 clippingPlanesRotMatrix; \n\
	uniform vec3 clippingPlanesPosHIGH;\n\
	uniform vec3 clippingPlanesPosLOW;\n\
	uniform bool bApplyClippingPlanes;\n\
	uniform int clippingPlanesCount;\n\
	uniform vec4 clippingPlanes[6];\n\
\n\
	varying vec3 vNormal;\n\
	varying vec2 vTexCoord;  \n\
	varying vec3 uAmbientColor;\n\
	varying vec3 vLightWeighting;\n\
	varying vec3 vertexPos;\n\
	varying float applySpecLighting;\n\
	varying vec4 aColor4; // color from attributes\n\
	varying vec4 vPosRelToLight; \n\
	varying vec3 vLightDir; \n\
	varying vec3 vNormalWC; \n\
	varying float currSunIdx;  \n\
	varying float discardFrag;\n\
	\n\
	bool clipVertexByPlane(in vec4 plane, in vec3 point)\n\
	{\n\
		float dist = plane.x * point.x + plane.y * point.y + plane.z * point.z + plane.w;\n\
		\n\
		if(dist < 0.0)\n\
		return true;\n\
		else return false;\n\
	}\n\
	\n\
	void main()\n\
    {	\n\
		vec4 scaledPos = vec4(position.x * scaleLC.x, position.y * scaleLC.y, position.z * scaleLC.z, 1.0);\n\
		vec4 rotatedPos;\n\
		mat3 currentTMat;\n\
		if(refMatrixType == 0)\n\
		{\n\
			rotatedPos = buildingRotMatrix * vec4(scaledPos.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
			currentTMat = mat3(buildingRotMatrix);\n\
		}\n\
		else if(refMatrixType == 1)\n\
		{\n\
			rotatedPos = buildingRotMatrix * vec4(scaledPos.xyz + refTranslationVec.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
			currentTMat = mat3(buildingRotMatrix);\n\
		}\n\
		else if(refMatrixType == 2)\n\
		{\n\
			rotatedPos = RefTransfMatrix * vec4(scaledPos.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
			currentTMat = mat3(RefTransfMatrix);\n\
		}\n\
\n\
		vec3 objPosHigh = buildingPosHIGH;\n\
		vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
		vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
		vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
		vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
		vec3 rotatedNormal = currentTMat * normal;\n\
		\n\
		// Check if clipping.********************************************\n\
		if(bApplyClippingPlanes)\n\
		{\n\
			discardFrag = 1.0; // true.\n\
			for(int i=0; i<6; i++)\n\
			{\n\
				vec4 plane = clippingPlanes[i];\n\
				\n\
				// calculate any point of the plane.\n\
				\n\
				\n\
				if(!clipVertexByPlane(plane, vertexPos))\n\
				{\n\
					discardFrag = -1.0; // false.\n\
					break;\n\
				}\n\
				if(i >= clippingPlanesCount)\n\
				break;\n\
			}\n\
			\n\
			//if(discardFrag)\n\
			//discard;\n\
		}\n\
		//----------------------------------------------------------------\n\
		\n\
		vec3 uLightingDirection = vec3(-0.1320580393075943, -0.9903827905654907, 0.041261956095695496); \n\
		uAmbientColor = vec3(1.0);\n\
		vNormalWC = rotatedNormal;\n\
		vNormal = normalize((normalMatrix4 * vec4(rotatedNormal.x, rotatedNormal.y, rotatedNormal.z, 1.0)).xyz); // original.***\n\
		vTexCoord = texCoord;\n\
		vLightDir = vec3(-0.1320580393075943, -0.9903827905654907, 0.041261956095695496);\n\
		vec3 directionalLightColor = vec3(0.7, 0.7, 0.7);\n\
		float directionalLightWeighting = 1.0;\n\
		\n\
		currSunIdx = -1.0; // initially no apply shadow.\n\
		if(bApplyShadow)\n\
		{\n\
			//vLightDir = normalize(vec3(normalMatrix4 * vec4(sunDirWC.xyz, 1.0)).xyz); // test.***\n\
			vLightDir = sunDirWC;\n\
			vNormalWC = rotatedNormal;\n\
						\n\
			// the sun lights count are 2.\n\
			\n\
			vec3 currSunPosLOW;\n\
			vec3 currSunPosHIGH;\n\
			mat4 currSunMatrix;\n\
			if(sunIdx == 0)\n\
			{\n\
				currSunPosLOW = sunPosLOW[0];\n\
				currSunPosHIGH = sunPosHIGH[0];\n\
				currSunMatrix = sunMatrix[0];\n\
				currSunIdx = 0.5;\n\
			}\n\
			else if(sunIdx == 1)\n\
			{\n\
				currSunPosLOW = sunPosLOW[1];\n\
				currSunPosHIGH = sunPosHIGH[1];\n\
				currSunMatrix = sunMatrix[1];\n\
				currSunIdx = 1.5;\n\
			}\n\
			\n\
			// Calculate the vertex relative to light.***\n\
			vec3 highDifferenceSun = objPosHigh.xyz - currSunPosHIGH.xyz;\n\
			vec3 lowDifferenceSun = objPosLow.xyz - currSunPosLOW.xyz;\n\
			vec4 pos4Sun = vec4(highDifferenceSun.xyz + lowDifferenceSun.xyz, 1.0);\n\
			vPosRelToLight = currSunMatrix * pos4Sun;\n\
			\n\
			uLightingDirection = sunDirWC; \n\
			//directionalLightColor = vec3(0.9, 0.9, 0.9);\n\
			directionalLightWeighting = max(dot(rotatedNormal, -sunDirWC), 0.0);\n\
		}\n\
		else\n\
		{\n\
			uAmbientColor = vec3(0.8);\n\
			uLightingDirection = normalize(vec3(0.6, 0.6, 0.6));\n\
			directionalLightWeighting = max(dot(vNormal, uLightingDirection), 0.0);\n\
		}\n\
\n\
		vLightWeighting = uAmbientColor + directionalLightColor * directionalLightWeighting;\n\
		\n\
		if(bApplySpecularLighting)\n\
			applySpecLighting = 1.0;\n\
		else\n\
			applySpecLighting = -1.0;\n\
\n\
        gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
		vertexPos = (modelViewMatrixRelToEye * pos4).xyz;\n\
		//vertexPos = objPosHigh + objPosLow;\n\
		\n\
		if(colorType == 1)\n\
			aColor4 = color4;\n\
		gl_PointSize = 5.0;\n\
	}";
ShaderSource.OrthogonalDepthShaderFS = "#ifdef GL_ES\n\
precision highp float;\n\
#endif\n\
uniform float near;\n\
uniform float far;\n\
\n\
varying float depth;  \n\
\n\
vec4 packDepth(const in float depth)\n\
{\n\
    const vec4 bit_shift = vec4(16777216.0, 65536.0, 256.0, 1.0);\n\
    const vec4 bit_mask  = vec4(0.0, 0.00390625, 0.00390625, 0.00390625); \n\
    //vec4 res = fract(depth * bit_shift); // Is not precise.\n\
	vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255); // Is better.\n\
    res -= res.xxyz * bit_mask;\n\
    return res;  \n\
}\n\
\n\
vec4 PackDepth32( in float depth )\n\
{\n\
    depth *= (16777216.0 - 1.0) / (16777216.0);\n\
    vec4 encode = fract( depth * vec4(1.0, 256.0, 256.0*256.0, 16777216.0) );// 256.0*256.0*256.0 = 16777216.0\n\
    return vec4( encode.xyz - encode.yzw / 256.0, encode.w ) + 1.0/512.0;\n\
}\n\
\n\
void main()\n\
{     \n\
    gl_FragData[0] = PackDepth32(depth);\n\
	//gl_FragData[0] = packDepth(-depth);\n\
}";
ShaderSource.OrthogonalDepthShaderVS = "attribute vec3 position;\n\
\n\
uniform mat4 buildingRotMatrix; \n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 RefTransfMatrix;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform float near;\n\
uniform float far;\n\
uniform vec3 aditionalPosition;\n\
uniform vec3 refTranslationVec;\n\
uniform int refMatrixType; // 0= identity, 1= translate, 2= transform\n\
\n\
varying float depth;\n\
  \n\
void main()\n\
{	\n\
	vec4 rotatedPos;\n\
\n\
	if(refMatrixType == 0)\n\
	{\n\
		rotatedPos = buildingRotMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
	else if(refMatrixType == 1)\n\
	{\n\
		rotatedPos = buildingRotMatrix * vec4(position.xyz + refTranslationVec.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
	else if(refMatrixType == 2)\n\
	{\n\
		rotatedPos = RefTransfMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
    \n\
    //linear depth in camera space (0..far)\n\
    //depth = (modelViewMatrixRelToEye * pos4).z/far; // original.***\n\
\n\
	gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
	depth = gl_Position.z*0.5+0.5;\n\
}\n\
";
ShaderSource.PngImageFS = "precision highp float;\n\
varying vec2 v_texcoord;\n\
uniform bool textureFlipYAxis;\n\
uniform sampler2D u_texture;\n\
uniform highp int colorType; // 0= oneColor, 1= attribColor, 2= texture.\n\
uniform vec4 oneColor4;\n\
\n\
\n\
varying vec2 imageSizeInPixels;\n\
\n\
void main()\n\
{\n\
    vec4 textureColor;\n\
	if(colorType == 2)\n\
	{\n\
		if(textureFlipYAxis)\n\
		{\n\
			textureColor = texture2D(u_texture, vec2(v_texcoord.s, 1.0 - v_texcoord.t));\n\
		}\n\
		else\n\
		{\n\
			textureColor = texture2D(u_texture, v_texcoord);\n\
		}\n\
		if(textureColor.w < 0.05)\n\
		{\n\
			discard;\n\
		}\n\
	}\n\
	else if( colorType == 0)\n\
	{\n\
		textureColor = oneColor4;\n\
	}\n\
\n\
    gl_FragColor = textureColor;\n\
}";
ShaderSource.PngImageVS = "attribute vec4 position;\n\
attribute vec2 texCoord;\n\
uniform mat4 buildingRotMatrix;\n\
uniform mat4 modelViewMatrixRelToEye;  \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;  \n\
uniform mat4 projectionMatrix;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform vec2 scale2d;\n\
uniform vec2 size2d;\n\
uniform vec3 aditionalOffset;\n\
uniform vec2 imageSize;\n\
uniform float screenWidth;    \n\
uniform float screenHeight;\n\
uniform bool bUseOriginalImageSize;\n\
varying vec2 v_texcoord;\n\
varying vec2 imageSizeInPixels;\n\
\n\
void main()\n\
{\n\
    vec4 position2 = vec4(position.xyz, 1.0);\n\
    vec4 rotatedPos = buildingRotMatrix * vec4(position2.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
	\n\
	//imageSizeInPixels = vec2(imageSize.x, imageSize.y);\n\
	\n\
	float order_w = position.w;\n\
	float sense = 1.0;\n\
	int orderInt = 0;\n\
	if(order_w > 0.0)\n\
	{\n\
		sense = -1.0;\n\
		if(order_w < 1.5)\n\
		{\n\
			orderInt = 1;\n\
		}\n\
		else{\n\
			orderInt = 2;\n\
		}\n\
	}\n\
	else\n\
	{\n\
		sense = 1.0;\n\
		if(order_w > -1.5)\n\
		{\n\
			orderInt = -1;\n\
		}\n\
		else{\n\
			orderInt = -2;\n\
		}\n\
	}\n\
	\n\
    v_texcoord = texCoord;\n\
	vec4 projected = ModelViewProjectionMatrixRelToEye * pos4;\n\
	//vec4 projected2 = modelViewMatrixRelToEye * pos4;\n\
\n\
	// Now, calculate the pixelSize in the plane of the projected point.\n\
	float pixelWidthRatio = 2. / (screenWidth * projectionMatrix[0][0]);\n\
	// alternative : float pixelWidthRatio = 2. / (screenHeight * projectionMatrix[1][1]);\n\
	float pixelWidth = projected.w * pixelWidthRatio;\n\
	\n\
	if(projected.w < 5.0)\n\
		pixelWidth = 5.0 * pixelWidthRatio;\n\
	\n\
	vec4 offset;\n\
	float offsetX;\n\
	float offsetY;\n\
	if(bUseOriginalImageSize)\n\
	{\n\
		offsetX = pixelWidth*imageSize.x/2.0;\n\
		offsetY = pixelWidth*imageSize.y/2.0;\n\
	}\n\
	else{\n\
		offsetX = pixelWidth*size2d.x/2.0;\n\
		offsetY = pixelWidth*size2d.y/2.0;\n\
	}\n\
	\n\
	// Offset our position along the normal\n\
	if(orderInt == 1)\n\
	{\n\
		offset = vec4(-offsetX*scale2d.x, 0.0, 0.0, 1.0);\n\
	}\n\
	else if(orderInt == -1)\n\
	{\n\
		offset = vec4(offsetX*scale2d.x, 0.0, 0.0, 1.0);\n\
	}\n\
	else if(orderInt == 2)\n\
	{\n\
		offset = vec4(-offsetX*scale2d.x, offsetY*4.0*scale2d.y, 0.0, 1.0);\n\
	}\n\
	else if(orderInt == -2)\n\
	{\n\
		offset = vec4(offsetX*scale2d.x, offsetY*4.0*scale2d.y, 0.0, 1.0);\n\
	}\n\
\n\
	gl_Position = projected + offset + vec4(aditionalOffset.x*pixelWidth, aditionalOffset.y*pixelWidth, aditionalOffset.z*pixelWidth, 0.0); \n\
}\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
";
ShaderSource.PointCloudDepthFS = "#ifdef GL_ES\n\
precision highp float;\n\
#endif\n\
uniform float near;\n\
uniform float far;\n\
\n\
// clipping planes.***\n\
uniform bool bApplyClippingPlanes;\n\
uniform int clippingPlanesCount;\n\
uniform vec4 clippingPlanes[6];\n\
\n\
varying float depth;  \n\
\n\
vec4 packDepth(const in float depth)\n\
{\n\
    const vec4 bit_shift = vec4(16777216.0, 65536.0, 256.0, 1.0);\n\
    const vec4 bit_mask  = vec4(0.0, 0.00390625, 0.00390625, 0.00390625); \n\
    vec4 res = fract(depth * bit_shift);\n\
    res -= res.xxyz * bit_mask;\n\
    return res;  \n\
}\n\
\n\
vec4 PackDepth32( in float depth )\n\
{\n\
    depth *= (16777216.0 - 1.0) / (16777216.0);\n\
    vec4 encode = fract( depth * vec4(1.0, 256.0, 256.0*256.0, 16777216.0) );// 256.0*256.0*256.0 = 16777216.0\n\
    return vec4( encode.xyz - encode.yzw / 256.0, encode.w ) + 1.0/512.0;\n\
}\n\
\n\
void main()\n\
{     \n\
    gl_FragData[0] = packDepth(-depth);\n\
	//gl_FragData[0] = PackDepth32(depth);\n\
}";
ShaderSource.PointCloudDepthVS = "attribute vec3 position;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform mat4 buildingRotMatrix;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform float near;\n\
uniform float far;\n\
uniform bool bPositionCompressed;\n\
uniform vec3 minPosition;\n\
uniform vec3 bboxSize;\n\
attribute vec4 color4;\n\
uniform bool bUse1Color;\n\
uniform vec4 oneColor4;\n\
uniform float fixPointSize;\n\
uniform float maxPointSize;\n\
uniform float minPointSize;\n\
uniform float pendentPointSize;\n\
uniform bool bUseFixPointSize;\n\
varying vec4 vColor;\n\
//varying float glPointSize;\n\
varying float depth;  \n\
\n\
void main()\n\
{\n\
	vec3 realPos;\n\
	vec4 rotatedPos;\n\
	if(bPositionCompressed)\n\
	{\n\
		float maxShort = 65535.0;\n\
		realPos = vec3(float(position.x)/maxShort*bboxSize.x + minPosition.x, float(position.y)/maxShort*bboxSize.y + minPosition.y, float(position.z)/maxShort*bboxSize.z + minPosition.z);\n\
	}\n\
	else\n\
	{\n\
		realPos = position;\n\
	}\n\
	rotatedPos = buildingRotMatrix * vec4(realPos.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
	\n\
    if(bUse1Color)\n\
	{\n\
		vColor=oneColor4;\n\
	}\n\
	else\n\
		vColor=color4;\n\
	\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
	float z_b = gl_Position.z/gl_Position.w;\n\
	float z_n = 2.0 * z_b - 1.0;\n\
    float z_e = 2.0 * near * far / (far + near - z_n * (far - near));\n\
	gl_PointSize = minPointSize + pendentPointSize/z_e; // Original.***\n\
    if(gl_PointSize > maxPointSize)\n\
        gl_PointSize = maxPointSize;\n\
	if(gl_PointSize < 2.0)\n\
		gl_PointSize = 2.0;\n\
		\n\
	depth = (modelViewMatrixRelToEye * pos).z/far; // original.***\n\
}\n\
";
ShaderSource.PointCloudFS = "	precision lowp float;\n\
	varying vec4 vColor;\n\
\n\
	void main()\n\
    {\n\
		gl_FragColor = vColor;\n\
	}";
ShaderSource.PointCloudSsaoFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
\n\
uniform sampler2D depthTex;\n\
uniform mat4 projectionMatrix;\n\
uniform float near;\n\
uniform float far;            \n\
uniform float fov;\n\
uniform float aspectRatio;    \n\
uniform float screenWidth;    \n\
uniform float screenHeight;    \n\
uniform vec3 kernel[16];   \n\
uniform vec4 oneColor4;\n\
varying vec4 aColor4; // color from attributes\n\
varying vec4 vColor;\n\
varying float glPointSize;\n\
\n\
const int kernelSize = 16;  \n\
uniform float radius;      \n\
\n\
uniform bool bApplySsao;\n\
uniform float externalAlpha;\n\
\n\
float unpackDepth(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
}                \n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
    float hfar = 2.0 * tan(fov/2.0) * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
}         \n\
            \n\
//linear view space depth\n\
float getDepth(vec2 coord)\n\
{\n\
    return unpackDepth(texture2D(depthTex, coord.xy));\n\
}    \n\
\n\
void main()\n\
{\n\
	float occlusion = 0.0;\n\
	if(bApplySsao)\n\
	{          \n\
		vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight);\n\
		float linearDepth = getDepth(screenPos);\n\
		vec3 origin = getViewRay(screenPos) * linearDepth;\n\
		float radiusAux = glPointSize/1.9;\n\
		radiusAux = 1.5;\n\
		vec2 screenPosAdjacent;\n\
		\n\
		for(int j = 0; j < 1; ++j)\n\
		{\n\
			radiusAux = 1.5 *(float(j)+1.0);\n\
			for(int i = 0; i < 8; ++i)\n\
			{    	 \n\
				if(i == 0)\n\
					screenPosAdjacent = vec2((gl_FragCoord.x - radiusAux)/ screenWidth, (gl_FragCoord.y - radiusAux) / screenHeight);\n\
				else if(i == 1)\n\
					screenPosAdjacent = vec2((gl_FragCoord.x)/ screenWidth, (gl_FragCoord.y - radiusAux) / screenHeight);\n\
				else if(i == 2)\n\
					screenPosAdjacent = vec2((gl_FragCoord.x + radiusAux)/ screenWidth, (gl_FragCoord.y - radiusAux) / screenHeight);\n\
				else if(i == 3)\n\
					screenPosAdjacent = vec2((gl_FragCoord.x + radiusAux)/ screenWidth, (gl_FragCoord.y) / screenHeight);\n\
				else if(i == 4)\n\
					screenPosAdjacent = vec2((gl_FragCoord.x + radiusAux)/ screenWidth, (gl_FragCoord.y + radiusAux) / screenHeight);\n\
				else if(i == 5)\n\
					screenPosAdjacent = vec2((gl_FragCoord.x)/ screenWidth, (gl_FragCoord.y + radiusAux) / screenHeight);\n\
				else if(i == 6)\n\
					screenPosAdjacent = vec2((gl_FragCoord.x - radiusAux)/ screenWidth, (gl_FragCoord.y + radiusAux) / screenHeight);\n\
				else if(i == 7)\n\
					screenPosAdjacent = vec2((gl_FragCoord.x - radiusAux)/ screenWidth, (gl_FragCoord.y) / screenHeight);\n\
				float depthBufferValue = getDepth(screenPosAdjacent);\n\
				float range_check = abs(linearDepth - depthBufferValue)*far;\n\
				if (range_check > 1.5 && depthBufferValue > linearDepth)\n\
				{\n\
					if (range_check < 20.0)\n\
						occlusion +=  1.0;\n\
				}\n\
			}   \n\
		}   \n\
			\n\
		if(occlusion > 6.0)\n\
			occlusion = 8.0;\n\
		//else occlusion = 0.0;\n\
		occlusion = 1.0 - occlusion / 8.0;\n\
	}\n\
	else{\n\
		occlusion = 1.0;\n\
	}\n\
\n\
    vec4 finalColor;\n\
	finalColor = vec4((vColor.xyz) * occlusion, externalAlpha);\n\
	//finalColor = vec4(vec3(0.8, 0.8, 0.8) * occlusion, externalAlpha);\n\
    gl_FragColor = finalColor; \n\
}";
ShaderSource.PointCloudSsaoFS_rainbow = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
\n\
uniform sampler2D depthTex;\n\
uniform mat4 projectionMatrix;\n\
uniform float near;\n\
uniform float far;            \n\
uniform float fov;\n\
uniform float aspectRatio;    \n\
uniform float screenWidth;    \n\
uniform float screenHeight;    \n\
uniform vec3 kernel[16];   \n\
uniform vec4 oneColor4;\n\
uniform bool bUseColorCodingByHeight;\n\
uniform float minHeight_rainbow;   \n\
uniform float maxHeight_rainbow;  \n\
varying vec4 aColor4; // color from attributes\n\
varying vec4 vColor;\n\
varying float glPointSize;\n\
varying float realHeigh;\n\
\n\
const int kernelSize = 16;  \n\
uniform float radius;      \n\
\n\
uniform bool bApplySsao;\n\
uniform float externalAlpha;\n\
\n\
float unpackDepth(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
}                \n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
    float hfar = 2.0 * tan(fov/2.0) * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
}         \n\
            \n\
//linear view space depth\n\
float getDepth(vec2 coord)\n\
{\n\
    return unpackDepth(texture2D(depthTex, coord.xy));\n\
}  \n\
\n\
vec3 getRainbowColor_byHeight(float height)\n\
{\n\
	float gray = (height - minHeight_rainbow)/(maxHeight_rainbow - minHeight_rainbow);\n\
	if (gray > 1.0){ gray = 1.0; }\n\
	else if (gray<0.0){ gray = 0.0; }\n\
	\n\
	float r, g, b;\n\
	\n\
	if(gray < 0.16666)\n\
	{\n\
		b = 0.0;\n\
		g = gray*6.0;\n\
		r = 1.0;\n\
	}\n\
	else if(gray >= 0.16666 && gray < 0.33333)\n\
	{\n\
		b = 0.0;\n\
		g = 1.0;\n\
		r = 2.0 - gray*6.0;\n\
	}\n\
	else if(gray >= 0.33333 && gray < 0.5)\n\
	{\n\
		b = -2.0 + gray*6.0;\n\
		g = 1.0;\n\
		r = 0.0;\n\
	}\n\
	else if(gray >= 0.5 && gray < 0.66666)\n\
	{\n\
		b = 1.0;\n\
		g = 4.0 - gray*6.0;\n\
		r = 0.0;\n\
	}\n\
	else if(gray >= 0.66666 && gray < 0.83333)\n\
	{\n\
		b = 1.0;\n\
		g = 0.0;\n\
		r = -4.0 + gray*6.0;\n\
	}\n\
	else if(gray >= 0.83333)\n\
	{\n\
		b = 6.0 - gray*6.0;\n\
		g = 0.0;\n\
		r = 1.0;\n\
	}\n\
	\n\
	float aux = r;\n\
	r = b;\n\
	b = aux;\n\
	\n\
	//b = -gray + 1.0;\n\
	//if (gray > 0.5)\n\
	//{\n\
	//	g = -gray*2.0 + 2.0; \n\
	//}\n\
	//else \n\
	//{\n\
	//	g = gray*2.0;\n\
	//}\n\
	//r = gray;\n\
	vec3 resultColor = vec3(r, g, b);\n\
    return resultColor;\n\
}   \n\
\n\
void main()\n\
{\n\
	float occlusion = 0.0;\n\
	if(bApplySsao)\n\
	{          \n\
		vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight);\n\
		float linearDepth = getDepth(screenPos);\n\
		vec3 origin = getViewRay(screenPos) * linearDepth;\n\
		float radiusAux = glPointSize/1.9;\n\
		radiusAux = 1.5;\n\
		vec2 screenPosAdjacent;\n\
		\n\
		for(int j = 0; j < 1; ++j)\n\
		{\n\
			radiusAux = 1.5 *(float(j)+1.0);\n\
			for(int i = 0; i < 8; ++i)\n\
			{    	 \n\
				if(i == 0)\n\
					screenPosAdjacent = vec2((gl_FragCoord.x - radiusAux)/ screenWidth, (gl_FragCoord.y - radiusAux) / screenHeight);\n\
				else if(i == 1)\n\
					screenPosAdjacent = vec2((gl_FragCoord.x)/ screenWidth, (gl_FragCoord.y - radiusAux) / screenHeight);\n\
				else if(i == 2)\n\
					screenPosAdjacent = vec2((gl_FragCoord.x + radiusAux)/ screenWidth, (gl_FragCoord.y - radiusAux) / screenHeight);\n\
				else if(i == 3)\n\
					screenPosAdjacent = vec2((gl_FragCoord.x + radiusAux)/ screenWidth, (gl_FragCoord.y) / screenHeight);\n\
				else if(i == 4)\n\
					screenPosAdjacent = vec2((gl_FragCoord.x + radiusAux)/ screenWidth, (gl_FragCoord.y + radiusAux) / screenHeight);\n\
				else if(i == 5)\n\
					screenPosAdjacent = vec2((gl_FragCoord.x)/ screenWidth, (gl_FragCoord.y + radiusAux) / screenHeight);\n\
				else if(i == 6)\n\
					screenPosAdjacent = vec2((gl_FragCoord.x - radiusAux)/ screenWidth, (gl_FragCoord.y + radiusAux) / screenHeight);\n\
				else if(i == 7)\n\
					screenPosAdjacent = vec2((gl_FragCoord.x - radiusAux)/ screenWidth, (gl_FragCoord.y) / screenHeight);\n\
				float depthBufferValue = getDepth(screenPosAdjacent);\n\
				float range_check = abs(linearDepth - depthBufferValue)*far;\n\
				if (range_check > 1.5 && depthBufferValue > linearDepth)\n\
				{\n\
					if (range_check < 20.0)\n\
						occlusion +=  1.0;\n\
				}\n\
			}   \n\
		}   \n\
			\n\
		if(occlusion > 6.0)\n\
			occlusion = 8.0;\n\
		//else occlusion = 0.0;\n\
		occlusion = 1.0 - occlusion / 8.0;\n\
	}\n\
	else{\n\
		occlusion = 1.0;\n\
	}\n\
\n\
    vec4 finalColor;\n\
	if(bUseColorCodingByHeight)\n\
	{\n\
		float rainbow = 0.5;\n\
		float texCol = 0.5;\n\
		vec3 rainbowColor3 = getRainbowColor_byHeight(realHeigh);\n\
		vec3 blendedColor3 = vec3(vColor.x * texCol + rainbowColor3.r * rainbow, vColor.y * texCol + rainbowColor3.g * rainbow, vColor.z * texCol + rainbowColor3.b * rainbow);\n\
		finalColor = vec4(blendedColor3 * occlusion, externalAlpha);\n\
	}\n\
	else\n\
		finalColor = vec4((vColor.xyz) * occlusion, externalAlpha);\n\
	//finalColor = vec4(vec3(0.8, 0.8, 0.8) * occlusion, externalAlpha);\n\
    gl_FragColor = finalColor; \n\
}\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
";
ShaderSource.PointCloudVS = "attribute vec3 position;\n\
attribute vec3 normal;\n\
attribute vec2 texCoord;\n\
attribute vec4 color4;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform mat4 buildingRotMatrix;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform float near;\n\
uniform float far;\n\
uniform bool bPositionCompressed;\n\
uniform vec3 minPosition;\n\
uniform vec3 bboxSize;\n\
uniform bool bUse1Color;\n\
uniform vec4 oneColor4;\n\
uniform float fixPointSize;\n\
uniform float maxPointSize;\n\
uniform float minPointSize;\n\
uniform float pendentPointSize;\n\
uniform bool bUseFixPointSize;\n\
uniform bool bUseColorCodingByHeight;\n\
varying vec4 vColor;\n\
varying float glPointSize;\n\
\n\
void main()\n\
{\n\
	vec3 realPos;\n\
	vec4 rotatedPos;\n\
	if(bPositionCompressed)\n\
	{\n\
		float maxShort = 65535.0;\n\
		realPos = vec3(float(position.x)/maxShort*bboxSize.x + minPosition.x, float(position.y)/maxShort*bboxSize.y + minPosition.y, float(position.z)/maxShort*bboxSize.z + minPosition.z);\n\
	}\n\
	else\n\
	{\n\
		realPos = position;\n\
	}\n\
	rotatedPos = buildingRotMatrix * vec4(realPos.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
	\n\
    if(bUse1Color)\n\
	{\n\
		vColor=oneColor4;\n\
	}\n\
	else\n\
		vColor=color4;\n\
	\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
	float z_b = gl_Position.z/gl_Position.w;\n\
	float z_n = 2.0 * z_b - 1.0;\n\
    float z_e = 2.0 * near * far / (far + near - z_n * (far - near));\n\
	gl_PointSize = minPointSize + pendentPointSize/z_e; // Original.***\n\
    if(gl_PointSize > maxPointSize)\n\
        gl_PointSize = maxPointSize;\n\
	if(gl_PointSize < 2.0)\n\
		gl_PointSize = 2.0;\n\
		\n\
	glPointSize = gl_PointSize;\n\
}";
ShaderSource.PointCloudVS_rainbow = "attribute vec3 position;\n\
attribute vec3 normal;\n\
attribute vec2 texCoord;\n\
attribute vec4 color4;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform mat4 buildingRotMatrix;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform float near;\n\
uniform float far;\n\
uniform bool bPositionCompressed;\n\
uniform vec3 minPosition;\n\
uniform vec3 bboxSize;\n\
uniform bool bUse1Color;\n\
uniform vec4 oneColor4;\n\
uniform float fixPointSize;\n\
uniform float maxPointSize;\n\
uniform float minPointSize;\n\
uniform float pendentPointSize;\n\
uniform bool bUseFixPointSize;\n\
varying vec4 vColor;\n\
varying float glPointSize;\n\
varying float realHeigh;\n\
\n\
void main()\n\
{\n\
	vec3 realPos;\n\
	vec4 rotatedPos;\n\
	if(bPositionCompressed)\n\
	{\n\
		float maxShort = 65535.0;\n\
		realPos = vec3(float(position.x)/maxShort*bboxSize.x + minPosition.x, float(position.y)/maxShort*bboxSize.y + minPosition.y, float(position.z)/maxShort*bboxSize.z + minPosition.z);\n\
	}\n\
	else\n\
	{\n\
		realPos = position;\n\
	}\n\
	realHeigh = realPos.z;\n\
	rotatedPos = buildingRotMatrix * vec4(realPos.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
	\n\
    if(bUse1Color)\n\
	{\n\
		vColor=oneColor4;\n\
	}\n\
	else\n\
		vColor=color4;\n\
	\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
	float z_b = gl_Position.z/gl_Position.w;\n\
	float z_n = 2.0 * z_b - 1.0;\n\
    float z_e = 2.0 * near * far / (far + near - z_n * (far - near));\n\
    gl_PointSize = minPointSize + pendentPointSize/z_e; // Original.***\n\
    if(gl_PointSize > maxPointSize)\n\
        gl_PointSize = maxPointSize;\n\
    if(gl_PointSize < 2.0)\n\
        gl_PointSize = 2.0;\n\
        \n\
    glPointSize = gl_PointSize;\n\
}\n\
";
ShaderSource.quad_vert = "precision mediump float;\n\
\n\
attribute vec2 a_pos;\n\
\n\
varying vec2 v_tex_pos;\n\
\n\
void main() {\n\
    v_tex_pos = a_pos;\n\
    gl_Position = vec4(1.0 - 2.0 * a_pos, 0, 1);\n\
}\n\
";
ShaderSource.RenderShowDepthFS = "#ifdef GL_ES\n\
precision highp float;\n\
#endif\n\
uniform float near;\n\
uniform float far;\n\
\n\
// clipping planes.***\n\
uniform bool bApplyClippingPlanes;\n\
uniform int clippingPlanesCount;\n\
uniform vec4 clippingPlanes[6];\n\
\n\
varying float depth;  \n\
varying vec3 vertexPos;\n\
\n\
vec4 packDepth(const in float depth)\n\
{\n\
    const vec4 bit_shift = vec4(16777216.0, 65536.0, 256.0, 1.0); // original.***\n\
    const vec4 bit_mask  = vec4(0.0, 0.00390625, 0.00390625, 0.00390625);  // original.*** \n\
	\n\
    //vec4 res = fract(depth * bit_shift); // Is not precise.\n\
	vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255); // Is better.\n\
    res -= res.xxyz * bit_mask;\n\
    return res;  \n\
}\n\
\n\
\n\
//vec4 PackDepth32( in float depth )\n\
//{\n\
//    depth *= (16777216.0 - 1.0) / (16777216.0);\n\
//    vec4 encode = fract( depth * vec4(1.0, 256.0, 256.0*256.0, 16777216.0) );// 256.0*256.0*256.0 = 16777216.0\n\
//    return vec4( encode.xyz - encode.yzw / 256.0, encode.w ) + 1.0/512.0;\n\
//}\n\
\n\
bool clipVertexByPlane(in vec4 plane, in vec3 point)\n\
{\n\
	float dist = plane.x * point.x + plane.y * point.y + plane.z * point.z + plane.w;\n\
	\n\
	if(dist < 0.0)\n\
	return true;\n\
	else return false;\n\
}\n\
\n\
void main()\n\
{     \n\
	// 1rst, check if there are clipping planes.\n\
	if(bApplyClippingPlanes)\n\
	{\n\
		bool discardFrag = true;\n\
		for(int i=0; i<6; i++)\n\
		{\n\
			vec4 plane = clippingPlanes[i];\n\
			if(!clipVertexByPlane(plane, vertexPos))\n\
			{\n\
				discardFrag = false;\n\
				break;\n\
			}\n\
			if(i >= clippingPlanesCount)\n\
			break;\n\
		}\n\
		\n\
		if(discardFrag)\n\
		discard;\n\
	}\n\
	\n\
    gl_FragData[0] = packDepth(-depth);\n\
	//gl_FragData[0] = PackDepth32(depth);\n\
}";
ShaderSource.RenderShowDepthVS = "attribute vec3 position;\n\
\n\
uniform mat4 buildingRotMatrix; \n\
uniform mat4 modelViewMatrix;\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 RefTransfMatrix;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 scaleLC;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform float near;\n\
uniform float far;\n\
uniform vec3 aditionalPosition;\n\
uniform vec3 refTranslationVec;\n\
uniform int refMatrixType; // 0= identity, 1= translate, 2= transform\n\
\n\
varying float depth;\n\
varying vec3 vertexPos;\n\
  \n\
void main()\n\
{	\n\
	vec4 scaledPos = vec4(position.x * scaleLC.x, position.y * scaleLC.y, position.z * scaleLC.z, 1.0);\n\
	vec4 rotatedPos;\n\
\n\
	if(refMatrixType == 0)\n\
	{\n\
		rotatedPos = buildingRotMatrix * vec4(scaledPos.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
	else if(refMatrixType == 1)\n\
	{\n\
		rotatedPos = buildingRotMatrix * vec4(scaledPos.xyz + refTranslationVec.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
	else if(refMatrixType == 2)\n\
	{\n\
		rotatedPos = RefTransfMatrix * vec4(scaledPos.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
    \n\
    //linear depth in camera space (0..far)\n\
	vec4 posCC = modelViewMatrixRelToEye * pos4;\n\
    depth = posCC.z/far; // original.***\n\
	//depth = posCC.z/(far-near); // test.***\n\
	//float farForDepth = 30000.0;\n\
	//depth = posCC.z/farForDepth; // test.***\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
	vertexPos = posCC.xyz;\n\
}";
ShaderSource.ScreenQuadFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
\n\
uniform sampler2D depthTex;\n\
uniform sampler2D shadowMapTex;\n\
uniform sampler2D shadowMapTex2;\n\
uniform mat4 modelViewMatrix;\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 modelViewMatrixInv;\n\
uniform mat4 modelViewProjectionMatrixInv;\n\
uniform mat4 modelViewMatrixRelToEyeInv;\n\
uniform mat4 projectionMatrix;\n\
uniform mat4 projectionMatrixInv;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform bool bApplyShadow;\n\
uniform bool bSilhouette;\n\
uniform mat4 sunMatrix[2]; \n\
uniform vec3 sunPosHIGH[2];\n\
uniform vec3 sunPosLOW[2];\n\
uniform int sunIdx;\n\
uniform float screenWidth;    \n\
uniform float screenHeight;   \n\
uniform float near;\n\
uniform float far;\n\
uniform float fov;\n\
uniform float tangentOfHalfFovy;\n\
uniform float aspectRatio;\n\
varying vec4 vColor; \n\
\n\
float unpackDepth(vec4 packedDepth)\n\
{\n\
	// See Aras Pranckevičius' post Encoding Floats to RGBA\n\
	// http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n\
	return dot(packedDepth, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n\
}\n\
\n\
float unpackDepthMago(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);// original.***\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
} \n\
\n\
float UnpackDepth32( in vec4 pack )\n\
{\n\
	float depth = dot( pack, vec4(1.0, 0.00390625, 0.000015258789, 0.000000059605) );\n\
    return depth * 1.000000059605;// 1.000000059605 = (16777216.0) / (16777216.0 - 1.0);\n\
}  \n\
\n\
float getDepthShadowMap(vec2 coord)\n\
{\n\
	// currSunIdx\n\
	if(sunIdx == 0)\n\
	{\n\
		return UnpackDepth32(texture2D(shadowMapTex, coord.xy));\n\
	}\n\
    else if(sunIdx ==1)\n\
	{\n\
		return UnpackDepth32(texture2D(shadowMapTex2, coord.xy));\n\
	}\n\
	else\n\
		return -1.0;\n\
}\n\
\n\
bool isInShadow(vec4 pointWC, int currSunIdx)\n\
{\n\
	bool inShadow = false;\n\
	vec3 currSunPosLOW;\n\
	vec3 currSunPosHIGH;\n\
	mat4 currSunMatrix;\n\
	if(currSunIdx == 0)\n\
	{\n\
		currSunPosLOW = sunPosLOW[0];\n\
		currSunPosHIGH = sunPosHIGH[0];\n\
		currSunMatrix = sunMatrix[0];\n\
	}\n\
	else if(currSunIdx == 1)\n\
	{\n\
		currSunPosLOW = sunPosLOW[1];\n\
		currSunPosHIGH = sunPosHIGH[1];\n\
		currSunMatrix = sunMatrix[1];\n\
	}\n\
	else\n\
	return false;\n\
	\n\
		\n\
	vec3 highDifferenceSun = pointWC.xyz -currSunPosHIGH.xyz;\n\
	vec3 lowDifferenceSun = -currSunPosLOW.xyz;\n\
	vec4 pos4Sun = vec4(highDifferenceSun.xyz + lowDifferenceSun.xyz, 1.0);\n\
	vec4 vPosRelToLight = currSunMatrix * pos4Sun;\n\
\n\
	vec3 posRelToLight = vPosRelToLight.xyz / vPosRelToLight.w;\n\
	float tolerance = 0.9963;\n\
	posRelToLight = posRelToLight * 0.5 + 0.5; // transform to [0,1] range\n\
	if(posRelToLight.x >= 0.0 && posRelToLight.x <= 1.0)\n\
	{\n\
		if(posRelToLight.y >= 0.0 && posRelToLight.y <= 1.0)\n\
		{\n\
			float depthRelToLight;\n\
			if(currSunIdx == 0)\n\
			{depthRelToLight = UnpackDepth32(texture2D(shadowMapTex, posRelToLight.xy));}\n\
			else if(currSunIdx == 1)\n\
			{depthRelToLight = UnpackDepth32(texture2D(shadowMapTex2, posRelToLight.xy));}\n\
			if(posRelToLight.z > depthRelToLight*tolerance )\n\
			{\n\
				inShadow = true;\n\
			}\n\
		}\n\
	}\n\
	\n\
	return inShadow;\n\
}\n\
\n\
void main()\n\
{\n\
	// 1rst, check if this is silhouette rendering.\n\
	if(bSilhouette)\n\
	{\n\
		// Check the adjacent pixels to decide if this is silhouette.\n\
		// Analize a 5x5 rectangle of the depthTexture: if there are objectDepth & backgroundDepth => is silhouette.\n\
		float pixelSizeW = 1.0/screenWidth;\n\
		float pixelSizeH = 1.0/screenHeight;\n\
		int objectDepthCount = 0;\n\
		int backgroundDepthCount = 0;\n\
		float tolerance = 0.9963;\n\
		tolerance = 0.9963;\n\
		\n\
		vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight); // centerPos.\n\
		vec2 screenPos_LD = vec2(screenPos.x - pixelSizeW*1.5, screenPos.y - pixelSizeH*1.5); // left-down corner.\n\
		\n\
		for(int w = 0; w<3; w++)\n\
		{\n\
			for(int h=0; h<3; h++)\n\
			{\n\
				vec2 screenPosAux = vec2(screenPos_LD.x + pixelSizeW*float(w), screenPos_LD.y + pixelSizeH*float(h));\n\
				float z_window  = unpackDepthMago(texture2D(depthTex, screenPosAux.xy)); // z_window  is [0.0, 1.0] range depth.\n\
\n\
				if(z_window > tolerance)\n\
				{\n\
					// is background.\n\
					backgroundDepthCount += 1;\n\
				}\n\
				else\n\
				{\n\
					// is object.\n\
					objectDepthCount += 1;\n\
				}\n\
\n\
				if(backgroundDepthCount > 0 && objectDepthCount > 0)\n\
				{\n\
					// is silhouette.\n\
					gl_FragColor = vec4(0.2, 1.0, 0.3, 1.0);\n\
					return;\n\
				}\n\
				\n\
			}\n\
		}\n\
		\n\
		return;\n\
	}\n\
	\n\
	float shadow_occlusion = 1.0;\n\
	float alpha = 0.0;\n\
	vec4 finalColor;\n\
	finalColor = vec4(0.2, 0.2, 0.2, 0.8);\n\
	if(bApplyShadow)\n\
	{\n\
		// the sun lights count are 2.\n\
		// 1rst, calculate the pixelPosWC.\n\
		vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight);\n\
		float z_window  = unpackDepth(texture2D(depthTex, screenPos.xy)); // z_window  is [0.0, 1.0] range depth.\n\
		if(z_window < 0.001)\n\
		discard;\n\
		\n\
		// https://stackoverflow.com/questions/11277501/how-to-recover-view-space-position-given-view-space-depth-value-and-ndc-xy\n\
		float depthRange_near = 0.0;\n\
		float depthRange_far = 1.0;\n\
		float x_ndc = 2.0 * screenPos.x - 1.0;\n\
		float y_ndc = 2.0 * screenPos.y - 1.0;\n\
		float z_ndc = (2.0 * z_window - depthRange_near - depthRange_far) / (depthRange_far - depthRange_near);\n\
		\n\
		vec4 viewPosH = projectionMatrixInv * vec4(x_ndc, y_ndc, z_ndc, 1.0);\n\
		vec3 posCC = viewPosH.xyz/viewPosH.w;\n\
		vec4 posWC = modelViewMatrixRelToEyeInv * vec4(posCC.xyz, 1.0) + vec4((encodedCameraPositionMCHigh + encodedCameraPositionMCLow).xyz, 1.0);\n\
		//----------------------------------------------------------------\n\
	\n\
		// 2nd, calculate the vertex relative to light.***\n\
		// 1rst, try with the closest sun. sunIdx = 0.\n\
		bool pointIsinShadow = isInShadow(posWC, 0);\n\
		if(!pointIsinShadow)\n\
		{\n\
			pointIsinShadow = isInShadow(posWC, 1);\n\
		}\n\
\n\
		if(pointIsinShadow)\n\
		{\n\
			shadow_occlusion = 0.5;\n\
			alpha = 0.5;\n\
		}\n\
		\n\
	}\n\
    gl_FragColor = vec4(finalColor.rgb*shadow_occlusion, alpha);\n\
}";
ShaderSource.ScreenQuadVS = "precision mediump float;\n\
\n\
attribute vec2 position;\n\
varying vec4 vColor; \n\
\n\
void main() {\n\
	vColor = vec4(0.2, 0.2, 0.2, 0.5);\n\
    gl_Position = vec4(1.0 - 2.0 * position, 0.0, 1.0);\n\
}";
ShaderSource.screen_frag = "precision mediump float;\n\
\n\
uniform sampler2D u_screen;\n\
uniform float u_opacity;\n\
\n\
varying vec2 v_tex_pos;\n\
\n\
void main() {\n\
    vec4 color = texture2D(u_screen, 1.0 - v_tex_pos);\n\
    // a hack to guarantee opacity fade out even with a value close to 1.0\n\
    gl_FragColor = vec4(floor(255.0 * color * u_opacity) / 255.0);\n\
}\n\
";
ShaderSource.SilhouetteFS = "precision highp float;\n\
uniform vec4 vColor4Aux;\n\
\n\
void main()\n\
{          \n\
    gl_FragColor = vColor4Aux;\n\
}";
ShaderSource.SilhouetteVS = "attribute vec3 position;\n\
\n\
uniform mat4 buildingRotMatrix; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 ModelViewMatrixRelToEye;\n\
uniform mat4 ProjectionMatrix;\n\
uniform mat4 RefTransfMatrix;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform vec3 aditionalPosition;\n\
uniform vec3 refTranslationVec;\n\
uniform int refMatrixType; // 0= identity, 1= translate, 2= transform\n\
uniform vec2 camSpacePixelTranslation;\n\
uniform vec2 screenSize;   \n\
varying vec2 camSpaceTranslation;\n\
\n\
void main()\n\
{    \n\
    vec4 rotatedPos;\n\
	if(refMatrixType == 0)\n\
	{\n\
		rotatedPos = buildingRotMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
	else if(refMatrixType == 1)\n\
	{\n\
		rotatedPos = buildingRotMatrix * vec4(position.xyz + refTranslationVec.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
	else if(refMatrixType == 2)\n\
	{\n\
		rotatedPos = RefTransfMatrix * vec4(position.xyz, 1.0) + vec4(aditionalPosition.xyz, 0.0);\n\
	}\n\
\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
    vec4 camSpacePos = ModelViewMatrixRelToEye * pos4;\n\
    vec4 translationVec = ProjectionMatrix * vec4(camSpacePixelTranslation.x*(-camSpacePos.z), camSpacePixelTranslation.y*(-camSpacePos.z), 0.0, 1.0);\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
    gl_Position += translationVec;  \n\
}";
ShaderSource.StandardFS = "precision lowp float;\n\
varying vec3 vColor;\n\
\n\
void main()\n\
{\n\
    gl_FragColor = vec4(vColor, 1.);\n\
}";
ShaderSource.StandardVS = "attribute vec3 position;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform mat4 RefTransfMatrix;\n\
attribute vec3 color;\n\
varying vec3 vColor;\n\
\n\
void main()\n\
{\n\
    vec4 rotatedPos = RefTransfMatrix * vec4(position.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
 \n\
    vColor=color;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
}";
ShaderSource.Test_QuadFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
 \n\
uniform sampler2D diffuseTex;  \n\
varying vec2 vTexCoord; \n\
void main()\n\
{          \n\
    vec4 textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, vTexCoord.t));\n\
    gl_FragColor = textureColor; \n\
}\n\
";
ShaderSource.Test_QuadVS = "attribute vec3 position;\n\
attribute vec2 texCoord;\n\
\n\
uniform sampler2D diffuseTex;\n\
uniform mat4 projectionMatrix;  \n\
uniform mat4 modelViewMatrix;\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 normalMatrix4;\n\
uniform mat4 buildingRotMatrix;  \n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
\n\
varying vec3 vNormal;\n\
varying vec2 vTexCoord;   \n\
\n\
void main()\n\
{	\n\
    vec4 rotatedPos = buildingRotMatrix * vec4(position.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
	\n\
    vTexCoord = texCoord;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
}\n\
";
ShaderSource.TextureA1FS = "precision mediump float;\n\
varying vec4 vColor;\n\
varying vec2 vTextureCoord;\n\
uniform sampler2D uSampler;\n\
\n\
void main()\n\
{\n\
    gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));\n\
}\n\
";
ShaderSource.TextureA1VS = "attribute vec3 position;\n\
attribute vec4 aVertexColor;\n\
attribute vec2 aTextureCoord;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
varying vec4 vColor;\n\
varying vec2 vTextureCoord;\n\
\n\
void main()\n\
{\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + position.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
 \n\
    vColor=aVertexColor;\n\
    vTextureCoord = aTextureCoord;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
}";
ShaderSource.TextureFS = "precision mediump float;\n\
varying vec4 vColor;\n\
varying vec2 vTextureCoord;\n\
uniform sampler2D uSampler;\n\
\n\
void main()\n\
{\n\
    gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));\n\
}";
ShaderSource.TextureNormalFS = "	precision mediump float;\n\
	varying vec4 vColor;\n\
	varying vec2 vTextureCoord;\n\
	uniform sampler2D uSampler;\n\
	varying vec3 vLightWeighting;\n\
\n\
	void main()\n\
    {\n\
		vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));\n\
        \n\
		gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);\n\
	}\n\
";
ShaderSource.TextureNormalVS = "attribute vec3 position;\n\
attribute vec4 aVertexColor;\n\
attribute vec2 aTextureCoord;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
varying vec4 vColor;\n\
varying vec2 vTextureCoord;\n\
attribute vec3 aVertexNormal;\n\
varying vec3 uAmbientColor;\n\
varying vec3 vLightWeighting;\n\
uniform mat3 uNMatrix;\n\
\n\
void main()\n\
{\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + position.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
    \n\
    vColor = aVertexColor;\n\
    vTextureCoord = aTextureCoord;\n\
    \n\
    vLightWeighting = vec3(1.0, 1.0, 1.0);\n\
    uAmbientColor = vec3(0.7, 0.7, 0.7);\n\
    vec3 uLightingDirection = vec3(0.8, 0.2, -0.9);\n\
    vec3 directionalLightColor = vec3(0.4, 0.4, 0.4);\n\
    vec3 transformedNormal = uNMatrix * aVertexNormal;\n\
    float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);\n\
    vLightWeighting = uAmbientColor + directionalLightColor * directionalLightWeighting;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
}\n\
";
ShaderSource.TextureVS = "attribute vec3 position;\n\
attribute vec4 aVertexColor;\n\
attribute vec2 aTextureCoord;\n\
uniform mat4 Mmatrix;\n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
varying vec4 vColor;\n\
varying vec2 vTextureCoord;\n\
\n\
void main()\n\
{\n\
    vec4 rotatedPos = Mmatrix * vec4(position.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
\n\
    vColor=aVertexColor;\n\
    vTextureCoord = aTextureCoord;\n\
\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos;\n\
    \n\
}";
ShaderSource.thickLineFS = "precision highp float;\n\
\n\
varying vec4 vColor;\n\
\n\
void main() {\n\
	gl_FragColor = vColor;\n\
}";
ShaderSource.thickLineVS = "\n\
attribute vec4 prev;\n\
attribute vec4 current;\n\
attribute vec4 next;\n\
attribute vec4 color4;\n\
\n\
uniform float thickness;\n\
uniform mat4 buildingRotMatrix;\n\
uniform mat4 projectionMatrix;\n\
uniform mat4 modelViewMatrix;\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec2 viewport;\n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform vec4 oneColor4;\n\
uniform highp int colorType; // 0= oneColor, 1= attribColor, 2= texture.\n\
\n\
varying vec4 vColor;\n\
\n\
const float error = 0.001;\n\
\n\
// see https://weekly-geekly.github.io/articles/331164/index.html\n\
// see too https://github.com/ridiculousfish/wavefiz/blob/master/ts/polyline.ts#L306\n\
\n\
vec2 project(vec4 p){\n\
	return (0.5 * p.xyz / p.w + 0.5).xy * viewport;\n\
}\n\
\n\
bool isEqual(float value, float valueToCompare)\n\
{\n\
	if(value + error > valueToCompare && value - error < valueToCompare)\n\
	return true;\n\
	\n\
	return false;\n\
}\n\
\n\
vec4 getPointRelToEye(in vec4 point)\n\
{\n\
	vec4 rotatedCurrent = buildingRotMatrix * vec4(point.xyz, 1.0);\n\
	vec3 objPosHigh = buildingPosHIGH;\n\
	vec3 objPosLow = buildingPosLOW.xyz + rotatedCurrent.xyz;\n\
	vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
	vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
	return vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
}\n\
\n\
void main(){\n\
	// current, prev & next.***\n\
	vec4 vCurrent = getPointRelToEye(vec4(current.xyz, 1.0));\n\
	vec4 vPrev = getPointRelToEye(vec4(prev.xyz, 1.0));\n\
	vec4 vNext = getPointRelToEye(vec4(next.xyz, 1.0));\n\
	\n\
	float order_w = current.w;\n\
	//float order_w = float(order);\n\
	float sense = 1.0;\n\
	int orderInt = 0;\n\
	if(order_w > 0.0)\n\
	{\n\
		sense = -1.0;\n\
		if(order_w < 1.5)\n\
		{\n\
			orderInt = 1;\n\
		}\n\
		else{\n\
			orderInt = 2;\n\
		}\n\
	}\n\
	else\n\
	{\n\
		sense = 1.0;\n\
		if(order_w > -1.5)\n\
		{\n\
			orderInt = -1;\n\
		}\n\
		else{\n\
			orderInt = -2;\n\
		}\n\
	}\n\
	\n\
	float aspect = viewport.x / viewport.y;\n\
	vec2 aspectVec = vec2(aspect, 1.0);\n\
	\n\
	vec4 previousProjected = ModelViewProjectionMatrixRelToEye * vPrev;\n\
	vec4 currentProjected = ModelViewProjectionMatrixRelToEye * vCurrent;\n\
	vec4 nextProjected = ModelViewProjectionMatrixRelToEye * vNext;\n\
	\n\
	float projectedDepth = currentProjected.w;                \n\
	// Get 2D screen space with W divide and aspect correction\n\
	vec2 currentScreen = currentProjected.xy / currentProjected.w * aspectVec;\n\
	vec2 previousScreen = previousProjected.xy / previousProjected.w * aspectVec;\n\
	vec2 nextScreen = nextProjected.xy / nextProjected.w * aspectVec;\n\
					\n\
	// This helps us handle 90 degree turns correctly\n\
	vec2 tangentNext = normalize(nextScreen - currentScreen);\n\
	vec2 tangentPrev = normalize(currentScreen - previousScreen);\n\
	vec2 normal; \n\
	if(orderInt == 1 || orderInt == -1)\n\
	{\n\
		normal = vec2(-tangentPrev.y, tangentPrev.x);\n\
	}\n\
	else{\n\
		normal = vec2(-tangentNext.y, tangentNext.x);\n\
	}\n\
	normal *= thickness/2.0;\n\
	normal.x /= aspect;\n\
	float direction = (thickness*sense*projectedDepth)/1000.0;\n\
	// Offset our position along the normal\n\
	vec4 offset = vec4(normal * direction, 0.0, 1.0);\n\
	gl_Position = currentProjected + offset; \n\
\n\
	\n\
	if(colorType == 0)\n\
		vColor = oneColor4;\n\
	else if(colorType == 1)\n\
		vColor = color4; //vec4(color4.r+0.8, color4.g+0.8, color4.b+0.8, color4.a+0.8);\n\
	else\n\
		vColor = oneColor4;\n\
}\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
";
ShaderSource.TinTerrainFS = "#ifdef GL_ES\n\
    precision highp float;\n\
#endif\n\
\n\
//uniform sampler2D depthTex;\n\
//uniform sampler2D noiseTex;  \n\
uniform sampler2D diffuseTex;\n\
uniform sampler2D shadowMapTex;\n\
uniform sampler2D shadowMapTex2;\n\
uniform bool textureFlipYAxis;\n\
uniform bool bIsMakingDepth;\n\
varying vec3 vNormal;\n\
uniform mat4 projectionMatrix;\n\
uniform mat4 m;\n\
uniform vec2 noiseScale;\n\
uniform float near;\n\
uniform float far;            \n\
uniform float fov;\n\
uniform float aspectRatio;    \n\
uniform float screenWidth;    \n\
uniform float screenHeight;    \n\
uniform float shininessValue;\n\
uniform vec3 kernel[16];   \n\
\n\
uniform vec4 oneColor4;\n\
uniform highp int colorType; // 0= oneColor, 1= attribColor, 2= texture.\n\
\n\
varying vec2 vTexCoord;   \n\
varying vec3 vLightWeighting;\n\
\n\
varying vec3 diffuseColor;\n\
uniform vec3 specularColor;\n\
varying vec3 vertexPos;\n\
varying float depthValue;\n\
\n\
const int kernelSize = 16;  \n\
uniform float radius;      \n\
\n\
uniform float ambientReflectionCoef;\n\
uniform float diffuseReflectionCoef;  \n\
uniform float specularReflectionCoef; \n\
uniform float externalAlpha;\n\
uniform bool bApplyShadow;\n\
uniform float shadowMapWidth;    \n\
uniform float shadowMapHeight;\n\
varying vec3 v3Pos;\n\
\n\
varying vec4 vPosRelToLight; \n\
varying vec3 vLightDir; \n\
varying vec3 vNormalWC;\n\
varying float currSunIdx;\n\
\n\
const float equatorialRadius = 6378137.0;\n\
const float polarRadius = 6356752.3142;\n\
\n\
float unpackDepth(const in vec4 rgba_depth)\n\
{\n\
    const vec4 bit_shift = vec4(0.000000059605, 0.000015258789, 0.00390625, 1.0);\n\
    float depth = dot(rgba_depth, bit_shift);\n\
    return depth;\n\
} \n\
\n\
float UnpackDepth32( in vec4 pack )\n\
{\n\
    float depth = dot( pack, 1.0 / vec4(1.0, 256.0, 256.0*256.0, 16777216.0) );// 256.0*256.0*256.0 = 16777216.0\n\
    return depth * (16777216.0) / (16777216.0 - 1.0);\n\
}\n\
\n\
vec4 packDepth(const in float depth)\n\
{\n\
    const vec4 bit_shift = vec4(16777216.0, 65536.0, 256.0, 1.0);\n\
    const vec4 bit_mask  = vec4(0.0, 0.00390625, 0.00390625, 0.00390625); \n\
    //vec4 res = fract(depth * bit_shift); // Is not precise.\n\
	vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255); // Is better.\n\
    res -= res.xxyz * bit_mask;\n\
    return res;  \n\
}               \n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
    float hfar = 2.0 * tan(fov/2.0) * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
}\n\
\n\
//linear view space depth\n\
//float getDepth(vec2 coord)\n\
//{\n\
//    return unpackDepth(texture2D(depthTex, coord.xy));\n\
//}  \n\
\n\
float getDepthShadowMap(vec2 coord)\n\
{\n\
	// currSunIdx\n\
	if(currSunIdx > 0.0 && currSunIdx < 1.0)\n\
	{\n\
		return UnpackDepth32(texture2D(shadowMapTex, coord.xy));\n\
	}\n\
    else if(currSunIdx > 1.0 && currSunIdx < 2.0)\n\
	{\n\
		return UnpackDepth32(texture2D(shadowMapTex2, coord.xy));\n\
	}\n\
	else\n\
		return 1000.0;\n\
} \n\
\n\
void main()\n\
{           \n\
	if(bIsMakingDepth)\n\
	{\n\
		gl_FragColor = packDepth(-depthValue);\n\
	}\n\
	else{\n\
		float shadow_occlusion = 1.0;\n\
		if(bApplyShadow)\n\
		{\n\
			if(currSunIdx > 0.0)\n\
			{\n\
				vec3 fragCoord = gl_FragCoord.xyz;\n\
				vec3 fragWC;\n\
				\n\
				//float ligthAngle = dot(vLightDir, vNormalWC);\n\
				//if(ligthAngle > 0.0)\n\
				//{\n\
				//	// The angle between the light direction & face normal is less than 90 degree, so, the face is in shadow.***\n\
				//	shadow_occlusion = 0.5;\n\
				//}\n\
				//else\n\
				{\n\
\n\
					vec3 posRelToLight = vPosRelToLight.xyz / vPosRelToLight.w;\n\
					float tolerance = 0.9963;\n\
					//tolerance = 0.9962;\n\
					//tolerance = 1.0;\n\
					posRelToLight = posRelToLight * 0.5 + 0.5; // transform to [0,1] range\n\
					if(posRelToLight.x >= 0.0 && posRelToLight.x <= 1.0)\n\
					{\n\
						if(posRelToLight.y >= 0.0 && posRelToLight.y <= 1.0)\n\
						{\n\
							float depthRelToLight = getDepthShadowMap(posRelToLight.xy);\n\
							if(posRelToLight.z > depthRelToLight*tolerance )\n\
							{\n\
								shadow_occlusion = 0.5;\n\
							}\n\
						}\n\
					}\n\
				}\n\
			}\n\
		}\n\
	\n\
		vec4 textureColor;\n\
		if(colorType == 0)\n\
		{\n\
			textureColor = oneColor4;\n\
			\n\
			if(textureColor.w == 0.0)\n\
			{\n\
				discard;\n\
			}\n\
		}\n\
		else if(colorType == 2)\n\
		{\n\
			if(textureFlipYAxis)\n\
			{\n\
				textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, 1.0 - vTexCoord.t));\n\
			}\n\
			else{\n\
				textureColor = texture2D(diffuseTex, vec2(vTexCoord.s, vTexCoord.t));\n\
			}\n\
			\n\
			if(textureColor.w == 0.0)\n\
			{\n\
				discard;\n\
			}\n\
		}\n\
		else{\n\
			textureColor = oneColor4;\n\
		}\n\
		\n\
		//vec3 ambientColor = vec3(textureColor.x, textureColor.y, textureColor.z);\n\
		//gl_FragColor = vec4(textureColor.xyz, externalAlpha); \n\
		textureColor.w = externalAlpha;\n\
		vec4 fogColor = vec4(0.9, 0.9, 0.9, 1.0);\n\
		float fogParam = v3Pos.z/(far - 100000.0);\n\
		float fogParam2 = fogParam*fogParam;\n\
		float fogAmount = fogParam2*fogParam2;\n\
		vec4 finalColor = mix(textureColor, fogColor, fogAmount); \n\
		gl_FragColor = vec4(finalColor.xyz * shadow_occlusion, 1.0);\n\
		\n\
		//if(currSunIdx > 0.0 && currSunIdx < 1.0 && shadow_occlusion<0.9)gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n\
	}\n\
}";
ShaderSource.TinTerrainVS = "attribute vec3 position;\n\
attribute vec3 normal;\n\
attribute vec4 color4;\n\
attribute vec2 texCoord;\n\
\n\
uniform mat4 projectionMatrix;  \n\
uniform mat4 modelViewMatrix;\n\
uniform mat4 modelViewMatrixInv;\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform mat4 ModelViewProjectionMatrix;\n\
uniform mat4 normalMatrix4;\n\
uniform mat4 sunMatrix[2]; \n\
uniform mat4 buildingRotMatrix;  \n\
uniform vec3 buildingPosHIGH;\n\
uniform vec3 buildingPosLOW;\n\
uniform vec3 sunPosHIGH[2];\n\
uniform vec3 sunPosLOW[2];\n\
uniform vec3 sunDirWC;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
uniform vec3 aditionalPosition;\n\
uniform vec4 oneColor4;\n\
uniform bool bUse1Color;\n\
uniform bool hasTexture;\n\
uniform bool bIsMakingDepth;\n\
uniform float near;\n\
uniform float far;\n\
uniform bool bApplyShadow;\n\
uniform int sunIdx;\n\
\n\
varying vec3 vNormal;\n\
varying vec2 vTexCoord;   \n\
varying vec3 uAmbientColor;\n\
varying vec3 vLightWeighting;\n\
varying vec4 vcolor4;\n\
varying vec3 v3Pos;\n\
varying float depthValue;\n\
\n\
varying vec4 vPosRelToLight; \n\
varying vec3 vLightDir; \n\
varying vec3 vNormalWC;\n\
varying float currSunIdx;\n\
\n\
void main()\n\
{	\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + position.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
	\n\
	currSunIdx = -1.0; // initially no apply shadow.\n\
	if(bApplyShadow && !bIsMakingDepth)\n\
	{\n\
		vLightDir = sunDirWC;\n\
		vec3 rotatedNormal = vec3(0.0, 0.0, 1.0); // provisional.***\n\
		vNormalWC = rotatedNormal;\n\
					\n\
		// the sun lights count are 2.\n\
		vec3 currSunPosLOW;\n\
		vec3 currSunPosHIGH;\n\
		mat4 currSunMatrix;\n\
		if(sunIdx == 0)\n\
		{\n\
			currSunPosLOW = sunPosLOW[0];\n\
			currSunPosHIGH = sunPosHIGH[0];\n\
			currSunMatrix = sunMatrix[0];\n\
			currSunIdx = 0.5;\n\
		}\n\
		else if(sunIdx == 1)\n\
		{\n\
			currSunPosLOW = sunPosLOW[1];\n\
			currSunPosHIGH = sunPosHIGH[1];\n\
			currSunMatrix = sunMatrix[1];\n\
			currSunIdx = 1.5;\n\
		}\n\
		\n\
		// Calculate the vertex relative to light.***\n\
		vec3 highDifferenceSun = objPosHigh.xyz - currSunPosHIGH.xyz;\n\
		vec3 lowDifferenceSun = objPosLow.xyz - currSunPosLOW.xyz;\n\
		vec4 pos4Sun = vec4(highDifferenceSun.xyz + lowDifferenceSun.xyz, 1.0);\n\
		vec4 posRelToLightAux = currSunMatrix * pos4Sun;\n\
		\n\
		// now, check if \"posRelToLightAux\" is inside of the lightVolume (inside of the depthTexture of the light).\n\
		vec3 posRelToLightNDC = posRelToLightAux.xyz / posRelToLightAux.w;\n\
		vPosRelToLight = posRelToLightAux;\n\
	}\n\
\n\
	if(bIsMakingDepth)\n\
	{\n\
		depthValue = (modelViewMatrixRelToEye * pos4).z/far;\n\
	}\n\
	else\n\
	{\n\
		vTexCoord = texCoord;\n\
	}\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
	v3Pos = gl_Position.xyz;\n\
}";
ShaderSource.update_frag = "precision highp float;\n\
\n\
uniform sampler2D u_particles;\n\
uniform sampler2D u_wind;\n\
uniform vec2 u_wind_res;\n\
uniform vec2 u_wind_min;\n\
uniform vec2 u_wind_max;\n\
uniform vec3 u_geoCoordRadiansMax;\n\
uniform vec3 u_geoCoordRadiansMin;\n\
uniform float u_rand_seed;\n\
uniform float u_speed_factor;\n\
uniform float u_interpolation;\n\
uniform float u_drop_rate;\n\
uniform float u_drop_rate_bump;\n\
uniform bool u_flipTexCoordY_windMap;\n\
uniform vec4 u_visibleTilesRanges[16];\n\
uniform int u_visibleTilesRangesCount;\n\
\n\
varying vec2 v_tex_pos;\n\
\n\
// pseudo-random generator\n\
const vec3 rand_constants = vec3(12.9898, 78.233, 4375.85453);\n\
// https://community.khronos.org/t/random-values/75728\n\
float rand(const vec2 co) {\n\
    float t = dot(rand_constants.xy, co);\n\
    return fract(sin(t) * (rand_constants.z + t));\n\
}\n\
\n\
// wind speed lookup; use manual bilinear filtering based on 4 adjacent pixels for smooth interpolation\n\
vec2 lookup_wind(const vec2 uv) {\n\
    //return texture2D(u_wind, uv).rg; // lower-res hardware filtering\n\
	\n\
    vec2 px = 1.0 / u_wind_res;\n\
    vec2 vc = (floor(uv * u_wind_res)) * px;\n\
    vec2 f = fract(uv * u_wind_res);\n\
    vec2 tl = texture2D(u_wind, vc).rg;\n\
    vec2 tr = texture2D(u_wind, vc + vec2(px.x, 0)).rg;\n\
    vec2 bl = texture2D(u_wind, vc + vec2(0, px.y)).rg;\n\
    vec2 br = texture2D(u_wind, vc + px).rg;\n\
    return mix(mix(tl, tr, f.x), mix(bl, br, f.x), f.y);\n\
	\n\
}\n\
\n\
bool checkFrustumCulling(vec2 pos)\n\
{\n\
	for(int i=0; i<16; i++)\n\
	{\n\
		if(i >= u_visibleTilesRangesCount)\n\
		return false;\n\
		\n\
		vec4 range = u_visibleTilesRanges[i]; // range = minX(x), minY(y), maxX(z), maxY(w)\n\
\n\
		float minX = range.x;\n\
		float minY = range.y;\n\
		float maxX = range.z;\n\
		float maxY = range.w;\n\
		\n\
		if(pos.x > minX && pos.x < maxX)\n\
		{\n\
			if(pos.y > minY && pos.y < maxY)\n\
			{\n\
				return true;\n\
			}\n\
		}\n\
	}\n\
	return false;\n\
}\n\
\n\
void main() {\n\
    vec4 color = texture2D(u_particles, v_tex_pos);\n\
    vec2 pos = vec2(\n\
        color.r / 255.0 + color.b,\n\
        color.g / 255.0 + color.a); // decode particle position from pixel RGBA\n\
	vec2 windMapTexCoord = pos;\n\
	if(u_flipTexCoordY_windMap)\n\
	{\n\
		windMapTexCoord.y = 1.0 - windMapTexCoord.y;\n\
	}\n\
    vec2 velocity = mix(u_wind_min, u_wind_max, lookup_wind(windMapTexCoord));\n\
    float speed_t = length(velocity) / length(u_wind_max);\n\
\n\
    // take EPSG:4236 distortion into account for calculating where the particle moved\n\
	float minLat = u_geoCoordRadiansMin.y;\n\
	float maxLat = u_geoCoordRadiansMax.y;\n\
	float latRange = maxLat - minLat;\n\
	float distortion = cos((minLat + pos.y * latRange ));\n\
    vec2 offset = vec2(velocity.x / distortion, -velocity.y) * 0.0001 * u_speed_factor * u_interpolation;\n\
\n\
    // update particle position, wrapping around the date line\n\
    pos = fract(1.0 + pos + offset);\n\
\n\
\n\
    // drop rate is a chance a particle will restart at random position, to avoid degeneration\n\
	float drop = 0.0;\n\
\n\
	if(u_interpolation < 0.99) // 0.9\n\
	{\n\
		drop = 0.0;\n\
	}\n\
	else\n\
	{\n\
		// a random seed to use for the particle drop\n\
		vec2 seed = (pos + v_tex_pos) * u_rand_seed;\n\
		float drop_rate = u_drop_rate + speed_t * u_drop_rate_bump;\n\
		drop = step(1.0 - drop_rate, rand(seed));\n\
	}\n\
	/*\n\
	if(drop > 0.5) // 0.01\n\
	{\n\
		vec2 random_pos = vec2( rand(pos), rand(v_tex_pos) );\n\
		float randomValue = (u_rand_seed);\n\
		int index = int(floor(float(u_visibleTilesRangesCount+1)*(randomValue)));\n\
		for(int i=0; i<32; i++)\n\
		{\n\
			if(i >= u_visibleTilesRangesCount)\n\
			break;\n\
		\n\
			if(i == index)\n\
			{\n\
				vec4 posAux4 = u_visibleTilesRanges[i];\n\
				float width = (posAux4.z-posAux4.x);\n\
				float height = (posAux4.w-posAux4.y);\n\
				float scaledX = posAux4.x + random_pos.x*width;\n\
				float scaledY = posAux4.y + random_pos.y*height;\n\
				random_pos = vec2(scaledX, 1.0-scaledY);\n\
				pos = random_pos;\n\
				break;\n\
			}\n\
		}\n\
	}\n\
	*/\n\
	\n\
	\n\
	if(drop > 0.01)\n\
	{\n\
		vec2 random_pos = vec2( rand(pos), rand(v_tex_pos) );\n\
		pos = random_pos;\n\
	}\n\
	\n\
\n\
    // encode the new particle position back into RGBA\n\
    gl_FragColor = vec4(\n\
        fract(pos * 255.0),\n\
        floor(pos * 255.0) / 255.0);\n\
}";
ShaderSource.vol_fs = "#ifdef GL_ES\n\
precision highp float;\n\
#endif\n\
\n\
//---------------------------------------------------------\n\
// MACROS\n\
//---------------------------------------------------------\n\
\n\
#define EPS       0.0001\n\
#define PI        3.14159265\n\
#define HALFPI    1.57079633\n\
#define ROOTTHREE 1.73205081\n\
\n\
#define EQUALS(A,B) ( abs((A)-(B)) < EPS )\n\
#define EQUALSZERO(A) ( ((A)<EPS) && ((A)>-EPS) )\n\
\n\
\n\
//---------------------------------------------------------\n\
// CONSTANTS\n\
//---------------------------------------------------------\n\
\n\
// 32 48 64 96 128\n\
#define MAX_STEPS 64\n\
\n\
#define LIGHT_NUM 2\n\
//#define uTMK 20.0\n\
#define TM_MIN 0.05\n\
\n\
\n\
//---------------------------------------------------------\n\
// SHADER VARS\n\
//---------------------------------------------------------\n\
\n\
varying vec2 vUv;\n\
varying vec3 vPos0; // position in world coords\n\
varying vec3 vPos1; // position in object coords\n\
varying vec3 vPos1n; // normalized 0 to 1, for texture lookup\n\
\n\
uniform vec3 uOffset; // TESTDEBUG\n\
\n\
uniform vec3 uCamPos;\n\
\n\
uniform vec3 uLightP[LIGHT_NUM];  // point lights\n\
uniform vec3 uLightC[LIGHT_NUM];\n\
\n\
uniform vec3 uColor;      // color of volume\n\
uniform sampler2D uTex;   // 3D(2D) volume texture\n\
uniform vec3 uTexDim;     // dimensions of texture\n\
\n\
uniform float uTMK;\n\
\n\
float gStepSize;\n\
float gStepFactor;\n\
\n\
\n\
//---------------------------------------------------------\n\
// PROGRAM\n\
//---------------------------------------------------------\n\
\n\
// TODO: convert world to local volume space\n\
vec3 toLocal(vec3 p) {\n\
  return p + vec3(0.5);\n\
}\n\
\n\
float sampleVolTex(vec3 pos) {\n\
  pos = pos + uOffset; // TESTDEBUG\n\
  \n\
  // note: z is up in 3D tex coords, pos.z is tex.y, pos.y is zSlice\n\
  float zSlice = (1.0-pos.y)*(uTexDim.z-1.0);   // float value of slice number, slice 0th to 63rd\n\
  \n\
  // calc pixels from top of texture\n\
  float fromTopPixels =\n\
    floor(zSlice)*uTexDim.y +   // offset pix from top of tex, from upper slice  \n\
    pos.z*(uTexDim.y-1.0) +     // y pos in pixels, range 0th to 63rd pix\n\
    0.5;  // offset to center of cell\n\
    \n\
  // calc y tex coords of two slices\n\
  float y0 = min( (fromTopPixels)/(uTexDim.y*uTexDim.z), 1.0);\n\
  float y1 = min( (fromTopPixels+uTexDim.y)/(uTexDim.y*uTexDim.z), 1.0);\n\
    \n\
  // get (bi)linear interped texture reads at two slices\n\
  float z0 = texture2D(uTex, vec2(pos.x, y0)).g;\n\
  float z1 = texture2D(uTex, vec2(pos.x, y1)).g;\n\
  \n\
  // lerp them again (thus trilinear), using remaining fraction of zSlice\n\
  return mix(z0, z1, fract(zSlice));\n\
}\n\
\n\
// accumulate density by ray marching\n\
float getDensity(vec3 ro, vec3 rd) {\n\
  vec3 step = rd*gStepSize;\n\
  vec3 pos = ro;\n\
  \n\
  float density = 0.0;\n\
  \n\
  for (int i=0; i<MAX_STEPS; ++i) {\n\
    density += (1.0-density) * sampleVolTex(pos) * gStepFactor;\n\
    //density += sampleVolTex(pos);\n\
    \n\
    pos += step;\n\
    \n\
    if (density > 0.95 ||\n\
      pos.x > 1.0 || pos.x < 0.0 ||\n\
      pos.y > 1.0 || pos.y < 0.0 ||\n\
      pos.z > 1.0 || pos.z < 0.0)\n\
      break;\n\
  }\n\
  \n\
  return density;\n\
}\n\
\n\
// calc transmittance\n\
float getTransmittance(vec3 ro, vec3 rd) {\n\
  vec3 step = rd*gStepSize;\n\
  vec3 pos = ro;\n\
  \n\
  float tm = 1.0;\n\
  \n\
  for (int i=0; i<MAX_STEPS; ++i) {\n\
    tm *= exp( -uTMK*gStepSize*sampleVolTex(pos) );\n\
    \n\
    pos += step;\n\
    \n\
    if (tm < TM_MIN ||\n\
      pos.x > 1.0 || pos.x < 0.0 ||\n\
      pos.y > 1.0 || pos.y < 0.0 ||\n\
      pos.z > 1.0 || pos.z < 0.0)\n\
      break;\n\
  }\n\
  \n\
  return tm;\n\
}\n\
\n\
vec4 raymarchNoLight(vec3 ro, vec3 rd) {\n\
  vec3 step = rd*gStepSize;\n\
  vec3 pos = ro;\n\
  \n\
  vec3 col = vec3(0.0);\n\
  float tm = 1.0;\n\
  \n\
  for (int i=0; i<MAX_STEPS; ++i) {\n\
    float dtm = exp( -uTMK*gStepSize*sampleVolTex(pos) );\n\
    tm *= dtm;\n\
    \n\
    col += (1.0-dtm) * uColor * tm;\n\
    \n\
    pos += step;\n\
    \n\
    if (tm < TM_MIN ||\n\
      pos.x > 1.0 || pos.x < 0.0 ||\n\
      pos.y > 1.0 || pos.y < 0.0 ||\n\
      pos.z > 1.0 || pos.z < 0.0)\n\
      break;\n\
  }\n\
  \n\
  float alpha = 1.0-tm;\n\
  return vec4(col/alpha, alpha);\n\
}\n\
\n\
vec4 raymarchLight(vec3 ro, vec3 rd) {\n\
  vec3 step = rd*gStepSize;\n\
  vec3 pos = ro;\n\
  \n\
  \n\
  vec3 col = vec3(0.0);   // accumulated color\n\
  float tm = 1.0;         // accumulated transmittance\n\
  \n\
  for (int i=0; i<MAX_STEPS; ++i) {\n\
    // delta transmittance \n\
    float dtm = exp( -uTMK*gStepSize*sampleVolTex(pos) );\n\
    tm *= dtm;\n\
    \n\
    // get contribution per light\n\
    for (int k=0; k<LIGHT_NUM; ++k) {\n\
      vec3 ld = normalize( toLocal(uLightP[k])-pos );\n\
      float ltm = getTransmittance(pos,ld);\n\
      \n\
      col += (1.0-dtm) * uColor*uLightC[k] * tm * ltm;\n\
    }\n\
    \n\
    pos += step;\n\
    \n\
    if (tm < TM_MIN ||\n\
      pos.x > 1.0 || pos.x < 0.0 ||\n\
      pos.y > 1.0 || pos.y < 0.0 ||\n\
      pos.z > 1.0 || pos.z < 0.0)\n\
      break;\n\
  }\n\
  \n\
  float alpha = 1.0-tm;\n\
  return vec4(col/alpha, alpha);\n\
}\n\
\n\
void main() {\n\
  // in world coords, just for now\n\
  vec3 ro = vPos1n;\n\
  vec3 rd = normalize( ro - toLocal(uCamPos) );\n\
  //vec3 rd = normalize(ro-uCamPos);\n\
  \n\
  // step_size = root_three / max_steps ; to get through diagonal  \n\
  gStepSize = ROOTTHREE / float(MAX_STEPS);\n\
  gStepFactor = 32.0 * gStepSize;\n\
  \n\
  gl_FragColor = raymarchLight(ro, rd);\n\
  //gl_FragColor = vec4(uColor, getDensity(ro,rd));\n\
  //gl_FragColor = vec4(vec3(sampleVolTex(pos)), 1.0);\n\
  //gl_FragColor = vec4(vPos1n, 1.0);\n\
  //gl_FragColor = vec4(uLightP[0], 1.0);\n\
}";
ShaderSource.vol_vs = "attribute vec3 aPosition;\n\
\n\
uniform sampler2D diffuseTex;\n\
uniform mat4 projectionMatrix;  \n\
uniform mat4 modelViewMatrix;\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
\n\
varying vec3 vNormal;\n\
varying vec3 vPosObjectCoord;\n\
varying vec3 vPosCameraCoord;\n\
varying vec3 vPosWorldCoord;\n\
\n\
// Render a fullScreen quad (2 triangles).***\n\
void main()\n\
{\n\
	vec4 rotatedPos = buildingRotMatrix * vec4(position.xyz + aditionalPosition.xyz, 1.0);\n\
    vec3 objPosHigh = buildingPosHIGH;\n\
    vec3 objPosLow = buildingPosLOW.xyz + rotatedPos.xyz;\n\
    vec3 highDifference = objPosHigh.xyz - encodedCameraPositionMCHigh.xyz;\n\
    vec3 lowDifference = objPosLow.xyz - encodedCameraPositionMCLow.xyz;\n\
    vec4 pos4 = vec4(highDifference.xyz + lowDifference.xyz, 1.0);\n\
	\n\
    gl_Position = ModelViewProjectionMatrixRelToEye * pos4;\n\
}";
ShaderSource.wgs84_volumFS = "precision mediump float;\n\
\n\
#define M_PI 3.1415926535897932384626433832795\n\
\n\
uniform sampler2D volumeTex;\n\
uniform mat4 projectionMatrix;  \n\
uniform mat4 modelViewMatrix;\n\
uniform mat4 modelViewMatrixInv;\n\
uniform mat4 modelViewMatrixRelToEye; \n\
uniform mat4 ModelViewProjectionMatrixRelToEye;\n\
uniform vec3 encodedCameraPositionMCHigh;\n\
uniform vec3 encodedCameraPositionMCLow;\n\
\n\
uniform float screenWidth;    \n\
uniform float screenHeight;\n\
uniform float aspectRatio;\n\
uniform float far;\n\
uniform float fovyRad;\n\
uniform float tanHalfFovy;\n\
\n\
// volume tex definition.***\n\
uniform int texNumCols;\n\
uniform int texNumRows;\n\
uniform int texNumSlices;\n\
uniform int numSlicesPerStacks;\n\
uniform int slicesNumCols;\n\
uniform int slicesNumRows;\n\
uniform float maxLon;\n\
uniform float minLon;\n\
uniform float maxLat;\n\
uniform float minLat;\n\
uniform float maxAlt;\n\
uniform float minAlt;\n\
uniform vec4 cuttingPlanes[6];   \n\
uniform int cuttingPlanesCount;\n\
\n\
uniform float maxValue;\n\
uniform float minValue;\n\
\n\
vec3 getViewRay(vec2 tc)\n\
{\n\
	float hfar = 2.0 * tanHalfFovy * far;\n\
    float wfar = hfar * aspectRatio;    \n\
    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -far);    \n\
    return ray;                      \n\
} \n\
\n\
float squaredLength(vec3 point1, vec3 point2)\n\
{\n\
	float a = point1.x - point2.x;\n\
	float b = point1.y - point2.y;\n\
	float c = point1.z - point2.z;\n\
	\n\
	float sqDist = a*a + b*b + c*c;\n\
	return sqDist;\n\
}\n\
\n\
void intersectionLineSphere(float radius, vec3 rayPos, vec3 rayDir, out int intersectType, out vec3 nearIntersectPos, out vec3 farIntersectPos)\n\
{\n\
	// line: (x, y, z) = x1 + t(x2 - x1), y1 + t(y2 - y1), z1 + t(z2 - z1)\n\
	// sphere: (x - x3)^2 + (y - y3)^2 + (z - z3)^2 = r^2, where x3, y3, z3 is the center of the sphere.\n\
	\n\
	// line:\n\
	vec3 p1 = rayPos;\n\
	vec3 lineDir = rayDir;\n\
	float dist = 1000.0;// any value is ok.***\n\
	vec3 p2 = vec3(p1.x + lineDir.x * dist, p1.y + lineDir.y * dist, p1.z + lineDir.z * dist);\n\
	float x1 = p1.x;\n\
	float y1 = p1.y;\n\
	float z1 = p1.z;\n\
	float x2 = p2.x;\n\
	float y2 = p2.y;\n\
	float z2 = p2.z;\n\
\n\
	// sphere:\n\
	float x3 = 0.0;\n\
	float y3 = 0.0;\n\
	float z3 = 0.0;\n\
	float r = radius;\n\
	\n\
	// resolve:\n\
	float x21 = (x2-x1);\n\
	float y21 = (y2-y1);\n\
	float z21 = (z2-z1);\n\
	\n\
	float a = x21*x21 + y21*y21 + z21*z21;\n\
	\n\
	float x13 = (x1-x3);\n\
	float y13 = (y1-y3);\n\
	float z13 = (z1-z3);\n\
	\n\
	float b = 2.0*(x21 * x13 + y21 * y13 + z21 * z13);\n\
	\n\
	float c = x3*x3 + y3*y3 + z3*z3 + x1*x1 + y1*y1 + z1*z1 - 2.0*(x3*x1 + y3*y1+ z3*z1) - r*r;\n\
	\n\
	float discriminant = b*b - 4.0*a*c;\n\
	\n\
	if (discriminant < 0.0)\n\
	{\n\
		// no intersection.***\n\
		intersectType = 0;\n\
	}\n\
	else if (discriminant == 0.0)\n\
	{\n\
		// this is tangent.***\n\
		intersectType = 1;\n\
		\n\
		float t1 = (-b)/(2.0*a);\n\
		nearIntersectPos = vec3(x1 + (x2 - x1)*t1, y1 + (y2 - y1)*t1, z1 + (z2 - z1)*t1);\n\
	}\n\
	else\n\
	{\n\
		intersectType = 2;\n\
		\n\
		// find the nearest to p1.***\n\
		float sqrtDiscriminant = sqrt(discriminant);\n\
		float t1 = (-b + sqrtDiscriminant)/(2.0*a);\n\
		float t2 = (-b - sqrtDiscriminant)/(2.0*a);\n\
		\n\
		// solution 1.***\n\
		vec3 intersectPoint1 = vec3(x1 + (x2 - x1)*t1, y1 + (y2 - y1)*t1, z1 + (z2 - z1)*t1);\n\
		vec3 intersectPoint2 = vec3(x1 + (x2 - x1)*t2, y1 + (y2 - y1)*t2, z1 + (z2 - z1)*t2);\n\
		\n\
		float dist1 = squaredLength(p1,intersectPoint1);\n\
		float dist2 = squaredLength(p1,intersectPoint2);\n\
		\n\
		// nearIntersectPos, out vec3 farIntersectPos\n\
		if (dist1 < dist2)\n\
		{\n\
			nearIntersectPos = intersectPoint1;\n\
			farIntersectPos = intersectPoint2;\n\
		}\n\
		else\n\
		{\n\
			nearIntersectPos = intersectPoint2;\n\
			farIntersectPos = intersectPoint1;\n\
		}\n\
	}\n\
}\n\
\n\
float atan2(float y, float x) \n\
{\n\
	if(x > 0.0)\n\
	{\n\
		return atan(y/x);\n\
	}\n\
	else if(x < 0.0)\n\
	{\n\
		if(y >= 0.0)\n\
		{\n\
			return atan(y/x) + M_PI;\n\
		}\n\
		else{\n\
			return atan(y/x) - M_PI;\n\
		}\n\
	}\n\
	else if(x == 0.0)\n\
	{\n\
		if(y>0.0)\n\
		{\n\
			return M_PI/2.0;\n\
		}\n\
		else if(y<0.0)\n\
		{\n\
			return -M_PI/2.0;\n\
		}\n\
		else{\n\
			return 0.0; // return undefined.***\n\
		}\n\
	}\n\
}\n\
\n\
void cartesianToGeographicWgs84(vec3 point, out vec3 result) \n\
{\n\
	// From WebWorldWind.***\n\
	// According to H. Vermeille, An analytical method to transform geocentric into geodetic coordinates\n\
	// http://www.springerlink.com/content/3t6837t27t351227/fulltext.pdf\n\
	\n\
	float firstEccentricitySquared = 6.69437999014E-3;\n\
	float equatorialRadius = 6378137.0;\n\
\n\
	// wwwind coord type.***\n\
	// X = point.z;\n\
	// Y = point.x;\n\
	// Z = point.y;\n\
\n\
	// magoWorld coord type.***\n\
	float X = point.x;\n\
	float Y = point.y;\n\
	float Z = point.z;\n\
	float XXpYY = X * X + Y * Y;\n\
	float sqrtXXpYY = sqrt(XXpYY);\n\
	float a = equatorialRadius;\n\
	float ra2 = 1.0 / (a * a);\n\
	float e2 = firstEccentricitySquared;\n\
	float e4 = e2 * e2;\n\
	float p = XXpYY * ra2;\n\
	float q = Z * Z * (1.0 - e2) * ra2;\n\
	float r = (p + q - e4) / 6.0;\n\
	float h;\n\
	float phi;\n\
	float u;\n\
	float evoluteBorderTest = 8.0 * r * r * r + e4 * p * q;\n\
	float rad1;\n\
	float rad2;\n\
	float rad3;\n\
	float atanAux;\n\
	float v;\n\
	float w;\n\
	float k;\n\
	float D;\n\
	float sqrtDDpZZ;\n\
	float e;\n\
	float lambda;\n\
	float s2;\n\
	float cbrtFac = 1.0/3.0;\n\
\n\
	if (evoluteBorderTest > 0.0 || q != 0.0) \n\
	{\n\
		if (evoluteBorderTest > 0.0) \n\
		{\n\
			// Step 2: general case\n\
			rad1 = sqrt(evoluteBorderTest);\n\
			rad2 = sqrt(e4 * p * q);\n\
\n\
			// 10*e2 is my arbitrary decision of what Vermeille means by near... the cusps of the evolute.\n\
			if (evoluteBorderTest > 10.0 * e2) \n\
			{\n\
				rad3 = pow((rad1 + rad2) * (rad1 + rad2), cbrtFac);\n\
				u = r + 0.5 * rad3 + 2.0 * r * r / rad3;\n\
			}\n\
			else \n\
			{\n\
				u = r + 0.5 * pow((rad1 + rad2) * (rad1 + rad2), cbrtFac)\n\
					+ 0.5 * pow((rad1 - rad2) * (rad1 - rad2), cbrtFac);\n\
			}\n\
		}\n\
		else \n\
		{\n\
			// Step 3: near evolute\n\
			rad1 = sqrt(-evoluteBorderTest);\n\
			rad2 = sqrt(-8.0 * r * r * r);\n\
			rad3 = sqrt(e4 * p * q);\n\
			atanAux = 2.0 * atan2(rad3, rad1 + rad2) / 3.0;\n\
\n\
			u = -4.0 * r * sin(atanAux) * cos(M_PI / 6.0 + atanAux);\n\
		}\n\
\n\
		v = sqrt(u * u + e4 * q);\n\
		w = e2 * (u + v - q) / (2.0 * v);\n\
		k = (u + v) / (sqrt(w * w + u + v) + w);\n\
		D = k * sqrtXXpYY / (k + e2);\n\
		sqrtDDpZZ = sqrt(D * D + Z * Z);\n\
\n\
		h = (k + e2 - 1.0) * sqrtDDpZZ / k;\n\
		phi = 2.0 * atan2(Z, sqrtDDpZZ + D);\n\
	}\n\
	else \n\
	{\n\
		// Step 4: singular disk\n\
		rad1 = sqrt(1.0 - e2);\n\
		rad2 = sqrt(e2 - p);\n\
		e = sqrt(e2);\n\
\n\
		h = -a * rad1 * rad2 / e;\n\
		phi = rad2 / (e * rad2 + rad1 * sqrt(p));\n\
	}\n\
\n\
	// Compute lambda\n\
	s2 = sqrt(2.0);\n\
	if ((s2 - 1.0) * Y < sqrtXXpYY + X) \n\
	{\n\
		// case 1 - -135deg < lambda < 135deg\n\
		lambda = 2.0 * atan2(Y, sqrtXXpYY + X);\n\
	}\n\
	else if (sqrtXXpYY + Y < (s2 + 1.0) * X) \n\
	{\n\
		// case 2 - -225deg < lambda < 45deg\n\
		lambda = -M_PI * 0.5 + 2.0 * atan2(X, sqrtXXpYY - Y);\n\
	}\n\
	else \n\
	{\n\
		// if (sqrtXXpYY-Y<(s2=1)*X) {  // is the test, if needed, but it's not\n\
		// case 3: - -45deg < lambda < 225deg\n\
		lambda = M_PI * 0.5 - 2.0 * atan2(X, sqrtXXpYY + Y);\n\
	}\n\
\n\
	float factor = 180.0 / M_PI;\n\
	result = vec3(factor * lambda, factor * phi, h); // (longitude, latitude, altitude).***\n\
}\n\
\n\
bool isPointRearCamera(vec3 point, vec3 camPos, vec3 camDir)\n\
{\n\
	bool isRear = false;\n\
	float lambdaX = 10.0;\n\
	float lambdaY = 10.0;\n\
	float lambdaZ = 10.0;\n\
	if(abs(camDir.x) > 0.0000001)\n\
	{\n\
		float lambdaX = (point.x - camPos.x)/camDir.x;\n\
	}\n\
	else if(abs(camDir.y) > 0.0000001)\n\
	{\n\
		float lambdaY = (point.y - camPos.y)/camDir.y;\n\
	}\n\
	else if(abs(camDir.z) > 0.0000001)\n\
	{\n\
		float lambdaZ = (point.z - camPos.z)/camDir.z;\n\
	}\n\
	\n\
	if(lambdaZ < 0.0 || lambdaY < 0.0 || lambdaX < 0.0)\n\
			isRear = true;\n\
		else\n\
			isRear = false;\n\
	return isRear;\n\
}\n\
\n\
float distPointToPlane(vec3 point, vec4 plane)\n\
{\n\
	return (point.x*plane.x + point.y*plane.y + point.z*plane.z + plane.w);\n\
}\n\
\n\
bool getValue(vec3 geoLoc, out vec4 value)\n\
{\n\
	// geoLoc = (longitude, latitude, altitude).***\n\
	float lon = geoLoc.x;\n\
	float lat = geoLoc.y;\n\
	float alt = geoLoc.z;\n\
	\n\
	// 1rst, check if geoLoc intersects the volume.***\n\
	// Note: minLon, maxLon, minLat, maxLat, minAlt & maxAlt are uniforms.***\n\
	if(lon < minLon || lon > maxLon)\n\
		return false;\n\
	else if(lat < minLat || lat > maxLat)\n\
		return false;\n\
	else if(alt < minAlt || alt > maxAlt)\n\
		return false;\n\
		\n\
	float lonRange = maxLon - minLon;\n\
	float latRange = maxLat - minLat;\n\
	float altRange = maxAlt - minAlt;\n\
	float col = (lon - minLon)/lonRange * float(slicesNumCols); \n\
	float row = (lat - minLat)/latRange * float(slicesNumRows); \n\
	float slice = (alt - minAlt)/altRange * float(texNumSlices); // slice if texture has only one stack.***\n\
	float sliceDown = floor(slice);\n\
	float sliceUp = ceil(slice);\n\
	float sliceDownDist = slice - sliceDown;\n\
	//slice = 18.0; // test. force slice to nearest to ground.***\n\
	\n\
	float stackDown = floor(sliceDown/float(numSlicesPerStacks));\n\
	float realSliceDown = sliceDown - stackDown * float(numSlicesPerStacks);\n\
	float tx = stackDown * float(slicesNumCols) + col;\n\
	float ty = realSliceDown * float(slicesNumRows) + row;\n\
	vec2 texCoord = vec2(tx/float(texNumCols), ty/float(texNumRows));\n\
	vec4 valueDown = texture2D(volumeTex, texCoord);\n\
	\n\
	if(sliceDown < float(texNumSlices-1))\n\
	{\n\
		float stackUp = floor(sliceUp/float(numSlicesPerStacks));\n\
		float realSliceUp = sliceUp - stackUp * float(numSlicesPerStacks);\n\
		float tx2 = stackUp * float(slicesNumCols) + col;\n\
		float ty2 = realSliceUp * float(slicesNumRows) + row;\n\
		vec2 texCoord2 = vec2(tx2/float(texNumCols), ty2/float(texNumRows));\n\
		vec4 valueUp = texture2D(volumeTex, texCoord2);\n\
		value = valueDown*(1.0-sliceDownDist)+valueUp*(sliceDownDist);\n\
	}\n\
	else{\n\
		value = valueDown;\n\
	}\n\
	//if((value.r * (maxValue - minValue)) > maxValue * 0.3)\n\
	//	return true;\n\
	//else return false;\n\
	return true;\n\
}\n\
\n\
void main() {\n\
	vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight);\n\
	float linearDepth = 1.0; // the quad is 1m of dist of the camera.***          \n\
    vec3 rayCamCoord = getViewRay(screenPos) * linearDepth;  \n\
	rayCamCoord = normalize(rayCamCoord);\n\
	\n\
	vec3 camTarget = rayCamCoord * 10000.0;\n\
	vec4 camPosWorld = vec4(encodedCameraPositionMCHigh + encodedCameraPositionMCLow, 1.0);\n\
	vec4 camTargetWorld = modelViewMatrixInv * vec4(camTarget.xyz, 1.0);\n\
	vec3 camDirWorld = camTargetWorld.xyz - camPosWorld.xyz;\n\
	camDirWorld = normalize(camDirWorld);\n\
\n\
	// now, must find sampling points.***\n\
	int intersectType = 0;\n\
	vec3 nearP;\n\
	vec3 farP;\n\
	float radius = 6378137.0 + maxAlt; // equatorial radius.***\n\
	//radius = 6250000.0 + maxAlt; // test radius.***\n\
	\n\
	intersectionLineSphere(radius, camPosWorld.xyz, camDirWorld, intersectType, nearP, farP);\n\
	\n\
	if(intersectType == 0)\n\
	{\n\
		discard;\n\
	}\n\
		\n\
	if(intersectType == 1)\n\
	{\n\
		// provisionally discard.***\n\
		discard;	\n\
	}\n\
	\n\
	// check if nearP is rear of the camera.***\n\
	if(isPointRearCamera(nearP, camPosWorld.xyz, camDirWorld.xyz))\n\
	{\n\
		nearP = vec3(camPosWorld.xyz);\n\
	}\n\
	float dist = distance(nearP, farP);\n\
	float testDist = dist;\n\
	if(dist > 1500000.0)\n\
		testDist = 1500000.0;\n\
	\n\
	// now calculate the geographicCoords of 2 points.***\n\
	// now, depending the dist(nearP, endPoint), determine numSmples.***\n\
	// provisionally take 16 samples.***\n\
	float numSamples = 512.0;\n\
	vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n\
	float alpha = 0.8/numSamples;\n\
	float tempRange = maxValue - minValue;\n\
	vec4 value;\n\
	float totalValue = 0.0;\n\
	int sampledsCount = 0;\n\
	int intAux = 0;\n\
	float increDist = testDist / numSamples;\n\
	int c = 0;\n\
	bool isPointRearPlane = true;\n\
	for(int i=0; i<512; i++)\n\
	{\n\
		vec3 currGeoLoc;\n\
		vec3 currPosWorld = vec3(nearP.x + camDirWorld.x * increDist*float(c), nearP.y + camDirWorld.y * increDist*float(c), nearP.z + camDirWorld.z * increDist*float(c));\n\
		// Check if the currPosWorld is in front or rear of planes (if exist planes).***\n\
		int planesCounter = 0;\n\
		for(int j=0; j<6; j++)\n\
		{\n\
			if(planesCounter == cuttingPlanesCount)\n\
				break;\n\
			\n\
			vec4 plane = cuttingPlanes[j];\n\
			float dist = distPointToPlane(currPosWorld, plane);\n\
			if(dist > 0.0)\n\
			{\n\
				isPointRearPlane = false;\n\
				break;\n\
			}\n\
			else{\n\
				isPointRearPlane = true;\n\
			}\n\
			planesCounter++;\n\
		}\n\
		\n\
		\n\
		if(isPointRearPlane)\n\
		{\n\
			cartesianToGeographicWgs84(currPosWorld, currGeoLoc);\n\
			if(getValue(currGeoLoc, value))\n\
			{\n\
				float realValue = value.r * tempRange + minValue*255.0;\n\
				totalValue += (value.r);\n\
				sampledsCount += 1;\n\
			}\n\
		}\n\
		if(sampledsCount >= 1)\n\
		{\n\
			break;\n\
		}\n\
		c++;\n\
	}\n\
	if(sampledsCount == 0)\n\
	{\n\
		discard;\n\
	}\n\
	float fValue = totalValue/numSamples;\n\
	fValue = totalValue;\n\
	if(fValue > 1.0)\n\
	{\n\
		gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n\
		return;\n\
	}\n\
	float b = 1.0 - fValue;\n\
	float g;\n\
	if(fValue > 0.5)\n\
	{\n\
		g = 2.0-2.0*fValue;\n\
	}\n\
	else{\n\
		g = 2.0*fValue;\n\
	}\n\
	float r = fValue;\n\
	color += vec4(r,g,b,0.8);\n\
	gl_FragColor = color;\n\
}";
ShaderSource.wgs84_volumVS = "precision mediump float;\n\
\n\
attribute vec3 position;\n\
uniform mat4 projectionMatrix;\n\
\n\
void main()\n\
{	\n\
	vec4 pos = projectionMatrix * vec4(position.xyz, 1.0);\n\
    gl_Position = pos;\n\
}";

'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Uniform1fDataPair
 * @param gl 변수
 */
var Uniform1fDataPair = function(gl, uniformName) 
{
	if (!(this instanceof Uniform1fDataPair)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl = gl;
	this.name = uniformName;
	this.uniformLocation;
	this.floatValue; 
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
Uniform1fDataPair.prototype.bindUniform = function() 
{
	this.gl.uniform1f(this.uniformLocation, this.floatValue[0]);
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class Uniform1iDataPair
 * @param gl 변수
 */
var Uniform1iDataPair = function(gl, uniformName) 
{
	if (!(this instanceof Uniform1iDataPair)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl = gl;
	this.name = uniformName;
	this.uniformLocation;
	this.intValue; 
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
Uniform1iDataPair.prototype.bindUniform = function() 
{
	this.gl.uniform1i(this.uniformLocation, this.intValue);
};
'use strict';


/**
 * 어떤 일을 하고 있습니까?
 * @class UniformMatrix4fvDataPair
 * @param gl 변수
 */
var UniformMatrix4fvDataPair = function(gl, uniformName) 
{
	if (!(this instanceof UniformMatrix4fvDataPair)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl = gl;
	this.name = uniformName;
	this.uniformLocation;
	this.matrix4fv; 
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
UniformMatrix4fvDataPair.prototype.bindUniform = function() 
{
	this.gl.uniformMatrix4fv(this.uniformLocation, false, this.matrix4fv);
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class UniformVec2fvDataPair
 * @param gl 변수
 */
var UniformVec2fvDataPair = function(gl, uniformName) 
{
	if (!(this instanceof UniformVec2fvDataPair)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl = gl;
	this.name = uniformName;
	this.uniformLocation;
	this.vec2fv; 
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
UniformVec2fvDataPair.prototype.bindUniform = function() 
{
	this.gl.uniform2fv(this.uniformLocation, this.vec2fv);
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class UniformVec3fvDataPair
 * @param gl 변수
 */
var UniformVec3fvDataPair = function(gl, uniformName) 
{
	if (!(this instanceof UniformVec3fvDataPair)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl = gl;
	this.name = uniformName;
	this.uniformLocation;
	this.vec3fv; 
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
UniformVec3fvDataPair.prototype.bindUniform = function() 
{
	this.gl.uniform3fv(this.uniformLocation, this.vec3fv);
};
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class UniformVec4fvDataPair
 * @param gl 변수
 */
var UniformVec4fvDataPair = function(gl, uniformName) 
{
	if (!(this instanceof UniformVec4fvDataPair)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.gl = gl;
	this.name = uniformName;
	this.uniformLocation;
	this.vec4fv; 
};

/**
 * 어떤 일을 하고 있습니까?
 * @param gl 변수
 */
UniformVec4fvDataPair.prototype.bindUniform = function() 
{
	this.gl.uniform4fv(this.uniformLocation, this.vec4fv);
};

'use strict';

/**
 * Network.
 * IndoorGML의 네트워크를 파싱하고 그리는 데 사용합니다.
 * @alias Network
 * @class Network
 */
var Network = function(owner) 
{
	if (!(this instanceof Network)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.nodeOwner;
	if (owner)
	{ this.nodeOwner = owner; }
	
	this.id; // network id.
	this.nodesArray;
	this.edgesArray;
	this.spacesArray;
	
	this.attributes;
	this.edgesVboKeysContainer; // to draw edges with an unique vbo.
	this.nodesVboKeysContainer; // to draw nodes with an unique vbo.
	
	this.renderSpaces = true;
	this.spacesAlpha = 0.2;
};

/**
 * 
 */
Network.prototype.newNode = function()
{
	if (this.nodesArray === undefined)
	{ this.nodesArray = []; }
	
	var networkNode = new NetworkNode(this);
	this.nodesArray.push(networkNode);
	return networkNode;
};

/**
 * 
 */
Network.prototype.newEdge = function()
{
	if (this.edgesArray === undefined)
	{ this.edgesArray = []; }
	
	var networkEdge = new NetworkEdge(this);
	this.edgesArray.push(networkEdge);
	return networkEdge;
};

/**
 * 
 */
Network.prototype.newSpace = function()
{
	if (this.spacesArray === undefined)
	{ this.spacesArray = []; }
	
	var networkSpace = new NetworkSpace(this);
	this.spacesArray.push(networkSpace);
	return networkSpace;
};

/**
 * 
 */
Network.prototype.test__makeVbos = function(magoManager)
{
	// Here makes meshes and vbos.
	// For edges, make an unique vbo for faster rendering.
	var edgesCount = 0;
	if (this.edgesArray)
	{ edgesCount = this.edgesArray.length; }
	
	var pointsArray = [];
	
	for (var i=0; i<edgesCount; i++)
	{
		var edge = this.edgesArray[i];
		var vtxSegment = edge.vtxSegment;
		var point1 = vtxSegment.startVertex.point3d;
		var point2 = vtxSegment.endVertex.point3d;
		pointsArray.push(point1.x);
		pointsArray.push(point1.y);
		pointsArray.push(point1.z);
		
		pointsArray.push(point2.x);
		pointsArray.push(point2.y);
		pointsArray.push(point2.z);
	}
	
	if (this.edgesVboKeysContainer === undefined)
	{
		this.edgesVboKeysContainer = new VBOVertexIdxCacheKeysContainer();
	}
	
	var vboKey = this.edgesVboKeysContainer.newVBOVertexIdxCacheKey();
	
	var vboMemManager = magoManager.vboMemoryManager;
	var pointsCount = edgesCount * 2;
	var posByteSize = pointsCount * 3;
	var classifiedPosByteSize = vboMemManager.getClassifiedBufferSize(posByteSize);
	vboKey.posVboDataArray = new Float32Array(classifiedPosByteSize);
	vboKey.posVboDataArray.set(pointsArray);
	vboKey.posArrayByteSize = pointsArray.length;
	vboKey.segmentsCount = edgesCount;
	
};

/**
 * Make triangle from IndoorGML data
 * @param magoManager
 * @param gmlDataContainer 
 * 
 */
Network.prototype.parseTopologyData = function(magoManager, gmlDataContainer) 
{
	// gmlDataContainer.cellSpaceMembers
	// gmlDataContainer.edges
	// gmlDataContainer.nodes
	// cityGML Lower point (78.02094, -82.801873, 18).
	// cityGML Upper point (152.17466, 19.03087, 39).
	// cityGML Center point {x=115.09780549999999 y=-31.885501999999999 z=28.500000000000000 ...}
	
	var bbox = new BoundingBox();
	bbox.minX = gmlDataContainer.min_X;
	bbox.minY = gmlDataContainer.min_Y;
	bbox.minZ = gmlDataContainer.min_Z;
	bbox.maxX = gmlDataContainer.max_X;
	bbox.maxY = gmlDataContainer.max_Y;
	bbox.maxZ = gmlDataContainer.max_Z;
	
	//bbox.maxX = 56.19070816040039;
	//bbox.maxY = 71.51078033447266;
	//bbox.maxZ = 10.5;
	//bbox.minX = -379.18280029296875;
	//bbox.minY = -142.4878387451172;
	//bbox.minZ = -46.5;
	
	var offsetVector = new Point3D();
	var zOffset = 0.1;
	offsetVector.set(-115.0978055, 31.885502, -28.5); // cityGML ORIGINAL Center point inversed.
	
	var nodesMap = {};
	var nodesCount = gmlDataContainer.nodes.length;
	for (var i=0; i<nodesCount; i++)
	{
		var node = gmlDataContainer.nodes[i];
		var networkNode = this.newNode();
		networkNode.id = "#" + node.id;
		
		networkNode.position = new Point3D(node.coordinates[0], node.coordinates[1], node.coordinates[2]);
		networkNode.position.addPoint(offsetVector); // rest bbox centerPoint.
		networkNode.position.add(0.0, 0.0, zOffset); // aditional pos.
		networkNode.box = new Box(0.6, 0.6, 0.6);
		
		nodesMap[networkNode.id] = networkNode;
	}
	
	
	var cellSpaceMap = {};
	var cellSpacesCount = gmlDataContainer.cellSpaceMembers.length;
	for (var i=0; i<cellSpacesCount; i++)
	{
		var cellSpace = gmlDataContainer.cellSpaceMembers[i];
		var id = cellSpace.href;
		var networkSpace = this.newSpace();
		var mesh = new Mesh();
		networkSpace.mesh = mesh; // assign mesh to networkSpace provisionally.
		var vertexList = mesh.getVertexList();
		
		var surfacesMembersCount = cellSpace.surfaceMember.length;
		for (var j=0; j<surfacesMembersCount; j++)
		{
			var surface = mesh.newSurface();
			var face = surface.newFace();
			
			var coordinates = cellSpace.surfaceMember[j].coordinates;
			var coordinatedCount = coordinates.length;
			var pointsCount = coordinatedCount/3;
			
			for (var k=0; k<pointsCount; k++)
			{
				var x = coordinates[k * 3];
				var y = coordinates[k * 3 + 1];
				var z = coordinates[k * 3 + 2];
				
				var vertex = vertexList.newVertex();
				vertex.setPosition(x, y, z);
				vertex.point3d.addPoint(offsetVector); // rest bbox centerPoint.
				face.addVertex(vertex);
				
			}
			face.solveUroborus(); // Check & solve if the last point is coincident with the 1rst point.
			face.calculateVerticesNormals();
		}
		
		cellSpaceMap[cellSpace.href] = cellSpace;
	}
	
	var edgesCount = gmlDataContainer.edges.length;
	for (var i=0; i<edgesCount; i++)
	{
		var edge = gmlDataContainer.edges[i];
		var networkEdge = this.newEdge();
		
		var point1 = edge.stateMembers[0].coordinates;
		var point2 = edge.stateMembers[1].coordinates;
		var vertex1 = new Vertex();
		var vertex2 = new Vertex();
		vertex1.setPosition(point1[0], point1[1], point1[2]);
		vertex2.setPosition(point2[0], point2[1], point2[2]);
		vertex1.point3d.addPoint(offsetVector); // rest bbox centerPoint.
		vertex1.point3d.add(0.0, 0.0, zOffset); // aditional pos.
		vertex2.point3d.addPoint(offsetVector); // rest bbox centerPoint.
		vertex2.point3d.add(0.0, 0.0, zOffset); // aditional pos.
		var vtxSegment = new VtxSegment(vertex1, vertex2);
		networkEdge.vtxSegment = vtxSegment; // assign vtxSegment to networkEdge provisionally.
		
		var connect_1_id = edge.connects[0];
		var connect_2_id = edge.connects[1];
		
		networkEdge.strNodeId = connect_1_id;
		networkEdge.endNodeId = connect_2_id;
	}
	
	this.test__makeVbos(magoManager);
};

/**
 * 
 */
Network.prototype.renderColorCoding = function(magoManager, shader, renderType)
{
	// Provisional function.
	// render nodes & edges.
	var selectionColor = magoManager.selectionColor;
	//selectionColor.init(); 
	
	// Check if exist selectionFamilies.
	var selFamilyNameNodes = "networkNodes";
	var selManager = magoManager.selectionManager;
	var selCandidateNodes = selManager.getSelectionCandidatesFamily(selFamilyNameNodes);
	if (selCandidateNodes === undefined)
	{
		selCandidateNodes = selManager.newCandidatesFamily(selFamilyNameNodes);
	}
	
	var selFamilyNameEdges = "networkEdges";
	var selManager = magoManager.selectionManager;
	var selCandidateEdges = selManager.getSelectionCandidatesFamily(selFamilyNameEdges);
	if (selCandidateEdges === undefined)
	{
		selCandidateEdges = selManager.newCandidatesFamily(selFamilyNameEdges);
	}
	
	var vboMemManager = magoManager.vboMemoryManager;
	var gl = magoManager.sceneState.gl;
	var vboKey;
	
	shader.disableVertexAttribArray(shader.texCoord2_loc); 
	shader.enableVertexAttribArray(shader.normal3_loc); 
	gl.uniform1i(shader.hasTexture_loc, false); //.
	gl.uniform4fv(shader.oneColor4_loc, [0.8, 0.8, 0.8, 1.0]);
	
	if (!shader.last_isAditionalMovedZero)
	{
		gl.uniform1i(shader.hasAditionalMov_loc, false);
		gl.uniform3fv(shader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.
		shader.last_isAditionalMovedZero = true;
	}
	
	// Nodes.**
	var nodesCount = 0;
	if (this.nodesArray)
	{ nodesCount = this.nodesArray.length; }
	
	if (nodesCount > 0 )//&& !magoManager.isCameraMoving)
	{
		var refMatrixType = 1; // translation-type.
		gl.uniform1i(shader.refMatrixType_loc, refMatrixType);
		//gl.uniform4fv(shader.oneColor4_loc, [0.3, 0.3, 0.9, 1.0]);
		var nodeMaster = this.nodesArray[0]; // render all with an unique box.
		for (var i=0; i<nodesCount; i++)
		{
			var node = this.nodesArray[i];
			
			// nodes has a position, so render a point or a box.
			gl.uniform3fv(shader.refTranslationVec_loc, [node.position.x, node.position.y, node.position.z]); 
			
			var selColor4 = selectionColor.getAvailableColor(undefined); // new.
			var idxKey = selectionColor.decodeColor3(selColor4.r, selColor4.g, selColor4.b);
			selManager.setCandidateCustom(idxKey, selFamilyNameNodes, node);
			gl.uniform4fv(shader.oneColor4_loc, [selColor4.r/255.0, selColor4.g/255.0, selColor4.b/255.0, 1.0]);

			nodeMaster.box.render(magoManager, shader, renderType);
			
		}
	}
	
	// Edges.**
	// Render with a unique vbo.
	if (this.edgesVboKeysContainer)
	{
		var vboKey = this.edgesVboKeysContainer.vboCacheKeysArray[0];
		if (vboKey.isReadyPositions(gl, vboMemManager))
		{ 
			shader.disableVertexAttribArray(shader.texCoord2_loc); 
			shader.disableVertexAttribArray(shader.normal3_loc); 
			refMatrixType = 0;
			gl.uniform1i(shader.refMatrixType_loc, refMatrixType);
			
			// Positions.
			if (vboKey.meshVertexCacheKey !== shader.lastVboKeyBindedMap[shader.position3_loc])
			{
				gl.bindBuffer(gl.ARRAY_BUFFER, vboKey.meshVertexCacheKey);
				gl.vertexAttribPointer(shader.position3_loc, 3, gl.FLOAT, false, 0, 0);
				shader.lastVboKeyBindedMap[shader.position3_loc] = vboKey.meshVertexCacheKey;
			}
				
			var edgesCount = this.edgesArray.length;
			for (var i=0; i<edgesCount; i++)
			{
				var edge = this.edgesArray[i];
				var selColor4 = selectionColor.getAvailableColor(undefined); // new.
				var idxKey = selectionColor.decodeColor3(selColor4.r, selColor4.g, selColor4.b);
				selManager.setCandidateCustom(idxKey, selFamilyNameEdges, edge);
				gl.uniform4fv(shader.oneColor4_loc, [selColor4.r/255.0, selColor4.g/255.0, selColor4.b/255.0, 1.0]);
				gl.drawArrays(gl.LINES, i*2, 2);
			}
		}
	}
	
};

/**
 * 
 */
Network.prototype.render = function(magoManager, shader, renderType)
{
	if (renderType === 2)
	{
		this.renderColorCoding(magoManager, shader, renderType);
		return;
	}
	
	// Check if ready smallBox and bigBox.
	var selectionColor = magoManager.selectionColor;
	selectionColor.init(); 
	
	// Check if exist selectionFamilies.
	var selFamilyNameNodes = "networkNodes";
	var selManager = magoManager.selectionManager;
	var selCandidateNodes = selManager.getSelectionCandidatesFamily(selFamilyNameNodes);
	if (selCandidateNodes === undefined)
	{
		selCandidateNodes = selManager.newCandidatesFamily(selFamilyNameNodes);
	}
	
	var selFamilyNameEdges = "networkEdges";
	var selManager = magoManager.selectionManager;
	var selCandidateEdges = selManager.getSelectionCandidatesFamily(selFamilyNameEdges);
	if (selCandidateEdges === undefined)
	{
		selCandidateEdges = selManager.newCandidatesFamily(selFamilyNameEdges);
	}
	
	// Provisional function.
	// render nodes & edges.
	var vboMemManager = magoManager.vboMemoryManager;
	var gl = magoManager.sceneState.gl;
	var vboKey;
	
	shader.disableVertexAttribArray(shader.texCoord2_loc); 
	shader.enableVertexAttribArray(shader.normal3_loc); 
	
	gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
	gl.uniform4fv(shader.oneColor4_loc, [0.8, 0.8, 0.8, 1.0]);
	
	if (!shader.last_isAditionalMovedZero)
	{
		gl.uniform1i(shader.hasAditionalMov_loc, false);
		gl.uniform3fv(shader.aditionalMov_loc, [0.0, 0.0, 0.0]); //.
		shader.last_isAditionalMovedZero = true;
	}
	
	// Nodes.**
	var nodesCount = 0;
	if (this.nodesArray)
	{ nodesCount = this.nodesArray.length; }
	
	if (nodesCount > 0 )//&& !magoManager.isCameraMoving)
	{
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
		var refMatrixType = 1; // translation-type.
		gl.uniform1i(shader.refMatrixType_loc, refMatrixType);
		gl.uniform4fv(shader.oneColor4_loc, [0.3, 0.3, 0.9, 1.0]);
		var nodeMaster = this.nodesArray[0]; // render all with an unique box.
		for (var i=0; i<nodesCount; i++)
		{
			var node = this.nodesArray[i];
			
			// check if is selected.
			if (node === selCandidateNodes.currentSelected)
			{
				gl.uniform4fv(shader.oneColor4_loc, [0.9, 0.5, 0.1, 1.0]);
			}
			
			// nodes has a position, so render a point or a box.
			gl.uniform3fv(shader.refTranslationVec_loc, [node.position.x, node.position.y, node.position.z]); 
			nodeMaster.box.render(magoManager, shader, renderType);
			
			// restore defaultColor.
			if (node === selCandidateNodes.currentSelected)
			{
				gl.uniform4fv(shader.oneColor4_loc, [0.3, 0.3, 0.9, 1.0]);
			}
		}
	}
	
	// Edges.**
	// Render with a unique vbo.
	if (this.edgesVboKeysContainer)
	{
		var vboKey = this.edgesVboKeysContainer.vboCacheKeysArray[0];
		if (vboKey.isReadyPositions(gl, vboMemManager))
		{ 
			shader.disableVertexAttribArray(shader.texCoord2_loc); 
			shader.disableVertexAttribArray(shader.normal3_loc); 
			gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
			refMatrixType = 0;
			gl.uniform1i(shader.refMatrixType_loc, refMatrixType);
			gl.uniform4fv(shader.oneColor4_loc, [0.1, 0.1, 0.6, 1.0]);
	
			// Positions.
			if (vboKey.meshVertexCacheKey !== shader.lastVboKeyBindedMap[shader.position3_loc])
			{
				gl.bindBuffer(gl.ARRAY_BUFFER, vboKey.meshVertexCacheKey);
				gl.vertexAttribPointer(shader.position3_loc, 3, gl.FLOAT, false, 0, 0);
				shader.lastVboKeyBindedMap[shader.position3_loc] = vboKey.meshVertexCacheKey;
			}
			
			//gl.drawArrays(gl.LINES, 0, vboKey.segmentsCount*2);
			
			var edgesCount = this.edgesArray.length;
			for (var i=0; i<edgesCount; i++)
			{
				var edge = this.edgesArray[i];
				if (edge === selCandidateEdges.currentSelected)
				{
					gl.uniform4fv(shader.oneColor4_loc, [0.0, 1.0, 0.0, 1.0]);
				}
				gl.drawArrays(gl.LINES, i*2, 2);
				
				// restore default color.
				if (edge === selCandidateEdges.currentSelected)
				{
					gl.uniform4fv(shader.oneColor4_loc, [0.1, 0.1, 0.6, 1.0]);
				}
			}
		}
	}
	
	// Spaces.
	this.renderSpaces = magoManager.tempSettings.renderSpaces;
	this.spacesAlpha = magoManager.tempSettings.spacesAlpha;
	
	if (renderType === 1)
	{ shader.enableVertexAttribArray(shader.normal3_loc); } 
	
	if (this.renderSpaces)
	{
		gl.uniform1i(shader.colorType_loc, 0); // 0= oneColor, 1= attribColor, 2= texture.
		refMatrixType = 0;
		gl.uniform1i(shader.refMatrixType_loc, refMatrixType);
		gl.uniform4fv(shader.oneColor4_loc, [0.8, 0.8, 0.8, this.spacesAlpha]);
		gl.enable(gl.BLEND);
		var spacesCount = 0;
		if (this.spacesArray)
		{ spacesCount = this.spacesArray.length; }
		
		for (var i=0; i<spacesCount; i++)
		{
			var space = this.spacesArray[i];
			space.mesh.render(magoManager, shader);
		}
		
		gl.disable(gl.BLEND);
	}
};







































'use strict';

/**
 * NetworkEdge.
 * 
 * @alias NetworkEdge
 * @class NetworkEdge
 */
var NetworkEdge = function(owner) 
{
	if (!(this instanceof NetworkEdge)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.networkOwner = owner;
	this.id;
	this.strNode;
	this.endNode;
	this.sense;
	this.attributes;
	
	// provisionally:
	this.strNodeId;
	this.endNodeId;
};
'use strict';

/**
 * NetworkNode.
 * 
 * @alias NetworkNode
 * @class NetworkNode
 */
var NetworkNode = function(owner) 
{
	if (!(this instanceof NetworkNode)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.networkOwner = owner;
	this.id;
	this.edgesArray;
	this.attributes;
	this.box;
	//this.mesh; // if display as a box, cilinder, etc.
};
'use strict';

/**
 * NetworkSpace.
 * 
 * @alias NetworkSpace
 * @class NetworkSpace
 */
var NetworkSpace = function(owner) 
{
	if (!(this instanceof NetworkSpace)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	this.networkOwner = owner;
	this.id;
	this.mesh;
	this.attributes;
	
};
'use strict';

function abstract() 
{
	return  ((function() 
	{
		throw new Error('Unimplemented abstract method.');
	})());
}
'use strict';

/**
 * 어떤 일을 하고 있습니까?
 * @class ByteColor
 */
var ByteColor = function() 
{
	if (!(this instanceof ByteColor)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}

	this.ByteR = 0;
	this.ByteG = 0;
	this.ByteB = 0;
	this.ByteAlfa = 255;
};

/**
 * 어떤 일을 하고 있습니까?
 */
ByteColor.prototype.destroy = function() 
{
	this.ByteR = null;
	this.ByteG = null;
	this.ByteB = null;
	this.ByteAlfa = null;
};

/**
 * 어떤 일을 하고 있습니까?
 * @param byteRed 변수
 * @param byteGreen 변수
 * @param byteBlue 변수
 */
ByteColor.prototype.set = function(byteRed, byteGreen, byteBlue) 
{
	this.ByteR = byteRed;
	this.ByteG = byteGreen;
	this.ByteB = byteBlue;
};

'use strict';

/**
 * This class is used to control the movement of objects.
 * @class CameraController
 */
var CameraController = function() 
{
	if (!(this instanceof CameraController)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
	this.startGeoCoord;
	this.targetGeoCoord;
	this.travelDurationInSeconds;
	
	this.acceleration; // m/s2.***
	this.velocity; // m/s.***
	
	
};
'use strict';

/**
 * Returns the first parameter if not undefined, otherwise the second parameter.
 * Useful for setting a default value for a parameter.
 *
 * @param {*} a
 * @param {*} b
 * @returns {*} Returns the first parameter if not undefined, otherwise the second parameter. 
 */
function defaultValue(a, b) 
{
	if (a !== undefined && a !== null) 
	{
		return a;
	}
	return b;
}
'use strict';

/**
 * Returns the first parameter if not undefined, otherwise the second parameter.
 * Useful for setting a default value for a parameter.
 *
 * @param {*} a
 * @param {*} b
 * @returns {*} Returns the first parameter if not undefined, otherwise the second parameter. 
 */
function defaultValueCheckLength(a, b) 
{
	if (a !== undefined && a !== null && a.toString().trim().length > 0) 
	{
		return a;
	}
	return b;
}
'use strict';

/**
 *
 * @param {*} value The object.
 * @returns {Boolean} Returns true if the object is defined, returns false otherwise.
 */
function defined(value) 
{
	return value !== undefined && value !== null;
}
'use strict';
/**
* Utils for geometry.
* @class GeometryUtils
*/
var GeometryUtils = function() 
{
	if (!(this instanceof GeometryUtils)) 
	{
		throw new Error(Messages.CONSTRUCT_ERROR);
	}
	
};

/**
 * Given an idx, this function returns the next idx of an array.
 * @param {Number} currIdx 
 * @param {Number} pointsCount The points count of the array.
 * @Return {Number} The next idx.
 */
GeometryUtils.projectPoint3DInToBestPlaneToProject = function(point3d, bestPlaneToProject, resultPoint2d)
{
	// This function returns projected point2d.
	if (resultPoint2d === undefined)
	{ resultPoint2d = new Point2D(); }
	
	if (bestPlaneToProject === 0)
	{
		//"xy";
		resultPoint2d.set(point3d.x, point3d.y);
	}
	else if (bestPlaneToProject === 1)
	{
		//"yz";
		resultPoint2d.set(point3d.y, point3d.z);
	}
	else if (bestPlaneToProject === 2)
	{
		//"xz";
		resultPoint2d.set(point3d.x, point3d.z);
	}
	
	return resultPoint2d;
};

/**
 * Given an idx, this function returns the next idx of an array.
 * @param {Number} currIdx 
 * @param {Number} pointsCount The points count of the array.
 * @Return {Number} The next idx.
 */
GeometryUtils.projectTriangle3DInToBestPlaneToProject = function(triangle3d, bestPlaneToProject, resultTriangle2d)
{
	// This function returns projected triangle2d.
	if (resultTriangle2d === undefined)
	{ resultTriangle2d = new Triangle2D(); }
	
	var point3d0 = triangle3d.vertex0.getPosition();
	var point2d0 = GeometryUtils.projectPoint3DInToBestPlaneToProject(point3d0, bestPlaneToProject, undefined);
	
	var point3d1 = triangle3d.vertex1.getPosition();
	var point2d1 = GeometryUtils.projectPoint3DInToBestPlaneToProject(point3d1, bestPlaneToProject, undefined);
	
	var point3d2 = triangle3d.vertex2.getPosition();
	var point2d2 = GeometryUtils.projectPoint3DInToBestPlaneToProject(point3d2, bestPlaneToProject, undefined);
	
	resultTriangle2d.setPoints(point2d0, point2d1, point2d2);
	
	return resultTriangle2d;
};

/**
 * Given an idx, this function returns the next idx of an array.
 * @param {Number} currIdx 
 * @param {Number} pointsCount The points count of the array.
 * @Return {Number} The next idx.
 */
GeometryUtils.getNextIdx = function(currIdx, pointsCount)
{
	if (currIdx === pointsCount - 1)
	{ return 0; }
	else
	{ return currIdx + 1; }
};

/**
 * Given an idx, this function returns the previous idx of an array.
 * @param {Number} currIdx 
 * @param {Number} pointsCount The points count of the array.
 * @Return {Number} The previous idx.
 */
GeometryUtils.getPrevIdx = function(currIdx, pointsCount)
{
	if (currIdx === 0)
	{ return pointsCount - 1; }
	else
	{ return currIdx - 1; }
};

/**
 * This function makes the triangles vertices indices for a regular grid.
 * @param {Number} numCols Grid columns count.
 * @param {Number} numRows Grid rows count.
 * @param {Uint16Array/undefined} resultIndicesArray
 * @param {Object} options 
 * @Return {Uint16Array} resultIndicesArray
 */
GeometryUtils.getIndicesTrianglesRegularNet = function(numCols, numRows, resultIndicesArray, resultSouthIndices, resultEastIndices, resultNorthIndices, resultWestIndices, options)
{
	// given a regular net this function returns triangles vertices indices of the net.
	var verticesCount = numCols * numRows;
	var trianglesCount = (numCols-1) * (numRows-1) * 2;
	if (resultIndicesArray === undefined)
	{ resultIndicesArray = new Uint16Array(trianglesCount * 3); }
	
	var idx_1, idx_2, idx_3;
	var idxCounter = 0;
	
	var resultObject = {};
	
	// bLoopColumns : if want object like a cilinder or sphere where the 1rstCol touch with the last col.
	var bLoopColumns = false; // Default.***
	var bTrianglesSenseCCW = true;
	if (options !== undefined)
	{
		if (options.bLoopColumns !== undefined)
		{ bLoopColumns = options.bLoopColumns; }
	
		if (options.bTrianglesSenseCCW !== undefined)
		{ bTrianglesSenseCCW = options.bTrianglesSenseCCW; }
	}
	
	for (var row = 0; row<numRows-1; row++)
	{
		for (var col=0; col<numCols-1; col++)
		{
			// there are 2 triangles: triA, triB.
			idx_1 = VertexMatrix.getIndexOfArray(numCols, numRows, col, row);
			idx_2 = VertexMatrix.getIndexOfArray(numCols, numRows, col+1, row);
			idx_3 = VertexMatrix.getIndexOfArray(numCols, numRows, col, row+1);
			
			if (bTrianglesSenseCCW)
			{
				resultIndicesArray[idxCounter] = idx_1; idxCounter++;
				resultIndicesArray[idxCounter] = idx_2; idxCounter++;
				resultIndicesArray[idxCounter] = idx_3; idxCounter++;
			}
			else
			{
				resultIndicesArray[idxCounter] = idx_1; idxCounter++;
				resultIndicesArray[idxCounter] = idx_3; idxCounter++;
				resultIndicesArray[idxCounter] = idx_2; idxCounter++;
			}
			
			idx_1 = VertexMatrix.getIndexOfArray(numCols, numRows, col+1, row);
			idx_2 = VertexMatrix.getIndexOfArray(numCols, numRows, col+1, row+1);
			idx_3 = VertexMatrix.getIndexOfArray(numCols, numRows, col, row+1);
			
			if (bTrianglesSenseCCW)
			{
				resultIndicesArray[idxCounter] = idx_1; idxCounter++;
				resultIndicesArray[idxCounter] = idx_2; idxCounter++;
				resultIndicesArray[idxCounter] = idx_3; idxCounter++;
			}
			else 
			{
				resultIndicesArray[idxCounter] = idx_1; idxCounter++;
				resultIndicesArray[idxCounter] = idx_3; idxCounter++;
				resultIndicesArray[idxCounter] = idx_2; idxCounter++;
			}
		}
	}
	
	resultObject.indicesArray = resultIndicesArray;
	
	var bCalculateBorderIndices = false;
	if (options)
	{
		if (options.bCalculateBorderIndices !== undefined && options.bCalculateBorderIndices === true)
		{ bCalculateBorderIndices = true; }
	}
	
	// Border indices.***
	if (bCalculateBorderIndices)
	{
		// South.
		if (!resultSouthIndices)
		{ resultSouthIndices = new Uint16Array(numCols); }
		
		for (var col=0; col<numCols; col++)
		{
			var idx = VertexMatrix.getIndexOfArray(numCols, numRows, col, 0);
			resultSouthIndices[col] = idx;
		}
		
		resultObject.southIndicesArray = resultSouthIndices;
		
		// East.
		if (!resultEastIndices)
		{ resultEastIndices = new Uint16Array(numRows); }
		
		for (var row = 0; row<numRows; row++)
		{
			var idx = VertexMatrix.getIndexOfArray(numCols, numRows, numCols-1, row);
			resultEastIndices[row] = idx;
		}
		
		resultObject.eastIndicesArray = resultEastIndices;
		
		// North.
		if (!resultNorthIndices)
		{ resultNorthIndices = new Uint16Array(numCols); }
		
		for (var col=numCols-1; col>=0; col--)
		{
			var idx = VertexMatrix.getIndexOfArray(numCols, numRows, col, numRows-1);
			resultNorthIndices[col] = idx;
		}
		
		resultObject.northIndicesArray = resultNorthIndices;
		
		// West.
		if (!resultWestIndices)
		{ resultWestIndices = new Uint16Array(numRows); }
		
		for (var row = numRows-1; row>=0; row--)
		{
			var idx = VertexMatrix.getIndexOfArray(numCols, numRows, 0, row);
			resultWestIndices[row] = idx;
		}
		
		resultObject.westIndicesArray = resultWestIndices;
	}
	
	if (bLoopColumns)
	{
		var firstCol = 0;
		var endCol = numCols;
		for (var row = 0; row<numRows-1; row++)
		{
			// there are triangles between lastColumn & 1rstColumn.
			// there are 2 triangles: triA, triB.
			idx_1 = VertexMatrix.getIndexOfArray(numCols, numRows, endCol, row);
			idx_2 = VertexMatrix.getIndexOfArray(numCols, numRows, firstCol, row);
			idx_3 = VertexMatrix.getIndexOfArray(numCols, numRows, endCol, row+1);
			if (bTrianglesSenseCCW)
			{
				resultIndicesArray[idxCounter] = idx_1; idxCounter++;
				resultIndicesArray[idxCounter] = idx_2; idxCounter++;
				resultIndicesArray[idxCounter] = idx_3; idxCounter++;
			}
			else 
			{
				resultIndicesArray[idxCounter] = idx_1; idxCounter++;
				resultIndicesArray[idxCounter] = idx_3; idxCounter++;
				resultIndicesArray[idxCounter] = idx_2; idxCounter++;
			}
			
			idx_1 = VertexMatrix.getIndexOfArray(numCols, numRows, firstCol, row);
			idx_2 = VertexMatrix.getIndexOfArray(numCols, numRows, firstCol, row+1);
			idx_3 = VertexMatrix.getIndexOfArray(numCols, numRows, endCol, row+1);
			if (bTrianglesSenseCCW)
			{
				resultIndicesArray[idxCounter] = idx_1; idxCounter++;
				resultIndicesArray[idxCounter] = idx_2; idxCounter++;
				resultIndicesArray[idxCounter] = idx_3; idxCounter++;
			}
			else 
			{
				resultIndicesArray[idxCounter] = idx_1; idxCounter++;
				resultIndicesArray[idxCounter] = idx_3; idxCounter++;
				resultIndicesArray[idxCounter] = idx_2; idxCounter++;
			}
		}
	}
	
	return resultObject;
};


































'use strict';

/**
 *
 * @param {String} url Required.
 * @param {XMLHttpRequest} xhr Optional.
 * @param {number} timeOut Optional. timeout time. milliseconds
 * @param {String} responseType Optional. Default is 'arraybuffer'
 * @param {String} method Optional. Default is 'GET'
 * 
 * @returns {Promise} Promise.js object
 *
 * @example
 * loadWithXhr('url', undefined, undefined, 'json', 'GET').done(function(res) {
 * 	TODO
 * });
 */
function loadWithXhr(url, xhr, timeOut, responseType, method) 
{
	if (!defined(url))
	{
		throw new Error('url required');
	}

	return new Promise(
		function (resolve, reject) 
		{
			if (xhr === undefined)
			{ xhr = new XMLHttpRequest(); }

			method = method ? method : 'GET';
			xhr.open(method, url, true);
			xhr.responseType = responseType ? responseType : 'arraybuffer';

			 // time in milliseconds
			if (timeOut !== undefined)
			{ xhr.timeout = timeOut; }
			
			// 이벤트 핸들러를 등록한다.
			xhr.onload = function() 
			{
				if (xhr.status < 200 || xhr.status >= 300) 
				{
					reject(xhr.status);
				}
				else 
				{
					// 3.1) DEFERRED를 해결한다. (모든 done()...을 동작시킬 것이다.)
					resolve(xhr.response);
				} 
			};
			
			xhr.ontimeout = function (e) 
			{
				// XMLHttpRequest timed out.***
				reject(-1);
			};
			
			xhr.onerror = function(e) 
			{
				console.log("Invalid XMLHttpRequest response type.");
				reject(xhr.status);
			};

			// 작업을 수행한다.
			xhr.send(null);
		}
	);
};
'use strict';

/**
 * ManagerUtils does some calculations about coordinates system of different earth coords.
 * 
 * @class ManagerUtils
 * @constructor 
 */
var ManagerUtils = function() 
{
	
	
};

/**
 * 어떤 일을 하고 있습니까?
 * @param octreesArray 변수
 * @param octree 변수
 * @returns result_idx
 */
ManagerUtils.getIndexToInsertBySquaredDistToEye = function(objectsArray, object, startIdx, endIdx) 
{
	// Note: the object must have "distToCamera" variable.
	// this do a dicotomic search of idx in a ordered table.
	// 1rst, check the range.
	if (startIdx === undefined)
	{ startIdx = 0; }
	
	if (endIdx === undefined)
	{ endIdx = objectsArray.length-1; }
	
	var range = endIdx - startIdx;
	
	if (range <= 0)
	{ return 0; }
	
	if (range < 6)
	{
		// in this case do a lineal search.
		var finished = false;
		var i = startIdx;
		var idx;
		var octreesCount = objectsArray.length;
		while (!finished && i<=endIdx)
		{
			if (object.distToCamera < objectsArray[i].distToCamera)
			{
				idx = i;
				finished = true;
			}
			i++;
		}
		
		if (finished)
		{
			return idx;
		}
		else 
		{
			return endIdx+1;
		}
	}
	else 
	{
		// in this case do the dicotomic search.
		var middleIdx = startIdx + Math.floor(range/2);
		var newStartIdx;
		var newEndIdx;
		if (objectsArray[middleIdx].distToCamera > object.distToCamera)
		{
			newStartIdx = startIdx;
			newEndIdx = middleIdx;
		}
		else 
		{
			newStartIdx = middleIdx;
			newEndIdx = endIdx;
		}
		return ManagerUtils.getIndexToInsertBySquaredDistToEye(objectsArray, object, newStartIdx, newEndIdx);
	}
};

/**
 * world coordinate to geographic coordinate.
 * @param {Point3D} point world coordinate.
 * @param {GeographicCoord|undefined} resultGeographicCoord Optional. result geographicCoord. if undefined, create GeographicCoord instance.
 * @param {MagoManager} magoManager worldwind mode removed, this args is not need. 
 * @returns {GeographicCoord} geographic coordinate object.
 */
ManagerUtils.pointToGeographicCoord = function(point, resultGeographicCoord) 
{
	if (!point) 
	{
		throw new Error('point is requred');
	}

	if (resultGeographicCoord === undefined)
	{ resultGeographicCoord = new GeographicCoord(); }
	
	var cartographic = Globe.CartesianToGeographicWgs84(point.x, point.y, point.z, cartographic);
	resultGeographicCoord.setLonLatAlt(cartographic.longitude, cartographic.latitude, cartographic.altitude);
	
	return resultGeographicCoord;
};

/**
 * geographic coordinate to world coordinate.
 * @param {number} longitude longitude.
 * @param {number} latitude latitude.
 * @param {number} altitude altitude.
 * @param {Point3D|undefined} resultWorldPoint Optional. result worldCoord. if undefined, create Point3D instance.
 * @returns {Point3D} world coordinate object.
 */
ManagerUtils.geographicCoordToWorldPoint = function(longitude, latitude, altitude, resultWorldPoint) 
{
	if (resultWorldPoint === undefined)
	{ resultWorldPoint = new Point3D(); }

	var cartesian = Globe.geographicToCartesianWgs84(longitude, latitude, altitude, undefined);
	resultWorldPoint.set(cartesian[0], cartesian[1], cartesian[2]);
	
	return resultWorldPoint;
};

/**
 * when node mapping type is boundingboxcenter, set pivotPointTraslation and create pivotPoint at geoLocationData
 * this function NO modifies the geographic coords.
 * "newPivotPoint" is in buildingCoords.
 * "newPivotPoint" is the desired position of the new origen of coords, for example:
 * in a building you can desire the center of the bbox as the origin of the coords.
 * @param {GeoLocationData} geoLocationData. Required.
 * @param {Point3D} newPivotPoint newPivotPoint.
 */
ManagerUtils.translatePivotPointGeoLocationData = function(geoLocationData, newPivotPoint) 
{
	if (geoLocationData === undefined)
	{ return; }

	var rawTranslation = new Point3D();
	rawTranslation.set(-newPivotPoint.x, -newPivotPoint.y, -newPivotPoint.z);

	geoLocationData.pivotPointTraslationLC = rawTranslation;
	geoLocationData.doEffectivePivotPointTranslation();
};

/**
 * this function calculates the transformation matrix for (x, y, z) coordinate, that has NO heading, pitch or roll rotations.
 * @param {Point3D} worldPosition worldPosition.
 * @param {Matrix4|undefined} resultGeoLocMatrix. Optional. result geolocation matrix. if undefined, create Matrix4 instance.
 * @returns {Matrix4} resultGeoLocMatrix. this matrix has NO heading, pitch or roll rotations.
 */
ManagerUtils.calculateGeoLocationMatrixAtWorldPosition = function(worldPosition, resultGeoLocMatrix) 
{
	if (resultGeoLocMatrix === undefined)
	{ resultGeoLocMatrix = new Matrix4(); }

	Globe.transformMatrixAtCartesianPointWgs84(worldPosition.x, worldPosition.y, worldPosition.z, resultGeoLocMatrix._floatArrays);
	
	return resultGeoLocMatrix;
};

/**
 * this function calculates the transformation matrix for (longitude, latitude, altitude) coordinate, that has NO heading, pitch or roll rotations.
 * @param {number} longitude longitude.
 * @param {number} latitude latitude.
 * @param {number} altitude altitude.
 * @param {Matrix4|undefined} resultGeoLocMatrix. Optional. result geolocation matrix. if undefined, create Matrix4 instance.
 * @returns {Matrix4} resultGeoLocMatrix. this matrix has NO heading, pitch or roll rotations.
 */
ManagerUtils.calculateGeoLocationMatrixAtLonLatAlt = function(longitude, latitude, altitude, resultGeoLocMatrix) 
{
	if (resultGeoLocMatrix === undefined)
	{ resultGeoLocMatrix = new Matrix4(); }
	
	var worldPosition = this.geographicCoordToWorldPoint(longitude, latitude, altitude, worldPosition);
	resultGeoLocMatrix = ManagerUtils.calculateGeoLocationMatrixAtWorldPosition(worldPosition, resultGeoLocMatrix);
	
	return resultGeoLocMatrix;
};

/**
 * This function calculates the "resultGeoLocMatrix" & "resultTransformMatrix".
 * @param {Point3D} worldPosition worldPosition.
 * @param {number} heading heading.
 * @param {number} pitch pitch.
 * @param {number} roll roll.
 * @param {Matrix4|undefined} resultGeoLocMatrix. Optional. result geolocation matrix. if undefined, create Matrix4 instance. this transformMatrix without the heading, pitch, roll rotations.
 * @param {Matrix4|undefined} resultTransformMatrix. Optional. result transform matrix. if undefined, create Matrix4 instance. this matrix including the heading, pitch, roll rotations.
 * @returns {Matrix4} resultTransformMatrix.
 */
ManagerUtils.calculateTransformMatrixAtWorldPosition = function(worldPosition, heading, pitch, roll, resultGeoLocMatrix, resultTransformMatrix) 
{
	var xRotMatrix = new Matrix4();  // created as identity matrix.
	var yRotMatrix = new Matrix4();  // created as identity matrix.
	var zRotMatrix = new Matrix4();  // created as identity matrix.
	
	if (heading !== undefined && heading !== 0)
	{ zRotMatrix.rotationAxisAngDeg(heading, 0.0, 0.0, 1.0); }

	if (pitch !== undefined && pitch !== 0)
	{ xRotMatrix.rotationAxisAngDeg(pitch, 1.0, 0.0, 0.0); }

	if (roll !== undefined && roll !== 0)
	{ yRotMatrix.rotationAxisAngDeg(roll, 0.0, 1.0, 0.0); }

	if (resultGeoLocMatrix === undefined)
	{ resultGeoLocMatrix = new Matrix4(); }  // created as identity matrix.
	
	if (resultTransformMatrix === undefined)
	{ resultTransformMatrix = new Matrix4(); }  // created as identity matrix.

	// 1rst, calculate the transformation matrix for the location.
	resultGeoLocMatrix = ManagerUtils.calculateGeoLocationMatrixAtWorldPosition(worldPosition, resultGeoLocMatrix);
	
	resultTransformMatrix.copyFromMatrix4(resultGeoLocMatrix);
	var zRotatedTMatrix;
	var zxRotatedTMatrix;
	var zxyRotatedTMatrix;

	zRotatedTMatrix = zRotMatrix.getMultipliedByMatrix(resultTransformMatrix, zRotatedTMatrix);
	zxRotatedTMatrix = xRotMatrix.getMultipliedByMatrix(zRotatedTMatrix, zxRotatedTMatrix);
	zxyRotatedTMatrix = yRotMatrix.getMultipliedByMatrix(zxRotatedTMatrix, zxyRotatedTMatrix);
	
	resultTransformMatrix = zxyRotatedTMatrix;
	return resultTransformMatrix;
};

/**
 * This function calculates all data and matrices for the location(longitude, latitude, altitude) and rotation(heading, pitch, roll).
 * @param {number} longitude Required. longitude.
 * @param {number} latitude Required. latitude.
 * @param {number} altitude altitude.
 * @param {number} heading heading. Unit is degree.
 * @param {number} pitch pitch. Unit is degree.
 * @param {number} roll roll. Unit is degree.
 * @param {GeoLocationData|undefined} resultGeoLocationData Optional. result geolocation matrix. if undefined, create GeoLocationData instance.
 * @param {MagoManager} magoManager for magoManager.globe
 * @returns {GeoLocationData} resultGeoLocationData.
 */
ManagerUtils.calculateGeoLocationData = function(longitude, latitude, altitude, heading, pitch, roll, resultGeoLocationData) 
{
	if (resultGeoLocationData === undefined)
	{ resultGeoLocationData = new GeoLocationData(); }

	// 0) Position.**
	if (resultGeoLocationData.geographicCoord === undefined)
	{ resultGeoLocationData.geographicCoord = new GeographicCoord(); }

	if (longitude !== undefined)
	{ resultGeoLocationData.geographicCoord.longitude = longitude; }
	else 
	{ longitude = resultGeoLocationData.geographicCoord.longitude; }

	if (latitude !== undefined)
	{ resultGeoLocationData.geographicCoord.latitude = latitude; }
	else 
	{ latitude = resultGeoLocationData.geographicCoord.latitude; }

	if (altitude !== undefined)
	{ resultGeoLocationData.geographicCoord.altitude = altitude; }
	else 
	{ altitude = resultGeoLocationData.geographicCoord.altitude; }

	if (heading !== undefined)
	{ resultGeoLocationData.heading = heading; }

	if (pitch !== undefined)
	{ resultGeoLocationData.pitch = pitch; }

	if (roll !== undefined)
	{ resultGeoLocationData.roll = roll; }

	if (resultGeoLocationData.geographicCoord.longitude === undefined || resultGeoLocationData.geographicCoord.latitude === undefined)
	{ return; }
	
	//if (magoManager.configInformation === undefined)
	//{ return; }

	resultGeoLocationData.position = ManagerUtils.geographicCoordToWorldPoint(longitude, latitude, altitude, resultGeoLocationData.position);

	// High and Low values of the position.**
	if (resultGeoLocationData.positionHIGH === undefined)
	{ resultGeoLocationData.positionHIGH = new Float32Array([0.0, 0.0, 0.0]); }
	if (resultGeoLocationData.positionLOW === undefined)
	{ resultGeoLocationData.positionLOW = new Float32Array([0.0, 0.0, 0.0]); }
	ManagerUtils.calculateSplited3fv([resultGeoLocationData.position.x, resultGeoLocationData.position.y, resultGeoLocationData.position.z], resultGeoLocationData.positionHIGH, resultGeoLocationData.positionLOW);

	// Determine the elevation of the position.**
	//var cartographic = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
	//var height = cartographic.height;
	// End Determine the elevation of the position.-------------------------------------------------------
	if (resultGeoLocationData.tMatrix === undefined)
	{ resultGeoLocationData.tMatrix = new Matrix4(); }
	else
	{ resultGeoLocationData.tMatrix.Identity(); }

	if (resultGeoLocationData.geoLocMatrix === undefined)
	{ resultGeoLocationData.geoLocMatrix = new Matrix4(); }
	else
	{ resultGeoLocationData.geoLocMatrix.Identity(); }

	if (resultGeoLocationData.rotMatrix === undefined)
	{ resultGeoLocationData.rotMatrix = new Matrix4(); }
	else
	{ resultGeoLocationData.rotMatrix.Identity(); }

	// Set inverseMatrices as undefined.
	resultGeoLocationData.tMatrixInv = undefined; // reset. is calculated when necessary.
	resultGeoLocationData.rotMatrixInv = undefined; // reset. is calculated when necessary.
	resultGeoLocationData.geoLocMatrixInv = undefined; // reset. is calculated when necessary.

	// 1rst, calculate the transformation matrix for the location.
	resultGeoLocationData.tMatrix = ManagerUtils.calculateTransformMatrixAtWorldPosition(resultGeoLocationData.position, resultGeoLocationData.heading, resultGeoLocationData.pitch, resultGeoLocationData.roll, 
		resultGeoLocationData.geoLocMatrix, resultGeoLocationData.tMatrix);
	resultGeoLocationData.rotMatrix.copyFromMatrix4(resultGeoLocationData.tMatrix);
	resultGeoLocationData.rotMatrix._floatArrays[12] = 0;
	resultGeoLocationData.rotMatrix._floatArrays[13] = 0;
	resultGeoLocationData.rotMatrix._floatArrays[14] = 0;
	
	// finally assing the pivotPoint.
	if (resultGeoLocationData.pivotPoint === undefined)
	{ resultGeoLocationData.pivotPoint = new Point3D(); }

	resultGeoLocationData.pivotPoint.set(resultGeoLocationData.position.x, resultGeoLocationData.position.y, resultGeoLocationData.position.z);
	resultGeoLocationData.doEffectivePivotPointTranslation();
	
	return resultGeoLocationData;
};

/**
 * This function calculates geolocation data use pixel point(calculated world point). 
 * When use Object Marker, this function called.
 * @param {number} absoluteX absoluteX.
 * @param {number} absoluteY absoluteY.
 * @param {number} absoluteZ absoluteZ.
 * @param {GeoLocationData|undefined} resultGeoLocationData Optional. result geolocation matrix. if undefined, create GeoLocationData instance.
 * @param {MagoManager} magoManager
 * @returns {GeoLocationData} resultGeoLocationData.
 */
ManagerUtils.calculateGeoLocationDataByAbsolutePoint = function(absoluteX, absoluteY, absoluteZ, resultGeoLocationData, magoManager) 
{
	if (resultGeoLocationData === undefined)
	{ resultGeoLocationData = new GeoLocationData(); }

	// 0) Position.**
	if (resultGeoLocationData.geographicCoord === undefined)
	{ resultGeoLocationData.geographicCoord = new GeographicCoord(); }
	
	if (magoManager.configInformation === undefined)
	{ return; }
	
	if (resultGeoLocationData.position === undefined)
	{ resultGeoLocationData.position = new Point3D(); }
		
	resultGeoLocationData.position.x = absoluteX;
	resultGeoLocationData.position.y = absoluteY;
	resultGeoLocationData.position.z = absoluteZ;
	
	//추후에 세슘의존성 버리는 코드로 대체 가능해 보임. 손수석님과 검토 필요.
	/*
	if (magoManager.isCesiumGlobe())
	{
		// *if this in Cesium:
		//resultGeoLocationData.position = Cesium.Cartesian3.fromDegrees(resultGeoLocationData.geographicCoord.longitude, resultGeoLocationData.geographicCoord.latitude, resultGeoLocationData.geographicCoord.altitude);
		// must find cartographic data.
		var cartographic = new Cesium.Cartographic();
		var cartesian = new Cesium.Cartesian3();
		cartesian.x = absoluteX;
		cartesian.y = absoluteY;
		cartesian.z = absoluteZ;
		cartographic = Cesium.Cartographic.fromCartesian(cartesian, magoManager.scene._globe._ellipsoid, cartographic);
		resultGeoLocationData.geographicCoord.longitude = cartographic.longitude * 180.0/Math.PI;
		resultGeoLocationData.geographicCoord.latitude = cartographic.latitude * 180.0/Math.PI;
		resultGeoLocationData.geographicCoord.altitude = cartographic.height;
	}
	*/

	resultGeoLocationData.geographicCoord = ManagerUtils.pointToGeographicCoord(new Point3D(absoluteX, absoluteY, absoluteZ));

	// High and Low values of the position.**
	if (resultGeoLocationData.positionHIGH === undefined)
	{ resultGeoLocationData.positionHIGH = new Float32Array([0.0, 0.0, 0.0]); }
	if (resultGeoLocationData.positionLOW === undefined)
	{ resultGeoLocationData.positionLOW = new Float32Array([0.0, 0.0, 0.0]); }
	this.calculateSplited3fv([resultGeoLocationData.position.x, resultGeoLocationData.position.y, resultGeoLocationData.position.z], resultGeoLocationData.positionHIGH, resultGeoLocationData.positionLOW);

	// Determine the elevation of the position.**
	//var cartographic = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
	//var height = cartographic.height;
	// End Determine the elevation of the position.-------------------------------------------------------
	if (resultGeoLocationData.tMatrix === undefined)
	{ resultGeoLocationData.tMatrix = new Matrix4(); }
	else
	{ resultGeoLocationData.tMatrix.Identity(); }

	if (resultGeoLocationData.geoLocMatrix === undefined)
	{ resultGeoLocationData.geoLocMatrix = new Matrix4(); }
	else
	{ resultGeoLocationData.geoLocMatrix.Identity(); }

	if (resultGeoLocationData.rotMatrix === undefined)
	{ resultGeoLocationData.rotMatrix = new Matrix4(); }
	else
	{ resultGeoLocationData.rotMatrix.Identity(); }

	// Set inverseMatrices as undefined.
	resultGeoLocationData.tMatrixInv = undefined; // reset. is calculated when necessary.
	resultGeoLocationData.rotMatrixInv = undefined; // reset. is calculated when necessary.
	resultGeoLocationData.geoLocMatrixInv = undefined; // reset. is calculated when necessary.

	// 1rst, calculate the transformation matrix for the location.
	resultGeoLocationData.tMatrix = ManagerUtils.calculateTransformMatrixAtWorldPosition(resultGeoLocationData.position, resultGeoLocationData.heading, resultGeoLocationData.pitch, resultGeoLocationData.roll, 
		resultGeoLocationData.geoLocMatrix, resultGeoLocationData.tMatrix);
	resultGeoLocationData.rotMatrix.copyFromMatrix4(resultGeoLocationData.tMatrix);
	resultGeoLocationData.rotMatrix._floatArrays[12] = 0;
	resultGeoLocationData.rotMatrix._floatArrays[13] = 0;
	resultGeoLocationData.rotMatrix._floatArrays[14] = 0;
	
	// finally assing the pivotPoint.
	if (resultGeoLocationData.pivotPoint === undefined)
	{ resultGeoLocationData.pivotPoint = new Point3D(); }

	resultGeoLocationData.pivotPoint.set(resultGeoLocationData.position.x, resultGeoLocationData.position.y, resultGeoLocationData.position.z);
	resultGeoLocationData.doEffectivePivotPointTranslation();
	
	return resultGeoLocationData;
};

/**
 * This function calculates geolocation data use pixel point(calculated world point). 
 * When use Object Marker, this function called.
 * @param {number} absoluteX absoluteX.
 * @param {number} absoluteY absoluteY.
 * @param {number} absoluteZ absoluteZ.
 * @param {GeoLocationData|undefined} resultGeoLocationData Optional. result geolocation matrix. if undefined, create GeoLocationData instance.
 * @param {MagoManager} magoManager
 * @returns {GeoLocationData} resultGeoLocationData.
 */
ManagerUtils.calculateGeoLocationDataByAbsolutePoint__original = function(absoluteX, absoluteY, absoluteZ, resultGeoLocationData, magoManager) 
{
	if (resultGeoLocationData === undefined)
	{ resultGeoLocationData = new GeoLocationData(); }

	// 0) Position.**
	if (resultGeoLocationData.geographicCoord === undefined)
	{ resultGeoLocationData.geographicCoord = new GeographicCoord(); }
	
	if (magoManager.configInformation === undefined)
	{ return; }
	
	if (resultGeoLocationData.position === undefined)
	{ resultGeoLocationData.position = new Point3D(); }
		
	resultGeoLocationData.position.x = absoluteX;
	resultGeoLocationData.position.y = absoluteY;
	resultGeoLocationData.position.z = absoluteZ;
	
	//추후에 세슘의존성 버리는 코드로 대체 가능해 보임. 손수석님과 검토 필요.
	if (magoManager.isCesiumGlobe())
	{
		// *if this in Cesium:
		//resultGeoLocationData.position = Cesium.Cartesian3.fromDegrees(resultGeoLocationData.geographicCoord.longitude, resultGeoLocationData.geographicCoord.latitude, resultGeoLocationData.geographicCoord.altitude);
		// must find cartographic data.
		var cartographic = new Cesium.Cartographic();
		var cartesian = new Cesium.Cartesian3();
		cartesian.x = absoluteX;
		cartesian.y = absoluteY;
		cartesian.z = absoluteZ;
		cartographic = Cesium.Cartographic.fromCartesian(cartesian, magoManager.scene._globe._ellipsoid, cartographic);
		resultGeoLocationData.geographicCoord.longitude = cartographic.longitude * 180.0/Math.PI;
		resultGeoLocationData.geographicCoord.latitude = cartographic.latitude * 180.0/Math.PI;
		resultGeoLocationData.geographicCoord.altitude = cartographic.height;
	}

	// High and Low values of the position.**
	if (resultGeoLocationData.positionHIGH === undefined)
	{ resultGeoLocationData.positionHIGH = new Float32Array([0.0, 0.0, 0.0]); }
	if (resultGeoLocationData.positionLOW === undefined)
	{ resultGeoLocationData.positionLOW = new Float32Array([0.0, 0.0, 0.0]); }
	this.calculateSplited3fv([resultGeoLocationData.position.x, resultGeoLocationData.position.y, resultGeoLocationData.position.z], resultGeoLocationData.positionHIGH, resultGeoLocationData.positionLOW);

	// Determine the elevation of the position.**
	//var cartographic = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
	//var height = cartographic.height;
	// End Determine the elevation of the position.-------------------------------------------------------
	if (resultGeoLocationData.tMatrix === undefined)
	{ resultGeoLocationData.tMatrix = new Matrix4(); }
	else
	{ resultGeoLocationData.tMatrix.Identity(); }

	if (resultGeoLocationData.geoLocMatrix === undefined)
	{ resultGeoLocationData.geoLocMatrix = new Matrix4(); }
	else
	{ resultGeoLocationData.geoLocMatrix.Identity(); }

	if (resultGeoLocationData.geoLocMatrixInv === undefined)
	{ resultGeoLocationData.geoLocMatrixInv = new Matrix4(); }
	else
	{ resultGeoLocationData.geoLocMatrixInv.Identity(); }

	//---------------------------------------------------------

	if (resultGeoLocationData.tMatrixInv === undefined)
	{ resultGeoLocationData.tMatrixInv = new Matrix4(); }
	else
	{ resultGeoLocationData.tMatrixInv.Identity(); }

	if (resultGeoLocationData.rotMatrix === undefined)
	{ resultGeoLocationData.rotMatrix = new Matrix4(); }
	else
	{ resultGeoLocationData.rotMatrix.Identity(); }

	if (resultGeoLocationData.rotMatrixInv === undefined)
	{ resultGeoLocationData.rotMatrixInv = new Matrix4(); }
	else
	{ resultGeoLocationData.rotMatrixInv.Identity(); }

	var xRotMatrix = new Matrix4();  // created as identity matrix.
	var yRotMatrix = new Matrix4();  // created as identity matrix.
	var zRotMatrix = new Matrix4();  // created as identity matrix.

	if (resultGeoLocationData.heading !== undefined && resultGeoLocationData.heading !== 0)
	{
		zRotMatrix.rotationAxisAngDeg(resultGeoLocationData.heading, 0.0, 0.0, -1.0);
	}

	if (resultGeoLocationData.pitch !== undefined && resultGeoLocationData.pitch !== 0)
	{
		xRotMatrix.rotationAxisAngDeg(resultGeoLocationData.pitch, -1.0, 0.0, 0.0);
	}

	if (resultGeoLocationData.roll !== undefined && resultGeoLocationData.roll !== 0)
	{
		yRotMatrix.rotationAxisAngDeg(resultGeoLocationData.roll, 0.0, -1.0, 0.0);
	}
	
	if (magoManager.isCesiumGlobe())
	{
		// *if this in Cesium:
		Cesium.Transforms.eastNorthUpToFixedFrame(resultGeoLocationData.position, undefined, resultGeoLocationData.tMatrix._floatArrays);
		resultGeoLocationData.geoLocMatrix.copyFromMatrix4(resultGeoLocationData.tMatrix);// "geoLocMatrix" is the pure transformation matrix, without heading or pitch or roll.

		var zRotatedTMatrix = zRotMatrix.getMultipliedByMatrix(resultGeoLocationData.tMatrix, zRotatedTMatrix);
		var zxRotatedTMatrix = xRotMatrix.getMultipliedByMatrix(zRotatedTMatrix, zxRotatedTMatrix);
		var zxyRotatedTMatrix = yRotMatrix.getMultipliedByMatrix(zxRotatedTMatrix, zxyRotatedTMatrix);
		resultGeoLocationData.tMatrix = zxyRotatedTMatrix;
		
		// test.
		//var yRotatedTMatrix = yRotMatrix.getMultipliedByMatrix(resultGeoLocationData.tMatrix, yRotatedTMatrix);
		//var yxRotatedTMatrix = xRotMatrix.getMultipliedByMatrix(yRotatedTMatrix, yxRotatedTMatrix);
		//var yxzRotatedTMatrix = zRotMatrix.getMultipliedByMatrix(yxRotatedTMatrix, yxzRotatedTMatrix);
		//resultGeoLocationData.tMatrix = yxzRotatedTMatrix;
		// end test.---

		resultGeoLocationData.rotMatrix.copyFromMatrix4(resultGeoLocationData.tMatrix);
		resultGeoLocationData.rotMatrix._floatArrays[12] = 0;
		resultGeoLocationData.rotMatrix._floatArrays[13] = 0;
		resultGeoLocationData.rotMatrix._floatArrays[14] = 0;

		// now, calculates the inverses.
		Cesium.Matrix4.inverse(resultGeoLocationData.tMatrix._floatArrays, resultGeoLocationData.tMatrixInv._floatArrays);
		Cesium.Matrix4.inverse(resultGeoLocationData.rotMatrix._floatArrays, resultGeoLocationData.rotMatrixInv._floatArrays);
		Cesium.Matrix4.inverse(resultGeoLocationData.geoLocMatrix._floatArrays, resultGeoLocationData.geoLocMatrixInv._floatArrays);
	}

	// finally assing the pivotPoint.
	if (resultGeoLocationData.pivotPoint === undefined)
	{ resultGeoLocationData.pivotPoint = new Point3D(); }

	resultGeoLocationData.pivotPoint.set(resultGeoLocationData.position.x, resultGeoLocationData.position.y, resultGeoLocationData.position.z);

	return resultGeoLocationData;
};

/**
 * 자릿수가 긴 숫자를 나머지와 몫으로 분리. gl에서는 float형밖에 처리 불가.
 * @example <caption>Example usage of calculateSplitedValues</caption>
 * ManagerUtils.calculateSplitedValues(4049653.5985745606, new SplitValue());
 * resultSplitValue.high = 3997696; // Math.floor(4049653.5985745606 / 65536.0) * 65536.0;
 * resultSplitValue.low = 51957.5985745606 // 4049653.5985745606 - 3997696;
 * @param {number} value Required. coordinate x or y or z.
 * @param {SplitValue} resultSplitValue Optional. result split value. if undefined, create SplitValue instance.
 * @returns {SplitValue} resultSplitValue.
 */
ManagerUtils.calculateSplitedValues = function(value, resultSplitValue)
{
	if (resultSplitValue === undefined)
	{ resultSplitValue = new SplitValue(); }

	var doubleHigh;
	if (value >= 0.0) 
	{
		doubleHigh = Math.floor(value / 65536.0) * 65536.0; //unsigned short max
		resultSplitValue.high = doubleHigh;
		resultSplitValue.low = value - doubleHigh;
	}
	else 
	{
		doubleHigh = Math.floor(-value / 65536.0) * 65536.0;
		resultSplitValue.high = -doubleHigh;
		resultSplitValue.low = value + doubleHigh;
	}

	return resultSplitValue;
};

/**
 * 자릿수가 긴 숫자를 나머지(low)와 몫(high)으로 분리한 결과를 각각 배열로 생성. gl에서는 float형밖에 처리 불가.
 * @param {Point3D} point3fv Required.
 * @param {Float32Array} resultSplitPoint3fvHigh Optional. result split high value array. if undefined, set new Float32Array(3).
 * @param {Float32Array} resultSplitPoint3fvLow Optional. result split low value array. if undefined, set new Float32Array(3).
 * 
 * @see ManagerUtils#calculateSplitedValues
 */
ManagerUtils.calculateSplited3fv = function(point3fv, resultSplitPoint3fvHigh, resultSplitPoint3fvLow)
{
	if (point3fv === undefined)
	{ return undefined; }

	if (resultSplitPoint3fvHigh === undefined) // delete unnecesary. agree
	{ resultSplitPoint3fvHigh = new Float32Array(3); }// delete unnecesary. agree

	if (resultSplitPoint3fvLow === undefined)// delete unnecesary. agree
	{ resultSplitPoint3fvLow = new Float32Array(3); }// delete unnecesary. agree

	var posSplitX = new SplitValue();
	posSplitX = this.calculateSplitedValues(point3fv[0], posSplitX);
	var posSplitY = new SplitValue();
	posSplitY = this.calculateSplitedValues(point3fv[1], posSplitY);
	var posSplitZ = new SplitValue();
	posSplitZ = this.calculateSplitedValues(point3fv[2], posSplitZ);

	resultSplitPoint3fvHigh[0] = posSplitX.high;
	resultSplitPoint3fvHigh[1] = posSplitY.high;
	resultSplitPoint3fvHigh[2] = posSplitZ.high;

	resultSplitPoint3fvLow[0] = posSplitX.low;
	resultSplitPoint3fvLow[1] = posSplitY.low;
	resultSplitPoint3fvLow[2] = posSplitZ.low;
};

/**
 * Calculates the pixel linear depth value.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Number} pixelX Screen x position of the pixel.
 * @param {Number} pixelY Screen y position of the pixel.
 * @param {FBO} depthFbo Depth frameBuffer object.
 * @param {MagoManager} magoManager Mago3D main manager.
 * @returns {Number} linearDepth Returns the linear depth [0.0, 1.0] ranged value.
 */
ManagerUtils.calculatePixelLinearDepth = function(gl, pixelX, pixelY, depthFbo, magoManager) 
{
	if (depthFbo === undefined)
	{ depthFbo = magoManager.depthFboNeo; }

	if (!depthFbo) 
	{
		return;
	}

	if (depthFbo) 
	{
		depthFbo.bind(); 
	}

	// Now, read the pixel and find the pixel position.
	var depthPixels = new Uint8Array(4 * 1 * 1); // 4 x 1x1 pixel.
	gl.readPixels(pixelX, magoManager.sceneState.drawingBufferHeight - pixelY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, depthPixels);
	
	var zDepth = depthPixels[0]/(256.0*256.0*256.0) + depthPixels[1]/(256.0*256.0) + depthPixels[2]/256.0 + depthPixels[3]; // 0 to 256 range depth.
	var linearDepth = zDepth / 256.0; // LinearDepth. Convert to [0.0, 1.0] range depth.

	return linearDepth;
};

/**
 * Calculates the pixel linear depth value.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Number} pixelX Screen x position of the pixel.
 * @param {Number} pixelY Screen y position of the pixel.
 * @param {FBO} depthFbo Depth frameBuffer object.
 * @param {MagoManager} magoManager Mago3D main manager.
 * @returns {Number} linearDepth Returns the linear depth [0.0, 1.0] ranged value.
 */
ManagerUtils.calculatePixelLinearDepthABGR = function(gl, pixelX, pixelY, depthFbo, magoManager) 
{
	// Test function.
	// Test function.
	// Test function.
	// Test function.
	// Called from MagoWorld.updateMouseStartClick(...).***
	if (depthFbo === undefined)
	{ depthFbo = magoManager.depthFboNeo; }

	if (!depthFbo) 
	{
		return;
	}
	
	if (depthFbo) 
	{
		depthFbo.bind(); 
	}
	
	// Now, read the pixel and find the pixel position.
	var depthPixels = new Uint8Array(4 * 1 * 1); // 4 x 1x1 pixel.
	gl.readPixels(pixelX, magoManager.sceneState.drawingBufferHeight - pixelY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, depthPixels);
	
	var zDepth = depthPixels[3]/(255.0*255.0*255.0) + depthPixels[2]/(255.0*255.0) + depthPixels[1]/255.0 + depthPixels[0]; // 0 to 256 range depth.
	var linearDepth = zDepth / 255.0; // LinearDepth. Convert to [0.0, 1.0] range depth.
	return linearDepth;
};

/**
 * Calculates the pixel position in camera coordinates.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Number} pixelX Screen x position of the pixel.
 * @param {Number} pixelY Screen y position of the pixel.
 * @param {Point3D} resultPixelPos The result of the calculation.
 * @param {MagoManager} magoManager Mago3D main manager.
 * @returns {Point3D} resultPixelPos The result of the calculation.
 */
ManagerUtils.calculatePixelPositionCamCoord = function(gl, pixelX, pixelY, resultPixelPos, depthFbo, frustumNear, frustumFar, magoManager) 
{
	/*
	vec2 screenPos = vec2(gl_FragCoord.x / screenWidth, gl_FragCoord.y / screenHeight);
		float z_window  = unpackDepth(texture2D(depthTex, screenPos.xy)); // z_window  is [0.0, 1.0] range depth.
		if(z_window < 0.001)
		discard;
	
		float depthRange_near = 0.0;
		float depthRange_far = 1.0;
		float x_ndc = 2.0 * screenPos.x - 1.0;
		float y_ndc = 2.0 * screenPos.y - 1.0;
		float z_ndc = (2.0 * z_window - depthRange_near - depthRange_far) / (depthRange_far - depthRange_near);
		
		vec4 viewPosH = projectionMatrixInv * vec4(x_ndc, y_ndc, z_ndc, 1.0);
		vec3 posCC = viewPosH.xyz/viewPosH.w;
		vec4 posWC = modelViewMatrixRelToEyeInv * vec4(posCC.xyz, 1.0) + vec4((encodedCameraPositionMCHigh + encodedCameraPositionMCLow).xyz, 1.0);
		*/
	// New.*** New.*** New.*** New.*** New.*** New.*** New.*** New.*** New.*** New.*** New.*** New.*** New.*** New.*** New.*** New.*** New.*** New.***
	/*
	if (depthFbo) 
	{
		depthFbo.bind(); 
	}
	
	var sceneState = magoManager.sceneState;
	var screenW = sceneState.drawingBufferWidth;
	var screenH = sceneState.drawingBufferHeight;

	// Now, read the pixel and find the pixel position.
	var depthPixels = new Uint8Array(4 * 1 * 1); // 4 x 1x1 pixel.
	gl.readPixels(pixelX, screenH - pixelY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, depthPixels);
	
	// Unpack the depthPixels.
	//var dot(packedDepth, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));

	var zDepth2 = depthPixels[0]/(256.0*256.0*256.0) + depthPixels[1]/(256.0*256.0) + depthPixels[2]/256.0 + depthPixels[3]; 
	var zDepth = depthPixels[3]/(256.0*256.0*256.0) + depthPixels[2]/(256.0*256.0) + depthPixels[1]/256.0 + depthPixels[0]; 
	
	//zDepth /= 256.0;
	// Calculate NDC coord.
	var depthRange_near = 0.0;
	var depthRange_far = 1.0;
	var screenPos = new Point2D(pixelX/screenW, pixelY/screenH);
	var xNdc = 2.0 * screenPos.x - 1.0;
	var yNdc = 2.0 * screenPos.y - 1.0;
	var zNdc = (2.0 * zDepth - depthRange_near - depthRange_far) / (depthRange_far - depthRange_near);
	
	var projectMatInv = sceneState.getProjectionMatrixInv();
	var viewPosH = projectMatInv.transformPoint4D__test([xNdc, yNdc, zNdc, 1.0], undefined);
	var viewPosCC = new Point3D(viewPosH[0]/viewPosH[3], viewPosH[1]/viewPosH[3], viewPosH[2]/viewPosH[3]);
	
	//********************************************************************************************************************************************
	// Old.*** Old.*** Old.*** Old.*** Old.*** Old.*** Old.*** Old.*** Old.*** Old.*** Old.*** Old.*** Old.*** Old.*** Old.*** Old.***
	*/
	if (frustumFar === undefined)
	{ frustumFar = magoManager.sceneState.camera.frustum.far; }

	if (frustumNear === undefined)
	{ frustumNear = 0.0; }
	
	var linearDepth = ManagerUtils.calculatePixelLinearDepth(gl, pixelX, pixelY, depthFbo, magoManager);
	if (!linearDepth) 
	{
		return;
	}
	//var realZDepth = frustumNear + linearDepth*frustumFar; // Use this code if the zDepth encoder uses frustum near & frustum far, both.
	// Note: In our RenderShowDepth shaders, we are encoding zDepth no considering the frustum near.
	var realZDepth = linearDepth*frustumFar; // original.
	//var realZDepth = linearDepth*30000.0; // new.

	// now, find the 3d position of the pixel in camCoord.*
	magoManager.resultRaySC = ManagerUtils.getRayCamSpace(pixelX, pixelY, magoManager.resultRaySC, magoManager);
	if (resultPixelPos === undefined)
	{ resultPixelPos = new Point3D(); }
	
	resultPixelPos.set(magoManager.resultRaySC[0] * realZDepth, magoManager.resultRaySC[1] * realZDepth, magoManager.resultRaySC[2] * realZDepth);
	gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	return resultPixelPos;
};

/**
 * Calculates the cameraCoord position in world coordinates.
 * @param {Point3D} cameraCoord Camera coordinate position.
 * @param {MagoManager} magoManager Mago3D main manager.
 * @returns {Point3D} resultPixelPos The result of the calculation.
 */
ManagerUtils.cameraCoordPositionToWorldCoord = function(camCoordPos, resultWorldPos, magoManager) 
{
	// now, must transform this pixelCamCoord to world coord.
	var mv_inv = magoManager.sceneState.getModelViewMatrixInv();
	if (resultWorldPos === undefined)
	{ var resultWorldPos = new Point3D(); }
	resultWorldPos = mv_inv.transformPoint3D(camCoordPos, resultWorldPos);
	return resultWorldPos;
};

/**
 * Calculates the pixel position in world coordinates.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Number} pixelX Screen x position of the pixel.
 * @param {Number} pixelY Screen y position of the pixel.
 * @param {Point3D} resultPixelPos The result of the calculation.
 * @param {MagoManager} magoManager Mago3D main manager.
 * @returns {Point3D} resultPixelPos The result of the calculation.
 */
ManagerUtils.screenCoordToWorldCoord = function(gl, pixelX, pixelY, resultWCPos, depthFbo, frustumNear, frustumFar, magoManager) 
{
	if (magoManager.isCesiumGlobe())
	{
		// https://cesium.com/docs/cesiumjs-ref-doc/Globe.html
		
		var cesiumScene = magoManager.scene; 
		var cesiumGlobe = cesiumScene.globe;
		var cesiumCamera = cesiumScene.camera;
		var windowCoordinates = new Cesium.Cartesian2(pixelX, pixelY);
		var ray = cesiumCamera.getPickRay(windowCoordinates);
		var intersection = cesiumGlobe.pick(ray, cesiumScene);
		return intersection;
	}
	else/* if (magoManager.configInformation.basicGlobe === Constant.MAGOWORLD)*/
	{
		// todo:
		
	}
};

/**
 * Calculates the pixel position in world coordinates.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Number} pixelX Screen x position of the pixel.
 * @param {Number} pixelY Screen y position of the pixel.
 * @param {Point3D} resultPixelPos The result of the calculation.
 * @param {MagoManager} magoManager Mago3D main manager.
 * @returns {Point3D} resultPixelPos The result of the calculation.
 */
ManagerUtils.calculatePixelPositionWorldCoord = function(gl, pixelX, pixelY, resultPixelPos, depthFbo, frustumNear, frustumFar, magoManager) 
{
	var pixelPosCamCoord = new Point3D();
	
	if (frustumFar === undefined)
	{ frustumFar = magoManager.sceneState.camera.frustum.far; }

	if (frustumNear === undefined)
	{ frustumNear = 0.0; }
	
	if (depthFbo === undefined)
	{ depthFbo = magoManager.depthFboNeo; }
	
	pixelPosCamCoord = ManagerUtils.calculatePixelPositionCamCoord(gl, pixelX, pixelY, pixelPosCamCoord, depthFbo, frustumNear, frustumFar, magoManager);

	if (resultPixelPos === undefined)
	{ var resultPixelPos = new Point3D(); }

	resultPixelPos = ManagerUtils.cameraCoordPositionToWorldCoord(pixelPosCamCoord, resultPixelPos, magoManager);
	return resultPixelPos;
};

/**
 * Calculates a world coordinate point to screen coordinate.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Number} worldCoordX x value of the point in world coordinate.
 * @param {Number} worldCoordY y value of the point in world coordinate.
 * @param {Number} worldCoordZ z value of the point in world coordinate.
 * @param {Point3D} resultPixelPos The result of the calculation.
 * @param {MagoManager} magoManager Mago3D main manager.
 * @returns {Point3D} resultPixelPos The result of the calculation.
 */
ManagerUtils.calculateWorldPositionToScreenCoord = function(gl, worldCoordX, worldCoordY, worldCoordZ, resultScreenCoord, magoManager)
{
	if (resultScreenCoord === undefined)
	{ resultScreenCoord = new Point3D(); }
	
	if (magoManager.pointSC === undefined)
	{ magoManager.pointSC = new Point3D(); }
	
	if (magoManager.pointSC2 === undefined)
	{ magoManager.pointSC2 = new Point3D(); }
	
	magoManager.pointSC.set(worldCoordX, worldCoordY, worldCoordZ);
	
	// calculate the position in camera coords.
	var pointSC2 = magoManager.pointSC2;
	var sceneState = magoManager.sceneState;
	pointSC2 = sceneState.modelViewMatrix.transformPoint3D(magoManager.pointSC, pointSC2);
	
	// now calculate the position in screen coords.
	var zDist = pointSC2.z;
	if (zDist > 0)
	{
		// the worldPoint is rear the camera.
		resultScreenCoord.set(-1, -1, 0);
		return resultScreenCoord;
	}
	
	// now calculate the width and height of the plane in zDist.
	//var fovyRad = sceneState.camera.frustum.fovyRad;
	
	var planeHeight = sceneState.camera.frustum.tangentOfHalfFovy*zDist*2;
	var planeWidth = planeHeight * sceneState.camera.frustum.aspectRatio; 
	var pixelX = -pointSC2.x * sceneState.drawingBufferWidth / planeWidth;
	var pixelY = -(pointSC2.y) * sceneState.drawingBufferHeight / planeHeight;

	pixelX += sceneState.drawingBufferWidth / 2;
	pixelY += sceneState.drawingBufferHeight / 2;
	pixelY = sceneState.drawingBufferHeight - pixelY;
	resultScreenCoord.set(pixelX, pixelY, 0);
	
	return resultScreenCoord;
};

/**
 * Calculates the direction vector of a ray that starts in the camera position and
 * continues to the pixel position in camera space.
 * @param {Number} pixelX Screen x position of the pixel.
 * @param {Number} pixelY Screen y position of the pixel.
 * @param {Float32Array(3)} resultRay Result of the calculation.
 * @returns {Float32Array(3)} resultRay Result of the calculation.
 */
ManagerUtils.getRayCamSpace = function(pixelX, pixelY, resultRay, magoManager) 
{
	// in this function "ray" is a vector.
	var sceneState = magoManager.sceneState;
	var frustum_far = 1.0; // unitary frustum far.
	var frustum = sceneState.camera.frustum;
	var aspectRatio = frustum.aspectRatio;
	var tangentOfHalfFovy = frustum.tangentOfHalfFovy; 
	
	var hfar = 2.0 * tangentOfHalfFovy * frustum_far; //var hfar = 2.0 * Math.tan(fovy/2.0) * frustum_far;
	var wfar = hfar * aspectRatio;
	var mouseX = pixelX;
	var mouseY = sceneState.drawingBufferHeight - pixelY;
	if (resultRay === undefined) 
	{ resultRay = new Float32Array(3); }
	resultRay[0] = wfar*((mouseX/sceneState.drawingBufferWidth) - 0.5);
	resultRay[1] = hfar*((mouseY/sceneState.drawingBufferHeight) - 0.5);
	resultRay[2] = - frustum_far;
	return resultRay;
};

/**
 * Calculates the direction vector of a ray that starts in the camera position and
 * continues to the pixel position in world space.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Number} pixelX Screen x position of the pixel.
 * @param {Number} pixelY Screen y position of the pixel.
 * @returns {Line} resultRay
 */
ManagerUtils.getRayWorldSpace = function(gl, pixelX, pixelY, resultRay, magoManager) 
{
	// in this function the "ray" is a line.
	if (resultRay === undefined) 
	{ resultRay = new Line(); }
	
	// world ray = camPos + lambda*camDir.
	var camPos = magoManager.sceneState.camera.position;
	var rayCamSpace = new Float32Array(3);
	rayCamSpace = ManagerUtils.getRayCamSpace(pixelX, pixelY, rayCamSpace, magoManager);
	
	if (magoManager.pointSC === undefined)
	{ magoManager.pointSC = new Point3D(); }
	
	var pointSC = magoManager.pointSC;
	var pointSC2 = magoManager.pointSC2;
	
	pointSC.set(rayCamSpace[0], rayCamSpace[1], rayCamSpace[2]);

	// now, must transform this posCamCoord to world coord.
	pointSC2 = magoManager.sceneState.modelViewMatrixInv.rotatePoint3D(pointSC, pointSC2); // rayWorldSpace.
	pointSC2.unitary(); // rayWorldSpace.
	resultRay.setPointAndDir(camPos.x, camPos.y, camPos.z,       pointSC2.x, pointSC2.y, pointSC2.z);// original.

	return resultRay;
};

/**
 * 두 점을 연결한 선과 정북선 사이의 각도 구하기. 주로 모델이나 데이터의 헤딩을 설정하는데 사용.
 * @param {GeographicCoord} startGeographic 
 * @param {GeographicCoord} endGeographic 
 * @returns {number} heading
 */
ManagerUtils.getHeadingToNorthByTwoGeographicCoords = function(startGeographic, endGeographic, magoManager) 
{
	var firstGeoLocData = Mago3D.ManagerUtils.calculateGeoLocationData(startGeographic.longitude, startGeographic.latitude, 0, 0, 0, 0, firstGeoLocData, magoManager);

	var lastWorldCoord = Mago3D.ManagerUtils.geographicCoordToWorldPoint(endGeographic.longitude, endGeographic.latitude, 0, lastWorldCoord, magoManager);
	var lastLocalCoord3D = firstGeoLocData.worldCoordToLocalCoord(lastWorldCoord, lastLocalCoord3D);
	var lastLocalCoord2D = new Point2D(lastLocalCoord3D.x, lastLocalCoord3D.y);
	lastLocalCoord2D.unitary();
	var yAxis = new Point2D(0, 1);
	var heading = yAxis.angleDegToVector(lastLocalCoord2D);
	if (lastLocalCoord2D.x > 0) 
	{
		heading *= -1;
	}

	return heading;
};

/**
 * Using screen coordinate, return world coord, geographic coord, screen coord.
 * @param {WebGLRenderingContext} gl WebGL Rendering Context.
 * @param {Number} pixelX Screen x position of the pixel.
 * @param {Number} pixelY Screen y position of the pixel.
 * @param {MagoManager} magoManager Mago3D main manager.
 * @returns {object} world coord, geographic coord, screen coord.
 */
ManagerUtils.getComplexCoordinateByScreenCoord = function(gl, pixelX, pixelY, depthFbo, frustumNear, frustumFar, magoManager) 
{
	var worldCoord = ManagerUtils.screenCoordToWorldCoord(magoManager.getGl(), pixelX, pixelY, worldCoord, undefined, undefined, undefined, magoManager);
	if (!worldCoord) 
	{
		return null;
	}
	var geographicCoord = ManagerUtils.pointToGeographicCoord(worldCoord, geographicCoord);
	
	return {
		screenCoordinate     : new Point2D(pixelX, pixelY),
		worldCoordinate      : worldCoord,
		geographicCoordinate : geographicCoord
	};
};
"function"!=typeof Promise.prototype.done&&(Promise.prototype.done=function(t,n){var o=arguments.length?this.then.apply(this,arguments):this;o.then(null,function(t){setTimeout(function(){throw t},0)})});
(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == "function" && require;
        if (!u && a) return a(o, !0);
        if (i) return i(o, !0);
        var f = new Error("Cannot find module '" + o + "'");
        throw f.code = "MODULE_NOT_FOUND", f;
      }
      var l = n[o] = {
        exports: {}
      };
      t[o][0].call(l.exports, function(e) {
        var n = t[o][1][e];
        return s(n ? n : e);
      }, l, l.exports, e, t, n, r);
    }
    return n[o].exports;
  }
  var i = typeof require == "function" && require;
  for (var o = 0; o < r.length; o++) s(r[o]);
  return s;
})({
  1: [ function(require, module, exports) {
    "use strict";
    var asap = require("asap/raw");
    function noop() {}
    var LAST_ERROR = null;
    var IS_ERROR = {};
    function getThen(obj) {
      try {
        return obj.then;
      } catch (ex) {
        LAST_ERROR = ex;
        return IS_ERROR;
      }
    }
    function tryCallOne(fn, a) {
      try {
        return fn(a);
      } catch (ex) {
        LAST_ERROR = ex;
        return IS_ERROR;
      }
    }
    function tryCallTwo(fn, a, b) {
      try {
        fn(a, b);
      } catch (ex) {
        LAST_ERROR = ex;
        return IS_ERROR;
      }
    }
    module.exports = Promise;
    function Promise(fn) {
      if (typeof this !== "object") {
        throw new TypeError("Promises must be constructed via new");
      }
      if (typeof fn !== "function") {
        throw new TypeError("not a function");
      }
      this._37 = 0;
      this._12 = null;
      this._59 = [];
      if (fn === noop) return;
      doResolve(fn, this);
    }
    Promise._99 = noop;
    Promise.prototype.then = function(onFulfilled, onRejected) {
      if (this.constructor !== Promise) {
        return safeThen(this, onFulfilled, onRejected);
      }
      var res = new Promise(noop);
      handle(this, new Handler(onFulfilled, onRejected, res));
      return res;
    };
    function safeThen(self, onFulfilled, onRejected) {
      return new self.constructor(function(resolve, reject) {
        var res = new Promise(noop);
        res.then(resolve, reject);
        handle(self, new Handler(onFulfilled, onRejected, res));
      });
    }
    function handle(self, deferred) {
      while (self._37 === 3) {
        self = self._12;
      }
      if (self._37 === 0) {
        self._59.push(deferred);
        return;
      }
      asap(function() {
        var cb = self._37 === 1 ? deferred.onFulfilled : deferred.onRejected;
        if (cb === null) {
          if (self._37 === 1) {
            resolve(deferred.promise, self._12);
          } else {
            reject(deferred.promise, self._12);
          }
          return;
        }
        var ret = tryCallOne(cb, self._12);
        if (ret === IS_ERROR) {
          reject(deferred.promise, LAST_ERROR);
        } else {
          resolve(deferred.promise, ret);
        }
      });
    }
    function resolve(self, newValue) {
      if (newValue === self) {
        return reject(self, new TypeError("A promise cannot be resolved with itself."));
      }
      if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
        var then = getThen(newValue);
        if (then === IS_ERROR) {
          return reject(self, LAST_ERROR);
        }
        if (then === self.then && newValue instanceof Promise) {
          self._37 = 3;
          self._12 = newValue;
          finale(self);
          return;
        } else if (typeof then === "function") {
          doResolve(then.bind(newValue), self);
          return;
        }
      }
      self._37 = 1;
      self._12 = newValue;
      finale(self);
    }
    function reject(self, newValue) {
      self._37 = 2;
      self._12 = newValue;
      finale(self);
    }
    function finale(self) {
      for (var i = 0; i < self._59.length; i++) {
        handle(self, self._59[i]);
      }
      self._59 = null;
    }
    function Handler(onFulfilled, onRejected, promise) {
      this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
      this.onRejected = typeof onRejected === "function" ? onRejected : null;
      this.promise = promise;
    }
    function doResolve(fn, promise) {
      var done = false;
      var res = tryCallTwo(fn, function(value) {
        if (done) return;
        done = true;
        resolve(promise, value);
      }, function(reason) {
        if (done) return;
        done = true;
        reject(promise, reason);
      });
      if (!done && res === IS_ERROR) {
        done = true;
        reject(promise, LAST_ERROR);
      }
    }
  }, {
    "asap/raw": 4
  } ],
  2: [ function(require, module, exports) {
    "use strict";
    var Promise = require("./core.js");
    module.exports = Promise;
    var TRUE = valuePromise(true);
    var FALSE = valuePromise(false);
    var NULL = valuePromise(null);
    var UNDEFINED = valuePromise(undefined);
    var ZERO = valuePromise(0);
    var EMPTYSTRING = valuePromise("");
    function valuePromise(value) {
      var p = new Promise(Promise._99);
      p._37 = 1;
      p._12 = value;
      return p;
    }
    Promise.resolve = function(value) {
      if (value instanceof Promise) return value;
      if (value === null) return NULL;
      if (value === undefined) return UNDEFINED;
      if (value === true) return TRUE;
      if (value === false) return FALSE;
      if (value === 0) return ZERO;
      if (value === "") return EMPTYSTRING;
      if (typeof value === "object" || typeof value === "function") {
        try {
          var then = value.then;
          if (typeof then === "function") {
            return new Promise(then.bind(value));
          }
        } catch (ex) {
          return new Promise(function(resolve, reject) {
            reject(ex);
          });
        }
      }
      return valuePromise(value);
    };
    Promise.all = function(arr) {
      var args = Array.prototype.slice.call(arr);
      return new Promise(function(resolve, reject) {
        if (args.length === 0) return resolve([]);
        var remaining = args.length;
        function res(i, val) {
          if (val && (typeof val === "object" || typeof val === "function")) {
            if (val instanceof Promise && val.then === Promise.prototype.then) {
              while (val._37 === 3) {
                val = val._12;
              }
              if (val._37 === 1) return res(i, val._12);
              if (val._37 === 2) reject(val._12);
              val.then(function(val) {
                res(i, val);
              }, reject);
              return;
            } else {
              var then = val.then;
              if (typeof then === "function") {
                var p = new Promise(then.bind(val));
                p.then(function(val) {
                  res(i, val);
                }, reject);
                return;
              }
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        }
        for (var i = 0; i < args.length; i++) {
          res(i, args[i]);
        }
      });
    };
    Promise.reject = function(value) {
      return new Promise(function(resolve, reject) {
        reject(value);
      });
    };
    Promise.race = function(values) {
      return new Promise(function(resolve, reject) {
        values.forEach(function(value) {
          Promise.resolve(value).then(resolve, reject);
        });
      });
    };
    Promise.prototype["catch"] = function(onRejected) {
      return this.then(null, onRejected);
    };
  }, {
    "./core.js": 1
  } ],
  3: [ function(require, module, exports) {
    "use strict";
    var rawAsap = require("./raw");
    var freeTasks = [];
    var pendingErrors = [];
    var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);
    function throwFirstError() {
      if (pendingErrors.length) {
        throw pendingErrors.shift();
      }
    }
    module.exports = asap;
    function asap(task) {
      var rawTask;
      if (freeTasks.length) {
        rawTask = freeTasks.pop();
      } else {
        rawTask = new RawTask();
      }
      rawTask.task = task;
      rawAsap(rawTask);
    }
    function RawTask() {
      this.task = null;
    }
    RawTask.prototype.call = function() {
      try {
        this.task.call();
      } catch (error) {
        if (asap.onerror) {
          asap.onerror(error);
        } else {
          pendingErrors.push(error);
          requestErrorThrow();
        }
      } finally {
        this.task = null;
        freeTasks[freeTasks.length] = this;
      }
    };
  }, {
    "./raw": 4
  } ],
  4: [ function(require, module, exports) {
    (function(global) {
      "use strict";
      module.exports = rawAsap;
      function rawAsap(task) {
        if (!queue.length) {
          requestFlush();
          flushing = true;
        }
        queue[queue.length] = task;
      }
      var queue = [];
      var flushing = false;
      var requestFlush;
      var index = 0;
      var capacity = 1024;
      function flush() {
        while (index < queue.length) {
          var currentIndex = index;
          index = index + 1;
          queue[currentIndex].call();
          if (index > capacity) {
            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
              queue[scan] = queue[scan + index];
            }
            queue.length -= index;
            index = 0;
          }
        }
        queue.length = 0;
        index = 0;
        flushing = false;
      }
      var BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;
      if (typeof BrowserMutationObserver === "function") {
        requestFlush = makeRequestCallFromMutationObserver(flush);
      } else {
        requestFlush = makeRequestCallFromTimer(flush);
      }
      rawAsap.requestFlush = requestFlush;
      function makeRequestCallFromMutationObserver(callback) {
        var toggle = 1;
        var observer = new BrowserMutationObserver(callback);
        var node = document.createTextNode("");
        observer.observe(node, {
          characterData: true
        });
        return function requestCall() {
          toggle = -toggle;
          node.data = toggle;
        };
      }
      function makeRequestCallFromTimer(callback) {
        return function requestCall() {
          var timeoutHandle = setTimeout(handleTimer, 0);
          var intervalHandle = setInterval(handleTimer, 50);
          function handleTimer() {
            clearTimeout(timeoutHandle);
            clearInterval(intervalHandle);
            callback();
          }
        };
      }
      rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;
    }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
  }, {} ],
  5: [ function(require, module, exports) {
    if (typeof Promise.prototype.done !== "function") {
      Promise.prototype.done = function(onFulfilled, onRejected) {
        var self = arguments.length ? this.then.apply(this, arguments) : this;
        self.then(null, function(err) {
          setTimeout(function() {
            throw err;
          }, 0);
        });
      };
    }
  }, {} ],
  6: [ function(require, module, exports) {
    var asap = require("asap");
    if (typeof Promise === "undefined") {
      Promise = require("./lib/core.js");
      require("./lib/es6-extensions.js");
    }
    require("./polyfill-done.js");
  }, {
    "./lib/core.js": 1,
    "./lib/es6-extensions.js": 2,
    "./polyfill-done.js": 5,
    asap: 3
  } ]
}, {}, [ 6 ]);
Promise.prototype.finally = Promise.prototype.finally || {
  finally (fn) {
    const onFinally = value => Promise.resolve(fn()).then(() => value);
    return this.then(
      result => onFinally(result),
      reason => onFinally(Promise.reject(reason))
    );
  }
}.finally;
/**
  * A module containing Data from IndoorGML.</br>
  * This module contains the variables required to navigate in 3D buildings built in DisplayHelper and
  * the functions required for parsing that variables from json object.</br>
  * Unlike existing maps, the indoor space viewer is restricted due to the spatial factor of the wall.</br>
  * With this in mind, this module ensures that the user moves only on the network defined in the GML file
  * to limit unusual behavior such as user penetration through the wall.</br>
  * @module GMLDataContainer
  */

  'use strict';


  /**
   * Create new GMLDataContainer
   * @alias module:GMLDataContainer
   * @param {Object} jsonresponse JSON object parsed from inputed json data file
   */
  function GMLDataContainer(jsonresponse, gmlVersion) {

    /**
     * JSON object parsed from inputed json data file.</br>
     * Inputed json data file is converted from IndoorGML file.</br>
     * You can convert IndoorGML to json through 'gmlToJson' in our git hub project.
     */
    this.jsonresponse = jsonresponse;

    /**
     * This value appears in the IndoorGML document <State>.</br>
     * Within the topographic space layer, a state can be associated with a room, corridor, door, etc.</br>
     * And this may be an isolated node, i.e. not connected to another State.
     */
    this.nodes = [];

    /**
     * This value appears in the IndoorGML document <Transition>.</br>
     * And Transition is an edge that represents the adjacency or connectivity relationships among nodes representing space objects in primal space.</br>
     * Transition always connects two States.
     */
    this.edges = [];

    /**
     * In IndoorGML, CellSpaceis a base class for representing the indoor space.</br>
     * Each CellSpace is associated with a geometry object which can be represented as several geometry primitive types such as 2D and 3D.</br>
     * In short, <State> and <Transition> are responsible for the relationship between the spaces, and <CellSpace> is about the geometry that constitutes the space.
     */
    this.cellSpaceMembers = [];

    /**
     * CellSpaceBoundary is used to semantically describe the boundary of each geographical feature in space.</br>
     * You can notice that if you visualize geometry of this it look like door or something connecting one space to other.</br>
     * In this project we don't need to use this value because we can distinguish door from description of cellSpaceMembers.
     */
    this.cellSpaceBoundaryMembers = [];

    /**
     * The maximum x coordinate. This value will used for calculating center x coordinate of building.
     */
    this.max_X = 0;

    /**
     * The maximum y coordinate. This value will used for calculating center y coordinate of building.
     */
    this.max_Y = 0;

    /**
     * The maximum z coordinate. This value will used for calculating center z coordinate of building.
     */
    this.max_Z = 0;



    /**
     * The maximum x coordinate. This value will used for calculating center x coordinate of building.
     */
    this.min_X = 0;

    /**
     * The maximum y coordinate. This value will used for calculating center y coordinate of building.
     */
    this.min_Y = 0;

    /**
     * The maximum z coordinate. This value will used for calculating center z coordinate of building.
     */
    this.min_Z = 0;



    /**
     * The Center X coordinate of building.
     */
    this.center_X = 0;

    /**
     * The Center Y coordinate of building.
     */
    this.center_Y = 0;


    /** The object onto which to store the transformation result. */
    this.ENU = new Cesium.Matrix4();

    this.jsonParsor;

    this.parsingJson(jsonresponse, gmlVersion);
    this.setCenter();
  }



  /**
   * Parse the data(nodes, edges, cellSpace, cellSpaceBoundary ) required to produce the viewer in the JSON object.
   * @param {Object} jsonresponse JSON object parsed from inputed json data file
   */
  GMLDataContainer.prototype.parsingJson = function(jsonresponse, gmlVersion) {

    if(gmlVersion == "1.0.1"){
      this.jsonParsor = new JsonParsor_1_0_1(jsonresponse);
    }
    else if(gmlVersion == "1.0.3"){
      this.jsonParsor = new JsonParsor_1_0_3(jsonresponse);
    }
    else{
      alert(gmlVersion + " is not a vailid version!");
    }

    this.nodes = this.jsonParsor.parsingNodeData(jsonresponse);
    this.edges = this.jsonParsor.parsingEdgeData(jsonresponse);
    this.cellSpaceMembers = this.jsonParsor.parsingCellSpaceMember(jsonresponse);

    this.max_X = this.jsonParsor.getMaxX();
    this.max_Y = this.jsonParsor.getMaxY();
    this.max_Z = this.jsonParsor.getMaxZ();
    this.min_X = this.jsonParsor.getMinX();
    this.min_Y = this.jsonParsor.getMinY();
    this.min_Z = this.jsonParsor.getMinZ();
    // this.cellSpaceBoundaryMembers = this.parsingCellSpaceBoundaryMember(jsonresponse);

  };


  /**
   * Calculate the central coordinates of the building.
   */
  GMLDataContainer.prototype.setCenter = function() {
    this.center_X = (this.min_X + this.max_X) / 2;
    this.center_Y = (this.min_Y + this.max_Y) / 2;
  }



  /**
   * When the inputted coordinates differs from the actual world, this tries to rotate the building to reduce the gap.
   * @param {Cesium.Viewer} viewer
   * @param {Cesium.Cartesian3} position position on actual world
   * @param {number} angle angle for rotate
   */
  GMLDataContainer.prototype.rotateBuilding = function(viewer, position, angle) {

    var ellipsoid = viewer.scene.globe.ellipsoid;

    /** Rotation matrix */
    var orientation = new Cesium.Matrix4(Math.cos(angle), -Math.sin(angle), 0, 0,
      Math.sin(angle), Math.cos(angle), 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1);


    this.rotateCellSpaceMember(orientation, position, ellipsoid);
    this.rotateCellSpaceBoundaryMembers(orientation, position, ellipsoid);
    this.rotateNodes(orientation);
    this.rotateEdges(orientation);

  }



  /**
   * Rotate nodes
   * @param {Cesium.Matrix4} orientation rotation matrix for rotation
   */
  GMLDataContainer.prototype.rotateNodes = function(orientation) {

    var nodesLen = this.nodes.length;

    /** Applying translation and rotation to the nodes */
    for (var i = 0; i < nodesLen; i++) {

      /** Translating coordinates + converting the result to Cartesian3 */
      var offset = new Cesium.Cartesian3(this.nodes[i].coordinates[0] - this.center_X,
        this.nodes[i].coordinates[1] - this.center_Y,
        this.nodes[i].coordinates[2] - this.min_Z);

      /** Applying rotation to the offset */
      var finalPos = Cesium.Matrix4.multiplyByPoint(orientation, offset, new Cesium.Cartesian3());

      /** Report offset to the actual position of LWM */
      var new_coord = Cesium.Matrix4.multiplyByPoint(this.ENU, finalPos, finalPos);

      /** Replacing the old coordinates by the new ones */
      this.nodes[i].coordinates[0] = new_coord.x;
      this.nodes[i].coordinates[1] = new_coord.y;
      this.nodes[i].coordinates[2] = new_coord.z;
    }
  }



  /**
   * Rotate edges
   * @param {Cesium.Matrix4} orientation rotation matrix for rotation
   */
  GMLDataContainer.prototype.rotateEdges = function(orientation) {

    /** Applying translation and rotation to the edges */
    for (var i = 0; i < this.edges.length; i++) {

      for (var j = 0; j < this.edges[i].stateMembers.length; j++) {

        var offset = new Cesium.Cartesian3(this.edges[i].stateMembers[j].coordinates[0] - this.center_X,
          this.edges[i].stateMembers[j].coordinates[1] - this.center_Y,
          this.edges[i].stateMembers[j].coordinates[2] - this.min_Z);

        var finalPos = Cesium.Matrix4.multiplyByPoint(orientation, offset, new Cesium.Cartesian3());

        var new_coord = Cesium.Matrix4.multiplyByPoint(this.ENU, finalPos, finalPos);

        this.edges[i].stateMembers[j].coordinates[0] = new_coord.x;
        this.edges[i].stateMembers[j].coordinates[1] = new_coord.y;
        this.edges[i].stateMembers[j].coordinates[2] = new_coord.z;
      }
    }
  }



  /**
   * Rotate cellSpaceMembers
   * @param {Cesium.Matrix4} orientation rotation matrix for rotation
   * @param {Cesium.Cartesian3} position position on actual world
   * @param {Cesium.Ellipsoid} ellipsoid
   */
  GMLDataContainer.prototype.rotateCellSpaceMember = function(orientation, position, ellipsoid) {

    Cesium.Transforms.eastNorthUpToFixedFrame(position, ellipsoid, this.ENU);

    /** Applying translation and rotation to coordinates */
    for (var i = 0; i < this.cellSpaceMembers.length; i++) {

      var csmLen = this.cellSpaceMembers[i].surfaceMember.length;

      for (var j = 0; j < csmLen; j++) {
        var smLen = this.cellSpaceMembers[i].surfaceMember[j].coordinates.length;

        for (var k = 0; k < smLen; k += 3) {

          /** Translating coordinates + converting the result to Cartesian3 */
          var offset = new Cesium.Cartesian3(this.cellSpaceMembers[i].surfaceMember[j].coordinates[k] - this.center_X,
            this.cellSpaceMembers[i].surfaceMember[j].coordinates[k + 1] - this.center_Y,
            this.cellSpaceMembers[i].surfaceMember[j].coordinates[k + 2] - this.min_Z);

          /** Applying rotation to the offset */
          var finalPos = Cesium.Matrix4.multiplyByPoint(orientation, offset, new Cesium.Cartesian3());

          /** Report offset to the actual position of LWM */
          var new_coord = Cesium.Matrix4.multiplyByPoint(this.ENU, finalPos, finalPos);

          /** Replacing the old coordinates by the new ones */
          this.cellSpaceMembers[i].surfaceMember[j].coordinates[k] = new_coord.x;
          this.cellSpaceMembers[i].surfaceMember[j].coordinates[k + 1] = new_coord.y;
          this.cellSpaceMembers[i].surfaceMember[j].coordinates[k + 2] = new_coord.z;
        }
      }
    }
  }



  /**
   * Rotate cellSpaceBoundaryMembers
   * @param {Cesium.Matrix4} orientation rotation matrix for rotation
   * @param {Cesium.Cartesian3} position position on actual world
   * @param {Cesium.Ellipsoid} ellipsoid
   */
  GMLDataContainer.prototype.rotateCellSpaceBoundaryMembers = function(orientation, position, ellipsoid) {

    Cesium.Transforms.eastNorthUpToFixedFrame(position, ellipsoid, this.ENU);

    /** Applying translation and rotation to coordinates */
    for (var i = 0; i < this.cellSpaceBoundaryMembers.length; i++) {

      var csmLen = this.cellSpaceBoundaryMembers[i].surfaceMember.length;

      for (var j = 0; j < csmLen; j++) {
        var smLen = this.cellSpaceBoundaryMembers[i].surfaceMember[j].coordinates.length;

        for (var k = 0; k < smLen; k += 3) {

          /** Translating coordinates + converting the result to Cartesian3 */
          var offset = new Cesium.Cartesian3(this.cellSpaceBoundaryMembers[i].surfaceMember[j].coordinates[k] - this.center_X,
            this.cellSpaceBoundaryMembers[i].surfaceMember[j].coordinates[k + 1] - this.center_Y,
            this.cellSpaceBoundaryMembers[i].surfaceMember[j].coordinates[k + 2] - this.min_Z);

          /** Applying rotation to the offset */
          var finalPos = Cesium.Matrix4.multiplyByPoint(orientation, offset, new Cesium.Cartesian3());

          /** Report offset to the actual position of LWM */
          var new_coord = Cesium.Matrix4.multiplyByPoint(this.ENU, finalPos, finalPos);

          /** Replacing the old coordinates by the new ones */
          this.cellSpaceBoundaryMembers[i].surfaceMember[j].coordinates[k] = new_coord.x;
          this.cellSpaceBoundaryMembers[i].surfaceMember[j].coordinates[k + 1] = new_coord.y;
          this.cellSpaceBoundaryMembers[i].surfaceMember[j].coordinates[k + 2] = new_coord.z;
        }
      }
    }
  }




/**
  * @module JsonParsor_1_0_1
  */

  'use strict';


  /**
   * @alias module:JsonParsor_1_0_1
   * @param {Object} jsonresponse JSON object parsed from inputed json data file
   */
  function JsonParsor_1_0_1(jsonresponse) {

    /**
     * JSON object parsed from inputed json data file.</br>
     * Inputed json data file is converted from IndoorGML file.</br>
     * You can convert IndoorGML to json through 'gmlToJson' in our git hub project.
     */
    this.jsonresponse = jsonresponse;

    /**
     * The maximum x coordinate. This value will used for calculating center x coordinate of building.
     */
    this.max_X = 0;

    /**
     * The maximum y coordinate. This value will used for calculating center y coordinate of building.
     */
    this.max_Y = 0;

    /**
     * The maximum z coordinate. This value will used for calculating center z coordinate of building.
     */
    this.max_Z = 0;



    /**
     * The maximum x coordinate. This value will used for calculating center x coordinate of building.
     */
    this.min_X = 0;

    /**
     * The maximum y coordinate. This value will used for calculating center y coordinate of building.
     */
    this.min_Y = 0;

    /**
     * The maximum z coordinate. This value will used for calculating center z coordinate of building.
     */
    this.min_Z = 0;

  }


  /**
   * @param {Object} jsonresponse JSON object parsed from inputed json data file
   */
  JsonParsor_1_0_1.prototype.parsingNodeData = function(jsonresponse) {

    var nodes = [];

    /** Extracting state members */
    var sm = jsonresponse.value.multiLayeredGraph.spaceLayers["0"].spaceLayerMember["0"].spaceLayer.nodes["0"].stateMember;
    var smLen = sm.length;

    for (var j = 0; j < smLen; j++) {

      var coordinates = sm[j].state.geometry.point.pos.value;
      var stateMemberObject = new StateMember(coordinates);

      /** Adding the state member to the nodes array */
      nodes.push(stateMemberObject);
    }

    return nodes;
  };



  /**
   * @param {Object} jsonresponse JSON object parsed from inputed json data file
   */
  JsonParsor_1_0_1.prototype.parsingEdgeData = function(jsonresponse) {

    var edges = [];

    /** Extracting transition members */
    var tm = jsonresponse.value.multiLayeredGraph.spaceLayers["0"].spaceLayerMember["0"].spaceLayer.edges["0"].transitionMember;

    /** Loop through transition Members and extracting connection, description and state members of each transition member */
    for (var i = 0; i < tm.length; i++) {

      /** Array of connections of a transition member */
      var connects = [];

      /** Getting the href of each connection */
      for (var j = 0; j < tm[i].transition.connects.length; j++) {
        connects.push(tm[i].transition.connects[j].href);
      }

      /** Description of a transition member */
      var description;
      if (tm[i].transition.description != null) {
        description = tm[i].transition.description.value;
      }


      /** Array of state members */
      var stateMembers = [];

      /** Getting coordinates of each state member */
      for (var k = 0; k < tm[i].transition.geometry.abstractCurve.value.posOrPointPropertyOrPointRep.length; k++) {
        /** Creating a state member instance*/

        var coordinates = tm[i].transition.geometry.abstractCurve.value.posOrPointPropertyOrPointRep[k].value.value;
        var smObject = new StateMember(coordinates);


        // smObject.coordinates.push(coordinates[0], coordinates[1], coordinates[2]);
        stateMembers.push(smObject);
      }


      /** Creating a transition member instance */
      var transitionMemberObject = new TransitionMember(connects, description, stateMembers);


      /** Adding the transition member to edges array */
      edges.push(transitionMemberObject);
    }

    return edges;
  };



  /**
   * Abstract cellSpaceMember data from JSON object and save it as cellSpaceMembers
   * @param {Object} jsonresponse JSON object parsed from inputed json data file
   */
  JsonParsor_1_0_1.prototype.parsingCellSpaceMember = function(jsonresponse) {

    var cellSpaceMembers = [];

    var cellSpaceMemberLen = jsonresponse.value.primalSpaceFeatures.primalSpaceFeatures.cellSpaceMember.length;

    for (var i = 0; i < cellSpaceMemberLen; i++) {

      /** Cell space member */
      var csm = jsonresponse.value.primalSpaceFeatures.primalSpaceFeatures.cellSpaceMember[i];

      /** Extracting the description of the cell space member */
      var description = "";
      if (csm.abstractFeature.value.description != null) {
        description = csm.abstractFeature.value.description.value;
      }

      var id = "";
      if (csm.abstractFeature.value.id != null) {
        id = csm.abstractFeature.value.id;
      }

      /** Extracting the href of the cell space member */
      var href = "";
      if (csm.abstractFeature.value.duality.href != null) {
        href = csm.abstractFeature.value.duality.href;
      }


      /** Creating an instance of the cell space member */
      var csmObject = new CellSpaceMember(description, href, id, []);

      /** Number of surface members */
      if (csm.abstractFeature.value.geometry3D != null) {
        csmObject.surfaceMember = this.getCsmSurfaceMemberFromGeometry3D(csm);
      } else if (csm.abstractFeature.value.geometry2D != null) {
        csmObject.surfaceMember = this.getCsmSurfaceMemberFromGeometry2D(csm);
      }


      /** Filling the array with the cell space member instancesBut the problem with outline has not been solved yet. */
      cellSpaceMembers.push(csmObject);
    }

    return cellSpaceMembers;
  };



  /**
   * @param {Object} jsonresponse JSON object parsed from inputed json data file
   */
  JsonParsor_1_0_1.prototype.parsingCellSpaceBoundaryMember = function(jsonresponse) {
    var cellSpaceBoundaryMembers = [];
    var cellSpaceBoundaryMemberLen = jsonresponse.value.primalSpaceFeatures.primalSpaceFeatures.cellSpaceBoundaryMember.length;

    for (var i = 0; i < cellSpaceBoundaryMemberLen; i++) {

      var csbm = jsonresponse.value.primalSpaceFeatures.primalSpaceFeatures.cellSpaceBoundaryMember[i];

      var description = "";
      if (csbm.abstractFeature.value.description != null) {
        description = csbm.abstractFeature.value.description.value;
      }

      var id = "";
      if (csbm.abstractFeature.value.id != null) {
        id = csbm.abstractFeature.value.id;
      }

      /** Extracting the href of the cell space member */
      var href = "";
      if (csbm.abstractFeature.value.duality != null) {
        href = csbm.abstractFeature.value.duality.href;
      }

      /** Creating an instance of the cell space member */
      var csbmObject = new CellSpaceMember(description, href, id, []);

      /** Number of surface members */
      if (csbm.abstractFeature.value.geometry3D != null) {
        csbmObject.surfaceMember = this.getCsbmSurfaceMemberFromGeometry3D(csbm);
      }

      cellSpaceBoundaryMembers.push(csbmObject);
    }

    return cellSpaceBoundaryMembers;
  };



  /**
   * Extract surfaceMember of cellSpaceMember from the JSON object when the surface of the given GML file is configured with geometry3D.
   * @param {Object} csm CellSpaceMember, cellSpaceMember part of jsonresponse.
   * @returns {array} array of {@link SurfaceMember}
   */
  JsonParsor_1_0_1.prototype.getCsmSurfaceMemberFromGeometry3D = function(csm) {
    /** get surface MemberLen */
    var surfaceMemberLen = csm.abstractFeature.value.geometry3D.abstractSolid.value.exterior.shell.surfaceMember.length;

    var surfaceMembers = [];

    /** Loop through the surface members and creating instances */
    for (var j = 0; j < surfaceMemberLen; j++) {

      /** Surface member */
      var sm = csm.abstractFeature.value.geometry3D.abstractSolid.value.exterior.shell.surfaceMember[j];

      /** Creating an instance of the surface member */
      var smObject = new SurfaceMember([]);

      /** Number of coordinates of the surface member */
      var coordLen = sm.abstractSurface.value.exterior.abstractRing.value.posOrPointPropertyOrPointRep.length;

      var value = sm.abstractSurface.value.exterior.abstractRing.value.posOrPointPropertyOrPointRep;

      /** Loop through the coordinates of a surfaceMember */
      for (var k = 0; k < coordLen; k++) {
        smObject = this.abstractCoordinate(value[k].value.value, smObject);
      }

      /** Adding the surface member to the corresponding cell space member */
      surfaceMembers.push(smObject);
    }
    return surfaceMembers;
  }



  /**
   * Extract surfaceMember of cellSpaceMember from the JSON object when the surface of the given GML file is configured with geometry2D.
   * @param {Object} csm CellSpaceMember, cellSpaceMember part of jsonresponse.
   * @returns {array} array of {@link SurfaceMember}
   */
  JsonParsor_1_0_1.prototype.getCsmSurfaceMemberFromGeometry2D = function(csm) {

    var surfaceMembers = [];

    /** abstractRing */
    var ar = csm.abstractFeature.value.geometry2D.abstractSurface.value.exterior.abstractRing;

    /** Creating an instance of abstractRing */
    var arObject = new SurfaceMember([]);

    /** Number of coordinates of the surface member */
    var coordLen = ar.value.posOrPointPropertyOrPointRep.length;

    /** Loop through the coordinates of a surfaceMember */
    for (var i = 0; i < coordLen; i++) {
      arObject = this.abstractCoordinate(ar.value.posOrPointPropertyOrPointRep[i].value.value, arObject);
    }

    surfaceMembers.push(arObject);

    return surfaceMembers;
  }



  /**
   * Extract surfaceMember of cellSpaceBoundaryMember from the JSON object when the surface of the given GML file is configured with geometry3D.
   * @param {Object} csm cellSpaceBoundaryMember, cellSpaceBoundaryMember part of jsonresponse.
   * @returns {array} array of {@link SurfaceMember}
   */
  JsonParsor_1_0_1.prototype.getCsbmSurfaceMemberFromGeometry3D = function(csbm) {

    var smObject = new SurfaceMember([]);

    var surfaceMembers = [];

    if (csbm.abstractFeature.value.geometry3D.abstractSurface.value.exterior != null) {

      var coordLen = csbm.abstractFeature.value.geometry3D.abstractSurface.value.exterior.abstractRing.value.posOrPointPropertyOrPointRep.length;
      for (var k = 0; k < coordLen; k++) {
        smObject = this.abstractCoordinate(csbm.abstractFeature.value.geometry3D.abstractSurface.value.exterior.abstractRing.value.posOrPointPropertyOrPointRep[k].value.value, smObject);
      }
    }

    surfaceMembers.push(smObject);

    return surfaceMembers;
  }



  /**
   * Abstract coordinates from value and save it in object.coordinates
   * @param {Array} value array of coordinates.
   * @param {SurfaceMember} object The coordinates obtained from value are stored in object.coordinates.
   * @returns {array} array of {@link SurfaceMember}
   */
  JsonParsor_1_0_1.prototype.abstractCoordinate = function(value, object) {

    /** Extracting X */
    var X = value[0];
    object.coordinates.push(X);


    /** Test if X is maximum or minimum */
    if (X > this.max_X) {
      this.max_X = X;
    } else if (X < this.min_X) {
      this.min_X = X;
    }

    /** Extracting Y */
    var Y = value[1];
    object.coordinates.push(Y);

    if (Y > this.max_Y) {
      this.max_Y = Y;
    } else if (Y < this.min_Y) {
      this.min_Y = Y;
    }

    /** Extracting Z */
    var Z = value[2];
    object.coordinates.push(Z);

    if (Z > this.max_Z) {
      this.max_Z = Z;
    } else if (Z < this.min_Z) {
      this.min_Z = Z;
    }

    return object;
  }

  JsonParsor_1_0_1.prototype.getMaxX = function(){
    return this.max_X;
  }

  JsonParsor_1_0_1.prototype.getMaxY = function(){
    return this.max_Y;
  }

  JsonParsor_1_0_1.prototype.getMaxZ = function(){
    return this.max_Z;
  }

  JsonParsor_1_0_1.prototype.getMinX = function(){
    return this.min_X;
  }

  JsonParsor_1_0_1.prototype.getMinY = function(){
    return this.min_Y;
  }

  JsonParsor_1_0_1.prototype.getMinZ = function(){
    return this.min_Z;
  }



/**
  * @module JsonParsor_1_0_3
  */

  'use strict';


  /**
   * @alias module:JsonParsor_1_0_3
   * @param {Object} jsonresponse JSON object parsed from inputed json data file
   */
  function JsonParsor_1_0_3(jsonresponse) {

    /**
     * JSON object parsed from inputed json data file.</br>
     * Inputed json data file is converted from IndoorGML file.</br>
     * You can convert IndoorGML to json through 'gmlToJson' in our git hub project.
     */
    this.jsonresponse = jsonresponse;

    /**
     * The maximum x coordinate. This value will used for calculating center x coordinate of building.
     */
    this.max_X = 0;

    /**
     * The maximum y coordinate. This value will used for calculating center y coordinate of building.
     */
    this.max_Y = 0;

    /**
     * The maximum z coordinate. This value will used for calculating center z coordinate of building.
     */
    this.max_Z = 0;



    /**
     * The maximum x coordinate. This value will used for calculating center x coordinate of building.
     */
    this.min_X = 0;

    /**
     * The maximum y coordinate. This value will used for calculating center y coordinate of building.
     */
    this.min_Y = 0;

    /**
     * The maximum z coordinate. This value will used for calculating center z coordinate of building.
     */
    this.min_Z = 0;

  }


  /**
   * @param {Object} jsonresponse JSON object parsed from inputed json data file
   */
  JsonParsor_1_0_3.prototype.parsingNodeData = function(jsonresponse) {

    var nodes = [];

    /** Extracting state members */
    var sm = jsonresponse.value.multiLayeredGraph.multiLayeredGraph.spaceLayers["0"].spaceLayerMember["0"].spaceLayer.nodes["0"].stateMember;
    var smLen = sm.length;

    for (var j = 0; j < smLen; j++) {

      var coordinates = sm[j].state.geometry.point.pos.value;
      var stateMemberObject = new StateMember(coordinates);
	  
	  // Son 20181121.*******************************************
	  stateMemberObject.id = sm[j].state.id;
	  // End Son 20181121.---------------------------------------

      /** Adding the state member to the nodes array */
      nodes.push(stateMemberObject);
    }

    return nodes;
  };



  /**
   * @param {Object} jsonresponse JSON object parsed from inputed json data file
   */
  JsonParsor_1_0_3.prototype.parsingEdgeData = function(jsonresponse) {

    var edges = [];

    /** Extracting transition members */
    var tm = jsonresponse.value.multiLayeredGraph.multiLayeredGraph.spaceLayers["0"].spaceLayerMember["0"].spaceLayer.edges["0"].transitionMember;

    /** Loop through transition Members and extracting connection, description and state members of each transition member */
    for (var i = 0; i < tm.length; i++) {

      /** Array of connections of a transition member */
      var connects = [];

      /** Getting the href of each connection */
      for (var j = 0; j < tm[i].transition.connects.length; j++) {
        connects.push(tm[i].transition.connects[j].href);
      }

      /** Description of a transition member */
      var description;
      if (tm[i].transition.description != null) {
        description = tm[i].transition.description.value;
      }


      /** Array of state members */
      var stateMembers = [];

      /** Getting coordinates of each state member */
      for (var k = 0; k < tm[i].transition.geometry.abstractCurve.value.posOrPointPropertyOrPointRep.length; k++) {
        /** Creating a state member instance*/

        var coordinates = tm[i].transition.geometry.abstractCurve.value.posOrPointPropertyOrPointRep[k].value.value;
        var smObject = new StateMember(coordinates);

		// Son 20181121.*******************************************
		//smObject.id = tm[i].transition.id;
		// End Son 20181121.---------------------------------------

        // smObject.coordinates.push(coordinates[0], coordinates[1], coordinates[2]);
        stateMembers.push(smObject);
      }


      /** Creating a transition member instance */
      var transitionMemberObject = new TransitionMember(connects, description, stateMembers);


      /** Adding the transition member to edges array */
      edges.push(transitionMemberObject);
    }

    return edges;
  };



  /**
   * Abstract cellSpaceMember data from JSON object and save it as cellSpaceMembers
   * @param {Object} jsonresponse JSON object parsed from inputed json data file
   */
  JsonParsor_1_0_3.prototype.parsingCellSpaceMember = function(jsonresponse) {

    var cellSpaceMembers = [];

    var cellSpaceMemberLen = jsonresponse.value.primalSpaceFeatures.primalSpaceFeatures.cellSpaceMember.length;

    for (var i = 0; i < cellSpaceMemberLen; i++) {

      /** Cell space member */
      var csm = jsonresponse.value.primalSpaceFeatures.primalSpaceFeatures.cellSpaceMember[i];

      /** Extracting the description of the cell space member */
      var description = "";
      if (csm.cellSpace.description != null) {
        description = csm.cellSpace.description.value;
      }

      var id = "";
      if (csm.cellSpace.id != null) {
        id = csm.cellSpace.id;
      }

      /** Extracting the href of the cell space member */
      var href = "";
      if (csm.cellSpace.duality.href != null) {
        href = csm.cellSpace.duality.href;
      }


      /** Creating an instance of the cell space member */
      var csmObject = new CellSpaceMember(description, href, id, []);

      /** Number of surface members */
      if (csm.cellSpace.cellSpaceGeometry.geometry3D != null) {
        csmObject.surfaceMember = this.getCsmSurfaceMemberFromGeometry3D(csm);
      } else if (csm.cellSpace.cellSpaceGeometry.geometry2D != null) {
        csmObject.surfaceMember = this.getCsmSurfaceMemberFromGeometry2D(csm);
      }


      /** Filling the array with the cell space member instancesBut the problem with outline has not been solved yet. */
      cellSpaceMembers.push(csmObject);
    }

    return cellSpaceMembers;
  };



  /**
   * @param {Object} jsonresponse JSON object parsed from inputed json data file
   */
  JsonParsor_1_0_3.prototype.parsingCellSpaceBoundaryMember = function(jsonresponse) {
    var cellSpaceBoundaryMembers = [];
    var cellSpaceBoundaryMemberLen = jsonresponse.value.primalSpaceFeatures.primalSpaceFeatures.cellSpaceBoundaryMember.length;

    for (var i = 0; i < cellSpaceBoundaryMemberLen; i++) {

      var csbm = jsonresponse.value.primalSpaceFeatures.primalSpaceFeatures.cellSpaceBoundaryMember[i];

      var description = "";
      if (csbm.cellSpaceBoundary.description != null) {
        description = csbm.cellSpaceBoundary.description.value;
      }

      var id = "";
      if (csbm.cellSpaceBoundary.id != null) {
        id = csbm.cellSpaceBoundary.id;
      }

      /** Extracting the href of the cell space member */
      var href = "";
      if (csbm.cellSpaceBoundary.duality != null) {
        href = csbm.cellSpaceBoundary.duality.href;
      }

      /** Creating an instance of the cell space member */
      var csbmObject = new CellSpaceMember(description, href, id, []);

      /** Number of surface members */
      if (csbm.cellSpaceBoundary.cellSpaceBoundaryGeometry.geometry3D != null) {
        csbmObject.surfaceMember = this.getCsbmSurfaceMemberFromGeometry3D(csbm);
      }

      cellSpaceBoundaryMembers.push(csbmObject);
    }

    return cellSpaceBoundaryMembers;
  };



  /**
   * Extract surfaceMember of cellSpaceMember from the JSON object when the surface of the given GML file is configured with geometry3D.
   * @param {Object} csm CellSpaceMember, cellSpaceMember part of jsonresponse.
   * @returns {array} array of {@link SurfaceMember}
   */
  JsonParsor_1_0_3.prototype.getCsmSurfaceMemberFromGeometry3D = function(csm) {
    /** get surface MemberLen */
    var surfaceMemberLen = csm.cellSpace.cellSpaceGeometry.geometry3D.abstractSolid.value.exterior.shell.surfaceMember.length;

    var surfaceMembers = [];

    /** Loop through the surface members and creating instances */
    for (var j = 0; j < surfaceMemberLen; j++) {

      /** Surface member */
      var sm = csm.cellSpace.cellSpaceGeometry.geometry3D.abstractSolid.value.exterior.shell.surfaceMember[j];

      /** Creating an instance of the surface member */
      var smObject = new SurfaceMember([]);

      /** Number of coordinates of the surface member */
      var coordLen = sm.abstractSurface.value.exterior.abstractRing.value.posOrPointPropertyOrPointRep.length;

      var value = sm.abstractSurface.value.exterior.abstractRing.value.posOrPointPropertyOrPointRep;

      /** Loop through the coordinates of a surfaceMember */
      for (var k = 0; k < coordLen; k++) {
        smObject = this.abstractCoordinate(value[k].value.value, smObject);
      }

      /** Adding the surface member to the corresponding cell space member */
      surfaceMembers.push(smObject);
    }
    return surfaceMembers;
  }



  /**
   * Extract surfaceMember of cellSpaceMember from the JSON object when the surface of the given GML file is configured with geometry2D.
   * @param {Object} csm CellSpaceMember, cellSpaceMember part of jsonresponse.
   * @returns {array} array of {@link SurfaceMember}
   */
  JsonParsor_1_0_3.prototype.getCsmSurfaceMemberFromGeometry2D = function(csm) {

    var surfaceMembers = [];

    /** abstractRing */
    var ar = csm.cellSpace.cellSpaceGeometry.geometry2D.abstractSurface.value.exterior.abstractRing;

    /** Creating an instance of abstractRing */
    var arObject = new SurfaceMember([]);

    /** Number of coordinates of the surface member */
    var coordLen = ar.value.posOrPointPropertyOrPointRep.length;

    /** Loop through the coordinates of a surfaceMember */
    for (var i = 0; i < coordLen; i++) {
      arObject = this.abstractCoordinate(ar.value.posOrPointPropertyOrPointRep[i].value.value, arObject);
    }

    surfaceMembers.push(arObject);

    return surfaceMembers;
  }



  /**
   * Extract surfaceMember of cellSpaceBoundaryMember from the JSON object when the surface of the given GML file is configured with geometry3D.
   * @param {Object} csm cellSpaceBoundaryMember, cellSpaceBoundaryMember part of jsonresponse.
   * @returns {array} array of {@link SurfaceMember}
   */
  JsonParsor_1_0_3.prototype.getCsbmSurfaceMemberFromGeometry3D = function(csbm) {

    var smObject = new SurfaceMember([]);

    var surfaceMembers = [];

    if (csbm.cellSpaceBoundary.cellSpaceBoundaryGeometry.geometry3D.abstractSurface.value.exterior != null) {

      var coordLen = csbm.cellSpaceBoundary.cellSpaceBoundaryGeometry.geometry3D.abstractSurface.value.exterior.abstractRing.value.posOrPointPropertyOrPointRep.length;
      for (var k = 0; k < coordLen; k++) {
        smObject = this.abstractCoordinate(csbm.cellSpaceBoundary.cellSpaceBoundaryGeometry.geometry3D.abstractSurface.value.exterior.abstractRing.value.posOrPointPropertyOrPointRep[k].value.value, smObject);
      }
    }

    surfaceMembers.push(smObject);

    return surfaceMembers;
  }



  /**
   * Abstract coordinates from value and save it in object.coordinates
   * @param {Array} value array of coordinates.
   * @param {SurfaceMember} object The coordinates obtained from value are stored in object.coordinates.
   * @returns {array} array of {@link SurfaceMember}
   */
  JsonParsor_1_0_3.prototype.abstractCoordinate = function(value, object) {

    /** Extracting X */
    var X = value[0];
    object.coordinates.push(X);


    /** Test if X is maximum or minimum */
    if (X > this.max_X) {
      this.max_X = X;
    } else if (X < this.min_X) {
      this.min_X = X;
    }

    /** Extracting Y */
    var Y = value[1];
    object.coordinates.push(Y);

    if (Y > this.max_Y) {
      this.max_Y = Y;
    } else if (Y < this.min_Y) {
      this.min_Y = Y;
    }

    /** Extracting Z */
    var Z = value[2];
    object.coordinates.push(Z);

    if (Z > this.max_Z) {
      this.max_Z = Z;
    } else if (Z < this.min_Z) {
      this.min_Z = Z;
    }

    return object;
  }

  JsonParsor_1_0_3.prototype.getMaxX = function(){
    return this.max_X;
  }

  JsonParsor_1_0_3.prototype.getMaxY = function(){
    return this.max_Y;
  }

  JsonParsor_1_0_3.prototype.getMaxZ = function(){
    return this.max_Z;
  }

  JsonParsor_1_0_3.prototype.getMinX = function(){
    return this.min_X;
  }

  JsonParsor_1_0_3.prototype.getMinY = function(){
    return this.min_Y;
  }

  JsonParsor_1_0_3.prototype.getMinZ = function(){
    return this.min_Z;
  }





    'use strict';

    /**
     * Objects storing CellSpaceMember in IndoorGML
     * @exports CellSpaceMember
     * @constructor
     * @param {string} description description of CellSpaceMember
     * @param {string} href href of CellSpaceMember
     * @param {string} id id of CellSpaceMember
     * @param {Array} surfaceMember Array of {@link SurfaceMember}
     */
    function CellSpaceMember(description, href, id, surfaceMember) {

      /** Description contains information about section and floor ... etc */
    	this.description = description;

      /** Duality.</br> This will work as a key of cell that distinguse one cell to this other. */
    	this.href = href;

    	this.id = id;

      /** Array of surface members */
    	this.surfaceMember = surfaceMember;

      /**
       * This means what role it plays.</br>
       * This value will be parsed from description.</br>
       * If description doesn't mention usage, this remains empty.
       */
      this.usage = "";
      if(description.indexOf("Usage=") != -1){
        var usageStart = description.indexOf("Usage=") + 6;
        this.usage = description.substring(usageStart, description.indexOf(":", usageStart));
      }

      /**
       * This is the section value to which the current cell belongs.</br>
       * This value will be parsed from description.</br>
       * If description doesn't mention section, this remains empty.</br>
       * You can change this value to information about the cells that your IndoorGML file contains.
       */
      this.section = "";
      if(description.indexOf("Section=") != -1){
        var sectionStart = description.indexOf("Section=") + 8;
        this.section = description.substring(sectionStart, description.indexOf(":", sectionStart));
      }

      /**
       * This is the floor value to which the current cell belongs.</br>
       * This value will be parsed from description.</br>
       * If description doesn't mention floor, this remains empty.</br>
       * You can change this value to information about the cells that your IndoorGML file contains.
       */
      this.floor = "";
      if(description.indexOf("Floor=") != -1){
        var floorStart = description.indexOf("Floor=") + 6;
        this.floor = description.substring(floorStart);
      }
    }



    'use strict';

    /**
     * State Member Class. This can be thought of as simply a node.
     * @exports StateMember
     * @constructor
     */
    function StateMember(coordinates) {

      /** Array of coordinates*/
      this.coordinates = coordinates;
      
    }




    'use strict';

    /**
     * Objects storing CellSpaceMember in IndoorGML.
     * Creating the surfaceMember Class.
     * @exports SurfaceMember
     * @constructor
     * @param {Coordinate} coordinates
     */
    function SurfaceMember(coordinates) {

      /** Array of surfaceMember coordinates */
      this.coordinates = coordinates;

    }




    'use strict';


    /**
     * Transition member Class. This can be thought of as simply a edge.
     * @exports TransitionMember
     * @constructor
     */
    function TransitionMember(connects, description, coordinates) {

      /**
       * Array of href.</br>
       * This means two nodes constituting an edge.
       */
      this.connects = connects;

      /**
       * information about section and floor...etc
       */
      this.description = description;

      /** Array of state members, each state member has X,Y,Z coordinates */
      this.stateMembers = coordinates;

      if(description != null){

        /**
         * This means what role it plays.</br>
         * This value will be parsed from description.</br>
         * If description doesn't mention usage, this remains empty.
         */
        this.usage = "";
        if(description.indexOf("Usage=") != -1){
          var usageStart = description.indexOf("Usage=") + 6;
          this.usage = description.substring(usageStart, description.indexOf(":", usageStart));
        }


        /**
         * This is the section value to which the current cell belongs.</br>
         * This value will be parsed from description.</br>
         * If description doesn't mention section, this remains empty.</br>
         * You can change this value to information about the cells that your IndoorGML file contains.
         */
        this.section = "";
        if(description.indexOf("Section=") != -1){
          var sectionStart = description.indexOf("Section=") + 8;
          this.section = description.substring(sectionStart, description.indexOf(":", sectionStart));
        }


        /**
         * This is the floor value to which the current cell belongs.</br>
         * This value will be parsed from description.</br>
         * If description doesn't mention floor, this remains empty.</br>
         * You can change this value to information about the cells that your IndoorGML file contains.
         */
        this.floor = "";
        if(description.indexOf("Floor=") != -1){
          var floorStart = description.indexOf("Floor=") + 6;
          this.floor = description.substring(floorStart);
        }

      }
    }



	var _mago3d = {
		VERSION: '2.0',
	};
	_mago3d['Emitter'] = Emitter;
	_mago3d['MagoRenderable'] = MagoRenderable;
	_mago3d['ViewerInit'] = ViewerInit;
	_mago3d['ColorAPI'] = ColorAPI;
	_mago3d['DrawAPI'] = DrawAPI;
	_mago3d['LocationAndRotationAPI'] = LocationAndRotationAPI;
	_mago3d['LodAPI'] = LodAPI;
	_mago3d['AnimationData'] = AnimationData;
	_mago3d['AnimationManager'] = AnimationManager;
	_mago3d['BoundingBox'] = BoundingBox;
	_mago3d['BoundingSphere'] = BoundingSphere;
	_mago3d['BuildingSeed'] = BuildingSeed;
	_mago3d['BuildingSeedList'] = BuildingSeedList;
	_mago3d['Camera'] = Camera;
	_mago3d['CCTV'] = CCTV;
	_mago3d['CCTVList'] = CCTVList;
	_mago3d['CesiumViewerInit'] = CesiumViewerInit;
	_mago3d['CollisionCheckScene'] = CollisionCheckScene;
	_mago3d['Color'] = Color;
	_mago3d['DynamicColor'] = DynamicColor;
	_mago3d['F4dController'] = F4dController;
	_mago3d['FBO'] = FBO;
	_mago3d['FileRequestControler'] = FileRequestControler;
	_mago3d['FirstPersonView'] = FirstPersonView;
	_mago3d['Frustum'] = Frustum;
	_mago3d['FrustumVolumeControl'] = FrustumVolumeControl;
	_mago3d['GeographicCoord'] = GeographicCoord;
	_mago3d['GeographicCoordSegment'] = GeographicCoordSegment;
	_mago3d['GeographicCoordsList'] = GeographicCoordsList;
	_mago3d['GeographicExtent'] = GeographicExtent;
	_mago3d['GeoLocationData'] = GeoLocationData;
	_mago3d['GeoLocationDataManager'] = GeoLocationDataManager;
	_mago3d['Globe'] = Globe;
	_mago3d['IdentifierManager'] = IdentifierManager;
	_mago3d['LightSource'] = LightSource;
	_mago3d['Mago3d'] = Mago3d;
	_mago3d['MagoEarthViewerInit'] = MagoEarthViewerInit;
	_mago3d['MagoEvent'] = MagoEvent;
	_mago3d['MagoManager'] = MagoManager;
	_mago3d['ManagerFactory'] = ManagerFactory;
	_mago3d['Matrix4'] = Matrix4;
	_mago3d['Message'] = Message;
	_mago3d['MouseAction'] = MouseAction;
	_mago3d['Movement'] = Movement;
	_mago3d['ObjectMarker'] = ObjectMarker;
	_mago3d['ObjectMarkerManager'] = ObjectMarkerManager;
	_mago3d['OcclusionCullingOctree'] = OcclusionCullingOctree;
	_mago3d['OcclusionCullingOctreeCell'] = OcclusionCullingOctreeCell;
	_mago3d['Pin'] = Pin;
	_mago3d['Plane'] = Plane;
	_mago3d['Quaternion'] = Quaternion;
	_mago3d['SelectionColor'] = SelectionColor;
	_mago3d['Settings'] = Settings;
	_mago3d['SmartTile'] = SmartTile;
	_mago3d['SmartTileManager'] = SmartTileManager;
	_mago3d['Sphere'] = Sphere;
	_mago3d['SplitValue'] = SplitValue;
	_mago3d['SunSystem'] = SunSystem;
	_mago3d['TerranTile'] = TerranTile;
	_mago3d['Texture'] = Texture;
	_mago3d['TexturesManager'] = TexturesManager;
	_mago3d['TexturesStore'] = TexturesStore;
	_mago3d['TriPolyhedron'] = TriPolyhedron;
	_mago3d['TriSurface'] = TriSurface;
	_mago3d['VboBuffer'] = VboBuffer;
	_mago3d['VBOKeysNation'] = VBOKeysNation;
	_mago3d['VBOKeysStore'] = VBOKeysStore;
	_mago3d['VBOKeysWorld'] = VBOKeysWorld;
	_mago3d['VBOMemoryManager'] = VBOMemoryManager;
	_mago3d['VBOVertexIdxCacheKey'] = VBOVertexIdxCacheKey;
	_mago3d['VBOVertexIdxCacheKeysContainer'] = VBOVertexIdxCacheKeysContainer;
	_mago3d['VisibleObjectsController'] = VisibleObjectsController;
	_mago3d['API'] = API;
	_mago3d['ChangeHistory'] = ChangeHistory;
	_mago3d['CODE'] = CODE;
	_mago3d['Constant'] = Constant;
	_mago3d['MagoConfig'] = MagoConfig;
	_mago3d['Policy'] = Policy;
	_mago3d['Effect'] = Effect;
	_mago3d['EffectsManager'] = EffectsManager;
	_mago3d['Accessor'] = Accessor;
	_mago3d['Block'] = Block;
	_mago3d['BlocksArrayPartition'] = BlocksArrayPartition;
	_mago3d['BlocksList'] = BlocksList;
	_mago3d['CollisionCheckOctree'] = CollisionCheckOctree;
	_mago3d['HierarchyManager'] = HierarchyManager;
	_mago3d['InspectorBox'] = InspectorBox;
	_mago3d['Lego'] = Lego;
	_mago3d['LoadQueue'] = LoadQueue;
	_mago3d['LodBuilding'] = LodBuilding;
	_mago3d['LodBuildingData'] = LodBuildingData;
	_mago3d['MetaData'] = MetaData;
	_mago3d['ModelReferencedGroup'] = ModelReferencedGroup;
	_mago3d['MultiBuildings'] = MultiBuildings;
	_mago3d['MultiBuildingsElement'] = MultiBuildingsElement;
	_mago3d['NeoBuilding'] = NeoBuilding;
	_mago3d['NeoBuildingsList'] = NeoBuildingsList;
	_mago3d['NeoReference'] = NeoReference;
	_mago3d['NeoReferencesMotherAndIndices'] = NeoReferencesMotherAndIndices;
	_mago3d['NeoSimpleBuilding'] = NeoSimpleBuilding;
	_mago3d['NeoTexture'] = NeoTexture;
	_mago3d['Node'] = Node;
	_mago3d['Octree'] = Octree;
	_mago3d['ParseQueue'] = ParseQueue;
	_mago3d['ProcessQueue'] = ProcessQueue;
	_mago3d['ProjectTree'] = ProjectTree;
	_mago3d['ReaderWriter'] = ReaderWriter;
	_mago3d['SkinBuilding'] = SkinBuilding;
	_mago3d['TinTerrain'] = TinTerrain;
	_mago3d['TinTerrainManager'] = TinTerrainManager;
	_mago3d['Arc2D'] = Arc2D;
	_mago3d['AxisXYZ'] = AxisXYZ;
	_mago3d['BoundingRectangle'] = BoundingRectangle;
	_mago3d['BoxAux'] = BoxAux;
	_mago3d['BSplineCubic3D'] = BSplineCubic3D;
	_mago3d['Circle2D'] = Circle2D;
	_mago3d['Cluster'] = Cluster;
	_mago3d['CuttingPlane'] = CuttingPlane;
	_mago3d['Excavation'] = Excavation;
	_mago3d['Face'] = Face;
	_mago3d['HalfEdge'] = HalfEdge;
	_mago3d['HalfEdgesList'] = HalfEdgesList;
	_mago3d['IndexData'] = IndexData;
	_mago3d['IndexRange'] = IndexRange;
	_mago3d['Intersect'] = Intersect;
	_mago3d['Line'] = Line;
	_mago3d['Line2D'] = Line2D;
	_mago3d['MagoNativeProject'] = MagoNativeProject;
	_mago3d['MagoWorld'] = MagoWorld;
	_mago3d['Material'] = Material;
	_mago3d['MaterialsManager'] = MaterialsManager;
	_mago3d['Mesh'] = Mesh;
	_mago3d['Modeler'] = Modeler;
	_mago3d['ParametricMesh'] = ParametricMesh;
	_mago3d['Path3D'] = Path3D;
	_mago3d['PipeKnot'] = PipeKnot;
	_mago3d['PipePath'] = PipePath;
	_mago3d['PlaneGrid'] = PlaneGrid;
	_mago3d['Point2D'] = Point2D;
	_mago3d['Point2DList'] = Point2DList;
	_mago3d['Point3D'] = Point3D;
	_mago3d['Point3DList'] = Point3DList;
	_mago3d['Point4D'] = Point4D;
	_mago3d['Polygon2D'] = Polygon2D;
	_mago3d['PolyLine2D'] = PolyLine2D;
	_mago3d['PolyLine3D'] = PolyLine3D;
	_mago3d['ProcessCounterManager'] = ProcessCounterManager;
	_mago3d['Profile2D'] = Profile2D;
	_mago3d['Profiles2DList'] = Profiles2DList;
	_mago3d['QuatTree'] = QuatTree;
	_mago3d['Rectangle2D'] = Rectangle2D;
	_mago3d['Ring2D'] = Ring2D;
	_mago3d['Ring2DList'] = Ring2DList;
	_mago3d['RingType'] = RingType;
	_mago3d['ScreenQuad'] = ScreenQuad;
	_mago3d['Segment2D'] = Segment2D;
	_mago3d['Segment3D'] = Segment3D;
	_mago3d['ShadowMesh'] = ShadowMesh;
	_mago3d['Sky'] = Sky;
	_mago3d['Star2D'] = Star2D;
	_mago3d['StaticModel'] = StaticModel;
	_mago3d['Surface'] = Surface;
	_mago3d['Triangle'] = Triangle;
	_mago3d['Triangle2D'] = Triangle2D;
	_mago3d['TrianglesList'] = TrianglesList;
	_mago3d['TrianglesMatrix'] = TrianglesMatrix;
	_mago3d['Tunnel'] = Tunnel;
	_mago3d['Vertex'] = Vertex;
	_mago3d['VertexList'] = VertexList;
	_mago3d['VertexMatrix'] = VertexMatrix;
	_mago3d['VertexOctree'] = VertexOctree;
	_mago3d['VtxProfile'] = VtxProfile;
	_mago3d['VtxProfilesList'] = VtxProfilesList;
	_mago3d['VtxRing'] = VtxRing;
	_mago3d['VtxRingsList'] = VtxRingsList;
	_mago3d['VtxSegment'] = VtxSegment;
	_mago3d['Message'] = Message;
	_mago3d['MessageSource'] = MessageSource;
	_mago3d['GeoServer'] = GeoServer;
	_mago3d['AnimatedPerson'] = AnimatedPerson;
	_mago3d['Arrow'] = Arrow;
	_mago3d['BasicFactory'] = BasicFactory;
	_mago3d['BasicVehicle'] = BasicVehicle;
	_mago3d['Box'] = Box;
	_mago3d['ClippingBox'] = ClippingBox;
	_mago3d['ConcentricTubes'] = ConcentricTubes;
	_mago3d['Cylinder'] = Cylinder;
	_mago3d['Ellipsoid'] = Ellipsoid;
	_mago3d['GolfHoleFlag'] = GolfHoleFlag;
	_mago3d['ImageViewerRectangle'] = ImageViewerRectangle;
	_mago3d['Pipe'] = Pipe;
	_mago3d['RenderableObject'] = RenderableObject;
	_mago3d['SkeletalAnimationObject'] = SkeletalAnimationObject;
	_mago3d['SpeechBubble'] = SpeechBubble;
	_mago3d['TestFreeContourWallBuilding'] = TestFreeContourWallBuilding;
	_mago3d['Tube'] = Tube;
	_mago3d['VectorMesh'] = VectorMesh;
	_mago3d['Vehicle'] = Vehicle;
	_mago3d['Wheel'] = Wheel;
	_mago3d['Renderer'] = Renderer;
	_mago3d['RenderingSettings'] = RenderingSettings;
	_mago3d['SceneState'] = SceneState;
	_mago3d['Selection'] = Selection;
	_mago3d['SelectionCandidateFamily'] = SelectionCandidateFamily;
	_mago3d['SelectionManager'] = SelectionManager;
	_mago3d['AttribLocationState'] = AttribLocationState;
	_mago3d['PostFxShader'] = PostFxShader;
	_mago3d['PostFxShadersManager'] = PostFxShadersManager;
	_mago3d['ShaderSource'] = ShaderSource;
	_mago3d['Uniform1fDataPair'] = Uniform1fDataPair;
	_mago3d['Uniform1iDataPair'] = Uniform1iDataPair;
	_mago3d['UniformMatrix4fvDataPair'] = UniformMatrix4fvDataPair;
	_mago3d['UniformVec2fvDataPair'] = UniformVec2fvDataPair;
	_mago3d['UniformVec3fvDataPair'] = UniformVec3fvDataPair;
	_mago3d['UniformVec4fvDataPair'] = UniformVec4fvDataPair;
	_mago3d['Network'] = Network;
	_mago3d['NetworkEdge'] = NetworkEdge;
	_mago3d['NetworkNode'] = NetworkNode;
	_mago3d['NetworkSpace'] = NetworkSpace;
	_mago3d['abstract'] = abstract;
	_mago3d['ByteColor'] = ByteColor;
	_mago3d['CameraController'] = CameraController;
	_mago3d['defaultValue'] = defaultValue;
	_mago3d['defaultValueCheckLength'] = defaultValueCheckLength;
	_mago3d['defined'] = defined;
	_mago3d['GeometryUtils'] = GeometryUtils;
	_mago3d['loadWithXhr'] = loadWithXhr;
	_mago3d['ManagerUtils'] = ManagerUtils;
	_mago3d['Promise.done'] = Promise.done;
	_mago3d['Promise'] = Promise;
	_mago3d['GMLDataContainer'] = GMLDataContainer;
	_mago3d['JsonParsor_1_0_1'] = JsonParsor_1_0_1;
	_mago3d['JsonParsor_1_0_3'] = JsonParsor_1_0_3;
	_mago3d['CellSpaceMember'] = CellSpaceMember;
	_mago3d['StateMember'] = StateMember;
	_mago3d['SurfaceMember'] = SurfaceMember;
	_mago3d['TransitionMember'] = TransitionMember;
	return _mago3d;
})();
